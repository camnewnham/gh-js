// Generated for: Eto 2.8.0.0
// Generated by: Microsoft.JavaScript.NodeApi.Generator 0.7.0.0
/* eslint-disable */

type DateTime = Date | { kind?: 'utc' | 'local' | 'unspecified' }

import { Duplex } from 'stream';

interface IDisposable { dispose(): void; }

/** A JavaScript projection of a .NET type. */
interface IType {
	/**
	 * Constructs a new instance of the type.
	 * (Not available for static class or interface types.)
	 */
	new?(...args: any[]): IType;

	/** Gets the full name of the .NET type. */
	toString(): string;
}

declare module 'node-api-dotnet' {

	export namespace Eto {
		/**
		 * Attribute to specify whether the handler interface should be initialized automatically
		 *
		 * Handler interfaces that defer creation of the control to various Create() methods can
		 * apply this attribute so that the initialization can be done afterwards.  If auto
		 * initialization is disabled, the widget author must call Widget.Initialize() after the
		 * control is created.  Initialization applies styles to the widget and the handler, sets
		 * up events based on overridden event methods, etc.  This is only needed by widget
		 * authors in advanced scenarios.  The default is to auto initialize, so this is only
		 * needed if you want to disable this behaviour.
		 */
		export class AutoInitializeAttribute {
			/** Initializes a new instance of the {@link Eto.AutoInitializeAttribute} class. */
			constructor(initialize: boolean);

			/**
			 * Gets a value indicating whether to auto initialize the handler, false to defer this to
			 * the widget author
			 */
			Initialize: boolean;
		}
	}

	export namespace Eto {
		/**
		 * [Generic type factory] Class to help implement collection changed events on a data
		 * store
		 *
		 * This is used for the platform handler of controls that use collections. This class
		 * helps detect changes to a collection so that the appropriate action can be taken to
		 * update the UI with the changes.  This is a simple helper that is much easier to
		 * implement than handling the
		 * {@link System.Collections.Specialized.INotifyCollectionChanged.CollectionChanged}
		 * event directly.
		 */
		export function CollectionChangedHandler$(TItem: IType, TCollection: IType): typeof CollectionChangedHandler$2<any, any>;

		/**
		 * Class to help implement collection changed events on a data store
		 *
		 * This is used for the platform handler of controls that use collections. This class
		 * helps detect changes to a collection so that the appropriate action can be taken to
		 * update the UI with the changes.  This is a simple helper that is much easier to
		 * implement than handling the
		 * {@link System.Collections.Specialized.INotifyCollectionChanged.CollectionChanged}
		 * event directly.
		 */
		export class CollectionChangedHandler$2<TItem, TCollection> {
			/** Gets the collection that this handler is observing */
			Collection: TCollection;

			/** Gets the count of the items in the current registered collection. */
			readonly Count: number;

			/** Registers a specific collection to observe */
			Register(collection: TCollection): boolean;

			/** Unregisters the current registered collection */
			Unregister(): void;

			/** Gets the index of the specified item */
			IndexOf(item: TItem): number;

			/** Gets the element at the specified index of the current registered collection. */
			ElementAt(index: number): TItem;

			/** Adds the item to the end of the collection */
			AddItem(item: TItem): void;

			/** Inserts an item at the specified index in the collection */
			InsertItem(
				index: number,
				item: TItem,
			): void;

			/** Removes the item at the specified index */
			RemoveItem(index: number): void;

			/** Removes all items from the collection */
			RemoveAllItems(): void;

			/**
			 * Removes the specified item
			 *
			 * This will remove the item by finding the index and removing based on index.
			 * Implementors should override this method if there is a faster mechanism to do so.
			 */
			RemoveItem(item: TItem): void;

			/**
			 * Adds multiple items to the end of the collection
			 *
			 * This simply calls {@link Eto.CollectionChangedHandler`2.AddItem(`0)} for each item in
			 * the list.  If there is a faster mechanism for doing so, implementors should override
			 * this method.  For example, sometimes adding a single item will update the UI for each
			 * item, this should be overridden so the UI is updated after all items have been added.
			 */
			AddRange(items: Iterable<TItem>): void;

			/**
			 * Inserts multiple items to the specified index in the collection
			 *
			 * This simply calls {@link Eto.CollectionChangedHandler`2.InsertItem(System.Int32,`0)}
			 * for each item in the list.  If there is a faster mechanism for doing so, implementors
			 * should override this method.  For example, sometimes inserting a single item will
			 * update the UI for each item, this should be overridden so the UI is updated after all
			 * items have been inserted.
			 */
			InsertRange(
				index: number,
				items: Iterable<TItem>,
			): void;

			/**
			 * Removes a specified count of items from the collection starting at the specified index
			 *
			 * This simply calls {@link Eto.CollectionChangedHandler`2.RemoveItem(System.Int32)} for
			 * each item to remove.  If there is a faster mechanism for doing so, implementors should
			 * override this method.  For example, sometimes removing a single item will update the
			 * UI for each item, this should be overridden so the UI is updated after all items have
			 * been removed.
			 */
			RemoveRange(
				index: number,
				count: number,
			): void;

			/**
			 * Removes the specified items from the collection
			 *
			 * This simply calls {@link Eto.CollectionChangedHandler`2.RemoveItem(`0)} for each item
			 * to remove.  If there is a faster mechanism for doing so, implementors should override
			 * this method.  For example, sometimes removing a single item will update the UI for
			 * each item, this should be overridden so the UI is updated after all items have been
			 * removed.
			 */
			RemoveRange(items: Iterable<TItem>): void;

			/**
			 * Resets the collection when it is dramatically changed
			 *
			 * By default this removes all items and adds all items back (if Collection is an
			 * IEnumerable{T}) Platform implementations can override this to do something more
			 * efficient if needed.
			 */
			Reset(): void;
		}
	}

	export namespace Eto {
		/**
		 * [Generic type factory] Helper class to handle collection change events of an
		 * {@link System.Collections.IEnumerable}
		 *
		 * This is used for the platform handler of controls that use collections. This class
		 * helps detect changes to a collection so that the appropriate action can be taken to
		 * update the UI with the changes.  Use this class as a base when you only have an
		 * {@link System.Collections.IEnumerable}.  If the object also implements
		 * {@link System.Collections.Specialized.INotifyCollectionChanged} it will get changed
		 * events otherwise you must register a new collection each time.
		 */
		export function EnumerableChangedHandler$(TItem: IType): typeof EnumerableChangedHandler$1<any>;

		/**
		 * Helper class to handle collection change events of an
		 * {@link System.Collections.IEnumerable}
		 *
		 * This is used for the platform handler of controls that use collections. This class
		 * helps detect changes to a collection so that the appropriate action can be taken to
		 * update the UI with the changes.  Use this class as a base when you only have an
		 * {@link System.Collections.IEnumerable}.  If the object also implements
		 * {@link System.Collections.Specialized.INotifyCollectionChanged} it will get changed
		 * events otherwise you must register a new collection each time.
		 */
		export class EnumerableChangedHandler$1<TItem> {
			readonly Count: number;

			Collection: Iterable<TItem>;

			Register(collection: Iterable<TItem>): boolean;

			Unregister(): void;

			IndexOf(item: TItem): number;

			ElementAt(index: number): TItem;

			AddItem(item: TItem): void;

			InsertItem(
				index: number,
				item: TItem,
			): void;

			RemoveItem(index: number): void;

			RemoveAllItems(): void;

			RemoveItem(item: TItem): void;

			AddRange(items: Iterable<TItem>): void;

			InsertRange(
				index: number,
				items: Iterable<TItem>,
			): void;

			RemoveRange(
				index: number,
				count: number,
			): void;

			RemoveRange(items: Iterable<TItem>): void;

			Reset(): void;
		}
	}

	export namespace Eto {
		/**
		 * [Generic type factory] Helper class to handle collection change events of an
		 * {@link System.Collections.IEnumerable}
		 *
		 * This is used for the platform handler of controls that use collections. This class
		 * helps detect changes to a collection so that the appropriate action can be taken to
		 * update the UI with the changes.  Use this class as a base when you only have an
		 * {@link System.Collections.IEnumerable}.  If the object also implements
		 * {@link System.Collections.Specialized.INotifyCollectionChanged} it will get changed
		 * events otherwise you must register a new collection each time.
		 */
		export function EnumerableChangedHandler$(TItem: IType, TCollection: IType): typeof EnumerableChangedHandler$2<any, any>;

		/**
		 * Helper class to handle collection change events of an
		 * {@link System.Collections.IEnumerable}
		 *
		 * This is used for the platform handler of controls that use collections. This class
		 * helps detect changes to a collection so that the appropriate action can be taken to
		 * update the UI with the changes.  Use this class as a base when you only have an
		 * {@link System.Collections.IEnumerable}.  If the object also implements
		 * {@link System.Collections.Specialized.INotifyCollectionChanged} it will get changed
		 * events otherwise you must register a new collection each time.
		 */
		export class EnumerableChangedHandler$2<TItem, TCollection> {
			/** Gets the count of the items in the current registered collection. */
			readonly Count: number;

			Collection: TCollection;

			Register(collection: TCollection): boolean;

			Unregister(): void;

			IndexOf(item: TItem): number;

			ElementAt(index: number): TItem;

			AddItem(item: TItem): void;

			InsertItem(
				index: number,
				item: TItem,
			): void;

			RemoveItem(index: number): void;

			RemoveAllItems(): void;

			RemoveItem(item: TItem): void;

			AddRange(items: Iterable<TItem>): void;

			InsertRange(
				index: number,
				items: Iterable<TItem>,
			): void;

			RemoveRange(
				index: number,
				count: number,
			): void;

			RemoveRange(items: Iterable<TItem>): void;

			Reset(): void;
		}
	}

	export namespace Eto {
		/**
		 * [Generic type factory] Class to help implement change handling for a
		 * {@link Eto.Forms.IDataStore<>}
		 *
		 * This is used for the platform handler of controls that use collections. This class
		 * helps detect changes to a collection so that the appropriate action can be taken to
		 * update the UI with the changes.  Use this class as a base when you are detecting
		 * changes for an {@link Eto.Forms.IDataStore<>}. If the object also implements
		 * {@link System.Collections.Specialized.INotifyCollectionChanged}, it will get changed
		 * events. Otherwise, you must register a new collection each time.
		 */
		export function DataStoreChangedHandler$(TItem: IType, TCollection: IType): typeof DataStoreChangedHandler$2<any, any>;

		/**
		 * Class to help implement change handling for a {@link Eto.Forms.IDataStore<>}
		 *
		 * This is used for the platform handler of controls that use collections. This class
		 * helps detect changes to a collection so that the appropriate action can be taken to
		 * update the UI with the changes.  Use this class as a base when you are detecting
		 * changes for an {@link Eto.Forms.IDataStore<>}. If the object also implements
		 * {@link System.Collections.Specialized.INotifyCollectionChanged}, it will get changed
		 * events. Otherwise, you must register a new collection each time.
		 */
		export class DataStoreChangedHandler$2<TItem, TCollection> {
			/** Gets the count of the items in the current registered collection. */
			readonly Count: number;

			Collection: TCollection;

			/** Gets the enumerator. */
			GetEnumerator(): unknown;

			Register(collection: TCollection): boolean;

			Unregister(): void;

			IndexOf(item: TItem): number;

			ElementAt(index: number): TItem;

			AddItem(item: TItem): void;

			InsertItem(
				index: number,
				item: TItem,
			): void;

			RemoveItem(index: number): void;

			RemoveAllItems(): void;

			RemoveItem(item: TItem): void;

			AddRange(items: Iterable<TItem>): void;

			InsertRange(
				index: number,
				items: Iterable<TItem>,
			): void;

			RemoveRange(
				index: number,
				count: number,
			): void;

			RemoveRange(items: Iterable<TItem>): void;

			Reset(): void;
		}
	}

	export namespace Eto {
		/**
		 * Attribute to indicate which property of a type is the content property
		 *
		 * Used for compatibility with XAML.
		 */
		export class ContentPropertyAttribute {
			/** Initializes a new instance of the ContentPropertyAttribute class */
			constructor();

			/**
			 * Initializes a new instance of the ContentPropertyAttribute class with the specified
			 * name
			 */
			constructor(name: string);

			/** Gets the name of the property to use as the content property */
			Name: string;
		}
	}

	export namespace Eto {
		/** The default style provider which supports setting styles from delegates. */
		export class DefaultStyleProvider {
			constructor();

			/**
			 * Gets or sets a value indicating whether this {@link DefaultStyleProvider} allows
			 * inheriting styles from the parent object.
			 *
			 * This is used when applying cascading styles, sometimes the user or the provider will
			 * not want parent styles to be applicable.
			 */
			Inherit: boolean;

			/**
			 * Adds a style for a widget
			 *
			 * Styling a widget allows you to access the widget or its native handler class and apply
			 * logic.  Styling a handler allows you to access both the platform-specifics for the
			 * widget.   It requires you to add a reference to one of the Eto.*.dll's so that you can
			 * utilize the platform handler directly.  Typically this would be called before your
			 * application is run.
			 */
			Add<T>(
				style: string,
				handler: (arg1: T) => void,
			): void;

			/** Clears all styles from this provider */
			Clear(): void;
		}
	}

	export namespace Eto {
		/** Enumeration of the special folders that can be retrieved */
		export enum EtoSpecialFolder {
			/**
			 * Application settings folder to store settings or data
			 *
			 * This will return a different folder, depending on the platform:  OS X:
			 * ~/Library/Application Support/  Windows: %APPDATA% [User's Home]/Appdata/Roaming
			 * Linux:   ~/.config
			 */
			ApplicationSettings = 0,

			/**
			 * The application resources.path
			 *
			 * In OS X, this will be the .app bundle's resource path.  Other platforms will typically
			 * return the same path as the current executable file.
			 */
			ApplicationResources = 1,

			/** The user's documents folder */
			Documents = 2,

			/**
			 * Gets the path of the entry executable (.exe or native executable)
			 *
			 * This is used as in some cases when the application is bundled (e.g. using mkbundle),
			 * the location of the assembly can no longer be found as it is loaded from memory.
			 */
			EntryExecutable = 3,

			/**
			 * Gets the user's downloads folder
			 *
			 * Note that for GTK on Windows, this will *always* return "[User's Home]/Downloads",
			 * regardless of what the user's actual download path is.
			 */
			Downloads = 4,
		}
	}

	export namespace Eto {
		/** Environment methods */
		export namespace EtoEnvironment {
			/** Gets the platform information for the currently running operating system */
			export const Platform: Eto.OperatingSystemPlatform;

			/** Gets a value indicating the runtime is a 64 bit process. */
			export const Is64BitProcess: boolean;

			/** Gets the folder path for the specified special folder */
			export function GetFolderPath(folder: Eto.EtoSpecialFolder): string;
		}
	}

	export namespace Eto.EtoEnvironment {
		export interface IHandler {
			GetFolderPath(folder: Eto.EtoSpecialFolder): string;
		}
	}

	export namespace Eto {
		/** Member identifier for attached properties */
		export class EtoMemberIdentifier {
			/** Initializes a new instance of the EtoMemberIdentifier class */
			constructor(
				declaringType: unknown,
				memberName: string,
			);

			/** Gets the type that declared the member. */
			readonly DeclaringType: unknown;

			/** Gets the name of the member. */
			readonly MemberName: string;

			/**
			 * Determines whether the specified {@link System.Object} is equal to the current
			 * {@link Eto.AttachableMemberIdentifier}.
			 */
			Equals(obj: unknown): boolean;

			/**
			 * Determines whether the specified {@link Eto.AttachableMemberIdentifier} is equal to
			 * the current {@link Eto.AttachableMemberIdentifier}.
			 */
			Equals(other: Eto.AttachableMemberIdentifier): boolean;

			/** Serves as a hash function for a {@link Eto.AttachableMemberIdentifier} object. */
			GetHashCode(): number;

			/**
			 * Returns a {@link System.String} that represents the current
			 * {@link Eto.AttachableMemberIdentifier}.
			 */
			ToString(): string;
		}
	}

	export namespace Eto {
		/**
		 * Attachable member identifier for properties, when xaml is not present/available
		 *
		 * This is used to provide an alternate implementation of the AttachableMemberIdentifier
		 * when compiling without XAML support.
		 */
		export class AttachableMemberIdentifier {
			/** Initializes a new instance of the {@link Eto.AttachableMemberIdentifier} class. */
			constructor(
				declaringType: unknown,
				memberName: string,
			);

			/** Gets the type that declared the member. */
			DeclaringType: unknown;

			/** Gets the name of the member. */
			MemberName: string;

			/**
			 * Determines whether the specified {@link System.Object} is equal to the current
			 * {@link Eto.AttachableMemberIdentifier}.
			 */
			Equals(obj: unknown): boolean;

			/**
			 * Determines whether the specified {@link Eto.AttachableMemberIdentifier} is equal to
			 * the current {@link Eto.AttachableMemberIdentifier}.
			 */
			Equals(other: Eto.AttachableMemberIdentifier): boolean;

			/** Serves as a hash function for a {@link Eto.AttachableMemberIdentifier} object. */
			GetHashCode(): number;

			/**
			 * Returns a {@link System.String} that represents the current
			 * {@link Eto.AttachableMemberIdentifier}.
			 */
			ToString(): string;
		}
	}

	export namespace Eto {
		/**
		 * Exports a handler from a 3rd party assembly.
		 *
		 * Use this to register a custom control from your custom assembly.  Use
		 * {@link Eto.ExportInitializerAttribute} when registering a lot of controls or to
		 * perform additional logic.
		 */
		export class ExportHandlerAttribute {
			/** Initializes a new instance of the {@link Eto.ExportHandlerAttribute} class. */
			constructor(
				widgetType: unknown,
				handlerType: unknown,
			);

			/** Gets the type of the widget or handler interface to map to */
			WidgetType: unknown;

			/** Gets the type of the handler to instantiate */
			HandlerType: unknown;

			/**
			 * Gets or sets the platform identifier this extension should be loaded on, or null to
			 * load for all platforms.
			 */
			PlatformID: string;

			/** Registers the extension with the specified platform */
			Register(platform: Eto.Platform): void;

			/**
			 * Gets a value indicating that this extension supports the specified platform.
			 *
			 * {@link Eto.PlatformExtensionAttribute.Register(Eto.Platform)} will only be called if
			 * this returns true .
			 */
			Supports(platform: Eto.Platform): boolean;
		}
	}

	export namespace Eto {
		/**
		 * [Generic type factory] Observable collection with extended functionality such as
		 * sorting and adding a range of items
		 */
		export function ExtendedObservableCollection$(T: IType): typeof ExtendedObservableCollection$1<any>;

		/**
		 * Observable collection with extended functionality such as sorting and adding a range
		 * of items
		 */
		export class ExtendedObservableCollection$1<T> {
			/**
			 * Initializes a new instance of the {@link Eto.ExtendedObservableCollection<>} class.
			 */
			new(): ExtendedObservableCollection$1<T>;

			/**
			 * Initializes a new instance of the {@link Eto.ExtendedObservableCollection<>} class
			 * with the specified items.
			 */
			new(items: Iterable<T>): ExtendedObservableCollection$1<T>;

			/** Sorts the collection using the specified `comparer`. */
			Sort(comparer: unknown): void;

			/** Sorts the collection using the specified `comparison`. */
			Sort(comparison: unknown): void;

			/** Adds the specified `items` to the collection. */
			AddRange(items: Iterable<T>): void;
		}
	}

	export namespace Eto {
		/** File action. */
		export enum FileAction {
			/** The open file. */
			OpenFile = 0,

			/** The save file. */
			SaveFile = 1,

			/** The select folder. */
			SelectFolder = 2,
		}
	}

	export namespace Eto {
		/**
		 * Attribute to specify the interface type to use for the handler of a {@link Eto.Widget}
		 *
		 * Apply this to your widget-derived class to allow it to automatically create your
		 * handler.
		 */
		export class HandlerAttribute {
			/** Initializes a new instance of the {@link Eto.HandlerAttribute} class. */
			constructor(type: unknown);

			/** Gets the type of the handler required for the widget */
			Type: unknown;
		}
	}

	export namespace Eto {
		/**
		 * Helper class to get information about a namespace and assembly
		 *
		 * This is used to easily split the namespace and assembly parts from a string, and get
		 * the assembly instance. For example, "Eto.Drawing, Eto" will be split into
		 * "Eto.Drawing" for the namespace and the {@link Eto.NamespaceInfo.Assembly} instance
		 * for the Eto.dll.  Used primarily for serialization and conversion of types.
		 */
		export class NamespaceInfo {
			/** Initializes a new instance of the {@link Eto.NamespaceInfo} class. */
			constructor(ns: string);

			/** Initializes a new instance of the {@link Eto.NamespaceInfo} class. */
			constructor(
				ns: string,
				assembly: unknown,
			);

			/** Gets or sets the assembly. */
			Assembly: unknown;

			/** Gets the namespace. */
			Namespace: string;

			/**
			 * Finds the specified type in the {@link Eto.NamespaceInfo.Namespace} of this
			 * {@link Eto.NamespaceInfo.Assembly}
			 */
			FindType(typeName: string): unknown;

			/**
			 * Finds the resource in the {@link Eto.NamespaceInfo.Namespace} of this
			 * {@link Eto.NamespaceInfo.Assembly}
			 */
			FindResource(resourceName: string): Duplex;

			/**
			 * Finds the resource in the {@link Eto.NamespaceInfo.Assembly} with the specified
			 * {@link Eto.NamespaceInfo.Namespace}
			 */
			FindResource(): Duplex;
		}
	}

	export namespace Eto {
		/**
		 * Operating system platform information
		 *
		 * Access this information from {@link Eto.EtoEnvironment.Platform}
		 */
		export class OperatingSystemPlatform {
			/** Initializes a new instance of the OperatingSystemPlatform class */
			constructor();

			/** Gets a value indicating that the current .NET runtime is mono */
			IsMono: boolean;

			/** Gets a value indicating that the current .NET runtime is .NET Core */
			IsNetCore: boolean;

			/** Gets a value indicating that the current OS is windows system */
			IsWindows: boolean;

			/** Gets a value indicating that the current OS is a Windows Runtime (WinRT) system. */
			IsWinRT: boolean;

			/**
			 * Gets a value indicating that the current OS is a unix-based system
			 *
			 * This will be true for both Unix (e.g. OS X) and all Linux variants.
			 */
			IsUnix: boolean;

			/** Gets a value indicating that the current OS is a Mac OS X system */
			IsMac: boolean;

			/** Gets a value indicating that the current OS is a Linux system */
			IsLinux: boolean;
		}
	}

	export namespace Eto {
		/**
		 * Interface for a type descriptor context, for type converter compatibility in portable
		 * class libraries.
		 */
		export interface ITypeDescriptorContext {
		}
	}

	export namespace Eto {
		/**
		 * Type converter attribute, for type converter compatibility in portable class
		 * libraries.
		 */
		export class TypeConverterAttribute {
			/** Initializes a new instance of the {@link Eto.TypeConverterAttribute} class. */
			constructor(type: unknown);

			/** Initializes a new instance of the {@link Eto.TypeConverterAttribute} class. */
			constructor(typeName: string);

			/** Gets the name of the type for the type converter of the associated type. */
			ConverterTypeName: string;
		}
	}

	export namespace Eto {
		/** Type descriptor for conversion compatibility. */
		export namespace TypeDescriptor {
			/** Gets the type converter for the specified type. */
			export function GetConverter(type: unknown): Eto.TypeConverter;
		}
	}

	export namespace Eto {
		/**
		 * Type converter implementation, for type converter compatibility in portable class
		 * libraries.
		 */
		export class TypeConverter {
			constructor();

			/** Determines whether this instance can convert from the specified sourceType. */
			CanConvertFrom(sourceType: unknown): boolean;

			/**
			 * Determines whether this instance can convert from the specified context sourceType.
			 */
			CanConvertFrom(
				context: Eto.ITypeDescriptorContext,
				sourceType: unknown,
			): boolean;

			/** Determines whether this instance can convert to the specified destinationType. */
			CanConvertTo(destinationType: unknown): boolean;

			/**
			 * Determines whether this instance can convert to the specified context destinationType.
			 */
			CanConvertTo(
				context: Eto.ITypeDescriptorContext,
				destinationType: unknown,
			): boolean;

			/** Converts from the specified object. */
			ConvertFrom(o: unknown): unknown;

			/** Converts the specified `value`. */
			ConvertFrom(
				context: Eto.ITypeDescriptorContext,
				culture: unknown,
				value: unknown,
			): unknown;

			/** Converts from an invariant string. */
			ConvertFromInvariantString(text: string): unknown;

			/** Converts from an invariant string. */
			ConvertFromInvariantString(
				context: Eto.ITypeDescriptorContext,
				text: string,
			): unknown;

			/** Converts from string. */
			ConvertFromString(text: string): unknown;

			/** Converts from string. */
			ConvertFromString(
				context: Eto.ITypeDescriptorContext,
				text: string,
			): unknown;

			/** Converts from string. */
			ConvertFromString(
				context: Eto.ITypeDescriptorContext,
				culture: unknown,
				text: string,
			): unknown;

			/** Converts to the specified type. */
			ConvertTo(
				value: unknown,
				destinationType: unknown,
			): unknown;

			/** Converts to the specified type. */
			ConvertTo(
				context: Eto.ITypeDescriptorContext,
				culture: unknown,
				value: unknown,
				destinationType: unknown,
			): unknown;

			/** Converts to an invariant string. */
			ConvertToInvariantString(value: unknown): string;

			/** Converts to invariant string. */
			ConvertToInvariantString(
				context: Eto.ITypeDescriptorContext,
				value: unknown,
			): string;

			/** Converts to a string. */
			ConvertToString(value: unknown): string;

			/** Converts to a string. */
			ConvertToString(
				context: Eto.ITypeDescriptorContext,
				value: unknown,
			): string;

			/** Converts to a string. */
			ConvertToString(
				context: Eto.ITypeDescriptorContext,
				culture: unknown,
				value: unknown,
			): string;

			/** Determines whether this instance is valid the specified value. */
			IsValid(value: unknown): boolean;

			/** Determines whether this instance is valid the specified context value. */
			IsValid(
				context: Eto.ITypeDescriptorContext,
				value: unknown,
			): boolean;
		}
	}

	export namespace Eto {
		/** Arguments for when a widget is created */
		export class WidgetCreatedEventArgs {
			/** Initializes a new instance of the WidgetCreatedArgs class */
			constructor(instance: Eto.Widget);

			/** Gets the instance of the widget that was created */
			Instance: Eto.Widget;
		}
	}

	export namespace Eto {
		/** Arguments for when a widget is created */
		export class HandlerCreatedEventArgs {
			/** Initializes a new instance of the WidgetCreatedArgs class */
			constructor(instance: unknown);

			/** Gets the instance of the widget that was created */
			Instance: unknown;
		}
	}

	export namespace Eto {
		/** Flags to specify which global features are supported for a platform */
		export enum PlatformFeatures {
			/** No extra features supported. */
			None = 0,

			/**
			 * Specifies that the {@link Eto.Forms.CustomCell} supports creating a Control for each
			 * cell. If not specified, then the CustomCell will paint its content when not in edit
			 * mode.
			 */
			CustomCellSupportsControlView = 1,

			/**
			 * Specifies that the {@link Eto.Forms.Drawable} supports automatic transparent
			 * background for its Content . If not specified, then setting the content may not work
			 * as intended (most often not rendering with transparent background, thus overpainting
			 * the drawable).
			 */
			DrawableWithTransparentContent = 2,

			/**
			 * Specifies the {@link Eto.Forms.Control.TabIndex} is based on the logical tree, not the
			 * visual tree. Both GTK and WinForms do not support creating a custom tab focus and is
			 * based on the direct containers.  For example, setting a TabIndex for controls in
			 * DynamicLayout and StackLayout might not behave as expected on platforms that do not
			 * support this.
			 */
			TabIndexWithCustomContainers = 4,
		}
	}

	export namespace Eto {
		/**
		 * Base platform class
		 *
		 * This class takes care of creating the platform-specific implementations of each
		 * control. All controls the platform can handle should be added using
		 * {@link Eto.Platform.Add``1(System.Func{``0})}.
		 */
		export class Platform {
			/**
			 * Gets the ID of this platform
			 *
			 * The platform ID can be used to determine which platform is currently in use.  The
			 * platform does not necessarily correspond to the OS that it is running on, as for
			 * example the GTK platform can run on OS X and Windows.
			 */
			readonly ID: string;

			/**
			 * Gets a value indicating whether this platform is a mac based platform (MonoMac/MacOS)
			 */
			readonly IsMac: boolean;

			/** Gets a value indicating whether this platform is based on Windows Forms */
			readonly IsWinForms: boolean;

			/** Gets a value indicating whether this platform is based on WPF */
			readonly IsWpf: boolean;

			/** Gets a value indicating whether this platform is based on GTK# (2 or 3) */
			readonly IsGtk: boolean;

			/** Gets a value indicating whether this platform is based on Xamarin.iOS */
			readonly IsIos: boolean;

			/** Gets a value indicating whether this platform is based on Xamarin.Android. */
			readonly IsAndroid: boolean;

			/**
			 * Gets a value indicating whether this is a desktop platform. This includes Mac, Gtk,
			 * WinForms, Wpf, Direct2D.
			 *
			 * A desktop platform is usually used via mouse &amp; keyboard, and can have complex user
			 * interface elements.
			 */
			readonly IsDesktop: boolean;

			/**
			 * Gets a value indicating whether this is a mobile platform. This includes iOS, Android,
			 * and WinRT.
			 *
			 * A mobile platform is usually touch friendly, and have a simpler interface.
			 */
			readonly IsMobile: boolean;

			/**
			 * Gets a value indicating that this platform is valid on the running device
			 *
			 * This is used in platform detection to ensure that the correct platform is loaded. For
			 * example, the Mac platforms are only valid when run in an .app bundle.
			 */
			readonly IsValid: boolean;

			/** Gets the supported features of the platform. */
			readonly SupportedFeatures: Eto.PlatformFeatures;

			/**
			 * Gets the platform for the current thread
			 *
			 * Typically you'd have only one platform active at a time, and this holds an instance to
			 * that value. The current platform is set automatically by the
			 * {@link Eto.Forms.Application} class when it is initially created.  This will return a
			 * different value for each thread, so if you have multiple platforms running (e.g. GTK +
			 * Mac for OS X), then this will allow for that.  This will be used when creating
			 * controls. To create controls on a different platform outside of its own thread,  use
			 * the {@link Eto.Platform.Context} property.
			 */
			static readonly Instance: Eto.Platform;

			/**
			 * Returns the current generator, or detects the generator to use if no current generator
			 * is set.
			 *
			 * This detects the platform to use based on the generator assemblies available and the
			 * current OS.  For windows, it will prefer WPF to Windows Forms. Mac OS X will prefer
			 * the Mac platform. Other unix-based platforms will prefer GTK.
			 */
			static readonly Detect: Eto.Platform;

			/**
			 * Gets or sets a value indicating that the platform should allow reinitialization.
			 *
			 * When false, prevents incorrect logic that may create multiple instances of
			 * {@link Eto.Forms.Application} or {@link Eto.Platform} in the same thread which can
			 * causes issues where handlers are no longer registered, etc.  Multiple instances should
			 * still be able to be created in separate threads (for platforms that support it) when
			 * this is false.
			 */
			static AllowReinitialize: boolean;

			/**
			 * Gets an object to wrap in the platform's context, when using multiple platforms.
			 *
			 * This sets this platform as current, and reverts back to the previous platform when
			 * disposed.  This value may be null.
			 */
			readonly Context: IDisposable;

			/** Gets a value indicating that the specified type is supported by this platform */
			Supports<T>(): boolean;

			/** Gets a value indicating that the specified `type` is supported by this platform */
			Supports(type: unknown): boolean;

			/**
			 * Loads the extensions specified by the assembly attribute
			 * {@link Eto.PlatformExtensionAttribute}.
			 */
			LoadAssembly(assemblyName: string): void;

			/**
			 * Loads the extensions specified by the assembly attribute
			 * {@link Eto.PlatformExtensionAttribute}.
			 *
			 * This is useful for 3rd party libraries and when defining your own custom controls.
			 * This method is called automatically on the same assembly of a custom control when its
			 * handler cannot be found. It will also be called for the same assembly with the prefix
			 * of the platform ID.  For example, if MyControl was declared in MyControls.dll , then
			 * Eto will automatically also load MyControls.Wpf.dll for the Wpf platform, and
			 * MyControls.MacOS.dll for the MacOS platform, etc.  Use
			 * {@link Eto.ExportHandlerAttribute} and {@link Eto.ExportInitializerAttribute} to
			 * register handlers with the platform when the assembly is loaded or perform other
			 * logic.
			 */
			LoadAssembly(assembly: unknown): void;

			/**
			 * Initializes the specified `platform` as the current generator, for the current thread
			 *
			 * This is called automatically by the {@link Eto.Forms.Application} when it is
			 * constructed
			 */
			static Initialize(platform: Eto.Platform): void;

			/**
			 * Initialize the generator with the specified `platformType` as the current generator
			 */
			static Initialize(platformType: string): void;

			/** Gets the generator of the specified type */
			static Get(generatorType: string): Eto.Platform;

			/** Add the `instantiator` for the specified handler type of  */
			Add<T>(instantiator: () => T): void;

			/** Add the specified type and instantiator. */
			Add(
				type: unknown,
				instantiator: () => unknown,
			): void;

			/** Find the delegate to create instances of the specified `type` */
			Find(type: unknown): () => unknown;

			/** Finds the delegate to create instances of the specified type */
			Find<T>(): () => T;

			/**
			 * Creates a new instance of the handler of the specified type of
			 *
			 * This extension should be used when creating instances of a fixed type.
			 */
			Create<T>(): T;

			/** Creates a new instance of the handler of the specified type */
			Create(type: unknown): unknown;

			/** Creates a shared singleton instance of the specified type of `type` */
			CreateShared(type: unknown): unknown;

			/**
			 * Creates a shared singleton instance of the specified type of
			 *
			 * This extension should be used when creating shared instances of a fixed type.
			 */
			CreateShared<T>(): T;

			/**
			 * Gets a shared cache dictionary
			 *
			 * This is used to cache things like brushes and pens, but can also be used to cache
			 * other things for your application's use.
			 */
			Cache<TKey, TValue>(cacheKey: unknown): unknown;

			/** Used at the start of your custom threads */
			ThreadStart(): IDisposable;

			/**
			 * Invoke the specified action within the context of this platform
			 *
			 * This is useful when you are using multiple platforms at the same time, and gives you
			 * an easy way to execute code within the context of this platform.
			 */
			Invoke(action: () => void): void;

			/**
			 * Invoke the specified function within the context of this platform, returning its
			 * value.
			 *
			 * This is useful when you are using multiple platforms at the same time, and gives you
			 * an easy way to execute code within the context of this platform, and return its value.
			 */
			Invoke<T>(action: () => T): T;
		}
	}

	export namespace Eto {
		/**
		 * Attribute to apply to 3rd party assemblies to load additional controls or
		 * functionality.
		 *
		 * This can be used by both by the cross platform control library, and in each of the
		 * platform-specific libraries.
		 */
		export class ExportInitializerAttribute {
			/** Initializes a new instance of the PlatformInitializerAttribute class */
			constructor(initializerType: unknown);

			/**
			 * Type of the extension class to instantiate when the assembly this attribute is
			 * supplied on is loaded by the platform.
			 *
			 * This type should usually implement {@link Eto.IPlatformInitializer} so that it can
			 * know what platform it is being loaded on.
			 */
			readonly InitializerType: unknown;

			/**
			 * Gets or sets the platform identifier this extension should be loaded on, or null to
			 * load for all platforms.
			 */
			PlatformID: string;

			/** Registers the extension with the specified platform */
			Register(platform: Eto.Platform): void;

			/**
			 * Gets a value indicating that this extension supports the specified platform.
			 *
			 * {@link Eto.PlatformExtensionAttribute.Register(Eto.Platform)} will only be called if
			 * this returns true .
			 */
			Supports(platform: Eto.Platform): boolean;
		}
	}

	export namespace Eto {
		/**
		 * Platform extension for 3rd party libraries to provide additional controls or
		 * functionality
		 *
		 * This is implemented for types that are referenced using the
		 * {@link Eto.ExportInitializerAttribute}.
		 */
		export interface IPlatformInitializer {
			/** Called to add specific functionality to the specified `platform` */
			Initialize(platform: Eto.Platform): void;
		}
	}

	export namespace Eto {
		/**
		 * Base extension attribute to wire up 3rd party controls and native handler
		 * implementations.
		 *
		 * All extensions are loaded via
		 * {@link Eto.Platform.LoadAssembly(System.Reflection.Assembly)}.    Use the
		 * {@link Eto.PlatformExtensionAttribute.PlatformID} property to specify which platform
		 * the extension applies to.
		 */
		export class PlatformExtensionAttribute {
			/**
			 * Gets or sets the platform identifier this extension should be loaded on, or null to
			 * load for all platforms.
			 */
			PlatformID: string;

			/**
			 * Gets a value indicating that this extension supports the specified platform.
			 *
			 * {@link Eto.PlatformExtensionAttribute.Register(Eto.Platform)} will only be called if
			 * this returns true .
			 */
			Supports(platform: Eto.Platform): boolean;

			/** Registers the extension with the specified platform */
			Register(platform: Eto.Platform): void;
		}
	}

	export namespace Eto {
		/** Constants for the standard Generator generators */
		export namespace Platforms {
		}
	}

	export namespace Eto {
		/**
		 * A storage for properties and events of a class
		 *
		 * This is used by {@link Eto.Widget} object to minimize the footprint of each instance.
		 * For example, the {@link Eto.Forms.Control} class has around 20 events, each would take
		 * up to 4 bytes on a 32 bit  system for a total overhead of 80 bytes per instance. Most
		 * of the events won't be handled on most controls, so using a dictionary can
		 * dramatically reduce the size.  This can also be used for rarely used properties that
		 * do not need to be extremely performant when getting or setting the value.
		 */
		export class PropertyStore {
			/** Initializes a new instance of the {@link Eto.PropertyStore} class. */
			constructor(parent: unknown);

			/**
			 * Gets the parent object that this property store is attached to
			 *
			 * This is used to attach/remove events
			 */
			Parent: unknown;

			/** Gets a value from the property store with the specified key of a concrete type */
			Get<T>(
				key: unknown,
				defaultValue?: T,
			): T;

			/** Gets a value from the property store with the specified key of a concrete type */
			Get<T>(
				key: unknown,
				defaultValue: () => T,
			): T;

			/**
			 * Gets a value from the property store with the specified key of a concrete type, and
			 * creates a new instance if it doesn't exist yet.
			 */
			Create<T>(key: unknown): T;

			/**
			 * Gets a value from the property store with the specified key of a concrete type, and
			 * creates a new instance if it doesn't exist yet.
			 */
			Create<T>(
				key: unknown,
				create: () => T,
			): T;

			/**
			 * Adds a generic event delegate with the specified key
			 *
			 * This should be called in an event's add accessor. If you are adding a handler-based
			 * event, call {@link Eto.PropertyStore.AddHandlerEvent(System.String,System.Delegate)}
			 * instead, which will automatically tell the handler that it needs to be wired up.  You
			 * can use any subclass of {@link System.EventArgs} for the type of event handler  To
			 * trigger the event, use
			 * {@link Eto.PropertyStore.TriggerEvent``1(System.Object,System.Object,``0)}.
			 */
			AddEvent(
				key: unknown,
				value: unknown,
			): void;

			/**
			 * Adds a handler-based event delegate with the specified key
			 *
			 * This should be called in an event's add accessor. This is used for any event that
			 * should be triggered by the platform handler.  This will call
			 * {@link Eto.Widget.IHandler.HandleEvent(string,bool)} with the specified `key` for the
			 * first subscription to the event.  You can use any subclass of {@link System.EventArgs}
			 * for the type of event handler  To trigger the event, use
			 * {@link Eto.PropertyStore.TriggerEvent``1(System.Object,System.Object,``0)}
			 */
			AddHandlerEvent(
				key: string,
				value: unknown,
			): void;

			/**
			 * Removes the event delegate with the specified `key`
			 *
			 * Use this in the remove accessor of your event.  See
			 * {@link Eto.PropertyStore.AddEvent(System.Object,System.Delegate)} and
			 * {@link Eto.PropertyStore.AddHandlerEvent(System.String,System.Delegate)} for examples.
			 */
			RemoveEvent(
				key: unknown,
				value: unknown,
			): void;

			/**
			 * Triggers an event with the specified key
			 *
			 * Call this in your OnMyEvent(EventArgs) method to trigger the event if it has been
			 * subscribed to. This can handle events that have any type of EventArgs.
			 */
			TriggerEvent<T>(
				key: unknown,
				sender: unknown,
				args: T,
			): void;

			/**
			 * Set the value for the specified property key, removing the value from the dictionary
			 * if it is the default value of T.
			 *
			 * This can be used as an optimized way to set the value in the dictionary as if the
			 * value set equal to the `defaultValue` (e.g. null for reference types, false for bool,
			 * 0 for int, etc), then it will be removed from the dictionary instead of just set to
			 * the value, reducing memory usage. The
			 * {@link Eto.PropertyStore.Get``1(System.Object,``0)} should be passed the same default
			 * when retrieving the parameter value.
			 */
			Set<T>(
				key: unknown,
				value: T,
				defaultValue?: T,
			): void;

			/**
			 * Set the value for the specified property key, removing the value from the dictionary
			 * if it is the default value of T.
			 *
			 * This can be used as an optimized way to set the value in the dictionary as if the
			 * value set equal to the default value. (e.g. null for reference types, false for bool,
			 * 0 for int, etc), then it will be removed from the dictionary instead of just set to
			 * the value, reducing memory usage.
			 */
			TrySet<T>(
				key: unknown,
				value: T,
				defaultValue?: T,
			): boolean;

			/**
			 * Set the value for the specified property key, raising the `propertyChanged` handler if
			 * it has changed.
			 *
			 * This is useful when creating properties that need to trigger changed events without
			 * having to write boilerplate code.
			 */
			Set<T>(
				key: unknown,
				value: T,
				propertyChanged: unknown,
				defaultValue?: T,
				propertyName?: string,
			): boolean;

			/**
			 * Set the value for the specified property key, calling the `propertyChanged` delegate
			 * if it has changed.
			 *
			 * This is useful when creating properties that need to trigger changed events without
			 * having to write boilerplate code.
			 */
			Set<T>(
				key: unknown,
				value: T,
				propertyChanged: () => void,
				defaultValue?: T,
			): boolean;

			/**
			 * Sets an {@link System.Windows.Input.ICommand} value for the specified property `key`.
			 */
			SetCommand(
				key: unknown,
				value: unknown,
				setEnabled: (arg1: boolean) => void,
				addExecute: (arg1: unknown) => void,
				removeExecute: (arg1: unknown) => void,
				getParameter: () => unknown,
			): void;

			/** Updates the command's execute status, typically when the CommandParameter changes. */
			UpdateCommandCanExecute(key: unknown): void;

			/** Gets the command instance for the specified property key. */
			GetCommand(key: unknown): unknown;
		}
	}

	export namespace Eto {
		/**
		 * Attribute to specify the name property of a control for serialization
		 *
		 * Used by Eto.Serialization.Xaml, for example, to specify which property is used for the
		 * name property.  E.g. when specifying the ID, it also specifies which name of the
		 * backing field.
		 */
		export class RuntimeNamePropertyAttribute {
			/** Initializes a new instance of the {@link Eto.RuntimeNamePropertyAttribute} class. */
			constructor(name: string);

			/** Gets the name of the property to use as the runtime name */
			Name: string;
		}
	}

	export namespace Eto {
		/**
		 * Interface for a style provider
		 *
		 * This can be used to create your own style engine to apply styles to widgets. The
		 * {@link Eto.DefaultStyleProvider} is a good example of how to implement a style
		 * provider.
		 */
		export interface IStyleProvider {
			/**
			 * Gets a value indicating whether this {@link Eto.IStyleProvider} allows inheriting
			 * styles from the parent object.
			 *
			 * This is used when applying cascading styles, sometimes the user or the provider will
			 * not want parent styles to be applicable.
			 */
			readonly Inherit: boolean;

			/**
			 * Applies cascading styles to the specified `widget`.
			 *
			 * Cascading styles are applied on a widget when it is loaded onto a form,  where styles
			 * are usually applied based on the container it is in.
			 */
			ApplyCascadingStyle(
				container: unknown,
				widget: unknown,
				style: string,
			): void;

			/**
			 * Applies styles to the specified `widget`
			 *
			 * This is used for global style providers when applying styles to a widget directly
			 * based on its style alone.  This is usually applied when the style itself is updated.
			 */
			ApplyStyle(
				widget: unknown,
				style: string,
			): void;

			/** Applies default styling to the specified widget after creation. */
			ApplyDefault(widget: unknown): void;
		}
	}

	export namespace Eto {
		/**
		 * [Generic type factory] Delegate to handle styling a widget
		 *
		 * This allows you to add additional logic or set properties on the widget based on the
		 * styles set on the widget.
		 */
		export function StyleWidgetHandler$(TWidget: IType): IType;

		/**
		 * Delegate to handle styling a widget
		 *
		 * This allows you to add additional logic or set properties on the widget based on the
		 * styles set on the widget.
		 */
		export interface StyleWidgetHandler$1<TWidget> { (widget: TWidget): void; }
	}

	export namespace Eto {
		/**
		 * [Generic type factory] Delegate to handle styling a widget handler
		 *
		 * This allows you to add additional logic or set properties on the widget and
		 * platform-specific control(s) based on the styles set on the widget.
		 */
		export function StyleHandler$(THandler: IType): IType;

		/**
		 * Delegate to handle styling a widget handler
		 *
		 * This allows you to add additional logic or set properties on the widget and
		 * platform-specific control(s) based on the styles set on the widget.
		 */
		export interface StyleHandler$1<THandler> { (handler: THandler): void; }
	}

	export namespace Eto {
		/**
		 * Style manager for widgets
		 *
		 * Styles allow you to attach custom platform-specific logic to a widget. In your
		 * platform-specific assembly, use Style.Add&lt;H&gt;(string, StyleHandler&lt;H&gt;) to
		 * add the style logic with the same id.  Typically, your styles will be added in your
		 * platform-specific executable, before your application is run.
		 */
		export namespace Style {
			/**
			 * Gets or sets the style provider.
			 *
			 * By default, this is an instance of {@link Eto.DefaultStyleProvider}. If you set this
			 * value, any styles applied using
			 * {@link Eto.Style.Add``1(System.String,Eto.StyleHandler{``0})} or
			 * {@link Eto.Style.Add``1(System.String,Eto.StyleWidgetHandler{``0})} will no longer be
			 * used.
			 */
			export var Provider: Eto.IStyleProvider;

			/**
			 * Adds a style for a widget
			 *
			 * Styling a widget allows you to access the widget, but not the platform-specific
			 * controls (in a type-safe way).  Typically, you'd use Style.Add&lt;H&gt;(string,
			 * StyleHandler&lt;H&gt;) instead, which will add a style based on the widget handler,
			 * which will give you direct and type safe access to platform-specifics of the widget.
			 */
			export function Add<TWidget>(
				style: string,
				handler: Eto.StyleWidgetHandler$1<TWidget>,
			): void;

			/**
			 * Adds a style for a widget handler
			 *
			 * Styling a widget handler allows you to access both the widget and the
			 * platform-specifics for the widget.  To use this, you would have to add a reference to
			 * one of the Eto.*.dll's so that you can utilize the platform handler directly.
			 * Typically this would be called before your application is run.
			 */
			export function Add<THandler>(
				style: string,
				styleHandler: Eto.StyleHandler$1<THandler>,
			): void;
		}
	}

	export namespace Eto {
		/**
		 * Provides data for the event that is raised when there is an exception that is not
		 * handled otherwise
		 *
		 * There is a System.UnhandledExceptionEventArgs class, but that doesn't seem to be
		 * available in the Core CLR, therefore we redefine it here.
		 */
		export class UnhandledExceptionEventArgs {
			/** Initializes a new instance of the {@link Eto.UnhandledExceptionEventArgs} class. */
			constructor(
				exception: unknown,
				isTerminating: boolean,
			);

			/** Gets the unhandled exception object. */
			ExceptionObject: unknown;

			/** Indicates whether the application is terminating. */
			IsTerminating: boolean;
		}
	}

	export namespace Eto {
		/** Interface for widgets that have a control object */
		export interface IControlObjectSource {
			/** Gets the control object for this widget */
			readonly ControlObject: unknown;
		}
	}

	export namespace Eto {
		/** Interface for widgets that have a handler */
		export interface IHandlerSource {
			/** Gets the platform handler object for the widget */
			readonly Handler: unknown;
		}
	}

	export namespace Eto {
		/** Interface to get the callback object for a widget */
		export interface ICallbackSource {
			/**
			 * Gets an instance of an object used to perform callbacks to the widget from handler
			 * implementations
			 *
			 * The callback should implement the parent class' callback interface so that there only
			 * needs to be a single callback for the entire hierarchy.  This should return a static
			 * instance to avoid having overhead for each instance of your widget.
			 */
			readonly Callback: unknown;
		}
	}

	export namespace Eto {
		/**
		 * Base widget class for all objects requiring a platform-specific implementation
		 *
		 * The Widget is the base of all abstracted objects that have platform-specific
		 * implementations.  To implement the handler for a widget, use the
		 * {@link Eto.WidgetHandler<>} as the base class.
		 */
		export class Widget implements
			Eto.IHandlerSource {
			/**
			 * Gets the platform that was used to create the {@link Eto.Widget.Handler} for this
			 * widget
			 *
			 * This gets set to the current {@link Eto.Platform.Instance} during the construction of
			 * the object
			 */
			Platform: Eto.Platform;

			/** Gets the platform-specific handler for this widget */
			Handler: unknown;

			/** Gets the native platform-specific handle for integration purposes */
			readonly NativeHandle: unknown;

			/** Gets the dictionary of properties for this widget */
			readonly Properties: Eto.PropertyStore;

			/** Gets or sets the ID of this widget */
			ID: string;

			/**
			 * Gets or sets the style of this widget
			 *
			 * Styles allow you to attach custom platform-specific logic to a widget. In your
			 * platform-specific assembly, use {@link Style.Add{H}(string, StyleHandler{H})} to add
			 * the style logic with the same id.
			 */
			Style: string;

			/**
			 * Gets the instance of the platform-specific object
			 *
			 * This can sometimes be useful to get the platform-specific object. Some handlers may
			 * not have any backing object for its functionality, so this may be null.  It is more
			 * preferred to use the {@link Eto.Widget.Handler} and cast that to the platform-specific
			 * handler class which can give you additional methods and helpers to do common tasks.
			 * For example, the {@link Eto.Forms.Application} object's handler for OS X has a
			 * AddFullScreenMenuItem property to specify if you want full screen support in your app.
			 */
			readonly ControlObject: unknown;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Widget} has been disposed.
			 *
			 * When the widget is disposed, it can no longer be used.
			 */
			IsDisposed: boolean;

			/** Disposes of this widget, supressing the finalizer */
			dispose(): void;

			/** Gets a string that represents the current object with its ID if specified. */
			ToString(): string;
		}
	}

	export namespace Eto.Widget {
		export interface ICallback {
		}
	}

	export namespace Eto.Widget {
		export interface IHandler {
			ID: string;

			Widget: Eto.Widget;

			readonly NativeHandle: unknown;

			Initialize(): void;

			HandleEvent(
				id: string,
				defaultEvent?: boolean,
			): void;
		}
	}

	export namespace Eto {
		/**
		 * [Generic type factory] Base platform handler for widgets
		 *
		 * This is the base class for platform handlers.  It is used to help wire up events and
		 * provide base functionality of a widget.  If you are creating an InstanceWidget, you
		 * should use {@link Eto.WidgetHandler<,>}.
		 */
		export function WidgetHandler$(TWidget: IType): typeof WidgetHandler$1<any>;

		/**
		 * Base platform handler for widgets
		 *
		 * This is the base class for platform handlers.  It is used to help wire up events and
		 * provide base functionality of a widget.  If you are creating an InstanceWidget, you
		 * should use {@link Eto.WidgetHandler<,>}.
		 */
		export class WidgetHandler$1<TWidget> implements Eto.Widget.IHandler {
			/** Gets the widget that this platform handler is attached to */
			Widget: TWidget;

			/** Gets or sets the ID of this widget */
			ID: string;

			/** Gets the native platform-specific handle for integration purposes */
			readonly NativeHandle: unknown;

			/** Gets a value indicating that the specified event is handled */
			IsEventHandled(id: string): boolean;

			/**
			 * Called to handle a specific event
			 *
			 * Most events are late bound by this method. Instead of wiring all events, this will be
			 * called with an event string that is defined by the control.  This is called
			 * automatically when attaching to events, but must be called manually when users of the
			 * control only override the event's On... method.  Override the
			 * {@link Eto.WidgetHandler`1.AttachEvent(System.String)} to attach your events
			 */
			HandleEvent(
				id: string,
				defaultEvent?: boolean,
			): void;

			/**
			 * Attaches the specified event to the platform-specific control
			 *
			 * Implementors should override this method to handle any events that the widget
			 * supports. Ensure to call the base class' implementation if the event is not one the
			 * specific widget supports, so the base class' events can be handled as well.
			 */
			AttachEvent(id: string): void;

			/**
			 * Disposes this object
			 *
			 * To handle disposal logic, use the {@link Eto.WidgetHandler`1.Dispose(System.Boolean)}
			 * method.
			 */
			dispose(): void;
		}
	}

	export namespace Eto {
		/**
		 * [Generic type factory] Base platform handler for {@link Eto.Widget} objects that have
		 * a backing platform object
		 *
		 * This is the base class for platform handlers.  It is used to help wire up events and
		 * provide base functionality of a widget.
		 */
		export function WidgetHandler$(TControl: IType, TWidget: IType): typeof WidgetHandler$2<any, any>;

		/**
		 * Base platform handler for {@link Eto.Widget} objects that have a backing platform
		 * object
		 *
		 * This is the base class for platform handlers.  It is used to help wire up events and
		 * provide base functionality of a widget.
		 */
		export class WidgetHandler$2<TControl, TWidget> implements
			Eto.Widget.IHandler {
			/** Gets or sets the platform-specific control object */
			Control: TControl;

			/**
			 * Gets a value indicating whether this instance has a
			 * {@link Eto.WidgetHandler`2.Control} instance.
			 */
			readonly HasControl: boolean;

			readonly Widget: TWidget;

			ID: string;

			readonly NativeHandle: unknown;

			/**
			 * Gets the platform-specific control object of the specified widget using this handler
			 *
			 * The widget must be using a handler that returns the same control.  This can be used
			 * very easily by platform code: MyControl mycontrol; 	var platformControl =
			 * MyControlHandler.GetControl(mycontrol); Note that even if the specified handler is
			 * used, the control might not actually be using that handler.  This method will still
			 * work as long as the handler implements using the same base platform-specific control.
			 */
			static GetControl(widget: any): any;

			IsEventHandled(id: string): boolean;

			HandleEvent(
				id: string,
				defaultEvent?: boolean,
			): void;

			AttachEvent(id: string): void;

			dispose(): void;
		}
	}

	export namespace Eto {
		/**
		 * [Generic type factory] Widget handler with type-specific callback
		 *
		 * This can be used by controls that have events to trigger using a callback class.
		 */
		export function WidgetHandler$(TControl: IType, TWidget: IType, TCallback: IType): typeof WidgetHandler$3<any, any, any>;

		/**
		 * Widget handler with type-specific callback
		 *
		 * This can be used by controls that have events to trigger using a callback class.
		 */
		export class WidgetHandler$3<TControl, TWidget, TCallback> implements
			Eto.Widget.IHandler {
			/**
			 * Gets the callback object for the control
			 *
			 * This object is typically a single static instance that is used by the platform
			 * handlers to call private or protected methods on the widget, such as protected event
			 * methods e.g. protected virtual void OnClick(EventArgs e)
			 */
			readonly Callback: TCallback;

			Control: TControl;

			readonly HasControl: boolean;

			readonly Widget: TWidget;

			ID: string;

			readonly NativeHandle: unknown;

			IsEventHandled(id: string): boolean;

			HandleEvent(
				id: string,
				defaultEvent?: boolean,
			): void;

			AttachEvent(id: string): void;

			dispose(): void;
		}
	}

	export namespace Eto.Threading {
		/**
		 * Provides access to platform-specific threading. Not all platforms implement this as
		 * you can use System.Threading.Thread instead in most cases.
		 *
		 * Most platforms have a concept of threads, though some (e.g. WinRT) do not. This may be
		 * removed in a future version in favour of using Task.Run(), Task.Delay(), which works
		 * across all platforms on .net 4.5+ and PCL.
		 */
		export class Thread implements
			Eto.IHandlerSource {
			/**
			 * Initializes a new instance of the {@link Eto.Threading.Thread} class for a specific
			 * ation
			 */
			constructor(action: () => void);

			/** Gets the current thread instance */
			static readonly CurrentThread: Eto.Threading.Thread;

			/** Gets the main thread. */
			static readonly MainThread: Eto.Threading.Thread;

			/** Gets a value indicating whether this thread is alive. */
			readonly IsAlive: boolean;

			/** Gets a value indicating whether this thread instance is the main UI thread. */
			readonly IsMain: boolean;

			/** Gets a value indicating if the current thread is the main UI thread. */
			static readonly IsMainThread: boolean;

			/**
			 * Gets the platform that was used to create the {@link Eto.Widget.Handler} for this
			 * widget
			 *
			 * This gets set to the current {@link Eto.Platform.Instance} during the construction of
			 * the object
			 */
			readonly Platform: Eto.Platform;

			/** Gets the platform-specific handler for this widget */
			Handler: unknown;

			/** Gets the native platform-specific handle for integration purposes */
			readonly NativeHandle: unknown;

			/** Gets the dictionary of properties for this widget */
			readonly Properties: Eto.PropertyStore;

			/** Gets or sets the ID of this widget */
			ID: string;

			/**
			 * Gets or sets the style of this widget
			 *
			 * Styles allow you to attach custom platform-specific logic to a widget. In your
			 * platform-specific assembly, use {@link Style.Add{H}(string, StyleHandler{H})} to add
			 * the style logic with the same id.
			 */
			Style: string;

			/**
			 * Gets the instance of the platform-specific object
			 *
			 * This can sometimes be useful to get the platform-specific object. Some handlers may
			 * not have any backing object for its functionality, so this may be null.  It is more
			 * preferred to use the {@link Eto.Widget.Handler} and cast that to the platform-specific
			 * handler class which can give you additional methods and helpers to do common tasks.
			 * For example, the {@link Eto.Forms.Application} object's handler for OS X has a
			 * AddFullScreenMenuItem property to specify if you want full screen support in your app.
			 */
			readonly ControlObject: unknown;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Widget} has been disposed.
			 *
			 * When the widget is disposed, it can no longer be used.
			 */
			IsDisposed: boolean;

			/** Start the thread, for custom thread instances */
			Start(): void;

			/** Abort this instance, for custom thread instances */
			Abort(): void;

			/** Disposes of this widget, supressing the finalizer */
			dispose(): void;

			/** Gets a string that represents the current object with its ID if specified. */
			ToString(): string;
		}
	}

	export namespace Eto.Threading.Thread {
		export interface ICallback extends Eto.Widget.ICallback {
			OnExecuted(widget: Eto.Threading.Thread): void;
		}
	}

	export namespace Eto.Threading.Thread {
		export interface IHandler extends Eto.Widget.IHandler {
			readonly IsAlive: boolean;

			readonly IsMain: boolean;

			Create(): void;

			CreateCurrent(): void;

			CreateMain(): void;

			Start(): void;

			Abort(): void;
		}
	}

	export namespace Eto.IO {
		/** Type of static icon to get */
		export enum StaticIconType {
			/** Icon for an open directory/folder */
			OpenDirectory = 0,

			/** Icon for a closed directory/folder */
			CloseDirectory = 1,
		}
	}

	export namespace Eto.IO {
		/** Size of icon to get */
		export enum IconSize {
			/** Large icon (32x32 or 64x64 for retina) */
			Large = 0,

			/** Small icon (16x16 or 32x32 for retina) */
			Small = 1,
		}
	}

	export namespace Eto.IO {
		/** Methods to get system icons for file types and static icons */
		export namespace SystemIcons {
			/**
			 * Gets a file icon for the specified file
			 *
			 * The file does not necessarily have to exist for the icon to be retrieved, though if it
			 * is a specific file then the platform may be able to return a file-specific icon if one
			 * is available.
			 */
			export function GetFileIcon(
				fileName: string,
				size: Eto.IO.IconSize,
			): Eto.Drawing.Icon;

			/** Gets a static system-defined icon for the specified type. */
			export function GetStaticIcon(
				type: Eto.IO.StaticIconType,
				size: Eto.IO.IconSize,
			): Eto.Drawing.Icon;
		}
	}

	export namespace Eto.Forms {
		/** Dialog for displaying information about the application. */
		export class AboutDialog implements
			Eto.IHandlerSource {
			/** Initializes a new instance of the {@link Eto.Forms.AboutDialog} class. */
			constructor();

			/** Initializes a new instance of the {@link Eto.Forms.AboutDialog} class. */
			constructor(assembly: unknown);

			/** Gets or sets the copyright text. */
			Copyright: string;

			/** Gets or sets the list of graphical designers. */
			Designers: string[];

			/** Gets or sets the list of developers. */
			Developers: string[];

			/** Gets or sets the list of documenters. */
			Documenters: string[];

			/** Gets or sets the license. */
			License: string;

			/** Gets or sets the application logo. */
			Logo: Eto.Drawing.Image;

			/** Gets or sets the program description. */
			ProgramDescription: string;

			/** Gets or sets the name of the program. */
			ProgramName: string;

			/** Gets or sets the window title. */
			Title: string;

			/** Gets or sets the application version. */
			Version: string;

			/** Gets or sets the application website. */
			Website: unknown;

			/** Gets or sets the application website label. */
			WebsiteLabel: string;

			/**
			 * Gets the platform that was used to create the {@link Eto.Widget.Handler} for this
			 * widget
			 *
			 * This gets set to the current {@link Eto.Platform.Instance} during the construction of
			 * the object
			 */
			readonly Platform: Eto.Platform;

			/** Gets the platform-specific handler for this widget */
			Handler: unknown;

			/** Gets the native platform-specific handle for integration purposes */
			readonly NativeHandle: unknown;

			/** Gets the dictionary of properties for this widget */
			readonly Properties: Eto.PropertyStore;

			/** Gets or sets the ID of this widget */
			ID: string;

			/**
			 * Gets or sets the style of this widget
			 *
			 * Styles allow you to attach custom platform-specific logic to a widget. In your
			 * platform-specific assembly, use {@link Style.Add{H}(string, StyleHandler{H})} to add
			 * the style logic with the same id.
			 */
			Style: string;

			/**
			 * Gets the instance of the platform-specific object
			 *
			 * This can sometimes be useful to get the platform-specific object. Some handlers may
			 * not have any backing object for its functionality, so this may be null.  It is more
			 * preferred to use the {@link Eto.Widget.Handler} and cast that to the platform-specific
			 * handler class which can give you additional methods and helpers to do common tasks.
			 * For example, the {@link Eto.Forms.Application} object's handler for OS X has a
			 * AddFullScreenMenuItem property to specify if you want full screen support in your app.
			 */
			readonly ControlObject: unknown;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Widget} has been disposed.
			 *
			 * When the widget is disposed, it can no longer be used.
			 */
			IsDisposed: boolean;

			/** Shows the dialog with the specified parent, blocking until a result is returned. */
			ShowDialog(parent: Eto.Forms.Control): Eto.Forms.DialogResult;

			/**
			 * Shows the dialog with the specified parent window, blocking until a result is
			 * returned.
			 */
			ShowDialog(parent: Eto.Forms.Window): Eto.Forms.DialogResult;

			/** Disposes of this widget, supressing the finalizer */
			dispose(): void;

			/** Gets a string that represents the current object with its ID if specified. */
			ToString(): string;
		}
	}

	export namespace Eto.Forms.AboutDialog {
		export interface IHandler extends
			Eto.Forms.CommonDialog.IHandler,
			Eto.Widget.IHandler {
			Copyright: string;

			Designers: string[];

			Developers: string[];

			Documenters: string[];

			License: string;

			Logo: Eto.Drawing.Image;

			ProgramDescription: string;

			ProgramName: string;

			Title: string;

			Version: string;

			Website: unknown;

			WebsiteLabel: string;
		}
	}

	export namespace Eto.Forms {
		/** UI Thread check mode when {@link Eto.Forms.Application.EnsureUIThread} is called. */
		export enum UIThreadCheckMode {
			/** Do no checking */
			None = 0,

			/** Emit a warning with Trace.WriteLine() */
			Warning = 1,

			/** Throw an exception */
			Error = 2,
		}
	}

	export namespace Eto.Forms {
		/**
		 * Exception thrown when a control method is accessed in a non-UI thread using
		 * {@link Eto.Forms.Application.EnsureUIThread}.
		 */
		export class UIThreadAccessException {
			/** Initializes a new instance of the UIThreadAccessException class */
			constructor();

			/**
			 * Initializes a new instance of the UIThreadAccessException class with the specified
			 * message
			 */
			constructor(message: string);

			/**
			 * Initializes a new instance of the UIThreadAccessException class with the specified
			 * message and inner exception
			 */
			constructor(
				message: string,
				inner: unknown,
			);
		}
	}

	export namespace Eto.Forms {
		/**
		 * Starting point for any UI application
		 *
		 * This class is used to start an application.  When you are using Eto.Forms within an
		 * existing application, you can use the
		 * {@link Eto.Forms.Application.Attach(System.Object)} method.
		 */
		export class Application implements
			Eto.IHandlerSource {
			/** Initializes a new instance of the {@link Eto.Forms.Application} class. */
			constructor();

			/**
			 * Initializes a new instance of the {@link Eto.Forms.Application} class with the
			 * specified platform type
			 */
			constructor(platformType: string);

			/**
			 * Initializes a new instance of the {@link Eto.Forms.Application} class with the
			 * specified platform
			 */
			constructor(platform: Eto.Platform);

			/** Gets the current application instance */
			static Instance: Eto.Forms.Application;

			/**
			 * Gets or sets the main form for your application.
			 *
			 * When you set this to your main application form, it will get standard platform
			 * behaviour applied, such as quitting the application when it is closed (on windows,
			 * linux), or showing the main form on OS X when clicking the application icon if it has
			 * been hidden/closed.  Setting this is optional, however you must then manually call
			 * {@link Eto.Forms.Application.Quit} when you want your application to quit in that
			 * case.
			 */
			MainForm: Eto.Forms.Form;

			/** Gets an enumeration of windows currently open in the application. */
			readonly Windows: Iterable<Eto.Forms.Window>;

			/** Gets or sets the name of your application */
			Name: string;

			/**
			 * Gets or sets the UI thread check mode which can be used to troubleshoot or ensure that
			 * all UI code is executed in the UI thread.
			 */
			UIThreadCheckMode: Eto.Forms.UIThreadCheckMode;

			/**
			 * Gets a value indicating whether this {@link Eto.Forms.Application} supports the
			 * {@link Eto.Forms.Application.Quit} operation.
			 */
			readonly QuitIsSupported: boolean;

			/**
			 * Gets the common modifier for shortcuts.
			 *
			 * On Windows/Linux, this will typically return {@link Eto.Forms.Keys.Control}, and on OS
			 * X this will be {@link Eto.Forms.Keys.Application} (the command key).
			 */
			readonly CommonModifier: Eto.Forms.Keys;

			/**
			 * Gets the alternate modifier for shortcuts.
			 *
			 * This is usually the {@link Eto.Forms.Keys.Alt} key.
			 */
			readonly AlternateModifier: Eto.Forms.Keys;

			/**
			 * Gets or sets the badge label on the application icon in the dock, taskbar, etc.
			 *
			 * This allows you to specify the text to show as a label to notify the state of your
			 * application to the user. Note that some platforms (iOS) only support numeric badge
			 * labels.
			 */
			BadgeLabel: string;

			/** Gets a value indicating that the application is currently the active application. */
			readonly IsActive: boolean;

			/**
			 * Gets the platform that was used to create the {@link Eto.Widget.Handler} for this
			 * widget
			 *
			 * This gets set to the current {@link Eto.Platform.Instance} during the construction of
			 * the object
			 */
			readonly Platform: Eto.Platform;

			/** Gets the platform-specific handler for this widget */
			Handler: unknown;

			/** Gets the native platform-specific handle for integration purposes */
			readonly NativeHandle: unknown;

			/** Gets the dictionary of properties for this widget */
			readonly Properties: Eto.PropertyStore;

			/** Gets or sets the ID of this widget */
			ID: string;

			/**
			 * Gets or sets the style of this widget
			 *
			 * Styles allow you to attach custom platform-specific logic to a widget. In your
			 * platform-specific assembly, use {@link Style.Add{H}(string, StyleHandler{H})} to add
			 * the style logic with the same id.
			 */
			Style: string;

			/**
			 * Gets the instance of the platform-specific object
			 *
			 * This can sometimes be useful to get the platform-specific object. Some handlers may
			 * not have any backing object for its functionality, so this may be null.  It is more
			 * preferred to use the {@link Eto.Widget.Handler} and cast that to the platform-specific
			 * handler class which can give you additional methods and helpers to do common tasks.
			 * For example, the {@link Eto.Forms.Application} object's handler for OS X has a
			 * AddFullScreenMenuItem property to specify if you want full screen support in your app.
			 */
			readonly ControlObject: unknown;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Widget} has been disposed.
			 *
			 * When the widget is disposed, it can no longer be used.
			 */
			IsDisposed: boolean;

			/** Ensures the current thread is the main/UI thread */
			EnsureUIThread(): void;

			/** Runs the application and begins the main loop. */
			Run(): void;

			/** Runs the application with the specified `mainForm` and begins the main loop. */
			Run(mainForm: Eto.Forms.Form): void;

			/**
			 * Runs the application with the specified `dialog` and begins the main loop.
			 *
			 * When the dialog is closed, the application will exit.
			 */
			Run(dialog: Eto.Forms.Dialog): void;

			/**
			 * Attach the application to an already-running native application with the same
			 * platform.
			 */
			Attach(context?: unknown): Eto.Forms.Application;

			/**
			 * Invoke the specified action on the UI thread, blocking the current execution until it
			 * is complete.
			 *
			 * Use this method when you want to perform changes to the UI from a worker thread, and
			 * return when the changes are complete.
			 */
			Invoke(action: () => void): void;

			/**
			 * Invoke the specified function on the UI thread returning its value after the execution
			 * is complete.
			 *
			 * Use this method when you want to return values from the UI in a worker thread.
			 */
			Invoke<T>(func: () => T): T;

			/**
			 * Invoke the action asynchronously on the UI thread
			 *
			 * This will return immediately and queue the action to be executed on the UI thread,
			 * regardless on whether the current thread is the UI thread.
			 */
			AsyncInvoke(action: () => void): void;

			/**
			 * Invokes the specified function on the UI thread asynchronously and return the result
			 * in a Task.
			 */
			InvokeAsync<T>(func: () => T): Promise<T>;

			/** Invokes the specified action on the UI thread asynchronously with a Task. */
			InvokeAsync(action: () => void): Promise<void>;

			/**
			 * Quits the application
			 *
			 * This will call the {@link Eto.Forms.Application.Terminating} event before terminating
			 * the application.
			 */
			Quit(): void;

			/** Open the specified file or url with its associated application. */
			Open(url: string): void;

			/**
			 * Advanced. Runs an iteration of the main UI loop when you are blocking the UI thread
			 * with logic.
			 *
			 * This is not recommended to use and you should use asynchronous calls instead via
			 * Task.Run or threads.
			 */
			RunIteration(): void;

			/** Restarts the application */
			Restart(): void;

			/**
			 * Localizes the specified text for the current locale, or provide alternative text for
			 * system supplied strings.
			 *
			 * This depends on your custom implementation for the
			 * {@link Eto.Forms.Application.LocalizeString} event. You can provide your own
			 * localization for system-supplied strings or change the strings to your own liking.
			 */
			Localize(
				source: unknown,
				text: string,
			): string;

			/** Disposes of this widget, supressing the finalizer */
			dispose(): void;

			/** Gets a string that represents the current object with its ID if specified. */
			ToString(): string;
		}
	}

	export namespace Eto.Forms.Application {
		export interface ICallback extends Eto.Widget.ICallback {
			OnInitialized(
				widget: Eto.Forms.Application,
				e: unknown,
			): void;

			OnTerminating(
				widget: Eto.Forms.Application,
				e: unknown,
			): void;

			OnUnhandledException(
				widget: Eto.Forms.Application,
				e: Eto.UnhandledExceptionEventArgs,
			): void;

			OnNotificationActivated(
				wiget: Eto.Forms.Application,
				e: Eto.Forms.NotificationEventArgs,
			): void;

			OnIsActiveChanged(
				wiget: Eto.Forms.Application,
				e: unknown,
			): void;
		}
	}

	export namespace Eto.Forms.Application {
		export interface IHandler extends Eto.Widget.IHandler {
			readonly QuitIsSupported: boolean;

			readonly CommonModifier: Eto.Forms.Keys;

			readonly AlternateModifier: Eto.Forms.Keys;

			BadgeLabel: string;

			readonly IsActive: boolean;

			Attach(context: unknown): void;

			Run(): void;

			Quit(): void;

			Open(url: string): void;

			Invoke(action: () => void): void;

			AsyncInvoke(action: () => void): void;

			OnMainFormChanged(): void;

			Restart(): void;

			RunIteration(): void;
		}
	}

	export namespace Eto.Forms {
		/** Extensions for bindings */
		export namespace BindingExtensions {
			/**
			 * Causes the change event of the binding to occur only when the
			 * {@link Eto.Forms.Control.LostFocus} event is triggered.
			 *
			 * This is useful for text-based input controls such as the
			 * {@link Eto.Forms.NumericStepper} when a partial input can be invalid. The binding will
			 * only be updated when the control has lost the input focus, where by default it will be
			 * updated for every change while the user is updating the control.
			 */
			export function WhenLostFocus<T, TValue>(binding: Eto.Forms.BindableBinding$2<T, TValue>): Eto.Forms.BindableBinding$2<T, TValue>;
		}
	}

	export namespace Eto.Forms {
		/**
		 * [Generic type factory] Binding object to easily bind a property of a
		 * {@link Eto.Forms.IBindable} object, such as a {@link Eto.Forms.Control}.
		 *
		 * This provides control-specific binding, such as binding to a
		 * {@link Eto.Forms.IBindable.DataContext}. Any bindings created using this will also add
		 * to the {@link Eto.Forms.IBindable.Bindings} collection to keep its reference.
		 */
		export function BindableBinding$(T: IType, TValue: IType): typeof BindableBinding$2<any, any>;

		/**
		 * Binding object to easily bind a property of a {@link Eto.Forms.IBindable} object, such
		 * as a {@link Eto.Forms.Control}.
		 *
		 * This provides control-specific binding, such as binding to a
		 * {@link Eto.Forms.IBindable.DataContext}. Any bindings created using this will also add
		 * to the {@link Eto.Forms.IBindable.Bindings} collection to keep its reference.
		 */
		export class BindableBinding$2<T, TValue> implements Eto.Forms.IBinding {
			/** Initializes a new instance of the {@link Eto.Forms.ControlBinding<,>} class. */
			new(
				dataItem: T,
				getValue: (arg1: T) => TValue,
				setValue?: (arg1: T, arg2: TValue) => void,
				addChangeEvent?: (arg1: T, arg2: unknown) => void,
				removeChangeEvent?: (arg1: T, arg2: unknown) => void,
			): BindableBinding$2<T, TValue>;

			/** Initializes a new instance of the {@link Eto.Forms.ControlBinding<,>} class. */
			new(
				dataItem: T,
				innerBinding: Eto.Forms.IndirectBinding$1<TValue>,
			): BindableBinding$2<T, TValue>;

			readonly InnerBinding: Eto.Forms.IndirectBinding$1<TValue>;

			DataItem: T;

			GetDataItem: () => T;

			SettingNullValue: TValue;

			GettingNullValue: TValue;

			DataValue: TValue;

			/**
			 * Binds the specified `sourceBinding` to this binding.
			 *
			 * This creates a {@link Eto.Forms.DualBinding<>} between the specified `sourceBinding`
			 * and this binding. The binding is added to the {@link Eto.Forms.IBindable.Bindings}
			 * collection.
			 */
			Bind(
				sourceBinding: Eto.Forms.DirectBinding$1<TValue>,
				mode?: Eto.Forms.DualBindingMode,
			): Eto.Forms.DualBinding$1<TValue>;

			/**
			 * Binds to an object's {@link Eto.Forms.IBindable.DataContext} using the specified
			 * `dataContextBinding`.
			 *
			 * This creates a {@link Eto.Forms.DualBinding<>} between a binding to the specified
			 * `dataContextBinding` and this binding. Since the data context changes, the binding
			 * passed for the data context binding is an indirect binding, in that it is reused. The
			 * binding is added to the {@link Eto.Forms.IBindable.Bindings} collection.
			 */
			BindDataContext(
				dataContextBinding: Eto.Forms.IndirectBinding$1<TValue>,
				mode?: Eto.Forms.DualBindingMode,
				defaultControlValue?: TValue,
				defaultContextValue?: TValue,
			): Eto.Forms.DualBinding$1<TValue>;

			/**
			 * Binds to a control's {@link Eto.Forms.IBindable.DataContext} using delegates to
			 * get/set the value.
			 *
			 * This is a shortcut to use the {@link Eto.Forms.DelegateBinding<,>} to bind to a
			 * control's {@link Eto.Forms.IBindable.DataContext} property. When the data context type
			 * is  , then the delegates will be called to get/set the value. Otherwise, if the data
			 * context is null or a different type, the `defaultGetValue` will be used.
			 */
			BindDataContext<TObject>(
				getValue: (arg1: TObject) => TValue,
				setValue: (arg1: TObject, arg2: TValue) => void,
				addChangeEvent?: (arg1: TObject, arg2: unknown) => void,
				removeChangeEvent?: (arg1: TObject, arg2: unknown) => void,
				mode?: Eto.Forms.DualBindingMode,
				defaultGetValue?: TValue,
				defaultSetValue?: TValue,
			): Eto.Forms.DualBinding$1<TValue>;

			/**
			 * Binds to the specified `propertyName` of the current data context.
			 *
			 * This is a shortcut to using the {@link Eto.Forms.PropertyBinding<>}. This has the
			 * advantage of registering automatically to
			 * {@link System.ComponentModel.INotifyPropertyChanged} or to an event named after the
			 * property with a "Changed" suffix.
			 */
			BindDataContext(
				propertyName: string,
				mode?: Eto.Forms.DualBindingMode,
			): Eto.Forms.DualBinding$1<TValue>;

			/**
			 * Binds to a specified property of the control's current data context.
			 *
			 * This has the advantage of registering automatically to
			 * {@link System.ComponentModel.INotifyPropertyChanged} or to an event named after the
			 * property with a "Changed" suffix, if the expression is a property. When the expression
			 * does not evaluate to a property, it will not be able to bind to the changed events and
			 * will use the expression as a delegate directly.
			 */
			BindDataContext<TObject>(
				propertyExpression: unknown,
				mode?: Eto.Forms.DualBindingMode,
			): Eto.Forms.DualBinding$1<TValue>;

			/**
			 * Converts this binding's value to another value using delegates.
			 *
			 * This is useful when you want to cast one binding to another, perform logic when
			 * getting/setting a value from a particular binding, or get/set a preoperty of the
			 * value.
			 */
			Convert<TNewValue>(
				toValue: (arg1: TValue) => TNewValue,
				fromValue?: (arg1: TNewValue) => TValue,
			): Eto.Forms.BindableBinding$2<T, TNewValue>;

			/** Casts this binding value to another (compatible) type. */
			Cast<TNewValue>(): Eto.Forms.BindableBinding$2<T, TNewValue>;

			/**
			 * Binds to the specified child `property` expression.
			 *
			 * This can be used to bind to properties of child objects of your view model, for
			 * example model.SomeProperty.ChildProperty .  This will automatically look up the
			 * changed event either by a [Property]Changed event or INotifyPropertyChanged
			 * implementation for each object in the heirarchy.  Note that you only really need to
			 * use this when you have an existing binding that you cannot change. See
			 * {@link Eto.Forms.Binding.Property``2(System.Linq.Expressions.Expression{System.Func{``0,``1}})}
			 * for an example of how to bind to child property values more directly.
			 */
			Child<TNewValue>(property: unknown): Eto.Forms.BindableBinding$2<T, TNewValue>;

			/**
			 * Binds to the specified child `binding` of this binding.
			 *
			 * This can be used to bind to child objects of your view model, for example
			 * model.SomeProperty.ChildProperty .
			 */
			Child<TNewValue>(binding: Eto.Forms.IndirectBinding$1<TNewValue>): Eto.Forms.BindableBinding$2<T, TNewValue>;

			/** Catches any exceptions when setting the value of the binding */
			CatchException(exceptionHandler?: (arg1: unknown) => boolean): Eto.Forms.BindableBinding$2<T, TValue>;

			/** Catches any exceptions of the specified  when setting the value of the binding. */
			CatchException<TException>(exceptionHandler?: (arg1: TException) => boolean): Eto.Forms.BindableBinding$2<T, TValue>;

			TriggerDataValueChanged(): void;

			Unbind(): void;

			Bind(
				getValue: () => TValue,
				setValue?: (arg1: TValue) => void,
				addChangeEvent?: (arg1: unknown) => void,
				removeChangeEvent?: (arg1: unknown) => void,
				mode?: Eto.Forms.DualBindingMode,
			): Eto.Forms.DualBinding$1<TValue>;

			Bind<TObject>(
				objectValue: TObject,
				objectBinding: Eto.Forms.IndirectBinding$1<TValue>,
				mode?: Eto.Forms.DualBindingMode,
			): Eto.Forms.DualBinding$1<TValue>;

			Bind(
				objectValue: unknown,
				propertyName: string,
				mode?: Eto.Forms.DualBindingMode,
			): Eto.Forms.DualBinding$1<TValue>;

			Bind<TObject>(
				objectValue: TObject,
				propertyExpression: unknown,
				mode?: Eto.Forms.DualBindingMode,
			): Eto.Forms.DualBinding$1<TValue>;

			ToString(): string;

			Convert<TValue>(
				toValue: (arg1: TValue) => TValue,
				fromValue?: (arg1: TValue) => TValue,
			): Eto.Forms.DirectBinding$1<TValue>;

			Cast<TValue>(): Eto.Forms.DirectBinding$1<TValue>;

			Child<TValue>(property: unknown): Eto.Forms.DirectBinding$1<TValue>;

			Child<TValue>(binding: Eto.Forms.IndirectBinding$1<TValue>): Eto.Forms.DirectBinding$1<TValue>;

			ToBool(
				trueValue: TValue,
				falseValue: TValue,
				nullValue: TValue,
			): Eto.Forms.DirectBinding$1<boolean | undefined>;

			ToBool(
				trueValue: TValue,
				falseValue: TValue,
			): Eto.Forms.DirectBinding$1<boolean | undefined>;

			ToBool(trueValue: TValue): Eto.Forms.DirectBinding$1<boolean | undefined>;

			ToType<TType>(
				invalidGetValue?: (arg1: TValue) => TType,
				invalidSetValue?: (arg1: TType) => TValue,
			): Eto.Forms.DirectBinding$1<TType>;

			CatchException(exceptionHandler?: (arg1: unknown) => boolean): Eto.Forms.DirectBinding$1<TValue>;

			CatchException<TException>(exceptionHandler?: (arg1: TException) => boolean): Eto.Forms.DirectBinding$1<TValue>;

			/**
			 * Updates the bound target object's value
			 *
			 * Typically the source would be your custom class and the destination would be a UI
			 * control, but this is not always the case.
			 */
			Update(mode?: Eto.Forms.BindingUpdateMode): void;
		}
	}

	export namespace Eto.Forms {
		/**
		 * Helper extensions for {@link Eto.Forms.IBindable} objects to set up object bindings.
		 */
		export namespace BindableExtensions {
			/** Adds a new dual binding between the control and the specified object */
			export function Bind<T>(
				bindable: Eto.Forms.IBindable,
				propertyName: string,
				source: unknown,
				sourcePropertyName: string,
				mode?: Eto.Forms.DualBindingMode,
			): Eto.Forms.DualBinding$1<T>;

			/** Adds a new dual binding between the control and the specified source binding */
			export function Bind<T>(
				bindable: Eto.Forms.IBindable,
				widgetPropertyName: string,
				sourceBinding: Eto.Forms.DirectBinding$1<T>,
				mode?: Eto.Forms.DualBindingMode,
			): Eto.Forms.DualBinding$1<T>;

			/**
			 * Adds a new binding with the control and the the control's current data context
			 *
			 * This binds to a property of the {@link Eto.Forms.IBindable.DataContext}, which will
			 * return the topmost value up the control hierarchy.  For example, you can set the
			 * DataContext of your form or panel, and then bind to properties of that context on any
			 * of the child controls such as a text box, etc.
			 */
			export function BindDataContext<T>(
				bindable: Eto.Forms.IBindable,
				controlPropertyName: string,
				dataContextPropertyName: string,
				mode?: Eto.Forms.DualBindingMode,
				defaultControlValue?: T,
				defaultContextValue?: T,
			): Eto.Forms.DualBinding$1<T>;

			/** Adds a new binding to the control with a direct value binding */
			export function Bind<T>(
				bindable: Eto.Forms.IBindable,
				controlBinding: Eto.Forms.IndirectBinding$1<T>,
				valueBinding: Eto.Forms.DirectBinding$1<T>,
				mode?: Eto.Forms.DualBindingMode,
			): Eto.Forms.DualBinding$1<T>;

			/**
			 * Adds a new binding to the control with an indirect binding to the provided
			 * `objectValue`
			 */
			export function Bind<T>(
				bindable: Eto.Forms.IBindable,
				controlBinding: Eto.Forms.IndirectBinding$1<T>,
				objectValue: unknown,
				objectBinding: Eto.Forms.IndirectBinding$1<T>,
				mode?: Eto.Forms.DualBindingMode,
				defaultControlValue?: T,
				defaultContextValue?: T,
			): Eto.Forms.DualBinding$1<T>;

			/** Adds a new binding from the control to its data context */
			export function BindDataContext<T>(
				bindable: Eto.Forms.IBindable,
				controlBinding: Eto.Forms.IndirectBinding$1<T>,
				dataContextBinding: Eto.Forms.IndirectBinding$1<T>,
				mode?: Eto.Forms.DualBindingMode,
				defaultControlValue?: T,
				defaultContextValue?: T,
			): Eto.Forms.DualBinding$1<T>;

			/** Binds a control property to a `source` property */
			export function Bind<TWidget, TSource, TValue>(
				control: TWidget,
				controlProperty: unknown,
				source: TSource,
				sourceProperty: unknown,
				mode?: Eto.Forms.DualBindingMode,
			): Eto.Forms.DualBinding$1<TValue>;

			/** Binds a control property to the `source` object using the `sourceBinding`. */
			export function Bind<TWidget, TSource, TValue>(
				control: TWidget,
				controlProperty: unknown,
				source: TSource,
				sourceBinding: Eto.Forms.IndirectBinding$1<TValue>,
				mode?: Eto.Forms.DualBindingMode,
			): Eto.Forms.DualBinding$1<TValue>;

			/** Bind a control property to the specified `sourceBinding` direct binding. */
			export function Bind<TWidget, TValue>(
				control: TWidget,
				controlProperty: unknown,
				sourceBinding: Eto.Forms.DirectBinding$1<TValue>,
				mode?: Eto.Forms.DualBindingMode,
			): Eto.Forms.DualBinding$1<TValue>;

			/**
			 * Binds a control property to a {@link Eto.Forms.BindableWidget.DataContext} property
			 */
			export function BindDataContext<TWidget, TContext, TValue>(
				control: TWidget,
				controlProperty: unknown,
				sourceProperty: unknown,
				mode?: Eto.Forms.DualBindingMode,
				defaultControlValue?: TValue,
				defaultContextValue?: TValue,
			): Eto.Forms.DualBinding$1<TValue>;

			/**
			 * Binds a control property to a {@link Eto.Forms.BindableWidget.DataContext} property
			 */
			export function BindDataContext<TWidget, TValue>(
				control: TWidget,
				controlProperty: unknown,
				sourceBinding: Eto.Forms.IndirectBinding$1<TValue>,
				mode?: Eto.Forms.DualBindingMode,
				defaultControlValue?: TValue,
				defaultContextValue?: TValue,
			): Eto.Forms.DualBinding$1<TValue>;

			/** Gets a bindable binding with the inverse of the specified boolean value binding. */
			export function Inverse<T>(binding: Eto.Forms.BindableBinding$2<T, boolean | undefined>): Eto.Forms.BindableBinding$2<T, boolean | undefined>;

			/** Gets a bindable binding with the inverse of the specified boolean value binding. */
			export function Inverse<T>(binding: Eto.Forms.BindableBinding$2<T, boolean>): Eto.Forms.BindableBinding$2<T, boolean>;

			/** Gets a binding with the inverse of the specified nullable boolean value binding. */
			export function Inverse(binding: Eto.Forms.DirectBinding$1<boolean | undefined>): Eto.Forms.DirectBinding$1<boolean | undefined>;

			/** Gets a binding with the inverse of the specified nullable boolean value binding. */
			export function Inverse(binding: Eto.Forms.DirectBinding$1<boolean>): Eto.Forms.DirectBinding$1<boolean>;

			/**
			 * Gets a binding that returns a `defaultValue` if the specified `binding` returns a null
			 * value.
			 */
			export function DefaultIfNull<T, TValue>(
				binding: Eto.Forms.BindableBinding$2<T, TValue | undefined>,
				defaultValue?: TValue,
			): Eto.Forms.BindableBinding$2<T, TValue>;

			/**
			 * Gets a binding that returns a `defaultValue` if the specified `binding` returns a null
			 * value.
			 */
			export function DefaultIfNull<T, TValue>(
				binding: Eto.Forms.BindableBinding$2<T, TValue>,
				defaultValue: TValue,
			): Eto.Forms.BindableBinding$2<T, TValue>;
		}
	}

	export namespace Eto.Forms {
		/** Extension methods from {@link Eto.Forms.BindableExtensions} */
		export interface IBindable {
			/** Adds a new dual binding between the control and the specified object */
			Bind<T>(
				propertyName: string,
				source: unknown,
				sourcePropertyName: string,
				mode?: Eto.Forms.DualBindingMode,
			): Eto.Forms.DualBinding$1<T>;

			/** Adds a new dual binding between the control and the specified source binding */
			Bind<T>(
				widgetPropertyName: string,
				sourceBinding: Eto.Forms.DirectBinding$1<T>,
				mode?: Eto.Forms.DualBindingMode,
			): Eto.Forms.DualBinding$1<T>;

			/**
			 * Adds a new binding with the control and the the control's current data context
			 *
			 * This binds to a property of the {@link Eto.Forms.IBindable.DataContext}, which will
			 * return the topmost value up the control hierarchy.  For example, you can set the
			 * DataContext of your form or panel, and then bind to properties of that context on any
			 * of the child controls such as a text box, etc.
			 */
			BindDataContext<T>(
				controlPropertyName: string,
				dataContextPropertyName: string,
				mode?: Eto.Forms.DualBindingMode,
				defaultControlValue?: T,
				defaultContextValue?: T,
			): Eto.Forms.DualBinding$1<T>;

			/** Adds a new binding to the control with a direct value binding */
			Bind<T>(
				controlBinding: Eto.Forms.IndirectBinding$1<T>,
				valueBinding: Eto.Forms.DirectBinding$1<T>,
				mode?: Eto.Forms.DualBindingMode,
			): Eto.Forms.DualBinding$1<T>;

			/**
			 * Adds a new binding to the control with an indirect binding to the provided
			 * `objectValue`
			 */
			Bind<T>(
				controlBinding: Eto.Forms.IndirectBinding$1<T>,
				objectValue: unknown,
				objectBinding: Eto.Forms.IndirectBinding$1<T>,
				mode?: Eto.Forms.DualBindingMode,
				defaultControlValue?: T,
				defaultContextValue?: T,
			): Eto.Forms.DualBinding$1<T>;

			/** Adds a new binding from the control to its data context */
			BindDataContext<T>(
				controlBinding: Eto.Forms.IndirectBinding$1<T>,
				dataContextBinding: Eto.Forms.IndirectBinding$1<T>,
				mode?: Eto.Forms.DualBindingMode,
				defaultControlValue?: T,
				defaultContextValue?: T,
			): Eto.Forms.DualBinding$1<T>;
		}
	}

	export namespace Eto.Forms.BindableExtensions {
		/** Extension methods from {@link Eto.Forms.BindableExtensions} */
		export interface TWidget {
			/** Binds a control property to a `source` property */
			Bind<TWidget, TSource, TValue>(
				controlProperty: unknown,
				source: TSource,
				sourceProperty: unknown,
				mode?: Eto.Forms.DualBindingMode,
			): Eto.Forms.DualBinding$1<TValue>;
		}
	}

	export namespace Eto.Forms.BindableExtensions {
		/** Extension methods from {@link Eto.Forms.BindableExtensions} */
		export interface TWidget {
			/** Binds a control property to the `source` object using the `sourceBinding`. */
			Bind<TWidget, TSource, TValue>(
				controlProperty: unknown,
				source: TSource,
				sourceBinding: Eto.Forms.IndirectBinding$1<TValue>,
				mode?: Eto.Forms.DualBindingMode,
			): Eto.Forms.DualBinding$1<TValue>;
		}
	}

	export namespace Eto.Forms.BindableExtensions {
		/** Extension methods from {@link Eto.Forms.BindableExtensions} */
		export interface TWidget {
			/** Bind a control property to the specified `sourceBinding` direct binding. */
			Bind<TWidget, TValue>(
				controlProperty: unknown,
				sourceBinding: Eto.Forms.DirectBinding$1<TValue>,
				mode?: Eto.Forms.DualBindingMode,
			): Eto.Forms.DualBinding$1<TValue>;
		}
	}

	export namespace Eto.Forms.BindableExtensions {
		/** Extension methods from {@link Eto.Forms.BindableExtensions} */
		export interface TWidget {
			/**
			 * Binds a control property to a {@link Eto.Forms.BindableWidget.DataContext} property
			 */
			BindDataContext<TWidget, TContext, TValue>(
				controlProperty: unknown,
				sourceProperty: unknown,
				mode?: Eto.Forms.DualBindingMode,
				defaultControlValue?: TValue,
				defaultContextValue?: TValue,
			): Eto.Forms.DualBinding$1<TValue>;
		}
	}

	export namespace Eto.Forms.BindableExtensions {
		/** Extension methods from {@link Eto.Forms.BindableExtensions} */
		export interface TWidget {
			/**
			 * Binds a control property to a {@link Eto.Forms.BindableWidget.DataContext} property
			 */
			BindDataContext<TWidget, TValue>(
				controlProperty: unknown,
				sourceBinding: Eto.Forms.IndirectBinding$1<TValue>,
				mode?: Eto.Forms.DualBindingMode,
				defaultControlValue?: TValue,
				defaultContextValue?: TValue,
			): Eto.Forms.DualBinding$1<TValue>;
		}
	}

	export namespace Eto.Forms {
		/**
		 * Interface to specify that the {@link Eto.Forms.BindableWidget} contains child bindable
		 * widgets that should participate in binding events.
		 */
		export interface IBindableWidgetContainer {
			/** Gets the children that in the container. */
			readonly Children: Iterable<Eto.Forms.BindableWidget>;
		}
	}

	export namespace Eto.Forms {
		/** Base widget to support binding with the {@link Eto.Forms.IBindable} interface. */
		export class BindableWidget implements
			Eto.IHandlerSource,
			Eto.Forms.IBindable {
			/**
			 * Gets or sets the parent widget which this widget has been added to, if any
			 *
			 * When implementing child widgets that can participate in the context based binding
			 * (MVVM), You can set this to the parent widget when it is added or removed to it
			 * (usually via a collection).  Note that you should typically provide a public new
			 * [ParentWidget] Parent { get; } property  so that consumers of your API cannot set the
			 * parent to an invalid value.
			 */
			Parent: Eto.Widget;

			/**
			 * Gets an enumeration of all parent widgets in the heirarchy by traversing the
			 * {@link Eto.Forms.BindableWidget.Parent} property.
			 */
			readonly Parents: Iterable<Eto.Widget>;

			/**
			 * Gets or sets the data context for this widget for binding
			 *
			 * Subclasses may override the standard behaviour so that hierarchy of widgets can be
			 * taken into account.  For example, a Control may return the data context of a parent,
			 * if it is not set explicitly.
			 */
			DataContext: unknown;

			/** Gets the collection of bindings that are attached to this widget */
			readonly Bindings: Eto.Forms.BindingCollection;

			/**
			 * Gets a value indicating that the {@link Eto.Forms.BindableWidget.DataContext} property
			 * is changing.
			 *
			 * This can be used to determine when to allow certain logic during the update of the
			 * data context.  It is used to disable binding setters on the model when the data
			 * context changes so that a binding does not cause the view model to be updated when the
			 * state hasn't been fully set yet.
			 */
			IsDataContextChanging: boolean;

			/**
			 * Gets the platform that was used to create the {@link Eto.Widget.Handler} for this
			 * widget
			 *
			 * This gets set to the current {@link Eto.Platform.Instance} during the construction of
			 * the object
			 */
			readonly Platform: Eto.Platform;

			/** Gets the platform-specific handler for this widget */
			Handler: unknown;

			/** Gets the native platform-specific handle for integration purposes */
			readonly NativeHandle: unknown;

			/** Gets the dictionary of properties for this widget */
			readonly Properties: Eto.PropertyStore;

			/** Gets or sets the ID of this widget */
			ID: string;

			/**
			 * Gets or sets the style of this widget
			 *
			 * Styles allow you to attach custom platform-specific logic to a widget. In your
			 * platform-specific assembly, use {@link Style.Add{H}(string, StyleHandler{H})} to add
			 * the style logic with the same id.
			 */
			Style: string;

			/**
			 * Gets the instance of the platform-specific object
			 *
			 * This can sometimes be useful to get the platform-specific object. Some handlers may
			 * not have any backing object for its functionality, so this may be null.  It is more
			 * preferred to use the {@link Eto.Widget.Handler} and cast that to the platform-specific
			 * handler class which can give you additional methods and helpers to do common tasks.
			 * For example, the {@link Eto.Forms.Application} object's handler for OS X has a
			 * AddFullScreenMenuItem property to specify if you want full screen support in your app.
			 */
			readonly ControlObject: unknown;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Widget} has been disposed.
			 *
			 * When the widget is disposed, it can no longer be used.
			 */
			IsDisposed: boolean;

			/**
			 * Finds a control in the parent hierarchy with the specified type and
			 * {@link Eto.Widget.ID} if specified
			 */
			FindParent<T>(id?: string): T;

			/**
			 * Finds a control in the parent hierarchy with the specified type and
			 * {@link Eto.Widget.ID} if specified
			 */
			FindParent(
				type: unknown,
				id?: string,
			): Eto.Widget;

			/** Finds a control in the parent hierarchy with the specified `id` */
			FindParent(id: string): Eto.Widget;

			/**
			 * Unbinds any bindings in the {@link Eto.Forms.BindableWidget.Bindings} collection and
			 * removes the bindings
			 *
			 * When you implement {@link Eto.Forms.IBindableWidgetContainer}, this will also unbind
			 * any of its children.
			 */
			Unbind(): void;

			/**
			 * Updates all bindings in this widget
			 *
			 * When you implement {@link Eto.Forms.IBindableWidgetContainer}, this will also update
			 * bindings for all of its children.
			 */
			UpdateBindings(mode?: Eto.Forms.BindingUpdateMode): void;

			/** Disposes of this widget, supressing the finalizer */
			dispose(): void;

			/** Gets a string that represents the current object with its ID if specified. */
			ToString(): string;
		}
	}

	export namespace Eto.Forms {
		/** Mode for updating the binding */
		export enum BindingUpdateMode {
			/** Update the binding source (usually the model) */
			Source = 0,

			/** Update the binding destination (usually the control) */
			Destination = 1,
		}
	}

	export namespace Eto.Forms {
		/**
		 * Base binding interface
		 *
		 * Binding provides a way to bind your data objects to control properties and grid
		 * values. This base class adds the ability to unbind the binding, or update it manually.
		 */
		export interface IBinding {
			/**
			 * Unbind this instance from its parent.
			 *
			 * This typically will unregister any event handlers to properties so that the controls
			 * can be garbage collected.
			 */
			Unbind(): void;

			/**
			 * Updates the binding from the source to the destination
			 *
			 * Typically the source would be your custom class and the destination would be a UI
			 * control, but this is not always the case.
			 */
			Update(mode?: Eto.Forms.BindingUpdateMode): void;
		}
	}

	export namespace Eto.Forms {
		/**
		 * Base class for binding between a value and another
		 *
		 * This is the base of any type of binding.  Some bindings may only be used to get/set a
		 * single value (e.g. {@link Eto.Forms.IndirectBinding<>} ), whereas the
		 * {@link Eto.Forms.DualBinding<>} can link two objects' values together
		 */
		export class Binding implements Eto.Forms.IBinding {
			/**
			 * Unbind this from the target object(s)
			 *
			 * Typically a binding may handle an event for when the target object(s) property values
			 * are changed.  This is called to unbind the binding from the objects so that they can
			 * be garbage collected
			 */
			Unbind(): void;

			/**
			 * Updates the bound target object's value
			 *
			 * Typically the source would be your custom class and the destination would be a UI
			 * control, but this is not always the case.
			 */
			Update(mode?: Eto.Forms.BindingUpdateMode): void;

			/** Creates a new indirect delegate binding. */
			static Delegate<T, TValue>(
				getValue: (arg1: T) => TValue,
				setValue?: (arg1: T, arg2: TValue) => void,
				addChangeEvent?: (arg1: T, arg2: unknown) => void,
				removeChangeEvent?: (arg1: T, arg2: unknown) => void,
				defaultGetValue?: TValue,
				defaultSetValue?: TValue,
			): Eto.Forms.IndirectBinding$1<TValue>;

			/** Creates a new direct delegate binding. */
			static Delegate<TValue>(
				getValue: () => TValue,
				setValue?: (arg1: TValue) => void,
				addChangeEvent?: (arg1: unknown) => void,
				removeChangeEvent?: (arg1: unknown) => void,
			): Eto.Forms.DirectBinding$1<TValue>;

			/** Creates a new direct property binding to the specified `model` object. */
			static Property<T, TValue>(
				model: T,
				propertyExpression: unknown,
			): Eto.Forms.DirectBinding$1<TValue>;

			/**
			 * Creates a new indirect property binding using the specified `propertyExpression`.
			 *
			 * This supports single and multiple levels of property accessors in the model.
			 */
			static Property<T, TValue>(propertyExpression: unknown): Eto.Forms.IndirectBinding$1<TValue>;

			/**
			 * Creates a new indirect property binding using the specified `propertyName`.
			 *
			 * This supports single and multiple levels of property accessors in the model.
			 */
			static Property<TValue>(propertyName: string): Eto.Forms.IndirectBinding$1<TValue>;

			/**
			 * Creates a new indirect property binding using the specified `propertyName`.
			 *
			 * This supports single and multiple levels of property accessors in the model.
			 */
			static Property<TValue>(
				propertyName: string,
				ignoreCase: boolean,
			): Eto.Forms.IndirectBinding$1<TValue>;

			/**
			 * Adds an event handler for a specified `propertyName` of a
			 * {@link System.ComponentModel.INotifyPropertyChanged} object.
			 *
			 * This can be used to translate an INotifyPropertyChanged event for a particular
			 * property to a single event. Typically, this would be used when creating a
			 * {@link Eto.Forms.DelegateBinding<,>} to attach to property notified events instead of
			 * singular events.
			 */
			static AddPropertyEvent(
				obj: unknown,
				propertyName: string,
				eh: unknown,
			): void;

			/**
			 * Adds an event handler for a specified `propertyExpression` of a
			 * {@link System.ComponentModel.INotifyPropertyChanged} object.
			 *
			 * This can be used to translate an INotifyPropertyChanged event for a particular
			 * property to a single event. Typically, this would be used when creating a
			 * {@link Eto.Forms.DelegateBinding<,>} to attach to property notified events instead of
			 * singular events.
			 */
			static AddPropertyEvent<T, TProperty>(
				obj: T,
				propertyExpression: unknown,
				eh: unknown,
			): void;

			/** Removes an event handler previously attached with the AddPropertyEvent method. */
			static RemovePropertyEvent(
				obj: unknown,
				eh: unknown,
			): void;

			/**
			 * Executes a command retrieved using the specified `commandBinding` from the
			 * `dataContext`.
			 *
			 * This helper method is useful for binding general events to fire an
			 * {@link System.Windows.Input.ICommand} that is in your view model. The command will
			 * only be executed if its
			 * {@link System.Windows.Input.ICommand.CanExecute(System.Object)} returns true .  Most
			 * controls (e.g. {@link Eto.Forms.Button} ) have a special Command parameter that can be
			 * set instead,  which takes into account the enabled state of the command and will
			 * enable/disable the control automatically.
			 */
			static ExecuteCommand(
				dataContext: unknown,
				commandBinding: Eto.Forms.IndirectBinding$1<unknown>,
				parameter?: unknown,
			): void;

			/**
			 * Executes a command retrieved using a property `commandExpression` from the
			 * `dataContext`.
			 *
			 * This helper method is useful for binding general events to fire an
			 * {@link System.Windows.Input.ICommand} that is in your view model. The command will
			 * only be executed if its
			 * {@link System.Windows.Input.ICommand.CanExecute(System.Object)} returns true .  Most
			 * controls (e.g. {@link Eto.Forms.Button} ) have a special Command parameter that can be
			 * set instead,  which takes into account the enabled state of the command and will
			 * enable/disable the control automatically.
			 */
			static ExecuteCommand<T>(
				dataContext: unknown,
				commandExpression: unknown,
				parameter?: unknown,
			): void;
		}
	}

	export namespace Eto.Forms {
		/** Arguments to handle when a binding value has changed */
		export class BindingChangedEventArgs {
			/** Initializes a new instance of the BindingChangedEventArgs with the specified value */
			constructor(value: unknown);

			/** Gets the value that was set to the binding */
			readonly Value: unknown;
		}
	}

	export namespace Eto.Forms {
		/**
		 * Arguments for when a binding's value is changing
		 *
		 * When handling the event, one could cancel setting the new value by setting the
		 * {@link System.ComponentModel.CancelEventArgs.Cancel} property to false.
		 */
		export class BindingChangingEventArgs {
			/** Initializes a new instance of the BindingChangingEventArgs with the specifid value */
			constructor(value: unknown);

			/** Proposed value to set to the binding */
			Value: unknown;
		}
	}

	export namespace Eto.Forms {
		/** Collection of bindings */
		export class BindingCollection {
			constructor();

			/**
			 * Unbinds all bindings in the collection
			 *
			 * Unbinding is used to remove all event handlers on objects so they can be garbage
			 * collected.
			 */
			Unbind(): void;

			/**
			 * Updates all bindings manually
			 *
			 * Bindings can automatically update if enabled and there are sufficient property changed
			 * event(s), However in some cases you will want to update the bindings manually, for
			 * example if you want to save the data on the form, it would validate first, then update
			 * the bound object(s) with the updated values.
			 */
			Update(mode?: Eto.Forms.BindingUpdateMode): void;
		}
	}

	export namespace Eto.Forms {
		/** Interface to provide a source for the {@link Eto.Forms.ColumnBinding<>} */
		export interface IColumnItem {
			/** Gets the value from this item for the specified column/index */
			GetValue(column: number): unknown;

			/** Sets the value of this object for the specified column/index */
			SetValue(
				column: number,
				value: unknown,
			): void;
		}
	}

	export namespace Eto.Forms {
		/**
		 * [Generic type factory] Column/Index binding for objects implementing
		 * {@link Eto.Forms.IColumnItem} or {@link System.Collections.IList}
		 *
		 * This binding is an indirect binding on a particular column/index of each object. This
		 * is used to get/set values of a passed-in object to the
		 * {@link Eto.Forms.IndirectBinding`1.GetValue(System.Object)} and
		 * {@link Eto.Forms.IndirectBinding`1.SetValue(System.Object,`0)}.
		 */
		export function ColumnBinding$(T: IType): typeof ColumnBinding$1<any>;

		/**
		 * Column/Index binding for objects implementing {@link Eto.Forms.IColumnItem} or
		 * {@link System.Collections.IList}
		 *
		 * This binding is an indirect binding on a particular column/index of each object. This
		 * is used to get/set values of a passed-in object to the
		 * {@link Eto.Forms.IndirectBinding`1.GetValue(System.Object)} and
		 * {@link Eto.Forms.IndirectBinding`1.SetValue(System.Object,`0)}.
		 */
		export class ColumnBinding$1<T> implements
			Eto.Forms.IBinding,
			Eto.Forms.IIndirectBinding$1<T> {
			/** Initializes a new instance of the ColumnBinding class */
			new(): ColumnBinding$1<T>;

			/** Initializes a new instance of the ColumnBinding class with the specified column */
			new(column: number): ColumnBinding$1<T>;

			/** Gets or sets the column the binding will get/set the value */
			Column: number;

			GetValue(dataItem: unknown): T;

			SetValue(
				dataItem: unknown,
				value: T,
			): void;

			AddValueChangedHandler(
				dataItem: unknown,
				handler: unknown,
			): unknown;

			RemoveValueChangedHandler(
				bindingReference: unknown,
				handler: unknown,
			): void;

			Convert<TValue>(
				toValue: (arg1: T) => TValue,
				fromValue?: (arg1: TValue) => T,
			): Eto.Forms.IndirectBinding$1<TValue>;

			Convert<TValue>(
				converter: Eto.Forms.IValueConverter,
				conveterParameter?: unknown,
				culture?: unknown,
			): Eto.Forms.IndirectBinding$1<TValue>;

			Convert(
				converter: Eto.Forms.IValueConverter,
				propertyType: unknown,
				conveterParameter?: unknown,
				culture?: unknown,
			): Eto.Forms.IndirectBinding$1<unknown>;

			Cast<TValue>(): Eto.Forms.IndirectBinding$1<TValue>;

			Child<TNewValue>(property: unknown): Eto.Forms.IndirectBinding$1<TNewValue>;

			Child<TNewValue>(binding: Eto.Forms.IndirectBinding$1<TNewValue>): Eto.Forms.IndirectBinding$1<TNewValue>;

			OfType<TValue>(
				defaultConvertedValue?: TValue,
				defaultValue?: T,
			): Eto.Forms.IndirectBinding$1<TValue>;

			ToBool(
				trueValue: T,
				falseValue: T,
				nullValue: T,
			): Eto.Forms.IndirectBinding$1<boolean | undefined>;

			ToBool(
				trueValue: T,
				falseValue: T,
			): Eto.Forms.IndirectBinding$1<boolean | undefined>;

			ToBool(trueValue: T): Eto.Forms.IndirectBinding$1<boolean | undefined>;

			EnumToString(defaultValue?: T): Eto.Forms.IndirectBinding$1<string>;

			ToType<TType>(
				invalidGetValue?: (arg1: T) => TType,
				invalidSetValue?: (arg1: TType) => T,
			): Eto.Forms.IndirectBinding$1<TType>;

			AfterDelay(
				delay: number,
				reset?: boolean,
			): Eto.Forms.IndirectBinding$1<T>;

			AfterDelay(
				delay: number,
				reset?: boolean,
			): Eto.Forms.IndirectBinding$1<T>;

			CatchException(exceptionHandler?: (arg1: unknown) => boolean): Eto.Forms.IndirectBinding$1<T>;

			CatchException<TException>(exceptionHandler?: (arg1: TException) => boolean): Eto.Forms.IndirectBinding$1<T>;

			/**
			 * Unbind this from the target object(s)
			 *
			 * Typically a binding may handle an event for when the target object(s) property values
			 * are changed.  This is called to unbind the binding from the objects so that they can
			 * be garbage collected
			 */
			Unbind(): void;

			/**
			 * Updates the bound target object's value
			 *
			 * Typically the source would be your custom class and the destination would be a UI
			 * control, but this is not always the case.
			 */
			Update(mode?: Eto.Forms.BindingUpdateMode): void;
		}
	}

	export namespace Eto.Forms {
		/**
		 * [Generic type factory] Direct delegate binding.
		 *
		 * This is a direct binding, in that the get/set delegates can get/set the value directly
		 * without any associated object instance. This is used when binding directly to a
		 * property or when an object instance isn't needed to get/set a value.
		 */
		export function DelegateBinding$(TValue: IType): typeof DelegateBinding$1<any>;

		/**
		 * Direct delegate binding.
		 *
		 * This is a direct binding, in that the get/set delegates can get/set the value directly
		 * without any associated object instance. This is used when binding directly to a
		 * property or when an object instance isn't needed to get/set a value.
		 */
		export class DelegateBinding$1<TValue> implements Eto.Forms.IBinding {
			/** Initializes a new instance of the {@link Eto.Forms.DelegateBinding<>} class. */
			new(): DelegateBinding$1<TValue>;

			/**
			 * Initializes a new instance of the {@link Eto.Forms.DelegateBinding<>} class with the
			 * specified delegates.
			 */
			new(
				getValue?: () => TValue,
				setValue?: (arg1: TValue) => void,
				addChangeEvent?: (arg1: unknown) => void,
				removeChangeEvent?: (arg1: unknown) => void,
			): DelegateBinding$1<TValue>;

			/** Gets or sets the delegate to get the value for this binding. */
			GetValue: () => TValue;

			/** Gets or sets the delegate to set the value for this binding. */
			SetValue: (arg1: TValue) => void;

			/**
			 * Gets or sets the delegate to register the change event, when needed by the consumer of
			 * this binding.
			 */
			AddChangeEvent: (arg1: unknown) => void;

			/** Gets or sets the delegate to remove the change event. */
			RemoveChangeEvent: (arg1: unknown) => void;

			/** Gets or sets the value of this binding */
			DataValue: TValue;

			Convert<TValue>(
				toValue: (arg1: TValue) => TValue,
				fromValue?: (arg1: TValue) => TValue,
			): Eto.Forms.DirectBinding$1<TValue>;

			Cast<TValue>(): Eto.Forms.DirectBinding$1<TValue>;

			Child<TValue>(property: unknown): Eto.Forms.DirectBinding$1<TValue>;

			Child<TValue>(binding: Eto.Forms.IndirectBinding$1<TValue>): Eto.Forms.DirectBinding$1<TValue>;

			ToBool(
				trueValue: TValue,
				falseValue: TValue,
				nullValue: TValue,
			): Eto.Forms.DirectBinding$1<boolean | undefined>;

			ToBool(
				trueValue: TValue,
				falseValue: TValue,
			): Eto.Forms.DirectBinding$1<boolean | undefined>;

			ToBool(trueValue: TValue): Eto.Forms.DirectBinding$1<boolean | undefined>;

			ToType<TType>(
				invalidGetValue?: (arg1: TValue) => TType,
				invalidSetValue?: (arg1: TType) => TValue,
			): Eto.Forms.DirectBinding$1<TType>;

			CatchException(exceptionHandler?: (arg1: unknown) => boolean): Eto.Forms.DirectBinding$1<TValue>;

			CatchException<TException>(exceptionHandler?: (arg1: TException) => boolean): Eto.Forms.DirectBinding$1<TValue>;

			/**
			 * Unbind this from the target object(s)
			 *
			 * Typically a binding may handle an event for when the target object(s) property values
			 * are changed.  This is called to unbind the binding from the objects so that they can
			 * be garbage collected
			 */
			Unbind(): void;

			/**
			 * Updates the bound target object's value
			 *
			 * Typically the source would be your custom class and the destination would be a UI
			 * control, but this is not always the case.
			 */
			Update(mode?: Eto.Forms.BindingUpdateMode): void;
		}
	}

	export namespace Eto.Forms {
		/**
		 * [Generic type factory] Indirect binding using delegate methods
		 *
		 * This is an indirect binding, in that the object to get/set the values from/to is
		 * passed to each of the delegates to get/set the value. This is used for things like
		 * columns in a {@link Eto.Forms.Grid} control to bind to specific values of each item in
		 * the grid.
		 */
		export function DelegateBinding$(T: IType, TValue: IType): typeof DelegateBinding$2<any, any>;

		/**
		 * Indirect binding using delegate methods
		 *
		 * This is an indirect binding, in that the object to get/set the values from/to is
		 * passed to each of the delegates to get/set the value. This is used for things like
		 * columns in a {@link Eto.Forms.Grid} control to bind to specific values of each item in
		 * the grid.
		 */
		export class DelegateBinding$2<T, TValue> implements
			Eto.Forms.IBinding,
			Eto.Forms.IIndirectBinding$1<TValue> {
			/** Initializes a new instance of the {@link Eto.Forms.DelegateBinding<,>} class. */
			new(
				getValue: (arg1: T) => TValue,
				setValue: (arg1: T, arg2: TValue) => void,
				addChangeEvent: (arg1: T, arg2: unknown) => void,
				removeChangeEvent: (arg1: T, arg2: unknown) => void,
				defaultGetValue?: TValue,
				defaultSetValue?: TValue,
			): DelegateBinding$2<T, TValue>;

			/** Initializes a new instance of the {@link Eto.Forms.DelegateBinding<,>} class. */
			new(
				getValue?: (arg1: T) => TValue,
				setValue?: (arg1: T, arg2: TValue) => void,
				addChangeEvent?: (arg1: T, arg2: unknown) => unknown,
				removeChangeEvent?: (arg1: unknown, arg2: unknown) => void,
				defaultGetValue?: TValue,
				defaultSetValue?: TValue,
			): DelegateBinding$2<T, TValue>;

			/** Initializes a new instance of the {@link Eto.Forms.DelegateBinding<,>} class. */
			new(
				getValue: (arg1: T) => TValue,
				setValue: (arg1: T, arg2: TValue) => void,
				notifyProperty: string,
				defaultGetValue?: TValue,
				defaultSetValue?: TValue,
			): DelegateBinding$2<T, TValue>;

			/** Gets or sets the delegate to get the value for this binding. */
			GetValue: (arg1: T) => TValue;

			/** Gets or sets the delegate to set the value for this binding. */
			SetValue: (arg1: T, arg2: TValue) => void;

			/**
			 * Gets or sets the delegate to register the change event, when needed by the consumer of
			 * this binding.
			 */
			AddChangeEvent: (arg1: T, arg2: unknown) => unknown;

			/** Gets or sets the delegate to remove the change event. */
			RemoveChangeEvent: (arg1: unknown, arg2: unknown) => void;

			/** Gets or sets the default get value, when the object instance is null. */
			DefaultGetValue: TValue;

			/** Gets or sets the default set value, when the incoming value is null. */
			DefaultSetValue: TValue;

			/** Wires an event handler to fire when the property of the dataItem is changed */
			AddValueChangedHandler(
				dataItem: unknown,
				handler: unknown,
			): unknown;

			/**
			 * Removes the handler for the specified reference from
			 * {@link Eto.Forms.DelegateBinding`2.AddValueChangedHandler(System.Object,System.EventHandler{System.EventArgs})}
			 */
			RemoveValueChangedHandler(
				bindingReference: unknown,
				handler: unknown,
			): void;

			GetValue(dataItem: unknown): TValue;

			SetValue(
				dataItem: unknown,
				value: TValue,
			): void;

			Convert<TValue>(
				toValue: (arg1: TValue) => TValue,
				fromValue?: (arg1: TValue) => TValue,
			): Eto.Forms.IndirectBinding$1<TValue>;

			Convert<TValue>(
				converter: Eto.Forms.IValueConverter,
				conveterParameter?: unknown,
				culture?: unknown,
			): Eto.Forms.IndirectBinding$1<TValue>;

			Convert(
				converter: Eto.Forms.IValueConverter,
				propertyType: unknown,
				conveterParameter?: unknown,
				culture?: unknown,
			): Eto.Forms.IndirectBinding$1<unknown>;

			Cast<TValue>(): Eto.Forms.IndirectBinding$1<TValue>;

			Child<TNewValue>(property: unknown): Eto.Forms.IndirectBinding$1<TNewValue>;

			Child<TNewValue>(binding: Eto.Forms.IndirectBinding$1<TNewValue>): Eto.Forms.IndirectBinding$1<TNewValue>;

			OfType<TValue>(
				defaultConvertedValue?: TValue,
				defaultValue?: TValue,
			): Eto.Forms.IndirectBinding$1<TValue>;

			ToBool(
				trueValue: TValue,
				falseValue: TValue,
				nullValue: TValue,
			): Eto.Forms.IndirectBinding$1<boolean | undefined>;

			ToBool(
				trueValue: TValue,
				falseValue: TValue,
			): Eto.Forms.IndirectBinding$1<boolean | undefined>;

			ToBool(trueValue: TValue): Eto.Forms.IndirectBinding$1<boolean | undefined>;

			EnumToString(defaultValue?: TValue): Eto.Forms.IndirectBinding$1<string>;

			ToType<TType>(
				invalidGetValue?: (arg1: TValue) => TType,
				invalidSetValue?: (arg1: TType) => TValue,
			): Eto.Forms.IndirectBinding$1<TType>;

			AfterDelay(
				delay: number,
				reset?: boolean,
			): Eto.Forms.IndirectBinding$1<TValue>;

			AfterDelay(
				delay: number,
				reset?: boolean,
			): Eto.Forms.IndirectBinding$1<TValue>;

			CatchException(exceptionHandler?: (arg1: unknown) => boolean): Eto.Forms.IndirectBinding$1<TValue>;

			CatchException<TException>(exceptionHandler?: (arg1: TException) => boolean): Eto.Forms.IndirectBinding$1<TValue>;

			/**
			 * Unbind this from the target object(s)
			 *
			 * Typically a binding may handle an event for when the target object(s) property values
			 * are changed.  This is called to unbind the binding from the objects so that they can
			 * be garbage collected
			 */
			Unbind(): void;

			/**
			 * Updates the bound target object's value
			 *
			 * Typically the source would be your custom class and the destination would be a UI
			 * control, but this is not always the case.
			 */
			Update(mode?: Eto.Forms.BindingUpdateMode): void;
		}
	}

	export namespace Eto.Forms {
		/**
		 * [Generic type factory] Abstraction to get/set values from a provided object
		 *
		 * This binding provides a way to get/set values of an object that is provided by the
		 * binding, and not passed in.  This differs from the
		 * {@link Eto.Forms.IndirectBinding<>}, which requires that the caller pass in the object
		 * to get/set the value from/to.
		 */
		export function DirectBinding$(T: IType): typeof DirectBinding$1<any>;

		/**
		 * Abstraction to get/set values from a provided object
		 *
		 * This binding provides a way to get/set values of an object that is provided by the
		 * binding, and not passed in.  This differs from the
		 * {@link Eto.Forms.IndirectBinding<>}, which requires that the caller pass in the object
		 * to get/set the value from/to.
		 */
		export class DirectBinding$1<T> implements Eto.Forms.IBinding {
			/** Gets or sets the value of this binding */
			DataValue: T;

			/**
			 * Converts this binding's value to another value using delegates.
			 *
			 * This is useful when you want to cast one binding to another, perform logic when
			 * getting/setting a value from a particular binding, or get/set a preoperty of the
			 * value.
			 */
			Convert<TValue>(
				toValue: (arg1: T) => TValue,
				fromValue?: (arg1: TValue) => T,
			): Eto.Forms.DirectBinding$1<TValue>;

			/** Casts this binding value to another (compatible) type. */
			Cast<TValue>(): Eto.Forms.DirectBinding$1<TValue>;

			/**
			 * Binds to the specified child `property` expression.
			 *
			 * This can be used to bind to properties of child objects of your view model, for
			 * example model.SomeProperty.ChildProperty .  This will automatically look up the
			 * changed event either by a [Property]Changed event or INotifyPropertyChanged
			 * implementation for each object in the heirarchy.  Note that you only really need to
			 * use this when you have an existing binding that you cannot change. See
			 * {@link Eto.Forms.Binding.Property``2(System.Linq.Expressions.Expression{System.Func{``0,``1}})}
			 * for an example of how to bind to child property values more directly.
			 */
			Child<TValue>(property: unknown): Eto.Forms.DirectBinding$1<TValue>;

			/**
			 * Binds to the specified child `binding` of this binding.
			 *
			 * This can be used to bind to child objects of your view model, for example
			 * model.SomeProperty.ChildProperty .
			 */
			Child<TValue>(binding: Eto.Forms.IndirectBinding$1<TValue>): Eto.Forms.DirectBinding$1<TValue>;

			/**
			 * Converts this binding to return a nullable boolean binding
			 *
			 * This is useful when converting a binding to be used for a checkbox's Checked binding
			 * for example. When the binding's value matches the `trueValue`, it will return true.
			 */
			ToBool(
				trueValue: T,
				falseValue: T,
				nullValue: T,
			): Eto.Forms.DirectBinding$1<boolean | undefined>;

			/**
			 * Converts this binding to return a nullable boolean binding
			 *
			 * This is useful when converting a binding to be used for a checkbox's Checked binding
			 * for example. When the binding's value matches the `trueValue`, it will return true.
			 */
			ToBool(
				trueValue: T,
				falseValue: T,
			): Eto.Forms.DirectBinding$1<boolean | undefined>;

			/**
			 * Converts this binding to return a nullable boolean binding
			 *
			 * This is useful when converting a binding to be used for a checkbox's Checked binding
			 * for example. When the binding's value matches the `trueValue`, it will return true.
			 */
			ToBool(trueValue: T): Eto.Forms.DirectBinding$1<boolean | undefined>;

			/**
			 * Uses System.Convert.ChangeType to change the value of the binding to the specified
			 * type.
			 *
			 * This has additional logic to deal with nullable types so they can be converted
			 * properly as well.
			 */
			ToType<TType>(
				invalidGetValue?: (arg1: T) => TType,
				invalidSetValue?: (arg1: TType) => T,
			): Eto.Forms.DirectBinding$1<TType>;

			/** Catches any exceptions when setting the value of the binding */
			CatchException(exceptionHandler?: (arg1: unknown) => boolean): Eto.Forms.DirectBinding$1<T>;

			/** Catches any exceptions of the specified  when setting the value of the binding. */
			CatchException<TException>(exceptionHandler?: (arg1: TException) => boolean): Eto.Forms.DirectBinding$1<T>;

			/**
			 * Unbind this from the target object(s)
			 *
			 * Typically a binding may handle an event for when the target object(s) property values
			 * are changed.  This is called to unbind the binding from the objects so that they can
			 * be garbage collected
			 */
			Unbind(): void;

			/**
			 * Updates the bound target object's value
			 *
			 * Typically the source would be your custom class and the destination would be a UI
			 * control, but this is not always the case.
			 */
			Update(mode?: Eto.Forms.BindingUpdateMode): void;
		}
	}

	export namespace Eto.Forms {
		/**
		 * Mode of the {@link Eto.Forms.DualBinding<>}
		 *
		 * This specifies what direction the updates of each of the properties are automatically
		 * handled. Only properties that have a Changed event, or objects that implement
		 * {@link System.ComponentModel.INotifyPropertyChanged} will handle automatically
		 * updating the binding.
		 */
		export enum DualBindingMode {
			/** Binding will update the destination if the source property is changed */
			OneWay = 0,

			/**
			 * Binding will update both the destination or source if updated on either the source or
			 * destination, respectively
			 */
			TwoWay = 1,

			/** Binding will update the source if the destination property is changed */
			OneWayToSource = 2,

			/**
			 * Binding will only set the destination from the source when initially bound
			 *
			 * This is ideal when you want to set the values of the destination, then only update the
			 * source at certain times using the
			 * {@link Eto.Forms.DualBinding`1.Update(Eto.Forms.BindingUpdateMode)} method.
			 */
			OneTime = 3,

			/**
			 * Binding will only update when the
			 * {@link Eto.Forms.Binding.Update(Eto.Forms.BindingUpdateMode)} method is called.
			 */
			Manual = 4,
		}
	}

	export namespace Eto.Forms {
		/**
		 * [Generic type factory] Binding for joining two object bindings together
		 *
		 * The DualBinding is the most useful binding, as it allows you to bind two objects
		 * together. This differs from the {@link Eto.Forms.IndirectBinding<>} where it only
		 * specifies how to get/set the value from a single object.
		 */
		export function DualBinding$(T: IType): typeof DualBinding$1<any>;

		/**
		 * Binding for joining two object bindings together
		 *
		 * The DualBinding is the most useful binding, as it allows you to bind two objects
		 * together. This differs from the {@link Eto.Forms.IndirectBinding<>} where it only
		 * specifies how to get/set the value from a single object.
		 */
		export class DualBinding$1<T> implements Eto.Forms.IBinding {
			/**
			 * Initializes a new instance of the DualBinding class with two object property bindings
			 */
			new(
				source: unknown,
				sourceProperty: string,
				destination: unknown,
				destinationProperty: string,
				mode?: Eto.Forms.DualBindingMode,
			): DualBinding$1<T>;

			/** Initializes a new instance of the DualBinding class with two specified bindings */
			new(
				source: Eto.Forms.DirectBinding$1<T>,
				destination: Eto.Forms.DirectBinding$1<T>,
				mode?: Eto.Forms.DualBindingMode,
			): DualBinding$1<T>;

			/** Gets the source binding */
			Source: Eto.Forms.DirectBinding$1<T>;

			/** Gets the destination binding */
			Destination: Eto.Forms.DirectBinding$1<T>;

			/** Gets the mode of the binding */
			Mode: Eto.Forms.DualBindingMode;

			/** Sets the source object's property with the value of the destination */
			SetSource(): void;

			/** Sets the destination object's property with the value of the source */
			SetDestination(): void;

			/** Updates the binding value (sets the source with the value of the destination) */
			Update(mode?: Eto.Forms.BindingUpdateMode): void;

			/** Unbinds both the source and destination bindings */
			Unbind(): void;

			/**
			 * Returns a {@link System.String} that represents the current
			 * {@link Eto.Forms.DualBinding<>}.
			 */
			ToString(): string;
		}
	}

	export namespace Eto.Forms {
		/** Interface for objects that support binding */
		export interface IBindable {
			/**
			 * Gets or sets the data context for the widget for binding
			 *
			 * Subclasses may override the standard behaviour so that hierarchy of widgets can be
			 * taken into account.  For example, a Control may return the data context of a parent,
			 * if it is not set explicitly.
			 */
			DataContext: unknown;

			/**
			 * Gets a value indicating that the {@link Eto.Forms.IBindable.DataContext} property is
			 * changing.
			 *
			 * This can be used to determine when to allow certain logic during the update of the
			 * data context.  It is used to disable binding setters on the model when the data
			 * context changes so that a binding does not cause the view model to be updated when the
			 * state hasn't been fully set yet.
			 */
			readonly IsDataContextChanging: boolean;

			/** Gets the collection of bindings that are attached to this widget */
			readonly Bindings: Eto.Forms.BindingCollection;
		}
	}

	export namespace Eto.Forms {
		/**
		 * [Generic type factory] Base interface for an indirect binding.
		 *
		 * An indirect binding is passed the data item to get/set values on the object. This is
		 * used for things like the {@link Eto.Forms.Grid}, {@link Eto.Forms.ListBox}, etc when
		 * binding to values for each item in the data store.
		 */
		export function IIndirectBinding$(T: IType): IType;

		/**
		 * Base interface for an indirect binding.
		 *
		 * An indirect binding is passed the data item to get/set values on the object. This is
		 * used for things like the {@link Eto.Forms.Grid}, {@link Eto.Forms.ListBox}, etc when
		 * binding to values for each item in the data store.
		 */
		export interface IIndirectBinding$1<T> extends Eto.Forms.IBinding {
			/**
			 * Gets the value from the specified object using this binding
			 *
			 * When values are needed from this binding, this method will be called.
			 */
			GetValue(dataItem: unknown): T;

			/**
			 * Sets the specified value to an object using this binding
			 *
			 * This is called to set the value to the object.
			 */
			SetValue(
				dataItem: unknown,
				value: T,
			): void;
		}
	}

	export namespace Eto.Forms {
		/**
		 * [Generic type factory] Provides an indirect binding to an indeterminate
		 * source/destination
		 *
		 * This binding does not directly bind to an object - you must pass the object to get/set
		 * the value.  The {@link Eto.Forms.DirectBinding<>} differs in  that it binds directly
		 * to an object.  The IndirectBinding is useful when you want to use the same binding on
		 * multiple objects, such as when binding cells in a {@link Eto.Forms.Grid}.  Typically
		 * one would use {@link Eto.Forms.PropertyBinding<>} or {@link Eto.Forms.ColumnBinding<>}
		 * which are ways to retrieve either a property value or column/index-based value.
		 */
		export function IndirectBinding$(T: IType): typeof IndirectBinding$1<any>;

		/**
		 * Provides an indirect binding to an indeterminate source/destination
		 *
		 * This binding does not directly bind to an object - you must pass the object to get/set
		 * the value.  The {@link Eto.Forms.DirectBinding<>} differs in  that it binds directly
		 * to an object.  The IndirectBinding is useful when you want to use the same binding on
		 * multiple objects, such as when binding cells in a {@link Eto.Forms.Grid}.  Typically
		 * one would use {@link Eto.Forms.PropertyBinding<>} or {@link Eto.Forms.ColumnBinding<>}
		 * which are ways to retrieve either a property value or column/index-based value.
		 */
		export class IndirectBinding$1<T> implements
			Eto.Forms.IBinding,
			Eto.Forms.IIndirectBinding$1<T> {
			/**
			 * Gets the value from the specified object using this binding
			 *
			 * When values are needed from this binding, this method will be called. Implementors of
			 * this binding would implement logic in
			 * {@link Eto.Forms.IndirectBinding`1.InternalGetValue(System.Object)}
			 */
			GetValue(dataItem: unknown): T;

			/**
			 * Sets the specified value to an object using this binding
			 *
			 * This is called to set the value to the object. Implementors of this binding woulc
			 * implement logic in
			 * {@link Eto.Forms.IndirectBinding`1.InternalSetValue(System.Object,`0)}.
			 */
			SetValue(
				dataItem: unknown,
				value: T,
			): void;

			/**
			 * Adds a handler to trap when the value of this binding changes for the specified object
			 *
			 * This is used to wire up events (or other mechanisms) to detect if the value is changed
			 * for a particular object.  This is typically used to fire the
			 * {@link Eto.Forms.DirectBinding`1.DataValueChanged} event (which is wired up
			 * automatically)
			 */
			AddValueChangedHandler(
				dataItem: unknown,
				handler: unknown,
			): unknown;

			/**
			 * Removes the handler for the specified reference from
			 * {@link Eto.Forms.IndirectBinding`1.AddValueChangedHandler(System.Object,System.EventHandler{System.EventArgs})}
			 */
			RemoveValueChangedHandler(
				bindingReference: unknown,
				handler: unknown,
			): void;

			/**
			 * Converts this binding's value to another value using delegates.
			 *
			 * This is useful when you want to cast one binding to another, perform logic when
			 * getting/setting a value from a particular binding, or get/set a preoperty of the
			 * value.
			 */
			Convert<TValue>(
				toValue: (arg1: T) => TValue,
				fromValue?: (arg1: TValue) => T,
			): Eto.Forms.IndirectBinding$1<TValue>;

			/** Converts the binding using the specified `converter` object. */
			Convert<TValue>(
				converter: Eto.Forms.IValueConverter,
				conveterParameter?: unknown,
				culture?: unknown,
			): Eto.Forms.IndirectBinding$1<TValue>;

			/** Converts the binding using the specified `converter` object. */
			Convert(
				converter: Eto.Forms.IValueConverter,
				propertyType: unknown,
				conveterParameter?: unknown,
				culture?: unknown,
			): Eto.Forms.IndirectBinding$1<unknown>;

			/** Casts this binding value to another (compatible) type. */
			Cast<TValue>(): Eto.Forms.IndirectBinding$1<TValue>;

			/**
			 * Binds to the specified child `property` expression.
			 *
			 * This can be used to bind to properties of child objects of your view model, for
			 * example model.SomeProperty.ChildProperty .  This will automatically look up the
			 * changed event either by a [Property]Changed event or INotifyPropertyChanged
			 * implementation for each object in the heirarchy.  Note that you only really need to
			 * use this when you have an existing binding that you cannot change. See
			 * {@link Eto.Forms.Binding.Property``2(System.Linq.Expressions.Expression{System.Func{``0,``1}})}
			 * for an example of how to bind to child property values more directly.
			 */
			Child<TNewValue>(property: unknown): Eto.Forms.IndirectBinding$1<TNewValue>;

			/**
			 * Binds to the specified child `binding` of this binding.
			 *
			 * This can be used to bind to child objects of your view model, for example
			 * model.SomeProperty.ChildProperty .
			 */
			Child<TNewValue>(binding: Eto.Forms.IndirectBinding$1<TNewValue>): Eto.Forms.IndirectBinding$1<TNewValue>;

			/**
			 * Casts this binding value to another (compatible) type, or returns the default if the
			 * types do not match.
			 */
			OfType<TValue>(
				defaultConvertedValue?: TValue,
				defaultValue?: T,
			): Eto.Forms.IndirectBinding$1<TValue>;

			/**
			 * Converts this binding to return a nullable boolean binding
			 *
			 * This is useful when converting a binding to be used for a checkbox's Checked binding
			 * for example. When the binding's value matches the `trueValue`, it will return true.
			 */
			ToBool(
				trueValue: T,
				falseValue: T,
				nullValue: T,
			): Eto.Forms.IndirectBinding$1<boolean | undefined>;

			/**
			 * Converts this binding to return a nullable boolean binding
			 *
			 * This is useful when converting a binding to be used for a checkbox's Checked binding
			 * for example. When the binding's value matches the `trueValue`, it will return true.
			 */
			ToBool(
				trueValue: T,
				falseValue: T,
			): Eto.Forms.IndirectBinding$1<boolean | undefined>;

			/**
			 * Converts this binding to return a nullable boolean binding
			 *
			 * This is useful when converting a binding to be used for a checkbox's Checked binding
			 * for example. When the binding's value matches the `trueValue`, it will return true.
			 */
			ToBool(trueValue: T): Eto.Forms.IndirectBinding$1<boolean | undefined>;

			/** Converts the a binding to an enumeration to/from its string representation */
			EnumToString(defaultValue?: T): Eto.Forms.IndirectBinding$1<string>;

			/**
			 * Uses System.Convert.ChangeType to change the value of the binding to the specified
			 * type.
			 *
			 * This has additional logic to deal with nullable types so they can be converted
			 * properly as well.
			 */
			ToType<TType>(
				invalidGetValue?: (arg1: T) => TType,
				invalidSetValue?: (arg1: TType) => T,
			): Eto.Forms.IndirectBinding$1<TType>;

			/**
			 * Specifies that the binding should only respond to change events after a delay.
			 *
			 * This is useful if the property/delegate that is bound is expensive to retrieve the new
			 * value, for example to dynamically generate a bitmap based on the state of the model,
			 * etc.   The `reset` boolean allows you to ensure that the binding is updated
			 * periodically when false (default),  or true to wait for the delay period after the
			 * last change event.
			 */
			AfterDelay(
				delay: number,
				reset?: boolean,
			): Eto.Forms.IndirectBinding$1<T>;

			/**
			 * Specifies that the binding should only respond to change events after a delay.
			 *
			 * This is useful if the property/delegate that is bound is expensive to retrieve the new
			 * value, for example to dynamically generate a bitmap based on the state of the model,
			 * etc.   The `reset` boolean allows you to ensure that the binding is updated
			 * periodically when false (default),  or true to wait for the delay period after the
			 * last change event.
			 */
			AfterDelay(
				delay: number,
				reset?: boolean,
			): Eto.Forms.IndirectBinding$1<T>;

			/** Catches any exceptions when setting the value of the binding */
			CatchException(exceptionHandler?: (arg1: unknown) => boolean): Eto.Forms.IndirectBinding$1<T>;

			/** Catches any exceptions of the specified  when setting the value of the binding. */
			CatchException<TException>(exceptionHandler?: (arg1: TException) => boolean): Eto.Forms.IndirectBinding$1<T>;

			/**
			 * Unbind this from the target object(s)
			 *
			 * Typically a binding may handle an event for when the target object(s) property values
			 * are changed.  This is called to unbind the binding from the objects so that they can
			 * be garbage collected
			 */
			Unbind(): void;

			/**
			 * Updates the bound target object's value
			 *
			 * Typically the source would be your custom class and the destination would be a UI
			 * control, but this is not always the case.
			 */
			Update(mode?: Eto.Forms.BindingUpdateMode): void;
		}
	}

	export namespace Eto.Forms {
		/**
		 * Interface for providing a reusable converter for binding values
		 *
		 * This can be used with the Convert() method for a binding.
		 */
		export interface IValueConverter {
			/**
			 * Converts the `value` to the specified `targetType`
			 *
			 * This is called when translating the value from the source to the destination, usually
			 * from the  Control to the View Model.
			 */
			Convert(
				value: unknown,
				targetType: unknown,
				parameter: unknown,
				culture: unknown,
			): unknown;

			/**
			 * Converts the `value` to the specified `targetType`.
			 *
			 * This is called when translating the value back from the destination to the source,
			 * usually from the View Model to the Control.  This should be the reverse implementation
			 * of the
			 * {@link Eto.Forms.IValueConverter.Convert(System.Object,System.Type,System.Object,System.Globalization.CultureInfo)}
			 * method.
			 */
			ConvertBack(
				value: unknown,
				targetType: unknown,
				parameter: unknown,
				culture: unknown,
			): unknown;
		}
	}

	export namespace Eto.Forms {
		/**
		 * [Generic type factory] Binding for a particular object to get/set values from/to
		 *
		 * This binding provides a way to get/set values for a particular object.  This uses a
		 * {@link Eto.Forms.IndirectBinding<>} as its logic to actually retrieve/set the values.
		 * This acts as a bridge between the {@link Eto.Forms.IndirectBinding<>} and
		 * {@link Eto.Forms.DirectBinding<>} so that you can utilize the
		 * {@link Eto.Forms.DirectBinding`1.DataValueChanged} method.  Typically, one would use
		 * the {@link Eto.Forms.PropertyBinding<>}, or the
		 * {@link ObjectBinding{T,TValue}(T, string)} constructor to hook up this binding to a
		 * particular property of the specified object
		 */
		export function ObjectBinding$(TValue: IType): typeof ObjectBinding$1<any>;

		/**
		 * Binding for a particular object to get/set values from/to
		 *
		 * This binding provides a way to get/set values for a particular object.  This uses a
		 * {@link Eto.Forms.IndirectBinding<>} as its logic to actually retrieve/set the values.
		 * This acts as a bridge between the {@link Eto.Forms.IndirectBinding<>} and
		 * {@link Eto.Forms.DirectBinding<>} so that you can utilize the
		 * {@link Eto.Forms.DirectBinding`1.DataValueChanged} method.  Typically, one would use
		 * the {@link Eto.Forms.PropertyBinding<>}, or the
		 * {@link ObjectBinding{T,TValue}(T, string)} constructor to hook up this binding to a
		 * particular property of the specified object
		 */
		export class ObjectBinding$1<TValue> implements Eto.Forms.IBinding {
			/**
			 * Initializes a new instance of the ObjectBinding with the specified object and binding
			 * to get/set values with
			 */
			new(
				dataItem: unknown,
				innerBinding: Eto.Forms.IndirectBinding$1<TValue>,
			): ObjectBinding$1<TValue>;

			/**
			 * Initializes a new instance of the ObjectBinding with the specified object and property
			 * for a {@link Eto.Forms.PropertyBinding<>}
			 *
			 * This is a shortcut to set up the binding to get/set values from a particular property
			 * of the specified object
			 */
			new(
				dataItem: unknown,
				property: string,
			): ObjectBinding$1<TValue>;

			readonly InnerBinding: Eto.Forms.IndirectBinding$1<TValue>;

			DataItem: unknown;

			GetDataItem: () => unknown;

			SettingNullValue: TValue;

			GettingNullValue: TValue;

			DataValue: TValue;

			TriggerDataValueChanged(): void;

			Unbind(): void;

			Bind(
				sourceBinding: Eto.Forms.DirectBinding$1<TValue>,
				mode?: Eto.Forms.DualBindingMode,
			): Eto.Forms.DualBinding$1<TValue>;

			Bind(
				getValue: () => TValue,
				setValue?: (arg1: TValue) => void,
				addChangeEvent?: (arg1: unknown) => void,
				removeChangeEvent?: (arg1: unknown) => void,
				mode?: Eto.Forms.DualBindingMode,
			): Eto.Forms.DualBinding$1<TValue>;

			Bind<TObject>(
				objectValue: TObject,
				objectBinding: Eto.Forms.IndirectBinding$1<TValue>,
				mode?: Eto.Forms.DualBindingMode,
			): Eto.Forms.DualBinding$1<TValue>;

			Bind(
				objectValue: unknown,
				propertyName: string,
				mode?: Eto.Forms.DualBindingMode,
			): Eto.Forms.DualBinding$1<TValue>;

			Bind<TObject>(
				objectValue: TObject,
				propertyExpression: unknown,
				mode?: Eto.Forms.DualBindingMode,
			): Eto.Forms.DualBinding$1<TValue>;

			ToString(): string;

			Convert<TValue>(
				toValue: (arg1: TValue) => TValue,
				fromValue?: (arg1: TValue) => TValue,
			): Eto.Forms.DirectBinding$1<TValue>;

			Cast<TValue>(): Eto.Forms.DirectBinding$1<TValue>;

			Child<TValue>(property: unknown): Eto.Forms.DirectBinding$1<TValue>;

			Child<TValue>(binding: Eto.Forms.IndirectBinding$1<TValue>): Eto.Forms.DirectBinding$1<TValue>;

			ToBool(
				trueValue: TValue,
				falseValue: TValue,
				nullValue: TValue,
			): Eto.Forms.DirectBinding$1<boolean | undefined>;

			ToBool(
				trueValue: TValue,
				falseValue: TValue,
			): Eto.Forms.DirectBinding$1<boolean | undefined>;

			ToBool(trueValue: TValue): Eto.Forms.DirectBinding$1<boolean | undefined>;

			ToType<TType>(
				invalidGetValue?: (arg1: TValue) => TType,
				invalidSetValue?: (arg1: TType) => TValue,
			): Eto.Forms.DirectBinding$1<TType>;

			CatchException(exceptionHandler?: (arg1: unknown) => boolean): Eto.Forms.DirectBinding$1<TValue>;

			CatchException<TException>(exceptionHandler?: (arg1: TException) => boolean): Eto.Forms.DirectBinding$1<TValue>;

			/**
			 * Updates the bound target object's value
			 *
			 * Typically the source would be your custom class and the destination would be a UI
			 * control, but this is not always the case.
			 */
			Update(mode?: Eto.Forms.BindingUpdateMode): void;
		}
	}

	export namespace Eto.Forms {
		/**
		 * [Generic type factory] Binding for a particular object to get/set values from/to
		 *
		 * This binding provides a way to get/set values for a particular object.  This uses a
		 * {@link Eto.Forms.IndirectBinding<>} as its logic to actually retrieve/set the values.
		 * This acts as a bridge between the {@link Eto.Forms.IndirectBinding<>} and
		 * {@link Eto.Forms.DirectBinding<>} so that you can utilize the
		 * {@link Eto.Forms.DirectBinding`1.DataValueChanged} method.  Typically, one would use
		 * the {@link Eto.Forms.PropertyBinding<>}, or the
		 * {@link ObjectBinding{T,TValue}(T, string)} constructor to hook up this binding to a
		 * particular property of the specified object
		 */
		export function ObjectBinding$(T: IType, TValue: IType): typeof ObjectBinding$2<any, any>;

		/**
		 * Binding for a particular object to get/set values from/to
		 *
		 * This binding provides a way to get/set values for a particular object.  This uses a
		 * {@link Eto.Forms.IndirectBinding<>} as its logic to actually retrieve/set the values.
		 * This acts as a bridge between the {@link Eto.Forms.IndirectBinding<>} and
		 * {@link Eto.Forms.DirectBinding<>} so that you can utilize the
		 * {@link Eto.Forms.DirectBinding`1.DataValueChanged} method.  Typically, one would use
		 * the {@link Eto.Forms.PropertyBinding<>}, or the
		 * {@link ObjectBinding{T,TValue}(T, string)} constructor to hook up this binding to a
		 * particular property of the specified object
		 */
		export class ObjectBinding$2<T, TValue> implements Eto.Forms.IBinding {
			/** Initializes a new instance of the {@link Eto.Forms.ObjectBinding<,>} class. */
			new(
				dataItem: T,
				getValue: (arg1: T) => TValue,
				setValue?: (arg1: T, arg2: TValue) => void,
				addChangeEvent?: (arg1: T, arg2: unknown) => void,
				removeChangeEvent?: (arg1: T, arg2: unknown) => void,
			): ObjectBinding$2<T, TValue>;

			/**
			 * Initializes a new instance of the ObjectBinding with the specified object and property
			 * for a {@link Eto.Forms.PropertyBinding<>}
			 *
			 * This is a shortcut to set up the binding to get/set values from a particular property
			 * of the specified object
			 */
			new(
				dataItem: T,
				property: string,
			): ObjectBinding$2<T, TValue>;

			/**
			 * Initializes a new instance of the ObjectBinding with the specified object and binding
			 * to get/set values with
			 */
			new(
				dataItem: T,
				innerBinding: Eto.Forms.IndirectBinding$1<TValue>,
			): ObjectBinding$2<T, TValue>;

			/**
			 * Gets the binding used to get/set the values from the
			 * {@link Eto.Forms.ObjectBinding`2.DataItem}
			 */
			InnerBinding: Eto.Forms.IndirectBinding$1<TValue>;

			/**
			 * Gets or sets the object to get/set the values using the
			 * {@link Eto.Forms.ObjectBinding`2.InnerBinding}
			 *
			 * This uses {@link Eto.Forms.ObjectBinding`2.GetDataItem} if set, otherwise it will use
			 * the set value.  Setting the value explicitly will set
			 * {@link Eto.Forms.ObjectBinding`2.GetDataItem} to null.
			 */
			DataItem: T;

			/**
			 * Gets or sets a delegate used to get the current
			 * {@link Eto.Forms.ObjectBinding`2.DataItem} value instead of storing the value in this
			 * binding.
			 *
			 * This is used so that all bindings using a DataContext will be updated with the correct
			 * value as soon as the DataContext is set. For example, if updating one binding would
			 * trigger the setter of a secondary binding that hasn't been updated with the new value
			 * yet it would inadvertently change the DataContext even though it is now actually null.
			 *  Use the {@link Eto.Forms.ObjectBinding`2.TriggerDataValueChanged} method to specify
			 * that the value returned by this delegate has changed, which will cause the binding to
			 * update all of its dependants.  Note if this is set, then it will always be used to
			 * retrieve the DataItem. If you set the DataItem directly, this will be set to null and
			 * will no longer be used..
			 */
			GetDataItem: () => T;

			/**
			 * Gets or sets the default value to use when setting the value for this binding when
			 * input value is null
			 */
			SettingNullValue: TValue;

			/**
			 * Gets or sets the default value to use when getting the value for this binding when the
			 * {@link Eto.Forms.ObjectBinding`2.DataItem} or property value is null
			 */
			GettingNullValue: TValue;

			/**
			 * Gets or sets the value of this binding on the bound object
			 *
			 * This uses the {@link Eto.Forms.ObjectBinding`2.InnerBinding} on the
			 * {@link Eto.Forms.ObjectBinding`2.DataItem} to get/set the value
			 */
			DataValue: TValue;

			/**
			 * Triggers the {@link Eto.Forms.DirectBinding`1.DataValueChanged} event.
			 *
			 * When using the {@link Eto.Forms.ObjectBinding`2.GetDataItem} delegate to retrieve the
			 * value of the DataItem, you can call this method to trigger that its value has been
			 * changed.
			 */
			TriggerDataValueChanged(): void;

			/** Unbinds this binding */
			Unbind(): void;

			/**
			 * Creates a new dual binding between the specified `sourceBinding` and this binding.
			 *
			 * This creates a {@link Eto.Forms.DualBinding<>} between the specified `sourceBinding`
			 * and this binding. You must keep a reference to the binding to unbind when finished.
			 */
			Bind(
				sourceBinding: Eto.Forms.DirectBinding$1<TValue>,
				mode?: Eto.Forms.DualBindingMode,
			): Eto.Forms.DualBinding$1<TValue>;

			/**
			 * Creates a new dual binding using a {@link Eto.Forms.DelegateBinding<>} with the
			 * specified delegates and this binding.
			 *
			 * This creates a {@link Eto.Forms.DualBinding<>} between a new
			 * {@link Eto.Forms.DelegateBinding<>} and this binding. This does not require an object
			 * instance for the delegates to get/set the value. You must keep a reference to the
			 * binding to unbind when finished.
			 */
			Bind(
				getValue: () => TValue,
				setValue?: (arg1: TValue) => void,
				addChangeEvent?: (arg1: unknown) => void,
				removeChangeEvent?: (arg1: unknown) => void,
				mode?: Eto.Forms.DualBindingMode,
			): Eto.Forms.DualBinding$1<TValue>;

			/** Creates a new dual binding between the specified `objectBinding` and this binding. */
			Bind<TObject>(
				objectValue: TObject,
				objectBinding: Eto.Forms.IndirectBinding$1<TValue>,
				mode?: Eto.Forms.DualBindingMode,
			): Eto.Forms.DualBinding$1<TValue>;

			/**
			 * Creates a binding to the `propertyName` of the specified `objectValue`.
			 *
			 * This is a shortcut to using the {@link Eto.Forms.PropertyBinding<>}. This has the
			 * advantage of registering automatically to
			 * {@link System.ComponentModel.INotifyPropertyChanged} or to an event named after the
			 * property with a "Changed" suffix.
			 */
			Bind(
				objectValue: unknown,
				propertyName: string,
				mode?: Eto.Forms.DualBindingMode,
			): Eto.Forms.DualBinding$1<TValue>;

			/**
			 * Creates a binding to the specified `objectValue` with the specified
			 * `propertyExpression`.
			 *
			 * This has the advantage of registering automatically to
			 * {@link System.ComponentModel.INotifyPropertyChanged} or to an event named after the
			 * property with a "Changed" suffix, if the expression is a property. When the expression
			 * does not evaluate to a property, it will not be able to bind to the changed events and
			 * will use the expression as a delegate directly.
			 */
			Bind<TObject>(
				objectValue: TObject,
				propertyExpression: unknown,
				mode?: Eto.Forms.DualBindingMode,
			): Eto.Forms.DualBinding$1<TValue>;

			/**
			 * Returns a {@link System.String} that represents the current
			 * {@link Eto.Forms.ObjectBinding<,>}.
			 */
			ToString(): string;

			Convert<TValue>(
				toValue: (arg1: TValue) => TValue,
				fromValue?: (arg1: TValue) => TValue,
			): Eto.Forms.DirectBinding$1<TValue>;

			Cast<TValue>(): Eto.Forms.DirectBinding$1<TValue>;

			Child<TValue>(property: unknown): Eto.Forms.DirectBinding$1<TValue>;

			Child<TValue>(binding: Eto.Forms.IndirectBinding$1<TValue>): Eto.Forms.DirectBinding$1<TValue>;

			ToBool(
				trueValue: TValue,
				falseValue: TValue,
				nullValue: TValue,
			): Eto.Forms.DirectBinding$1<boolean | undefined>;

			ToBool(
				trueValue: TValue,
				falseValue: TValue,
			): Eto.Forms.DirectBinding$1<boolean | undefined>;

			ToBool(trueValue: TValue): Eto.Forms.DirectBinding$1<boolean | undefined>;

			ToType<TType>(
				invalidGetValue?: (arg1: TValue) => TType,
				invalidSetValue?: (arg1: TType) => TValue,
			): Eto.Forms.DirectBinding$1<TType>;

			CatchException(exceptionHandler?: (arg1: unknown) => boolean): Eto.Forms.DirectBinding$1<TValue>;

			CatchException<TException>(exceptionHandler?: (arg1: TException) => boolean): Eto.Forms.DirectBinding$1<TValue>;

			/**
			 * Updates the bound target object's value
			 *
			 * Typically the source would be your custom class and the destination would be a UI
			 * control, but this is not always the case.
			 */
			Update(mode?: Eto.Forms.BindingUpdateMode): void;
		}
	}

	export namespace Eto.Forms {
		/**
		 * [Generic type factory] Indirect binding to get/set values using a property of a
		 * specified object
		 *
		 * This is used when you are binding to a particular property of an object.  This can be
		 * used to get/set values from any object.  If you want to bind to a particular object
		 * directly, use the {@link Eto.Forms.ObjectBinding<>} with this class as its inner
		 * binding.
		 */
		export function PropertyBinding$(T: IType): typeof PropertyBinding$1<any>;

		/**
		 * Indirect binding to get/set values using a property of a specified object
		 *
		 * This is used when you are binding to a particular property of an object.  This can be
		 * used to get/set values from any object.  If you want to bind to a particular object
		 * directly, use the {@link Eto.Forms.ObjectBinding<>} with this class as its inner
		 * binding.
		 */
		export class PropertyBinding$1<T> implements
			Eto.Forms.IBinding,
			Eto.Forms.IIndirectBinding$1<T> {
			/** Initializes a new instance of the {@link Eto.Forms.PropertyBinding<>} class. */
			new(): PropertyBinding$1<T>;

			/** Initializes a new instance of the PropertyBinding with the specified property */
			new(
				property: string,
				ignoreCase?: boolean,
			): PropertyBinding$1<T>;

			/** Gets or sets the property in which to get/set values from for this binding */
			Property: string;

			/**
			 * Gets or sets whether the {@link Eto.Forms.PropertyBinding`1.Property} specified is
			 * case-sensitive or not
			 */
			IgnoreCase: boolean;

			/** Wires an event handler to fire when the property of the dataItem is changed */
			AddValueChangedHandler(
				dataItem: unknown,
				handler: unknown,
			): unknown;

			/**
			 * Removes the handler for the specified reference from
			 * {@link Eto.Forms.PropertyBinding`1.AddValueChangedHandler(System.Object,System.EventHandler{System.EventArgs})}
			 */
			RemoveValueChangedHandler(
				bindingReference: unknown,
				handler: unknown,
			): void;

			/**
			 * Returns a {@link System.String} that represents the current
			 * {@link Eto.Forms.PropertyBinding<>}.
			 */
			ToString(): string;

			GetValue(dataItem: unknown): T;

			SetValue(
				dataItem: unknown,
				value: T,
			): void;

			Convert<TValue>(
				toValue: (arg1: T) => TValue,
				fromValue?: (arg1: TValue) => T,
			): Eto.Forms.IndirectBinding$1<TValue>;

			Convert<TValue>(
				converter: Eto.Forms.IValueConverter,
				conveterParameter?: unknown,
				culture?: unknown,
			): Eto.Forms.IndirectBinding$1<TValue>;

			Convert(
				converter: Eto.Forms.IValueConverter,
				propertyType: unknown,
				conveterParameter?: unknown,
				culture?: unknown,
			): Eto.Forms.IndirectBinding$1<unknown>;

			Cast<TValue>(): Eto.Forms.IndirectBinding$1<TValue>;

			Child<TNewValue>(property: unknown): Eto.Forms.IndirectBinding$1<TNewValue>;

			Child<TNewValue>(binding: Eto.Forms.IndirectBinding$1<TNewValue>): Eto.Forms.IndirectBinding$1<TNewValue>;

			OfType<TValue>(
				defaultConvertedValue?: TValue,
				defaultValue?: T,
			): Eto.Forms.IndirectBinding$1<TValue>;

			ToBool(
				trueValue: T,
				falseValue: T,
				nullValue: T,
			): Eto.Forms.IndirectBinding$1<boolean | undefined>;

			ToBool(
				trueValue: T,
				falseValue: T,
			): Eto.Forms.IndirectBinding$1<boolean | undefined>;

			ToBool(trueValue: T): Eto.Forms.IndirectBinding$1<boolean | undefined>;

			EnumToString(defaultValue?: T): Eto.Forms.IndirectBinding$1<string>;

			ToType<TType>(
				invalidGetValue?: (arg1: T) => TType,
				invalidSetValue?: (arg1: TType) => T,
			): Eto.Forms.IndirectBinding$1<TType>;

			AfterDelay(
				delay: number,
				reset?: boolean,
			): Eto.Forms.IndirectBinding$1<T>;

			AfterDelay(
				delay: number,
				reset?: boolean,
			): Eto.Forms.IndirectBinding$1<T>;

			CatchException(exceptionHandler?: (arg1: unknown) => boolean): Eto.Forms.IndirectBinding$1<T>;

			CatchException<TException>(exceptionHandler?: (arg1: TException) => boolean): Eto.Forms.IndirectBinding$1<T>;

			/**
			 * Unbind this from the target object(s)
			 *
			 * Typically a binding may handle an event for when the target object(s) property values
			 * are changed.  This is called to unbind the binding from the objects so that they can
			 * be garbage collected
			 */
			Unbind(): void;

			/**
			 * Updates the bound target object's value
			 *
			 * Typically the source would be your custom class and the destination would be a UI
			 * control, but this is not always the case.
			 */
			Update(mode?: Eto.Forms.BindingUpdateMode): void;
		}
	}

	export namespace Eto.Forms {
		/**
		 * Exception when getting/setting values in a {@link Eto.Forms.PropertyBinding<>}
		 *
		 * This exception is thrown explicitly if there is a problem getting or setting the value
		 * on the data item. Since using descriptors can sometimes bury the actual stack trace,
		 * this can be useful to figure out what property setter/getter is throwing.
		 */
		export class PropertyBindingException {
			/** Initializes a new instance of the PropertyBindingException class. */
			constructor();

			/**
			 * Initializes a new instance of the PropertyBindingException class with the specified
			 * message.
			 */
			constructor(message: string);

			/**
			 * Initializes a new instance of the PropertyBindingException class with the specified
			 * message and inner exception.
			 */
			constructor(
				message: string,
				inner: unknown,
			);
		}
	}

	export namespace Eto.Forms {
		/** Base class for cells in a {@link Eto.Forms.Grid}. */
		export class Cell implements
			Eto.IHandlerSource {
			/**
			 * Gets the platform that was used to create the {@link Eto.Widget.Handler} for this
			 * widget
			 *
			 * This gets set to the current {@link Eto.Platform.Instance} during the construction of
			 * the object
			 */
			readonly Platform: Eto.Platform;

			/** Gets the platform-specific handler for this widget */
			Handler: unknown;

			/** Gets the native platform-specific handle for integration purposes */
			readonly NativeHandle: unknown;

			/** Gets the dictionary of properties for this widget */
			readonly Properties: Eto.PropertyStore;

			/** Gets or sets the ID of this widget */
			ID: string;

			/**
			 * Gets or sets the style of this widget
			 *
			 * Styles allow you to attach custom platform-specific logic to a widget. In your
			 * platform-specific assembly, use {@link Style.Add{H}(string, StyleHandler{H})} to add
			 * the style logic with the same id.
			 */
			Style: string;

			/**
			 * Gets the instance of the platform-specific object
			 *
			 * This can sometimes be useful to get the platform-specific object. Some handlers may
			 * not have any backing object for its functionality, so this may be null.  It is more
			 * preferred to use the {@link Eto.Widget.Handler} and cast that to the platform-specific
			 * handler class which can give you additional methods and helpers to do common tasks.
			 * For example, the {@link Eto.Forms.Application} object's handler for OS X has a
			 * AddFullScreenMenuItem property to specify if you want full screen support in your app.
			 */
			readonly ControlObject: unknown;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Widget} has been disposed.
			 *
			 * When the widget is disposed, it can no longer be used.
			 */
			IsDisposed: boolean;

			/** Disposes of this widget, supressing the finalizer */
			dispose(): void;

			/** Gets a string that represents the current object with its ID if specified. */
			ToString(): string;
		}
	}

	export namespace Eto.Forms {
		/**
		 * Cell for {@link Eto.Forms.Grid} controls to show and bind a boolean value to a check
		 * box.
		 */
		export class CheckBoxCell implements
			Eto.IHandlerSource {
			/** Initializes a new instance of the {@link Eto.Forms.CheckBoxCell} class. */
			constructor(column: number);

			/**
			 * Initializes a new instance of the {@link Eto.Forms.CheckBoxCell} class with the
			 * specified property to bind to.
			 */
			constructor(property: string);

			/** Initializes a new instance of the {@link Eto.Forms.CheckBoxCell} class. */
			constructor();

			Binding: Eto.Forms.IIndirectBinding$1<boolean | undefined>;

			/**
			 * Gets the platform that was used to create the {@link Eto.Widget.Handler} for this
			 * widget
			 *
			 * This gets set to the current {@link Eto.Platform.Instance} during the construction of
			 * the object
			 */
			readonly Platform: Eto.Platform;

			/** Gets the platform-specific handler for this widget */
			Handler: unknown;

			/** Gets the native platform-specific handle for integration purposes */
			readonly NativeHandle: unknown;

			/** Gets the dictionary of properties for this widget */
			readonly Properties: Eto.PropertyStore;

			/** Gets or sets the ID of this widget */
			ID: string;

			/**
			 * Gets or sets the style of this widget
			 *
			 * Styles allow you to attach custom platform-specific logic to a widget. In your
			 * platform-specific assembly, use {@link Style.Add{H}(string, StyleHandler{H})} to add
			 * the style logic with the same id.
			 */
			Style: string;

			/**
			 * Gets the instance of the platform-specific object
			 *
			 * This can sometimes be useful to get the platform-specific object. Some handlers may
			 * not have any backing object for its functionality, so this may be null.  It is more
			 * preferred to use the {@link Eto.Widget.Handler} and cast that to the platform-specific
			 * handler class which can give you additional methods and helpers to do common tasks.
			 * For example, the {@link Eto.Forms.Application} object's handler for OS X has a
			 * AddFullScreenMenuItem property to specify if you want full screen support in your app.
			 */
			readonly ControlObject: unknown;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Widget} has been disposed.
			 *
			 * When the widget is disposed, it can no longer be used.
			 */
			IsDisposed: boolean;

			/** Disposes of this widget, supressing the finalizer */
			dispose(): void;

			/** Gets a string that represents the current object with its ID if specified. */
			ToString(): string;
		}
	}

	export namespace Eto.Forms.CheckBoxCell {
		export interface IHandler extends Eto.Widget.IHandler {
		}
	}

	export namespace Eto.Forms {
		/** Cell to present a combo box in a {@link Eto.Forms.Grid}. */
		export class ComboBoxCell implements
			Eto.IHandlerSource {
			/**
			 * Initializes a new instance of the {@link Eto.Forms.ComboBoxCell} class with the column
			 * index to bind.
			 */
			constructor(column: number);

			/**
			 * Initializes a new instance of the {@link Eto.Forms.ComboBoxCell} class with the
			 * specified property to bind to.
			 */
			constructor(property: string);

			/** Initializes a new instance of the {@link Eto.Forms.ComboBoxCell} class. */
			constructor();

			/** Binding to get the text value for the items in the combo box. */
			ComboTextBinding: Eto.Forms.IIndirectBinding$1<string>;

			/** Binding to get the key value for the items in the combo box. */
			ComboKeyBinding: Eto.Forms.IIndirectBinding$1<string>;

			/** Gets or sets the data store of the items in the combo box for this cell. */
			DataStore: Iterable<unknown>;

			Binding: Eto.Forms.IIndirectBinding$1<unknown>;

			/**
			 * Gets the platform that was used to create the {@link Eto.Widget.Handler} for this
			 * widget
			 *
			 * This gets set to the current {@link Eto.Platform.Instance} during the construction of
			 * the object
			 */
			readonly Platform: Eto.Platform;

			/** Gets the platform-specific handler for this widget */
			Handler: unknown;

			/** Gets the native platform-specific handle for integration purposes */
			readonly NativeHandle: unknown;

			/** Gets the dictionary of properties for this widget */
			readonly Properties: Eto.PropertyStore;

			/** Gets or sets the ID of this widget */
			ID: string;

			/**
			 * Gets or sets the style of this widget
			 *
			 * Styles allow you to attach custom platform-specific logic to a widget. In your
			 * platform-specific assembly, use {@link Style.Add{H}(string, StyleHandler{H})} to add
			 * the style logic with the same id.
			 */
			Style: string;

			/**
			 * Gets the instance of the platform-specific object
			 *
			 * This can sometimes be useful to get the platform-specific object. Some handlers may
			 * not have any backing object for its functionality, so this may be null.  It is more
			 * preferred to use the {@link Eto.Widget.Handler} and cast that to the platform-specific
			 * handler class which can give you additional methods and helpers to do common tasks.
			 * For example, the {@link Eto.Forms.Application} object's handler for OS X has a
			 * AddFullScreenMenuItem property to specify if you want full screen support in your app.
			 */
			readonly ControlObject: unknown;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Widget} has been disposed.
			 *
			 * When the widget is disposed, it can no longer be used.
			 */
			IsDisposed: boolean;

			/** Disposes of this widget, supressing the finalizer */
			dispose(): void;

			/** Gets a string that represents the current object with its ID if specified. */
			ToString(): string;
		}
	}

	export namespace Eto.Forms.ComboBoxCell {
		export interface IHandler extends Eto.Widget.IHandler {
			DataStore: Iterable<unknown>;
		}
	}

	export namespace Eto.Forms {
		/** State for a {@link Eto.Forms.Cell} */
		export enum CellStates {
			/** Normal state */
			None = 0,

			/** Row is selected */
			Selected = 1,

			/** Cell is in edit mode */
			Editing = 2,
		}
	}

	export namespace Eto.Forms {
		/** Event arguments for events that refer to a {@link Eto.Forms.CellEventArgs.Cell}. */
		export class CellEventArgs {
			/** Initializes a new instance of the {@link Eto.Forms.CellEventArgs} class. */
			constructor(
				row: number,
				item: unknown,
				cellState: Eto.Forms.CellStates,
			);

			/** Initializes a new instance of the {@link Eto.Forms.CellEventArgs} class. */
			constructor(
				grid: Eto.Forms.Grid,
				cell: Eto.Forms.Cell,
				row: number,
				item: unknown,
				cellState: Eto.Forms.CellStates,
			);

			/** Initializes a new instance of the {@link Eto.Forms.CellEventArgs} class. */
			constructor(
				grid: Eto.Forms.Grid,
				cell: Eto.Forms.Cell,
				row: number,
				column: number,
				item: unknown,
				cellState: Eto.Forms.CellStates,
				control: Eto.Forms.Control,
			);

			/** Gets the state of the cell. */
			CellState: Eto.Forms.CellStates;

			/** Gets or sets the item for the cell. */
			Item: unknown;

			/** Gets or sets the row for the cell. */
			Row: number;

			/** Gets the column index for the cell. */
			readonly Column: number;

			/** Gets the column for the cell. */
			readonly GridColumn: Eto.Forms.GridColumn;

			/** Gets the cell that triggered this event */
			readonly Cell: Eto.Forms.Cell;

			/** Gets the grid that this event was triggered from */
			readonly Grid: Eto.Forms.Grid;

			/** Gets the custom control associated with the cell (if any) */
			Control: Eto.Forms.Control;

			/**
			 * Gets or sets a value indicating that the default behavior should not be executed for
			 * the event, if supported.
			 *
			 * Note that not all events can be handled.
			 */
			Handled: boolean;

			/** Gets or sets the preferred color of the cell text given its state. */
			CellTextColor: Eto.Drawing.Color;

			/** Gets or sets a value indicating whether the cell is in edit mode. */
			IsEditing: boolean;

			/** Gets or sets a value indicating whether the cell is selected. */
			IsSelected: boolean;
		}
	}

	export namespace Eto.Forms {
		/**
		 * Cell for {@link Eto.Forms.Grid} controls to create custom content for the cell.
		 *
		 * The CustomCell is useful when you want to provide a fully custom implementation of a
		 * cell, including editable controls.  Note that some platforms bahave differently with a
		 * CustomCell, depending on the value of
		 * {@link Eto.Forms.CustomCell.SupportsControlView}.  When false , the grid will use the
		 * {@link Eto.Forms.CustomCell.Paint} event to paint the contents of each cell, and only
		 * use {@link Eto.Forms.CustomCell.CreateCell} and
		 * {@link Eto.Forms.CustomCell.ConfigureCell} when the cell is in edit mode.  When true ,
		 * the {@link Eto.Forms.CustomCell.CreateCell} and
		 * {@link Eto.Forms.CustomCell.ConfigureCell} methods will be used for all cells, even
		 * when not in edit mode.
		 */
		export class CustomCell implements
			Eto.IHandlerSource {
			constructor();

			/**
			 * Gets a value indicating that the CustomCell on the current platform supports using a
			 * Control for its view mode. Gtk and WinForms only support custom controls when editing
			 * a cell.
			 *
			 * When false , you must handle the {@link Eto.Forms.CustomCell.Paint} event (or override
			 * {@link Eto.Forms.CustomCell.OnPaint(Eto.Forms.CellPaintEventArgs)} ) to provide a view
			 * mode for the cell contents.
			 */
			static readonly SupportsControlView: boolean;

			/**
			 * Gets or sets a delegate to create the contents of the cell.
			 *
			 * You can also override the
			 * {@link Eto.Forms.CustomCell.OnCreateCell(Eto.Forms.CellEventArgs)} method in
			 * subclasses. Note that you need to handle {@link Eto.Forms.CustomCell.ConfigureCell} to
			 * set up the cell for a particular row of data as the control may be reused when
			 * scrolling the view.
			 */
			CreateCell: (arg1: Eto.Forms.CellEventArgs) => Eto.Forms.Control;

			/**
			 * Gets or sets a delegate to get the identifier of the cell based on its content.
			 *
			 * When you have different controls on a per-row level, each variation must have an
			 * identifier string to allow the framework to cache the different types of cells to
			 * provide good performance.  This hooks into standard cell caching mechanisms in certain
			 * platforms, such as on the Mac.
			 */
			GetIdentifier: (arg1: Eto.Forms.CellEventArgs) => string;

			/**
			 * Gets or sets a delegate to get the preferred width of the cell based on its content.
			 *
			 * This may only be used when {@link Eto.Forms.CustomCell.SupportsControlView} is false.
			 */
			GetPreferredWidth: (arg1: Eto.Forms.CellEventArgs) => number;

			/**
			 * Gets or sets a delegate to configure an cell when it is reused for a different row or
			 * the data changes.
			 *
			 * This should set up your control your cell content to be reused.  If null, the
			 * DataContext of your control will be set to the row model instance.  Typically if you
			 * use MVVM data binding, you do not need to override the standard behaviour.
			 */
			ConfigureCell: (arg1: Eto.Forms.CellEventArgs, arg2: Eto.Forms.Control) => void;

			/**
			 * Gets the platform that was used to create the {@link Eto.Widget.Handler} for this
			 * widget
			 *
			 * This gets set to the current {@link Eto.Platform.Instance} during the construction of
			 * the object
			 */
			readonly Platform: Eto.Platform;

			/** Gets the platform-specific handler for this widget */
			Handler: unknown;

			/** Gets the native platform-specific handle for integration purposes */
			readonly NativeHandle: unknown;

			/** Gets the dictionary of properties for this widget */
			readonly Properties: Eto.PropertyStore;

			/** Gets or sets the ID of this widget */
			ID: string;

			/**
			 * Gets or sets the style of this widget
			 *
			 * Styles allow you to attach custom platform-specific logic to a widget. In your
			 * platform-specific assembly, use {@link Style.Add{H}(string, StyleHandler{H})} to add
			 * the style logic with the same id.
			 */
			Style: string;

			/**
			 * Gets the instance of the platform-specific object
			 *
			 * This can sometimes be useful to get the platform-specific object. Some handlers may
			 * not have any backing object for its functionality, so this may be null.  It is more
			 * preferred to use the {@link Eto.Widget.Handler} and cast that to the platform-specific
			 * handler class which can give you additional methods and helpers to do common tasks.
			 * For example, the {@link Eto.Forms.Application} object's handler for OS X has a
			 * AddFullScreenMenuItem property to specify if you want full screen support in your app.
			 */
			readonly ControlObject: unknown;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Widget} has been disposed.
			 *
			 * When the widget is disposed, it can no longer be used.
			 */
			IsDisposed: boolean;

			/** Creates a new CustomCell with instances of the specified  type. */
			static Create<TControl>(): Eto.Forms.CustomCell;

			/** Disposes of this widget, supressing the finalizer */
			dispose(): void;

			/** Gets a string that represents the current object with its ID if specified. */
			ToString(): string;
		}
	}

	export namespace Eto.Forms.CustomCell {
		export interface IHandler extends Eto.Widget.IHandler {
		}
	}

	export namespace Eto.Forms.CustomCell {
		export interface ICallback extends Eto.Widget.ICallback {
			OnGetPreferredWidth(
				widget: Eto.Forms.CustomCell,
				args: Eto.Forms.CellEventArgs,
			): number;

			OnGetIdentifier(
				widget: Eto.Forms.CustomCell,
				args: Eto.Forms.CellEventArgs,
			): string;

			OnConfigureCell(
				widget: Eto.Forms.CustomCell,
				args: Eto.Forms.CellEventArgs,
				control: Eto.Forms.Control,
			): void;

			OnCreateCell(
				widget: Eto.Forms.CustomCell,
				args: Eto.Forms.CellEventArgs,
			): Eto.Forms.Control;

			OnPaint(
				widget: Eto.Forms.CustomCell,
				args: Eto.Forms.CellPaintEventArgs,
			): void;

			OnBeginEdit(
				widget: Eto.Forms.CustomCell,
				args: Eto.Forms.CellEventArgs,
			): void;

			OnCancelEdit(
				widget: Eto.Forms.CustomCell,
				args: Eto.Forms.CellEventArgs,
			): void;

			OnCommitEdit(
				widget: Eto.Forms.CustomCell,
				args: Eto.Forms.CellEventArgs,
			): void;
		}
	}

	export namespace Eto.Forms {
		/**
		 * Event arguments for a {@link Eto.Forms.DrawableCell.Paint} or
		 * {@link Eto.Forms.CustomCell.Paint} event.
		 */
		export class CellPaintEventArgs {
			/**
			 * Initializes a new instance of the {@link Eto.Forms.DrawableCellPaintEventArgs} class.
			 */
			constructor(
				graphics: Eto.Drawing.Graphics,
				clipRectangle: Eto.Drawing.RectangleF,
				cellState: Eto.Forms.CellStates,
				item: unknown,
			);

			/** The state of the cell to be painted. */
			CellState: Eto.Forms.CellStates;

			/** The model data item for the row being painted. */
			Item: unknown;

			/** Gets a value indicating whether the cell is in edit mode. */
			readonly IsEditing: boolean;

			/** Gets a value indicating whether the cell is currently selected. */
			readonly IsSelected: boolean;

			/** Gets the graphics for the paint operation */
			readonly Graphics: Eto.Drawing.Graphics;

			/**
			 * Gets the rectangle of the region being painted
			 *
			 * This should be used to optimize what is drawn by only drawing content that intersects
			 * with this rectangle.
			 */
			readonly ClipRectangle: Eto.Drawing.RectangleF;
		}
	}

	export namespace Eto.Forms {
		/** Drawable cell paint event arguments. */
		export class DrawableCellPaintEventArgs {
			/**
			 * Initializes a new instance of the {@link Eto.Forms.DrawableCellPaintEventArgs} class.
			 */
			constructor(
				graphics: Eto.Drawing.Graphics,
				clipRectangle: Eto.Drawing.RectangleF,
				cellState: Eto.Forms.CellStates,
				item: unknown,
			);

			/** The state of the cell to be painted. */
			readonly CellState: Eto.Forms.CellStates;

			/** The model data item for the row being painted. */
			readonly Item: unknown;

			/** Gets a value indicating whether the cell is in edit mode. */
			readonly IsEditing: boolean;

			/** Gets a value indicating whether the cell is currently selected. */
			readonly IsSelected: boolean;

			/** Gets the graphics for the paint operation */
			readonly Graphics: Eto.Drawing.Graphics;

			/**
			 * Gets the rectangle of the region being painted
			 *
			 * This should be used to optimize what is drawn by only drawing content that intersects
			 * with this rectangle.
			 */
			readonly ClipRectangle: Eto.Drawing.RectangleF;
		}
	}

	export namespace Eto.Forms {
		/** A cell that is rendered by custom code. */
		export class DrawableCell implements
			Eto.IHandlerSource {
			constructor();

			/**
			 * Gets the platform that was used to create the {@link Eto.Widget.Handler} for this
			 * widget
			 *
			 * This gets set to the current {@link Eto.Platform.Instance} during the construction of
			 * the object
			 */
			readonly Platform: Eto.Platform;

			/** Gets the platform-specific handler for this widget */
			Handler: unknown;

			/** Gets the native platform-specific handle for integration purposes */
			readonly NativeHandle: unknown;

			/** Gets the dictionary of properties for this widget */
			readonly Properties: Eto.PropertyStore;

			/** Gets or sets the ID of this widget */
			ID: string;

			/**
			 * Gets or sets the style of this widget
			 *
			 * Styles allow you to attach custom platform-specific logic to a widget. In your
			 * platform-specific assembly, use {@link Style.Add{H}(string, StyleHandler{H})} to add
			 * the style logic with the same id.
			 */
			Style: string;

			/**
			 * Gets the instance of the platform-specific object
			 *
			 * This can sometimes be useful to get the platform-specific object. Some handlers may
			 * not have any backing object for its functionality, so this may be null.  It is more
			 * preferred to use the {@link Eto.Widget.Handler} and cast that to the platform-specific
			 * handler class which can give you additional methods and helpers to do common tasks.
			 * For example, the {@link Eto.Forms.Application} object's handler for OS X has a
			 * AddFullScreenMenuItem property to specify if you want full screen support in your app.
			 */
			readonly ControlObject: unknown;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Widget} has been disposed.
			 *
			 * When the widget is disposed, it can no longer be used.
			 */
			IsDisposed: boolean;

			/** Disposes of this widget, supressing the finalizer */
			dispose(): void;

			/** Gets a string that represents the current object with its ID if specified. */
			ToString(): string;
		}
	}

	export namespace Eto.Forms.DrawableCell {
		export interface ICallback extends Eto.Widget.ICallback {
			OnPaint(
				widget: Eto.Forms.DrawableCell,
				e: Eto.Forms.DrawableCellPaintEventArgs,
			): void;
		}
	}

	export namespace Eto.Forms.DrawableCell {
		export interface IHandler extends Eto.Widget.IHandler {
		}
	}

	export namespace Eto.Forms {
		/** Orientation of a {@link Eto.Forms.Splitter} control. */
		export class DrawableCellStates {
			/** Row is selected */
			static readonly Selected: Eto.Forms.DrawableCellStates;

			/** Normal state */
			static readonly None: Eto.Forms.DrawableCellStates;

			/**
			 * Determines whether the specified {@link System.Object} is equal to the current
			 * {@link Eto.Forms.SplitterOrientation}.
			 */
			Equals(obj: unknown): boolean;

			/** Serves as a hash function for a {@link Eto.Forms.SplitterOrientation} object. */
			GetHashCode(): number;
		}
	}

	export namespace Eto.Forms {
		/** Cell for {@link Eto.Forms.Grid} controls to show image and text in one cell. */
		export class ImageTextCell implements
			Eto.IHandlerSource {
			/**
			 * Initializes a new instance of the {@link Eto.Forms.ImageTextCell} class when binding
			 * to an indexed-based data item.
			 */
			constructor(
				imageColumn: number,
				textColumn: number,
			);

			/**
			 * Initializes a new instance of the {@link Eto.Forms.ImageTextCell} class when binding
			 * to properties via reflection.
			 */
			constructor(
				imageProperty: string,
				textProperty: string,
			);

			/** Initializes a new instance of the {@link Eto.Forms.ImageTextCell} class. */
			constructor();

			/** Gets or sets the horizontal alignment of the text within the cell. */
			TextAlignment: Eto.Forms.TextAlignment;

			/** Gets or sets the vertical alignment of the text within the cell. */
			VerticalAlignment: Eto.Forms.VerticalAlignment;

			/** Gets or sets the auto selection mode. */
			AutoSelectMode: Eto.Forms.AutoSelectMode;

			/** Gets or sets the binding of the image to display for the cell. */
			ImageBinding: Eto.Forms.IIndirectBinding$1<Eto.Drawing.Image>;

			/** Gets or sets the binding of the text to display for the cell. */
			TextBinding: Eto.Forms.IIndirectBinding$1<string>;

			/** Gets or sets the interpolation mode when scaling images to fit into the cell. */
			ImageInterpolation: Eto.Drawing.ImageInterpolation;

			/**
			 * Gets the platform that was used to create the {@link Eto.Widget.Handler} for this
			 * widget
			 *
			 * This gets set to the current {@link Eto.Platform.Instance} during the construction of
			 * the object
			 */
			readonly Platform: Eto.Platform;

			/** Gets the platform-specific handler for this widget */
			Handler: unknown;

			/** Gets the native platform-specific handle for integration purposes */
			readonly NativeHandle: unknown;

			/** Gets the dictionary of properties for this widget */
			readonly Properties: Eto.PropertyStore;

			/** Gets or sets the ID of this widget */
			ID: string;

			/**
			 * Gets or sets the style of this widget
			 *
			 * Styles allow you to attach custom platform-specific logic to a widget. In your
			 * platform-specific assembly, use {@link Style.Add{H}(string, StyleHandler{H})} to add
			 * the style logic with the same id.
			 */
			Style: string;

			/**
			 * Gets the instance of the platform-specific object
			 *
			 * This can sometimes be useful to get the platform-specific object. Some handlers may
			 * not have any backing object for its functionality, so this may be null.  It is more
			 * preferred to use the {@link Eto.Widget.Handler} and cast that to the platform-specific
			 * handler class which can give you additional methods and helpers to do common tasks.
			 * For example, the {@link Eto.Forms.Application} object's handler for OS X has a
			 * AddFullScreenMenuItem property to specify if you want full screen support in your app.
			 */
			readonly ControlObject: unknown;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Widget} has been disposed.
			 *
			 * When the widget is disposed, it can no longer be used.
			 */
			IsDisposed: boolean;

			/** Disposes of this widget, supressing the finalizer */
			dispose(): void;

			/** Gets a string that represents the current object with its ID if specified. */
			ToString(): string;
		}
	}

	export namespace Eto.Forms.ImageTextCell {
		export interface IHandler extends Eto.Widget.IHandler {
			ImageInterpolation: Eto.Drawing.ImageInterpolation;

			TextAlignment: Eto.Forms.TextAlignment;

			VerticalAlignment: Eto.Forms.VerticalAlignment;

			AutoSelectMode: Eto.Forms.AutoSelectMode;
		}
	}

	export namespace Eto.Forms {
		/**
		 * Cell for {@link Eto.Forms.Grid} controls to show a single {@link Eto.Drawing.Image}.
		 */
		export class ImageViewCell implements
			Eto.IHandlerSource {
			/**
			 * Initializes a new instance of the {@link Eto.Forms.ImageViewCell} class when binding
			 * to an indexed-based data item.
			 */
			constructor(column: number);

			/**
			 * Initializes a new instance of the {@link Eto.Forms.ImageViewCell} class when binding
			 * to properties via reflection.
			 */
			constructor(property: string);

			/** Initializes a new instance of the {@link Eto.Forms.ImageViewCell} class. */
			constructor();

			/** Gets or sets the interpolation mode when scaling images to fit into the cell. */
			ImageInterpolation: Eto.Drawing.ImageInterpolation;

			Binding: Eto.Forms.IIndirectBinding$1<Eto.Drawing.Image>;

			/**
			 * Gets the platform that was used to create the {@link Eto.Widget.Handler} for this
			 * widget
			 *
			 * This gets set to the current {@link Eto.Platform.Instance} during the construction of
			 * the object
			 */
			readonly Platform: Eto.Platform;

			/** Gets the platform-specific handler for this widget */
			Handler: unknown;

			/** Gets the native platform-specific handle for integration purposes */
			readonly NativeHandle: unknown;

			/** Gets the dictionary of properties for this widget */
			readonly Properties: Eto.PropertyStore;

			/** Gets or sets the ID of this widget */
			ID: string;

			/**
			 * Gets or sets the style of this widget
			 *
			 * Styles allow you to attach custom platform-specific logic to a widget. In your
			 * platform-specific assembly, use {@link Style.Add{H}(string, StyleHandler{H})} to add
			 * the style logic with the same id.
			 */
			Style: string;

			/**
			 * Gets the instance of the platform-specific object
			 *
			 * This can sometimes be useful to get the platform-specific object. Some handlers may
			 * not have any backing object for its functionality, so this may be null.  It is more
			 * preferred to use the {@link Eto.Widget.Handler} and cast that to the platform-specific
			 * handler class which can give you additional methods and helpers to do common tasks.
			 * For example, the {@link Eto.Forms.Application} object's handler for OS X has a
			 * AddFullScreenMenuItem property to specify if you want full screen support in your app.
			 */
			readonly ControlObject: unknown;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Widget} has been disposed.
			 *
			 * When the widget is disposed, it can no longer be used.
			 */
			IsDisposed: boolean;

			/** Disposes of this widget, supressing the finalizer */
			dispose(): void;

			/** Gets a string that represents the current object with its ID if specified. */
			ToString(): string;
		}
	}

	export namespace Eto.Forms.ImageViewCell {
		export interface IHandler extends Eto.Widget.IHandler {
			ImageInterpolation: Eto.Drawing.ImageInterpolation;
		}
	}

	export namespace Eto.Forms {
		/**
		 * Cell for {@link Eto.Forms.Grid} controls to show and bind a int value to a progress
		 * bar.
		 */
		export class ProgressCell implements
			Eto.IHandlerSource {
			/** Initializes a new instance of the {@link Eto.Forms.ProgressCell} class. */
			constructor(column: number);

			/**
			 * Initializes a new instance of the {@link Eto.Forms.ProgressCell} class with the
			 * specified property to bind to.
			 */
			constructor(
				property: string,
				ignoreCase?: boolean,
			);

			/** Initializes a new instance of the {@link Eto.Forms.ProgressCell} class. */
			constructor();

			Binding: Eto.Forms.IIndirectBinding$1<number | undefined>;

			/**
			 * Gets the platform that was used to create the {@link Eto.Widget.Handler} for this
			 * widget
			 *
			 * This gets set to the current {@link Eto.Platform.Instance} during the construction of
			 * the object
			 */
			readonly Platform: Eto.Platform;

			/** Gets the platform-specific handler for this widget */
			Handler: unknown;

			/** Gets the native platform-specific handle for integration purposes */
			readonly NativeHandle: unknown;

			/** Gets the dictionary of properties for this widget */
			readonly Properties: Eto.PropertyStore;

			/** Gets or sets the ID of this widget */
			ID: string;

			/**
			 * Gets or sets the style of this widget
			 *
			 * Styles allow you to attach custom platform-specific logic to a widget. In your
			 * platform-specific assembly, use {@link Style.Add{H}(string, StyleHandler{H})} to add
			 * the style logic with the same id.
			 */
			Style: string;

			/**
			 * Gets the instance of the platform-specific object
			 *
			 * This can sometimes be useful to get the platform-specific object. Some handlers may
			 * not have any backing object for its functionality, so this may be null.  It is more
			 * preferred to use the {@link Eto.Widget.Handler} and cast that to the platform-specific
			 * handler class which can give you additional methods and helpers to do common tasks.
			 * For example, the {@link Eto.Forms.Application} object's handler for OS X has a
			 * AddFullScreenMenuItem property to specify if you want full screen support in your app.
			 */
			readonly ControlObject: unknown;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Widget} has been disposed.
			 *
			 * When the widget is disposed, it can no longer be used.
			 */
			IsDisposed: boolean;

			/** Disposes of this widget, supressing the finalizer */
			dispose(): void;

			/** Gets a string that represents the current object with its ID if specified. */
			ToString(): string;
		}
	}

	export namespace Eto.Forms.ProgressCell {
		export interface IHandler extends Eto.Widget.IHandler {
		}
	}

	export namespace Eto.Forms {
		/**
		 * Base type for a {@link Eto.Forms.PropertyCell} to display cell contents for a
		 * particular type.
		 */
		export class PropertyCellType {
			/**
			 * Gets the identifier of this type.
			 *
			 * This is used to cache the cell content so it can be reused for performance reasons.
			 * You must ensure that all your cell types have unique identifiers, otherwise the
			 * incorrect content control will be used in the grid.
			 */
			readonly Identifier: string;

			/** Determines whether this instance can be used to display the specified `itemType`. */
			CanDisplay(itemType: unknown): boolean;

			/**
			 * Creates the content control for the cell.
			 *
			 * The control returned may be reused for other cells, so it is ideal to use MVVM data
			 * binding using BindDataContext()  methods of your controls. This should return the same
			 * control for each row, otherwise the incorrect control may be shown on certain cells.
			 */
			OnCreate(args: Eto.Forms.CellEventArgs): Eto.Forms.Control;

			/**
			 * Configures the content control for the given cell information.
			 *
			 * When the DataContext changes on a cell, this will be called to configure the cell.
			 * You are only required to override this when you are not using MVVM data binding with
			 * your controls created by
			 * {@link Eto.Forms.PropertyCellType.OnCreate(Eto.Forms.CellEventArgs)}.
			 */
			OnConfigure(
				args: Eto.Forms.CellEventArgs,
				control: Eto.Forms.Control,
			): void;

			/**
			 * Paints the cell when {@link Eto.Forms.CustomCell.SupportsControlView} is false.
			 *
			 * For platforms like GTK and WinForms which don't support using a custom control per
			 * cell, this will be called to paint the content of the cell when it is not in edit
			 * mode.
			 */
			OnPaint(args: Eto.Forms.CellPaintEventArgs): void;
		}
	}

	export namespace Eto.Forms {
		/**
		 * [Generic type factory] Base property cell type for a given type
		 *
		 * This is useful when displaying a cell with data of a particular type.  It will be used
		 * for any row that returns a type with {@link Eto.Forms.PropertyCell.TypeBinding} that
		 * is compatible with the specified  type.
		 */
		export function PropertyCellType$(T: IType): typeof PropertyCellType$1<any>;

		/**
		 * Base property cell type for a given type
		 *
		 * This is useful when displaying a cell with data of a particular type.  It will be used
		 * for any row that returns a type with {@link Eto.Forms.PropertyCell.TypeBinding} that
		 * is compatible with the specified  type.
		 */
		export class PropertyCellType$1<T> {
			/**
			 * Gets the identifier of this type.
			 *
			 * This is used to cache the cell content so it can be reused for performance reasons.
			 * You must ensure that all your cell types have unique identifiers, otherwise the
			 * incorrect content control will be used in the grid.
			 */
			readonly Identifier: string;

			/** Gets or sets the item binding to get/set the value of the cell from the model. */
			ItemBinding: Eto.Forms.IndirectBinding$1<T>;

			/** Determines whether this instance can display the specified itemType. */
			CanDisplay(itemType: unknown): boolean;

			/**
			 * Creates the content control for the cell.
			 *
			 * The control returned may be reused for other cells, so it is ideal to use MVVM data
			 * binding using BindDataContext()  methods of your controls. This should return the same
			 * control for each row, otherwise the incorrect control may be shown on certain cells.
			 */
			OnCreate(args: Eto.Forms.CellEventArgs): Eto.Forms.Control;

			/**
			 * Configures the content control for the given cell information.
			 *
			 * When the DataContext changes on a cell, this will be called to configure the cell.
			 * You are only required to override this when you are not using MVVM data binding with
			 * your controls created by
			 * {@link Eto.Forms.PropertyCellType.OnCreate(Eto.Forms.CellEventArgs)}.
			 */
			OnConfigure(
				args: Eto.Forms.CellEventArgs,
				control: Eto.Forms.Control,
			): void;

			/**
			 * Paints the cell when {@link Eto.Forms.CustomCell.SupportsControlView} is false.
			 *
			 * For platforms like GTK and WinForms which don't support using a custom control per
			 * cell, this will be called to paint the content of the cell when it is not in edit
			 * mode.
			 */
			OnPaint(args: Eto.Forms.CellPaintEventArgs): void;
		}
	}

	export namespace Eto.Forms {
		/**
		 * Property cell type to edit boolean values using a check box and a True/False label.
		 */
		export class PropertyCellTypeBoolean {
			constructor();

			/**
			 * Gets or sets a binding to indicate that the check box should allow three state (null).
			 */
			ItemThreeStateBinding: Eto.Forms.IndirectBinding$1<boolean>;

			readonly Identifier: string;

			ItemBinding: Eto.Forms.IndirectBinding$1<boolean | undefined>;

			/**
			 * Creates the content control for the cell.
			 *
			 * The control returned may be reused for other cells, so it is ideal to use MVVM data
			 * binding using BindDataContext()  methods of your controls. This should return the same
			 * control for each row, otherwise the incorrect control may be shown on certain cells.
			 */
			OnCreate(args: Eto.Forms.CellEventArgs): Eto.Forms.Control;

			/**
			 * Paints the cell when {@link Eto.Forms.CustomCell.SupportsControlView} is false.
			 *
			 * For platforms like GTK and WinForms which don't support using a custom control per
			 * cell, this will be called to paint the content of the cell when it is not in edit
			 * mode.
			 */
			OnPaint(args: Eto.Forms.CellPaintEventArgs): void;

			CanDisplay(itemType: unknown): boolean;

			/**
			 * Configures the content control for the given cell information.
			 *
			 * When the DataContext changes on a cell, this will be called to configure the cell.
			 * You are only required to override this when you are not using MVVM data binding with
			 * your controls created by
			 * {@link Eto.Forms.PropertyCellType.OnCreate(Eto.Forms.CellEventArgs)}.
			 */
			OnConfigure(
				args: Eto.Forms.CellEventArgs,
				control: Eto.Forms.Control,
			): void;
		}
	}

	export namespace Eto.Forms {
		/** Property cell type to edit string values. */
		export class PropertyCellTypeString {
			constructor();

			readonly Identifier: string;

			ItemBinding: Eto.Forms.IndirectBinding$1<string>;

			/**
			 * Creates the content control for the cell.
			 *
			 * The control returned may be reused for other cells, so it is ideal to use MVVM data
			 * binding using BindDataContext()  methods of your controls. This should return the same
			 * control for each row, otherwise the incorrect control may be shown on certain cells.
			 */
			OnCreate(args: Eto.Forms.CellEventArgs): Eto.Forms.Control;

			/**
			 * Paints the cell when {@link Eto.Forms.CustomCell.SupportsControlView} is false.
			 *
			 * For platforms like GTK and WinForms which don't support using a custom control per
			 * cell, this will be called to paint the content of the cell when it is not in edit
			 * mode.
			 */
			OnPaint(args: Eto.Forms.CellPaintEventArgs): void;

			CanDisplay(itemType: unknown): boolean;

			/**
			 * Configures the content control for the given cell information.
			 *
			 * When the DataContext changes on a cell, this will be called to configure the cell.
			 * You are only required to override this when you are not using MVVM data binding with
			 * your controls created by
			 * {@link Eto.Forms.PropertyCellType.OnCreate(Eto.Forms.CellEventArgs)}.
			 */
			OnConfigure(
				args: Eto.Forms.CellEventArgs,
				control: Eto.Forms.Control,
			): void;
		}
	}

	export namespace Eto.Forms {
		/** [Generic type factory] Property cell type to edit int values. */
		export function PropertyCellTypeNumber$(T: IType): typeof PropertyCellTypeNumber$1<any>;

		/** Property cell type to edit int values. */
		export class PropertyCellTypeNumber$1<T> {
			new(): PropertyCellTypeNumber$1<T>;

			readonly Identifier: string;

			ItemBinding: Eto.Forms.IndirectBinding$1<T>;

			/**
			 * Creates the content control for the cell.
			 *
			 * The control returned may be reused for other cells, so it is ideal to use MVVM data
			 * binding using BindDataContext()  methods of your controls. This should return the same
			 * control for each row, otherwise the incorrect control may be shown on certain cells.
			 */
			OnCreate(args: Eto.Forms.CellEventArgs): Eto.Forms.Control;

			/**
			 * Paints the cell when {@link Eto.Forms.CustomCell.SupportsControlView} is false.
			 *
			 * For platforms like GTK and WinForms which don't support using a custom control per
			 * cell, this will be called to paint the content of the cell when it is not in edit
			 * mode.
			 */
			OnPaint(args: Eto.Forms.CellPaintEventArgs): void;

			CanDisplay(itemType: unknown): boolean;

			/**
			 * Configures the content control for the given cell information.
			 *
			 * When the DataContext changes on a cell, this will be called to configure the cell.
			 * You are only required to override this when you are not using MVVM data binding with
			 * your controls created by
			 * {@link Eto.Forms.PropertyCellType.OnCreate(Eto.Forms.CellEventArgs)}.
			 */
			OnConfigure(
				args: Eto.Forms.CellEventArgs,
				control: Eto.Forms.Control,
			): void;
		}
	}

	export namespace Eto.Forms {
		/**
		 * Property cell type to edit a color value with a color picker and optional hex masked
		 * value.
		 */
		export class PropertyCellTypeColor {
			/** Initializes a new instance of the {@link Eto.Forms.PropertyCellTypeColor} class. */
			constructor();

			/** Gets or sets a value indicating whether to show the hex value */
			ShowHex: boolean;

			/** Gets or sets a value indicating whether to show the alpha component of the color. */
			ShowAlpha: boolean;

			/** Gets or sets a value indicating the hex value is editable by the user. */
			HexEditable: boolean;

			readonly Identifier: string;

			ItemBinding: Eto.Forms.IndirectBinding$1<Eto.Drawing.Color>;

			/**
			 * Creates the content control for the cell.
			 *
			 * The control returned may be reused for other cells, so it is ideal to use MVVM data
			 * binding using BindDataContext()  methods of your controls. This should return the same
			 * control for each row, otherwise the incorrect control may be shown on certain cells.
			 */
			OnCreate(args: Eto.Forms.CellEventArgs): Eto.Forms.Control;

			/**
			 * Paints the cell when {@link Eto.Forms.CustomCell.SupportsControlView} is false.
			 *
			 * For platforms like GTK and WinForms which don't support using a custom control per
			 * cell, this will be called to paint the content of the cell when it is not in edit
			 * mode.
			 */
			OnPaint(args: Eto.Forms.CellPaintEventArgs): void;

			CanDisplay(itemType: unknown): boolean;

			/**
			 * Configures the content control for the given cell information.
			 *
			 * When the DataContext changes on a cell, this will be called to configure the cell.
			 * You are only required to override this when you are not using MVVM data binding with
			 * your controls created by
			 * {@link Eto.Forms.PropertyCellType.OnCreate(Eto.Forms.CellEventArgs)}.
			 */
			OnConfigure(
				args: Eto.Forms.CellEventArgs,
				control: Eto.Forms.Control,
			): void;
		}
	}

	export namespace Eto.Forms {
		/** Property cell type to edit a cell value using a date/time picker. */
		export class PropertyCellTypeDateTime {
			/**
			 * Initializes a new instance of the {@link Eto.Forms.PropertyCellTypeDateTime} class.
			 */
			constructor();

			/** Gets or sets the mode to use for the picker. */
			Mode: Eto.Forms.DateTimePickerMode;

			readonly Identifier: string;

			ItemBinding: Eto.Forms.IndirectBinding$1<DateTime | undefined>;

			/**
			 * Creates the content control for the cell.
			 *
			 * The control returned may be reused for other cells, so it is ideal to use MVVM data
			 * binding using BindDataContext()  methods of your controls. This should return the same
			 * control for each row, otherwise the incorrect control may be shown on certain cells.
			 */
			OnCreate(args: Eto.Forms.CellEventArgs): Eto.Forms.Control;

			/**
			 * Paints the cell when {@link Eto.Forms.CustomCell.SupportsControlView} is false.
			 *
			 * For platforms like GTK and WinForms which don't support using a custom control per
			 * cell, this will be called to paint the content of the cell when it is not in edit
			 * mode.
			 */
			OnPaint(args: Eto.Forms.CellPaintEventArgs): void;

			CanDisplay(itemType: unknown): boolean;

			/**
			 * Configures the content control for the given cell information.
			 *
			 * When the DataContext changes on a cell, this will be called to configure the cell.
			 * You are only required to override this when you are not using MVVM data binding with
			 * your controls created by
			 * {@link Eto.Forms.PropertyCellType.OnCreate(Eto.Forms.CellEventArgs)}.
			 */
			OnConfigure(
				args: Eto.Forms.CellEventArgs,
				control: Eto.Forms.Control,
			): void;
		}
	}

	export namespace Eto.Forms {
		/**
		 * [Generic type factory] Property cell type to edit an enum value using an
		 * {@link Eto.Forms.EnumDropDown<>}.
		 */
		export function PropertyCellTypeEnum$(T: IType): typeof PropertyCellTypeEnum$1<any>;

		/**
		 * Property cell type to edit an enum value using an {@link Eto.Forms.EnumDropDown<>}.
		 */
		export class PropertyCellTypeEnum$1<T> {
			new(): PropertyCellTypeEnum$1<T>;

			readonly Identifier: string;

			ItemBinding: Eto.Forms.IndirectBinding$1<T>;

			/**
			 * Creates the content control for the cell.
			 *
			 * The control returned may be reused for other cells, so it is ideal to use MVVM data
			 * binding using BindDataContext()  methods of your controls. This should return the same
			 * control for each row, otherwise the incorrect control may be shown on certain cells.
			 */
			OnCreate(args: Eto.Forms.CellEventArgs): Eto.Forms.Control;

			/**
			 * Paints the cell when {@link Eto.Forms.CustomCell.SupportsControlView} is false.
			 *
			 * For platforms like GTK and WinForms which don't support using a custom control per
			 * cell, this will be called to paint the content of the cell when it is not in edit
			 * mode.
			 */
			OnPaint(args: Eto.Forms.CellPaintEventArgs): void;

			CanDisplay(itemType: unknown): boolean;

			/**
			 * Configures the content control for the given cell information.
			 *
			 * When the DataContext changes on a cell, this will be called to configure the cell.
			 * You are only required to override this when you are not using MVVM data binding with
			 * your controls created by
			 * {@link Eto.Forms.PropertyCellType.OnCreate(Eto.Forms.CellEventArgs)}.
			 */
			OnConfigure(
				args: Eto.Forms.CellEventArgs,
				control: Eto.Forms.Control,
			): void;
		}
	}

	export namespace Eto.Forms {
		/** Property cell type to edit any type of number */
		export class PropertyCellTypeNumber {
			constructor();

			/** Gets the identifier for this cell type */
			readonly Identifier: string;

			/**
			 * Gets or sets the item binding to get/set the type of the numeric value
			 *
			 * Use this to specify what numeric type should be used to create the
			 * NumericMaskedTextBox. Otherwise, the type of the current value will be used.  This is
			 * only needed when the value can be null.
			 */
			ItemTypeBinding: Eto.Forms.IndirectBinding$1<unknown>;

			ItemBinding: Eto.Forms.IndirectBinding$1<unknown>;

			/** Determines whether this instance can display the specified itemType. */
			CanDisplay(itemType: unknown): boolean;

			/**
			 * Creates the content control for the cell.
			 *
			 * The control returned may be reused for other cells, so it is ideal to use MVVM data
			 * binding using BindDataContext()  methods of your controls. This should return the same
			 * control for each row, otherwise the incorrect control may be shown on certain cells.
			 */
			OnCreate(args: Eto.Forms.CellEventArgs): Eto.Forms.Control;

			/**
			 * Configures the content control for the given cell information.
			 *
			 * When the DataContext changes on a cell, this will be called to configure the cell.
			 * You are only required to override this when you are not using MVVM data binding with
			 * your controls created by
			 * {@link Eto.Forms.PropertyCellTypeNumber.OnCreate(Eto.Forms.CellEventArgs)}.
			 */
			OnConfigure(
				args: Eto.Forms.CellEventArgs,
				control: Eto.Forms.Control,
			): void;

			/**
			 * Paints the cell when {@link Eto.Forms.CustomCell.SupportsControlView} is false.
			 *
			 * For platforms like GTK and WinForms which don't support using a custom control per
			 * cell, this will be called to paint the content of the cell when it is not in edit
			 * mode.
			 */
			OnPaint(args: Eto.Forms.CellPaintEventArgs): void;
		}
	}

	export namespace Eto.Forms {
		/** Property cell type to display any type of enumeration */
		export class PropertyCellTypeEnum {
			constructor();

			/** Gets the identifier for this cell type */
			readonly Identifier: string;

			/**
			 * Gets or sets the item binding to get/set the type of the numeric value
			 *
			 * Use this to specify what enum type should be used to create the EnumDropDown.
			 * Otherwise, the type of the current value will be used.  This is only needed when the
			 * value can be null.
			 */
			ItemTypeBinding: Eto.Forms.IndirectBinding$1<unknown>;

			ItemBinding: Eto.Forms.IndirectBinding$1<unknown>;

			/** Determines whether this instance can display the specified itemType. */
			CanDisplay(itemType: unknown): boolean;

			/**
			 * Creates the content control for the cell.
			 *
			 * The control returned may be reused for other cells, so it is ideal to use MVVM data
			 * binding using BindDataContext()  methods of your controls. This should return the same
			 * control for each row, otherwise the incorrect control may be shown on certain cells.
			 */
			OnCreate(args: Eto.Forms.CellEventArgs): Eto.Forms.Control;

			/**
			 * Configures the content control for the given cell information.
			 *
			 * When the DataContext changes on a cell, this will be called to configure the cell.
			 * You are only required to override this when you are not using MVVM data binding with
			 * your controls created by
			 * {@link Eto.Forms.PropertyCellTypeEnum.OnCreate(Eto.Forms.CellEventArgs)}.
			 */
			OnConfigure(
				args: Eto.Forms.CellEventArgs,
				control: Eto.Forms.Control,
			): void;

			/**
			 * Paints the cell when {@link Eto.Forms.CustomCell.SupportsControlView} is false.
			 *
			 * For platforms like GTK and WinForms which don't support using a custom control per
			 * cell, this will be called to paint the content of the cell when it is not in edit
			 * mode.
			 */
			OnPaint(args: Eto.Forms.CellPaintEventArgs): void;
		}
	}

	export namespace Eto.Forms {
		/** Property cell type drop down. */
		export class PropertyCellTypeDropDown {
			constructor();

			/**
			 * Gets or sets the binding to get the items for the drop down.
			 *
			 * If all rows have the same items, you can use a delegate binding to return a single
			 * instance of an items enumeration.
			 */
			ItemsBinding: Eto.Forms.IndirectBinding$1<Iterable<unknown>>;

			/** Gets or sets the binding to get the text value for the drop down. */
			ItemTextBinding: Eto.Forms.IndirectBinding$1<string>;

			/** Gets or sets the binding to get the key value for the drop down. */
			ItemKeyBinding: Eto.Forms.IndirectBinding$1<string>;

			readonly Identifier: string;

			ItemBinding: Eto.Forms.IndirectBinding$1<unknown>;

			/**
			 * Creates the content control for the cell.
			 *
			 * The control returned may be reused for other cells, so it is ideal to use MVVM data
			 * binding using BindDataContext()  methods of your controls. This should return the same
			 * control for each row, otherwise the incorrect control may be shown on certain cells.
			 */
			OnCreate(args: Eto.Forms.CellEventArgs): Eto.Forms.Control;

			/**
			 * Paints the cell when {@link Eto.Forms.CustomCell.SupportsControlView} is false.
			 *
			 * For platforms like GTK and WinForms which don't support using a custom control per
			 * cell, this will be called to paint the content of the cell when it is not in edit
			 * mode.
			 */
			OnPaint(args: Eto.Forms.CellPaintEventArgs): void;

			CanDisplay(itemType: unknown): boolean;

			/**
			 * Configures the content control for the given cell information.
			 *
			 * When the DataContext changes on a cell, this will be called to configure the cell.
			 * You are only required to override this when you are not using MVVM data binding with
			 * your controls created by
			 * {@link Eto.Forms.PropertyCellType.OnCreate(Eto.Forms.CellEventArgs)}.
			 */
			OnConfigure(
				args: Eto.Forms.CellEventArgs,
				control: Eto.Forms.Control,
			): void;
		}
	}

	export namespace Eto.Forms {
		/**
		 * A custom cell implementation that implements a generic method of showing different
		 * types of controls on a per row basis.
		 *
		 * This is ideal for things like showing a property grid to edit various properties of an
		 * object.  The way this works is by using the {@link Eto.Forms.PropertyCell.TypeBinding}
		 * of each row to determine which {@link Eto.Forms.PropertyCellType} to use from the
		 * {@link Eto.Forms.PropertyCell.Types} collection.  It calls
		 * {@link Eto.Forms.PropertyCellType.CanDisplay(System.Object)} on each to find a type
		 * that can display based on the value returned.  Each {@link Eto.Forms.PropertyCellType}
		 * added to the cell must have a unique value for
		 * {@link Eto.Forms.PropertyCellType.Identifier} to ensure the correct control is shown
		 * in the cell.  The identifier is used to cache the content controls generated by the
		 * PropertyCellType when displaying the same value for other rows while scrolling.
		 * Ideally, the content control generated from the {@link Eto.Forms.PropertyCellType}
		 * should use MVVM BindDataContext() methods for its children so that they are updated
		 * automatically when reused for different controls.  This is not a requirement, however
		 * you must then implement/override the
		 * {@link Eto.Forms.PropertyCellType.OnConfigure(Eto.Forms.CellEventArgs,Eto.Forms.Control)}
		 * to update your control when the item/row is changed.
		 */
		export class PropertyCell implements
			Eto.IHandlerSource {
			/** Initializes a new instance of the property cell */
			constructor();

			/** Gets or sets the binding to get the type for the */
			TypeBinding: Eto.Forms.IIndirectBinding$1<unknown>;

			/**
			 * Gets the list of types to use for each cell, in order of preference.
			 *
			 * When attempting to use a type for a cell, the types collection is scanned in order for
			 * the first PropertyCellType that returns true for
			 * {@link Eto.Forms.PropertyCellType.CanDisplay(System.Object)}.
			 */
			readonly Types: Eto.Forms.PropertyCellType[];

			/**
			 * Gets or sets a delegate to create the contents of the cell.
			 *
			 * You can also override the
			 * {@link Eto.Forms.CustomCell.OnCreateCell(Eto.Forms.CellEventArgs)} method in
			 * subclasses. Note that you need to handle {@link Eto.Forms.CustomCell.ConfigureCell} to
			 * set up the cell for a particular row of data as the control may be reused when
			 * scrolling the view.
			 */
			CreateCell: (arg1: Eto.Forms.CellEventArgs) => Eto.Forms.Control;

			/**
			 * Gets or sets a delegate to get the identifier of the cell based on its content.
			 *
			 * When you have different controls on a per-row level, each variation must have an
			 * identifier string to allow the framework to cache the different types of cells to
			 * provide good performance.  This hooks into standard cell caching mechanisms in certain
			 * platforms, such as on the Mac.
			 */
			GetIdentifier: (arg1: Eto.Forms.CellEventArgs) => string;

			/**
			 * Gets or sets a delegate to get the preferred width of the cell based on its content.
			 *
			 * This may only be used when {@link Eto.Forms.CustomCell.SupportsControlView} is false.
			 */
			GetPreferredWidth: (arg1: Eto.Forms.CellEventArgs) => number;

			/**
			 * Gets or sets a delegate to configure an cell when it is reused for a different row or
			 * the data changes.
			 *
			 * This should set up your control your cell content to be reused.  If null, the
			 * DataContext of your control will be set to the row model instance.  Typically if you
			 * use MVVM data binding, you do not need to override the standard behaviour.
			 */
			ConfigureCell: (arg1: Eto.Forms.CellEventArgs, arg2: Eto.Forms.Control) => void;

			/**
			 * Gets the platform that was used to create the {@link Eto.Widget.Handler} for this
			 * widget
			 *
			 * This gets set to the current {@link Eto.Platform.Instance} during the construction of
			 * the object
			 */
			readonly Platform: Eto.Platform;

			/** Gets the platform-specific handler for this widget */
			Handler: unknown;

			/** Gets the native platform-specific handle for integration purposes */
			readonly NativeHandle: unknown;

			/** Gets the dictionary of properties for this widget */
			readonly Properties: Eto.PropertyStore;

			/** Gets or sets the ID of this widget */
			ID: string;

			/**
			 * Gets or sets the style of this widget
			 *
			 * Styles allow you to attach custom platform-specific logic to a widget. In your
			 * platform-specific assembly, use {@link Style.Add{H}(string, StyleHandler{H})} to add
			 * the style logic with the same id.
			 */
			Style: string;

			/**
			 * Gets the instance of the platform-specific object
			 *
			 * This can sometimes be useful to get the platform-specific object. Some handlers may
			 * not have any backing object for its functionality, so this may be null.  It is more
			 * preferred to use the {@link Eto.Widget.Handler} and cast that to the platform-specific
			 * handler class which can give you additional methods and helpers to do common tasks.
			 * For example, the {@link Eto.Forms.Application} object's handler for OS X has a
			 * AddFullScreenMenuItem property to specify if you want full screen support in your app.
			 */
			readonly ControlObject: unknown;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Widget} has been disposed.
			 *
			 * When the widget is disposed, it can no longer be used.
			 */
			IsDisposed: boolean;

			/** Disposes of this widget, supressing the finalizer */
			dispose(): void;

			/** Gets a string that represents the current object with its ID if specified. */
			ToString(): string;
		}
	}

	export namespace Eto.Forms {
		/** [Generic type factory] Base class for cells that bind to a single value. */
		export function SingleValueCell$(T: IType): typeof SingleValueCell$1<any>;

		/** Base class for cells that bind to a single value. */
		export class SingleValueCell$1<T> implements
			Eto.IHandlerSource {
			/** Gets or sets the binding to get/set the value of the cell. */
			Binding: Eto.Forms.IIndirectBinding$1<T>;

			/**
			 * Gets the platform that was used to create the {@link Eto.Widget.Handler} for this
			 * widget
			 *
			 * This gets set to the current {@link Eto.Platform.Instance} during the construction of
			 * the object
			 */
			readonly Platform: Eto.Platform;

			/** Gets the platform-specific handler for this widget */
			Handler: unknown;

			/** Gets the native platform-specific handle for integration purposes */
			readonly NativeHandle: unknown;

			/** Gets the dictionary of properties for this widget */
			readonly Properties: Eto.PropertyStore;

			/** Gets or sets the ID of this widget */
			ID: string;

			/**
			 * Gets or sets the style of this widget
			 *
			 * Styles allow you to attach custom platform-specific logic to a widget. In your
			 * platform-specific assembly, use {@link Style.Add{H}(string, StyleHandler{H})} to add
			 * the style logic with the same id.
			 */
			Style: string;

			/**
			 * Gets the instance of the platform-specific object
			 *
			 * This can sometimes be useful to get the platform-specific object. Some handlers may
			 * not have any backing object for its functionality, so this may be null.  It is more
			 * preferred to use the {@link Eto.Widget.Handler} and cast that to the platform-specific
			 * handler class which can give you additional methods and helpers to do common tasks.
			 * For example, the {@link Eto.Forms.Application} object's handler for OS X has a
			 * AddFullScreenMenuItem property to specify if you want full screen support in your app.
			 */
			readonly ControlObject: unknown;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Widget} has been disposed.
			 *
			 * When the widget is disposed, it can no longer be used.
			 */
			IsDisposed: boolean;

			/** Disposes of this widget, supressing the finalizer */
			dispose(): void;

			/** Gets a string that represents the current object with its ID if specified. */
			ToString(): string;
		}
	}

	export namespace Eto.Forms {
		/** Cell for a text box in a {@link Eto.Forms.Grid}. */
		export class TextBoxCell implements
			Eto.IHandlerSource {
			/**
			 * Initializes a new instance of the {@link Eto.Forms.TextBoxCell} class binding to the
			 * specified `column`.
			 */
			constructor(column: number);

			/**
			 * Initializes a new instance of the {@link Eto.Forms.TextBoxCell} class binding the text
			 * value to the specified `property` of the data store.
			 */
			constructor(property: string);

			/** Initializes a new instance of the {@link Eto.Forms.TextBoxCell} class. */
			constructor();

			/** Gets or sets the horizontal alignment of the text within the cell. */
			TextAlignment: Eto.Forms.TextAlignment;

			/** Gets or sets the vertical alignment of the text within the cell. */
			VerticalAlignment: Eto.Forms.VerticalAlignment;

			/** Gets or sets the auto selection mode. */
			AutoSelectMode: Eto.Forms.AutoSelectMode;

			Binding: Eto.Forms.IIndirectBinding$1<string>;

			/**
			 * Gets the platform that was used to create the {@link Eto.Widget.Handler} for this
			 * widget
			 *
			 * This gets set to the current {@link Eto.Platform.Instance} during the construction of
			 * the object
			 */
			readonly Platform: Eto.Platform;

			/** Gets the platform-specific handler for this widget */
			Handler: unknown;

			/** Gets the native platform-specific handle for integration purposes */
			readonly NativeHandle: unknown;

			/** Gets the dictionary of properties for this widget */
			readonly Properties: Eto.PropertyStore;

			/** Gets or sets the ID of this widget */
			ID: string;

			/**
			 * Gets or sets the style of this widget
			 *
			 * Styles allow you to attach custom platform-specific logic to a widget. In your
			 * platform-specific assembly, use {@link Style.Add{H}(string, StyleHandler{H})} to add
			 * the style logic with the same id.
			 */
			Style: string;

			/**
			 * Gets the instance of the platform-specific object
			 *
			 * This can sometimes be useful to get the platform-specific object. Some handlers may
			 * not have any backing object for its functionality, so this may be null.  It is more
			 * preferred to use the {@link Eto.Widget.Handler} and cast that to the platform-specific
			 * handler class which can give you additional methods and helpers to do common tasks.
			 * For example, the {@link Eto.Forms.Application} object's handler for OS X has a
			 * AddFullScreenMenuItem property to specify if you want full screen support in your app.
			 */
			readonly ControlObject: unknown;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Widget} has been disposed.
			 *
			 * When the widget is disposed, it can no longer be used.
			 */
			IsDisposed: boolean;

			/** Disposes of this widget, supressing the finalizer */
			dispose(): void;

			/** Gets a string that represents the current object with its ID if specified. */
			ToString(): string;
		}
	}

	export namespace Eto.Forms.TextBoxCell {
		export interface IHandler extends Eto.Widget.IHandler {
			TextAlignment: Eto.Forms.TextAlignment;

			VerticalAlignment: Eto.Forms.VerticalAlignment;

			AutoSelectMode: Eto.Forms.AutoSelectMode;
		}
	}

	export namespace Eto.Forms {
		/**
		 * Object to handle the system clipboard. Use {@link Eto.Forms.Clipboard.Instance} to
		 * avoid creating multiple copies of this object.
		 */
		export class Clipboard implements
			Eto.IHandlerSource,
			Eto.Forms.IDataObject {
			constructor();

			/** Gets the shared clipboard instance */
			static readonly Instance: Eto.Forms.Clipboard;

			/** Gets the type id's for each type of data in the clipboard. */
			readonly Types: string[];

			/**
			 * Gets a value indicating whether this {@link Eto.Forms.Clipboard} contains a value for
			 * {@link Eto.Forms.Clipboard.Text}.
			 */
			readonly ContainsText: boolean;

			/**
			 * Gets a value indicating whether this {@link Eto.Forms.Clipboard} contains a value for
			 * {@link Eto.Forms.Clipboard.Html}.
			 */
			readonly ContainsHtml: boolean;

			/**
			 * Gets a value indicating whether this {@link Eto.Forms.Clipboard} contains a value for
			 * {@link Eto.Forms.Clipboard.Image}.
			 */
			readonly ContainsImage: boolean;

			/**
			 * Gets a value indicating whether this {@link Eto.Forms.Clipboard} contains a value for
			 * {@link Eto.Forms.Clipboard.Uris}.
			 *
			 * This can be a mix of both URL and File objects.  You can use {@link System.Uri.IsFile}
			 * to test for that. On some platforms, (e.g. windows), only a single URL can be
			 * retrieved or set.
			 */
			readonly ContainsUris: boolean;

			/** Gets or sets the plain text in the clipboard. */
			Text: string;

			/** Gets or sets html text in the clipboard. */
			Html: string;

			/** Gets or sets an image in the clipboard. */
			Image: Eto.Drawing.Image;

			/** Gets or sets the Uri's of the files in the clipboard. */
			Uris: unknown[];

			/**
			 * Gets the platform that was used to create the {@link Eto.Widget.Handler} for this
			 * widget
			 *
			 * This gets set to the current {@link Eto.Platform.Instance} during the construction of
			 * the object
			 */
			readonly Platform: Eto.Platform;

			/** Gets the platform-specific handler for this widget */
			Handler: unknown;

			/** Gets the native platform-specific handle for integration purposes */
			readonly NativeHandle: unknown;

			/** Gets the dictionary of properties for this widget */
			readonly Properties: Eto.PropertyStore;

			/** Gets or sets the ID of this widget */
			ID: string;

			/**
			 * Gets or sets the style of this widget
			 *
			 * Styles allow you to attach custom platform-specific logic to a widget. In your
			 * platform-specific assembly, use {@link Style.Add{H}(string, StyleHandler{H})} to add
			 * the style logic with the same id.
			 */
			Style: string;

			/**
			 * Gets the instance of the platform-specific object
			 *
			 * This can sometimes be useful to get the platform-specific object. Some handlers may
			 * not have any backing object for its functionality, so this may be null.  It is more
			 * preferred to use the {@link Eto.Widget.Handler} and cast that to the platform-specific
			 * handler class which can give you additional methods and helpers to do common tasks.
			 * For example, the {@link Eto.Forms.Application} object's handler for OS X has a
			 * AddFullScreenMenuItem property to specify if you want full screen support in your app.
			 */
			readonly ControlObject: unknown;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Widget} has been disposed.
			 *
			 * When the widget is disposed, it can no longer be used.
			 */
			IsDisposed: boolean;

			/** Sets a data stream into the clipboard with the specified type identifier. */
			SetDataStream(
				stream: Duplex,
				type: string,
			): void;

			/** sets a data array into the clipboard with the specified type identifier. */
			SetData(
				value: number[],
				type: string,
			): void;

			/**
			 * Gets a value indicating that data with the specified type is contained in the
			 * clipboard.
			 */
			Contains(type: string): boolean;

			/** Gets a data array from the clipboard with the specified type identifier. */
			GetData(type: string): number[];

			/** Gets the data stream with the specified type identifier. */
			GetDataStream(type: string): Duplex;

			/**
			 * Sets a string into the clipboard with the specified type identifier.
			 *
			 * This is useful when setting alternate string values into the clipboard that are not
			 * plain text. If you are storing plain text, use the {@link Eto.Forms.Clipboard.Text}
			 * property instead.
			 */
			SetString(
				value: string,
				type: string,
			): void;

			/** Gets a string from the clipboard with the specified type identifier. */
			GetString(type: string): string;

			/** Clears the clipboard completely of all values */
			Clear(): void;

			/**
			 * Sets the `value` into the data object with the specified `type` using serialization or
			 * type converter
			 *
			 * The object specified must be serializable or have a type converter to convert to a
			 * string.
			 */
			SetObject(
				value: unknown,
				type: string,
			): void;

			/**
			 * Gets an object from the data object with the specified type
			 *
			 * This is useful when you know the type of object, and it is serializable or has a type
			 * converter to convert from string. If it cannot be converted it will return the default
			 * value.
			 */
			GetObject<T>(type: string): T;

			/** Gets a serialized value with the specified `type` identifier. */
			GetObject(type: string): unknown;

			/**
			 * Gets an object from the data object with the specified type
			 *
			 * This is useful when you know the type of object, and it is serializable or has a type
			 * converter to convert from string. If it cannot be converted it will return the default
			 * value.
			 */
			GetObject(
				type: string,
				objectType: unknown,
			): unknown;

			/** Disposes of this widget, supressing the finalizer */
			dispose(): void;

			/** Gets a string that represents the current object with its ID if specified. */
			ToString(): string;
		}
	}

	export namespace Eto.Forms.Clipboard {
		export interface IHandler extends
			Eto.Widget.IHandler,
			Eto.Forms.IDataObject {
			TrySetObject(
				value: unknown,
				type: string,
			): boolean;

			TryGetObject(
				type: string,
				objectType: unknown,
			): unknown | undefined;
		}
	}

	export namespace Eto.Forms {
		/**
		 * Dialog for choosing a color
		 *
		 * The color dialog on some platforms may run asynchronously, and return immediately
		 * after the {@link Eto.Forms.CommonDialog.ShowDialog(Eto.Forms.Control)} call. For
		 * example, on OS X the color picker is a non-modal shared tool window that stays on the
		 * screen until the user dismisses it.  You should always handle the
		 * {@link Eto.Forms.ColorDialog.ColorChanged} event to determine when the value has
		 * changed.
		 */
		export class ColorDialog implements
			Eto.IHandlerSource {
			constructor();

			/** Gets or sets the selected color. */
			Color: Eto.Drawing.Color;

			/**
			 * Gets or sets a value indicating whether the user can adjust the Alpha component of the
			 * Color.
			 *
			 * This may or may not be supported in all platforms (e.g. WinForms).   Use
			 * {@link Eto.Forms.ColorDialog.SupportsAllowAlpha} to determine if the current platform
			 * supports this feature.
			 */
			AllowAlpha: boolean;

			/**
			 * Gets a value indicating that the current platform supports the
			 * {@link Eto.Forms.ColorDialog.AllowAlpha} property.
			 *
			 * If not supported, the setting will be ignored.
			 */
			readonly SupportsAllowAlpha: boolean;

			/**
			 * Gets the platform that was used to create the {@link Eto.Widget.Handler} for this
			 * widget
			 *
			 * This gets set to the current {@link Eto.Platform.Instance} during the construction of
			 * the object
			 */
			readonly Platform: Eto.Platform;

			/** Gets the platform-specific handler for this widget */
			Handler: unknown;

			/** Gets the native platform-specific handle for integration purposes */
			readonly NativeHandle: unknown;

			/** Gets the dictionary of properties for this widget */
			readonly Properties: Eto.PropertyStore;

			/** Gets or sets the ID of this widget */
			ID: string;

			/**
			 * Gets or sets the style of this widget
			 *
			 * Styles allow you to attach custom platform-specific logic to a widget. In your
			 * platform-specific assembly, use {@link Style.Add{H}(string, StyleHandler{H})} to add
			 * the style logic with the same id.
			 */
			Style: string;

			/**
			 * Gets the instance of the platform-specific object
			 *
			 * This can sometimes be useful to get the platform-specific object. Some handlers may
			 * not have any backing object for its functionality, so this may be null.  It is more
			 * preferred to use the {@link Eto.Widget.Handler} and cast that to the platform-specific
			 * handler class which can give you additional methods and helpers to do common tasks.
			 * For example, the {@link Eto.Forms.Application} object's handler for OS X has a
			 * AddFullScreenMenuItem property to specify if you want full screen support in your app.
			 */
			readonly ControlObject: unknown;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Widget} has been disposed.
			 *
			 * When the widget is disposed, it can no longer be used.
			 */
			IsDisposed: boolean;

			/** Shows the dialog with the specified parent, blocking until a result is returned. */
			ShowDialog(parent: Eto.Forms.Control): Eto.Forms.DialogResult;

			/**
			 * Shows the dialog with the specified parent window, blocking until a result is
			 * returned.
			 */
			ShowDialog(parent: Eto.Forms.Window): Eto.Forms.DialogResult;

			/** Disposes of this widget, supressing the finalizer */
			dispose(): void;

			/** Gets a string that represents the current object with its ID if specified. */
			ToString(): string;
		}
	}

	export namespace Eto.Forms.ColorDialog {
		export interface ICallback {
			OnColorChanged(
				widget: Eto.Forms.ColorDialog,
				e: unknown,
			): void;
		}
	}

	export namespace Eto.Forms.ColorDialog {
		export interface IHandler extends
			Eto.Forms.CommonDialog.IHandler,
			Eto.Widget.IHandler {
			Color: Eto.Drawing.Color;

			AllowAlpha: boolean;

			readonly SupportsAllowAlpha: boolean;
		}
	}

	export namespace Eto.Forms {
		/** Command for a menu/tool item that can be checked on or off. */
		export class CheckCommand implements
			Eto.Forms.IBindable {
			/** Initializes a new instance of the {@link Eto.Forms.CheckCommand} class. */
			constructor();

			/**
			 * Initializes a new instance of the {@link Eto.Forms.CheckCommand} class with the
			 * specified `execute` handler.
			 */
			constructor(execute: unknown);

			/** Gets or sets a value indicating whether this command is checked. */
			Checked: boolean;

			/**
			 * Gets or sets the ID of the command
			 *
			 * This can be used to identify a command.
			 */
			ID: string;

			/** Gets or sets a value indicating whether this {@link Eto.Forms.Command} is enabled. */
			Enabled: boolean;

			/** Gets or sets a user-defined tag value for this instance. */
			Tag: unknown;

			/** Gets or sets the text when shown on the menu. */
			MenuText: string;

			/** Gets or sets the tool bar text. */
			ToolBarText: string;

			/** Gets or sets the tool tip on both the menu and toolbar. */
			ToolTip: string;

			/**
			 * Gets or sets the image for the menu or tool item.
			 *
			 * On some platforms, the menu bar does not show the image by default (e.g. OS X). You
			 * can override this behaviour using a style on the handler.
			 */
			Image: Eto.Drawing.Image;

			/** Gets or sets the shortcut to trigger this command. */
			Shortcut: Eto.Forms.Keys;

			/** Gets the dictionary of properties for this widget */
			readonly Properties: Eto.PropertyStore;

			/**
			 * Gets or sets a command to delegate to when the command is invoked.
			 *
			 * This allows you to use a command to define menu/toolbar items or other functionality,
			 * and use a delegated command to chain to when invoked. This is especially useful when
			 * binding to a view model, you can do something like the following: var myCommand = new
			 * Command { MenuText = "My Command", Parent = myForm }; myCommand.BindDataContext(c
			 * =&gt; c.DelegatedCommand, (MyModel m) =&gt; m.MyModelCommand);  //...
			 * myForm.DataContext = new MyModel { MyModelCommand = ... }; The
			 * {@link System.Windows.Input.ICommand.CanExecute(System.Object)} will also used to set
			 * the enabled/disabled state of the current command.
			 */
			DelegatedCommand: unknown;

			/**
			 * Gets or sets the parameter to pass to the {@link Eto.Forms.Command} when executing or
			 * determining its CanExecute state.
			 */
			CommandParameter: unknown;

			/** Gets the parent widget which this widget has been added to, if any */
			Parent: Eto.Forms.IBindable;

			/**
			 * Gets or sets the data context for this widget for binding
			 *
			 * Subclasses may override the standard behaviour so that hierarchy of widgets can be
			 * taken into account.  For example, a Control may return the data context of a parent,
			 * if it is not set explicitly.
			 */
			DataContext: unknown;

			/**
			 * Gets a value indicating that the {@link Eto.Forms.Command.DataContext} property is
			 * changing.
			 *
			 * This can be used to determine when to allow certain logic during the update of the
			 * data context.  It is used to disable binding setters on the model when the data
			 * context changes so that a binding does not cause the view model to be updated when the
			 * state hasn't been fully set yet.
			 */
			IsDataContextChanging: boolean;

			/** Gets the collection of bindings that are attached to this widget */
			readonly Bindings: Eto.Forms.BindingCollection;

			/** Creates a new menu item attached to this command. */
			CreateMenuItem(): Eto.Forms.MenuItem;

			/** Creates a new tool item attached to this command. */
			CreateToolItem(): Eto.Forms.ToolItem;

			/** Execute the command programatically. */
			Execute(): void;
		}
	}

	export namespace Eto.Forms {
		/**
		 * Command for a radio button for a tool or menu item.
		 *
		 * A radio command works by using a {@link Eto.Forms.RadioCommand.Controller} which
		 * allows you to group the radio buttons together.
		 */
		export class RadioCommand implements
			Eto.Forms.IBindable {
			/** Initializes a new instance of the {@link Eto.Forms.RadioCommand} class. */
			constructor();

			/**
			 * Initializes a new instance of the {@link Eto.Forms.RadioCommand} class with the
			 * specified `execute` handler.
			 */
			constructor(execute: unknown);

			/** Gets or sets the controller of the radio button group. */
			Controller: Eto.Forms.RadioCommand;

			/** Gets or sets a value indicating whether this command is checked. */
			Checked: boolean;

			/**
			 * Gets or sets the ID of the command
			 *
			 * This can be used to identify a command.
			 */
			ID: string;

			/** Gets or sets a value indicating whether this {@link Eto.Forms.Command} is enabled. */
			Enabled: boolean;

			/** Gets or sets a user-defined tag value for this instance. */
			Tag: unknown;

			/** Gets or sets the text when shown on the menu. */
			MenuText: string;

			/** Gets or sets the tool bar text. */
			ToolBarText: string;

			/** Gets or sets the tool tip on both the menu and toolbar. */
			ToolTip: string;

			/**
			 * Gets or sets the image for the menu or tool item.
			 *
			 * On some platforms, the menu bar does not show the image by default (e.g. OS X). You
			 * can override this behaviour using a style on the handler.
			 */
			Image: Eto.Drawing.Image;

			/** Gets or sets the shortcut to trigger this command. */
			Shortcut: Eto.Forms.Keys;

			/** Gets the dictionary of properties for this widget */
			readonly Properties: Eto.PropertyStore;

			/**
			 * Gets or sets a command to delegate to when the command is invoked.
			 *
			 * This allows you to use a command to define menu/toolbar items or other functionality,
			 * and use a delegated command to chain to when invoked. This is especially useful when
			 * binding to a view model, you can do something like the following: var myCommand = new
			 * Command { MenuText = "My Command", Parent = myForm }; myCommand.BindDataContext(c
			 * =&gt; c.DelegatedCommand, (MyModel m) =&gt; m.MyModelCommand);  //...
			 * myForm.DataContext = new MyModel { MyModelCommand = ... }; The
			 * {@link System.Windows.Input.ICommand.CanExecute(System.Object)} will also used to set
			 * the enabled/disabled state of the current command.
			 */
			DelegatedCommand: unknown;

			/**
			 * Gets or sets the parameter to pass to the {@link Eto.Forms.Command} when executing or
			 * determining its CanExecute state.
			 */
			CommandParameter: unknown;

			/** Gets the parent widget which this widget has been added to, if any */
			Parent: Eto.Forms.IBindable;

			/**
			 * Gets or sets the data context for this widget for binding
			 *
			 * Subclasses may override the standard behaviour so that hierarchy of widgets can be
			 * taken into account.  For example, a Control may return the data context of a parent,
			 * if it is not set explicitly.
			 */
			DataContext: unknown;

			/**
			 * Gets a value indicating that the {@link Eto.Forms.Command.DataContext} property is
			 * changing.
			 *
			 * This can be used to determine when to allow certain logic during the update of the
			 * data context.  It is used to disable binding setters on the model when the data
			 * context changes so that a binding does not cause the view model to be updated when the
			 * state hasn't been fully set yet.
			 */
			IsDataContextChanging: boolean;

			/** Gets the collection of bindings that are attached to this widget */
			readonly Bindings: Eto.Forms.BindingCollection;

			/** Creates a new menu item attached to this command. */
			CreateMenuItem(): Eto.Forms.MenuItem;

			/** Creates a new tool item attached to this command. */
			CreateToolItem(): Eto.Forms.ToolItem;

			/** Execute the command programatically. */
			Execute(): void;
		}
	}

	export namespace Eto.Forms {
		/**
		 * Base command for use on either {@link Eto.Forms.ToolBar} or {@link Eto.Forms.MenuBar}
		 *
		 * Commands allow you to create a single class that can be used for both menu and tool
		 * items.
		 */
		export class Command implements Eto.Forms.IBindable {
			/** Initializes a new instance of the {@link Eto.Forms.Command} class. */
			constructor();

			/**
			 * Initializes a new instance of the {@link Eto.Forms.Command} class with the specified
			 * `execute` handler.
			 */
			constructor(execute: unknown);

			/**
			 * Gets or sets the ID of the command
			 *
			 * This can be used to identify a command.
			 */
			ID: string;

			/** Gets or sets a value indicating whether this {@link Eto.Forms.Command} is enabled. */
			Enabled: boolean;

			/** Gets or sets a user-defined tag value for this instance. */
			Tag: unknown;

			/** Gets or sets the text when shown on the menu. */
			MenuText: string;

			/** Gets or sets the tool bar text. */
			ToolBarText: string;

			/** Gets or sets the tool tip on both the menu and toolbar. */
			ToolTip: string;

			/**
			 * Gets or sets the image for the menu or tool item.
			 *
			 * On some platforms, the menu bar does not show the image by default (e.g. OS X). You
			 * can override this behaviour using a style on the handler.
			 */
			Image: Eto.Drawing.Image;

			/** Gets or sets the shortcut to trigger this command. */
			Shortcut: Eto.Forms.Keys;

			/** Gets the dictionary of properties for this widget */
			readonly Properties: Eto.PropertyStore;

			/**
			 * Gets or sets a command to delegate to when the command is invoked.
			 *
			 * This allows you to use a command to define menu/toolbar items or other functionality,
			 * and use a delegated command to chain to when invoked. This is especially useful when
			 * binding to a view model, you can do something like the following: var myCommand = new
			 * Command { MenuText = "My Command", Parent = myForm }; myCommand.BindDataContext(c
			 * =&gt; c.DelegatedCommand, (MyModel m) =&gt; m.MyModelCommand);  //...
			 * myForm.DataContext = new MyModel { MyModelCommand = ... }; The
			 * {@link System.Windows.Input.ICommand.CanExecute(System.Object)} will also used to set
			 * the enabled/disabled state of the current command.
			 */
			DelegatedCommand: unknown;

			/**
			 * Gets or sets the parameter to pass to the {@link Eto.Forms.Command} when executing or
			 * determining its CanExecute state.
			 */
			CommandParameter: unknown;

			/** Gets the parent widget which this widget has been added to, if any */
			Parent: Eto.Forms.IBindable;

			/**
			 * Gets or sets the data context for this widget for binding
			 *
			 * Subclasses may override the standard behaviour so that hierarchy of widgets can be
			 * taken into account.  For example, a Control may return the data context of a parent,
			 * if it is not set explicitly.
			 */
			DataContext: unknown;

			/**
			 * Gets a value indicating that the {@link Eto.Forms.Command.DataContext} property is
			 * changing.
			 *
			 * This can be used to determine when to allow certain logic during the update of the
			 * data context.  It is used to disable binding setters on the model when the data
			 * context changes so that a binding does not cause the view model to be updated when the
			 * state hasn't been fully set yet.
			 */
			IsDataContextChanging: boolean;

			/** Gets the collection of bindings that are attached to this widget */
			readonly Bindings: Eto.Forms.BindingCollection;

			/** Execute the command programatically. */
			Execute(): void;

			/** Creates a new tool item attached to this command. */
			CreateToolItem(): Eto.Forms.ToolItem;

			/** Creates a new menu item attached to this command. */
			CreateMenuItem(): Eto.Forms.MenuItem;
		}
	}

	export namespace Eto.Forms {
		/**
		 * Result codes for {@link Eto.Forms.CommonDialog} or {@link Eto.Forms.MessageBox}
		 * dialogs
		 */
		export enum DialogResult {
			/** No specific result */
			None = 0,

			/** User clicked 'OK' */
			Ok = 1,

			/** User clicked 'Cancel' or pressed escape to cancel */
			Cancel = 2,

			/** User clicked 'Yes' */
			Yes = 3,

			/** User clicked 'No' */
			No = 4,

			/** User clicked 'Abort' */
			Abort = 5,

			/** User clicked 'Ignore' */
			Ignore = 6,

			/** User clicked 'Retry' */
			Retry = 7,
		}
	}

	export namespace Eto.Forms {
		/** Base class for common dialogs */
		export class CommonDialog implements
			Eto.IHandlerSource {
			/**
			 * Gets the platform that was used to create the {@link Eto.Widget.Handler} for this
			 * widget
			 *
			 * This gets set to the current {@link Eto.Platform.Instance} during the construction of
			 * the object
			 */
			readonly Platform: Eto.Platform;

			/** Gets the platform-specific handler for this widget */
			Handler: unknown;

			/** Gets the native platform-specific handle for integration purposes */
			readonly NativeHandle: unknown;

			/** Gets the dictionary of properties for this widget */
			readonly Properties: Eto.PropertyStore;

			/** Gets or sets the ID of this widget */
			ID: string;

			/**
			 * Gets or sets the style of this widget
			 *
			 * Styles allow you to attach custom platform-specific logic to a widget. In your
			 * platform-specific assembly, use {@link Style.Add{H}(string, StyleHandler{H})} to add
			 * the style logic with the same id.
			 */
			Style: string;

			/**
			 * Gets the instance of the platform-specific object
			 *
			 * This can sometimes be useful to get the platform-specific object. Some handlers may
			 * not have any backing object for its functionality, so this may be null.  It is more
			 * preferred to use the {@link Eto.Widget.Handler} and cast that to the platform-specific
			 * handler class which can give you additional methods and helpers to do common tasks.
			 * For example, the {@link Eto.Forms.Application} object's handler for OS X has a
			 * AddFullScreenMenuItem property to specify if you want full screen support in your app.
			 */
			readonly ControlObject: unknown;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Widget} has been disposed.
			 *
			 * When the widget is disposed, it can no longer be used.
			 */
			IsDisposed: boolean;

			/** Shows the dialog with the specified parent, blocking until a result is returned. */
			ShowDialog(parent: Eto.Forms.Control): Eto.Forms.DialogResult;

			/**
			 * Shows the dialog with the specified parent window, blocking until a result is
			 * returned.
			 */
			ShowDialog(parent: Eto.Forms.Window): Eto.Forms.DialogResult;

			/** Disposes of this widget, supressing the finalizer */
			dispose(): void;

			/** Gets a string that represents the current object with its ID if specified. */
			ToString(): string;
		}
	}

	export namespace Eto.Forms.CommonDialog {
		export interface IHandler extends Eto.Widget.IHandler {
			ShowDialog(parent: Eto.Forms.Window): Eto.Forms.DialogResult;
		}
	}

	export namespace Eto.Forms {
		/** Base class for controls that contain children controls */
		export class Container implements
			Eto.IHandlerSource,
			Eto.Forms.IBindable,
			Eto.Forms.IMouseInputSource,
			Eto.Forms.IKeyboardInputSource {
			/**
			 * Gets or sets the size for the client area of the control
			 *
			 * The client size differs from the {@link Eto.Forms.Control.Size} in that it excludes
			 * the decorations of the container, such as the title bar and border around a
			 * {@link Eto.Forms.Window}, or the title and line  around a {@link Eto.Forms.GroupBox}.
			 */
			ClientSize: Eto.Drawing.Size;

			/**
			 * Gets an enumeration of logical controls that are directly contained by this container
			 *
			 * These controls are directly contained by the container, but do not include controls
			 * that are used to form the visual appearance, if any.  Controls like the
			 * {@link Eto.Forms.StackLayout}, {@link Eto.Forms.DynamicLayout} or a  customized
			 * container using the {@link Eto.Forms.ThemedContainerHandler<,,>} should not  include
			 * any intermediate controls.
			 */
			readonly Controls: Iterable<Eto.Forms.Control>;

			/**
			 * Gets an enumeration of all contained child controls, including controls within child
			 * containers
			 */
			readonly Children: Iterable<Eto.Forms.Control>;

			/**
			 * Gets an enumeration of all contained child controls in the visual tree, including
			 * controls within child containers.
			 */
			readonly VisualChildren: Iterable<Eto.Forms.Control>;

			/**
			 * Gets or sets the style provider for this container.
			 *
			 * The style provider is used to style this container and its children.
			 */
			StyleProvider: Eto.IStyleProvider;

			/**
			 * Gets the default style provider for this container.
			 *
			 * Use this to apply styles to any child controls of this container. By default, styles
			 * will apply to all children, including children of children unless
			 * {@link Eto.DefaultStyleProvider.Inherit} is set to false .  Typically, you would set
			 * Inherit to false when creating composite controls that already have all their styles
			 * applied and you don't want any other styles to be inherited.
			 */
			readonly Styles: Eto.DefaultStyleProvider;

			/**
			 * Gets a value indicating that the control is loaded onto a form, that is it has been
			 * created, added to a parent, and shown
			 *
			 * The {@link Eto.Forms.Control.OnLoad(System.EventArgs)} method sets this value to true
			 * after cascading to all children (for a {@link Eto.Forms.Container} ) and calling the
			 * platform handler's implementation.  It is called after adding to a loaded form, or
			 * when showing a new form.  The {@link Eto.Forms.Control.OnUnLoad(System.EventArgs)}
			 * method will set this value to false when the control is removed from its parent
			 */
			readonly Loaded: boolean;

			/**
			 * Gets an enumeration of controls that are in the visual tree.
			 *
			 * This is used to specify which controls are contained by this instance that are part of
			 * the visual tree. This should include all controls including non-logical Eto controls
			 * used for layout.
			 */
			readonly VisualControls: Iterable<Eto.Forms.Control>;

			/**
			 * Gets or sets a user-defined object that contains data about the control
			 *
			 * A common use of the tag property is to store data that is associated with the control
			 * that you can later retrieve.
			 */
			Tag: unknown;

			/**
			 * Gets the logical parent control.
			 *
			 * When the control is part of the visual tree (
				 * {@link Eto.Forms.Control.IsVisualControl} is true), this returns the logical parent
				 * that contains this control. Otherwise this is the same as
				 * {@link Eto.Forms.Control.Parent}.
				 */
				readonly LogicalParent: Eto.Forms.Container;

			/** Gets a value indicating this {@link Eto.Forms.Control} is part of the visual tree. */
			IsVisualControl: boolean;

			/**
			 * Gets or sets the size of the control. Use -1 to specify auto sizing for either the
			 * width and/or height.
			 *
			 * Setting the size of controls is entirely optional as most controls will size
			 * themselves appropriately. When specifying a size, it will be used as the desired size
			 * of the control.  The container will reposition and resize the control depending on the
			 * available size.  For a {@link Eto.Forms.Window}, it is preferred to set the
			 * {@link Eto.Forms.Container.ClientSize} instead, as various platforms have different
			 * sizes of window decorations, toolbars, etc.
			 */
			Size: Eto.Drawing.Size;

			/**
			 * Gets a value indicating this control currently has mouse capture
			 *
			 * Mouse capture can happen during a handled MouseDown event until MouseUp, or it can be
			 * captured explicitly via {@link Eto.Forms.Control.CaptureMouse}.
			 */
			readonly IsMouseCaptured: boolean;

			/** Gets or sets the width of the control size. */
			Width: number;

			/** Gets or sets the height of the control size. */
			Height: number;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Forms.Control} (or its
			 * children) are enabled and accept user input.
			 *
			 * Typically when a control is disabled, the user cannot do anything with the control or
			 * any of its children. Including for example, selecting text in a text control. Certain
			 * controls can have a 'Read Only' mode, such as {@link Eto.Forms.TextBox.ReadOnly} which
			 * allow the user to  select text, but not change its contents.
			 */
			Enabled: boolean;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Forms.Control} is visible to
			 * the user.
			 *
			 * When the visibility of a control is set to false, it will not occupy space in the
			 * layout.
			 */
			Visible: boolean;

			/** Gets the container which this control has been added to, if any */
			readonly Parent: Eto.Forms.Container;

			/**
			 * Gets the visual container of this control, if any.
			 *
			 * Some containers may use other Eto controls to layout its children, such as the
			 * {@link Eto.Forms.StackLayout}. This will return the parent control that visually
			 * contains this control as opposed to {@link Eto.Forms.Control.Parent} which will return
			 * the logical parent.
			 */
			VisualParent: Eto.Forms.Container;

			/** Gets a value indicating this control has been attached to a native container */
			readonly IsAttached: boolean;

			/**
			 * Gets or sets the color for the background of the control
			 *
			 * Note that on some platforms (e.g. Mac), setting the background color of a control can
			 * change the performance characteristics of the control and its children, since it must
			 * enable layers to do so.
			 */
			BackgroundColor: Eto.Drawing.Color;

			/** Gets a value indicating whether this instance has the keyboard input focus. */
			readonly HasFocus: boolean;

			/** Gets a value indicating whether the layout of child controls is suspended. */
			readonly IsSuspended: boolean;

			/** Gets the window this control is contained in */
			readonly ParentWindow: Eto.Forms.Window;

			/**
			 * Gets the supported platform commands that can be used to hook up system functions to
			 * user defined logic
			 *
			 * This lists all available commands that can be mapped using the
			 * {@link Eto.Forms.Control.MapPlatformCommand(System.String,Eto.Forms.Command)} method
			 * of the control.
			 */
			readonly SupportedPlatformCommands: Iterable<string>;

			/** Gets the bounding rectangle of this control relative to its container */
			readonly Bounds: Eto.Drawing.Rectangle;

			/**
			 * Gets the location of the control as positioned by the container
			 *
			 * A control's location is set by the container. This can be used to determine where the
			 * control is for overlaying floating windows, menus, etc.
			 */
			readonly Location: Eto.Drawing.Point;

			/** Gets or sets the type of cursor to use when the mouse is hovering over the control */
			Cursor: Eto.Forms.Cursor;

			/** Gets or sets the tool tip to show when the mouse is hovered over the control */
			ToolTip: string;

			/**
			 * Gets or sets the tab index order for this control within its container.
			 *
			 * This sets the order when using the tab key to cycle through controls  Note that some
			 * platforms (Gtk and WinForms) may not support setting the context of the tab order to
			 * StackLayout  or DynamicLayout containers and may not behave exactly as expected. Use
			 * the {@link Eto.PlatformFeatures.TabIndexWithCustomContainers} flag to determine if it
			 * is supported.
			 */
			TabIndex: number;

			/** Gets or sets a value indicating whether this control can serve as drop target. */
			AllowDrop: boolean;

			/**
			 * Gets or sets the parent widget which this widget has been added to, if any
			 *
			 * When implementing child widgets that can participate in the context based binding
			 * (MVVM), You can set this to the parent widget when it is added or removed to it
			 * (usually via a collection).  Note that you should typically provide a public new
			 * [ParentWidget] Parent { get; } property  so that consumers of your API cannot set the
			 * parent to an invalid value.
			 */
			Parent: Eto.Widget;

			/**
			 * Gets an enumeration of all parent widgets in the heirarchy by traversing the
			 * {@link Eto.Forms.BindableWidget.Parent} property.
			 */
			readonly Parents: Iterable<Eto.Widget>;

			/**
			 * Gets or sets the data context for this widget for binding
			 *
			 * Subclasses may override the standard behaviour so that hierarchy of widgets can be
			 * taken into account.  For example, a Control may return the data context of a parent,
			 * if it is not set explicitly.
			 */
			DataContext: unknown;

			/** Gets the collection of bindings that are attached to this widget */
			readonly Bindings: Eto.Forms.BindingCollection;

			/**
			 * Gets a value indicating that the {@link Eto.Forms.BindableWidget.DataContext} property
			 * is changing.
			 *
			 * This can be used to determine when to allow certain logic during the update of the
			 * data context.  It is used to disable binding setters on the model when the data
			 * context changes so that a binding does not cause the view model to be updated when the
			 * state hasn't been fully set yet.
			 */
			IsDataContextChanging: boolean;

			/**
			 * Gets the platform that was used to create the {@link Eto.Widget.Handler} for this
			 * widget
			 *
			 * This gets set to the current {@link Eto.Platform.Instance} during the construction of
			 * the object
			 */
			readonly Platform: Eto.Platform;

			/** Gets the platform-specific handler for this widget */
			Handler: unknown;

			/** Gets the native platform-specific handle for integration purposes */
			readonly NativeHandle: unknown;

			/** Gets the dictionary of properties for this widget */
			readonly Properties: Eto.PropertyStore;

			/** Gets or sets the ID of this widget */
			ID: string;

			/**
			 * Gets or sets the style of this widget
			 *
			 * Styles allow you to attach custom platform-specific logic to a widget. In your
			 * platform-specific assembly, use {@link Style.Add{H}(string, StyleHandler{H})} to add
			 * the style logic with the same id.
			 */
			Style: string;

			/**
			 * Gets the instance of the platform-specific object
			 *
			 * This can sometimes be useful to get the platform-specific object. Some handlers may
			 * not have any backing object for its functionality, so this may be null.  It is more
			 * preferred to use the {@link Eto.Widget.Handler} and cast that to the platform-specific
			 * handler class which can give you additional methods and helpers to do common tasks.
			 * For example, the {@link Eto.Forms.Application} object's handler for OS X has a
			 * AddFullScreenMenuItem property to specify if you want full screen support in your app.
			 */
			readonly ControlObject: unknown;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Widget} has been disposed.
			 *
			 * When the widget is disposed, it can no longer be used.
			 */
			IsDisposed: boolean;

			/** Remove the specified `controls` from this container */
			Remove(controls: Iterable<Eto.Forms.Control>): void;

			/** Removes all controls from this container */
			RemoveAll(): void;

			/** Removes the specified `child` control */
			Remove(child: Eto.Forms.Control): void;

			/**
			 * Finds a child control in this container or any of its child containers with the
			 * specified `id`
			 */
			FindChild<T>(id?: string): T;

			/**
			 * Finds a child control in this container or any of its child containers with the
			 * specified `type`
			 */
			FindChild(
				type: unknown,
				id?: string,
			): Eto.Forms.Control;

			/**
			 * Finds a child control in this container or any of its child containers with the
			 * specified `id`.
			 */
			FindChild(id: string): Eto.Forms.Control;

			/**
			 * Queues a repaint of the entire control on the screen and any of its children.
			 *
			 * This is only useful when the control is visible.
			 */
			Invalidate(): void;

			/**
			 * Queues a repaint of the entire control on the screen
			 *
			 * This is only useful when the control is visible.
			 */
			Invalidate(invalidateChildren: boolean): void;

			/**
			 * Queues a repaint of the specified `rect` of the control and any children.
			 *
			 * This is only useful when the control is visible.
			 */
			Invalidate(rect: Eto.Drawing.Rectangle): void;

			/**
			 * Queues a repaint of the specified `rect` of the control
			 *
			 * This is only useful when the control is visible.
			 */
			Invalidate(
				rect: Eto.Drawing.Rectangle,
				invalidateChildren: boolean,
			): void;

			/**
			 * Updates the layout of this control if necessary.
			 *
			 * This will ensure the control has had all of its layout applied so you can use its
			 * position and size right after this call. Most platforms (except WinForms) use a
			 * deferred layout system so that after adding your control to the form dynamically it
			 * won't get laid out until the next idle loop. This is useful when you need to know the
			 * dimensions of the control immediately. Note that this can be an expensive operation,
			 * so it is recommended to only call this method when necessary and after all of the
			 * controls have been added/updated.
			 */
			UpdateLayout(): void;

			/** Gets the preferred size of this control given infinite space available. */
			GetPreferredSize(): Eto.Drawing.SizeF;

			/** Gets the preferred size of this control given the specified `availableSize`. */
			GetPreferredSize(availableSize: Eto.Drawing.SizeF): Eto.Drawing.SizeF;

			/**
			 * Captures all mouse events to this control.
			 *
			 * This captures all mouse events until {@link Eto.Forms.Control.ReleaseMouseCapture} is
			 * called.  Note that not all platforms will allow a mouse capture unless the mouse is
			 * currently down.
			 */
			CaptureMouse(): boolean;

			/** Releases the mouse capture after a call to {@link Eto.Forms.Control.CaptureMouse}. */
			ReleaseMouseCapture(): void;

			/**
			 * Finds a control in the parent hierarchy with the specified type and
			 * {@link Eto.Widget.ID} if specified
			 */
			FindParent(
				type: unknown,
				id?: string,
			): Eto.Forms.Container;

			/** Finds a control in the parent hierarchy with the specified `id` */
			FindParent(id: string): Eto.Forms.Container;

			/**
			 * Detaches the control by removing it from its parent
			 *
			 * This is essentially a shortcut to myControl.Parent.Remove(myControl);
			 */
			Detach(): void;

			/**
			 * Attaches the control for direct use in a native application
			 *
			 * Use this to use a control directly in a native application.  Note that the native
			 * application must be running the same framework as the current platform.  E.g. a
			 * WinForms application can use an Eto.Forms control when using the Eto.WinForms
			 * platform.  This prepares the control by firing the {@link Eto.Forms.Control.PreLoad},
			 * {@link Eto.Forms.Control.Load}, etc. events.
			 */
			AttachNative(): void;

			/**
			 * Detaches the control when it is used in a native application, when you want to reuse
			 * the control.
			 *
			 * This should only be called after {@link Eto.Forms.Control.AttachNative} has been
			 * called, which is usually done by calling to ToNative(true) .
			 */
			DetachNative(): void;

			/**
			 * Attempts to set the keyboard input focus to this control, or the first child that
			 * accepts focus. For Windows, this will bring it to front and activate it.
			 */
			Focus(): void;

			/**
			 * Suspends the layout of child controls
			 *
			 * This can be used to optimize some platforms while adding, removing, or changing many
			 * child controls at once. It disables the calculation of control positioning until
			 * {@link Eto.Forms.Control.ResumeLayout} is called. Each call to SuspendLayout() must be
			 * balanced with a call to {@link Eto.Forms.Control.ResumeLayout}.
			 */
			SuspendLayout(): void;

			/**
			 * Resumes the layout after it has been suspended, and performs a layout
			 *
			 * This can be used to optimize some platforms while adding, removing, or changing many
			 * child controls at once. Each call to ResumeLayout() must be balanced with a call to
			 * {@link Eto.Forms.Control.SuspendLayout} before it.
			 */
			ResumeLayout(): void;

			/**
			 * Specifies a command to execute for a platform-specific command
			 *
			 * Some platforms have specific system-defined commands that can be associated with a
			 * control. For example, the Mac platform's cut/copy/paste functionality is defined by
			 * the system, and if you want to hook into it, you can use this to map it to your own
			 * defined logic. The valid values of the `systemCommand` parameter are defined by each
			 * platform, and a list can be retrieved using
			 * {@link Eto.Forms.Control.SupportedPlatformCommands}
			 */
			MapPlatformCommand(
				systemCommand: string,
				command: Eto.Forms.Command,
			): void;

			/** Converts a point from screen space to control space. */
			PointFromScreen(point: Eto.Drawing.PointF): Eto.Drawing.PointF;

			/** Converts a point from control space to screen space */
			PointToScreen(point: Eto.Drawing.PointF): Eto.Drawing.PointF;

			/** Converts a rectangle from screen space to control space. */
			RectangleToScreen(rect: Eto.Drawing.RectangleF): Eto.Drawing.RectangleF;

			/** Converts a rectangle from control space to screen space */
			RectangleFromScreen(rect: Eto.Drawing.RectangleF): Eto.Drawing.RectangleF;

			/**
			 * Starts drag operation using this control as drag source.
			 *
			 * This method can be blocking on some platforms (Wpf, WinForms), and non-blocking on
			 * others (Mac, Gtk). Use the {@link Eto.Forms.Control.DragEnd} event to determine when
			 * the drag operation is completed and get its resulting DragEffects.
			 */
			DoDragDrop(
				data: Eto.Forms.DataObject,
				allowedEffects: Eto.Forms.DragEffects,
			): void;

			/**
			 * Starts drag operation using this control as drag source.
			 *
			 * This method can be blocking on some platforms (Wpf, WinForms), and non-blocking on
			 * others (Mac, Gtk). Use the {@link Eto.Forms.Control.DragEnd} event to determine when
			 * the drag operation is completed and get its resulting DragEffects.
			 */
			DoDragDrop(
				data: Eto.Forms.DataObject,
				allowedEffects: Eto.Forms.DragEffects,
				image: Eto.Drawing.Image,
				cursorOffset: Eto.Drawing.PointF,
			): void;

			/**
			 * Triggers the StyleChanged event and re-applies the styles to this control and its
			 * children.
			 */
			TriggerStyleChanged(): void;

			/** Shows a print dialog to print the specified control */
			Print(): void;

			/**
			 * Finds a control in the parent hierarchy with the specified type and
			 * {@link Eto.Widget.ID} if specified
			 */
			FindParent<T>(id?: string): T;

			/**
			 * Finds a control in the parent hierarchy with the specified type and
			 * {@link Eto.Widget.ID} if specified
			 */
			FindParent(
				type: unknown,
				id?: string,
			): Eto.Widget;

			/** Finds a control in the parent hierarchy with the specified `id` */
			FindParent(id: string): Eto.Widget;

			/**
			 * Unbinds any bindings in the {@link Eto.Forms.BindableWidget.Bindings} collection and
			 * removes the bindings
			 *
			 * When you implement {@link Eto.Forms.IBindableWidgetContainer}, this will also unbind
			 * any of its children.
			 */
			Unbind(): void;

			/**
			 * Updates all bindings in this widget
			 *
			 * When you implement {@link Eto.Forms.IBindableWidgetContainer}, this will also update
			 * bindings for all of its children.
			 */
			UpdateBindings(mode?: Eto.Forms.BindingUpdateMode): void;

			/** Disposes of this widget, supressing the finalizer */
			dispose(): void;

			/** Gets a string that represents the current object with its ID if specified. */
			ToString(): string;
		}
	}

	export namespace Eto.Forms.Container {
		export interface IHandler extends
			Eto.Forms.Control.IHandler,
			Eto.Widget.IHandler {
			ClientSize: Eto.Drawing.Size;

			readonly RecurseToChildren: boolean;
		}
	}

	export namespace Eto.Forms {
		/**
		 * [Generic type factory] Binding object to easily bind a property of a
		 * {@link Eto.Forms.Control}.
		 *
		 * This provides control-specific binding, such as binding to a
		 * {@link Eto.Forms.BindableWidget.DataContext}. Any bindings created using this will
		 * also add to the {@link Eto.Forms.BindableWidget.Bindings} collection to keep its
		 * reference.
		 */
		export function ControlBinding$(T: IType, TValue: IType): typeof ControlBinding$2<any, any>;

		/**
		 * Binding object to easily bind a property of a {@link Eto.Forms.Control}.
		 *
		 * This provides control-specific binding, such as binding to a
		 * {@link Eto.Forms.BindableWidget.DataContext}. Any bindings created using this will
		 * also add to the {@link Eto.Forms.BindableWidget.Bindings} collection to keep its
		 * reference.
		 */
		export class ControlBinding$2<T, TValue> implements Eto.Forms.IBinding {
			/** Initializes a new instance of the {@link Eto.Forms.ControlBinding<,>} class. */
			new(
				dataItem: T,
				getValue: (arg1: T) => TValue,
				setValue?: (arg1: T, arg2: TValue) => void,
				addChangeEvent?: (arg1: T, arg2: unknown) => void,
				removeChangeEvent?: (arg1: T, arg2: unknown) => void,
			): ControlBinding$2<T, TValue>;

			/** Initializes a new instance of the {@link Eto.Forms.ControlBinding<,>} class. */
			new(
				dataItem: T,
				innerBinding: Eto.Forms.IndirectBinding$1<TValue>,
			): ControlBinding$2<T, TValue>;

			readonly InnerBinding: Eto.Forms.IndirectBinding$1<TValue>;

			DataItem: T;

			GetDataItem: () => T;

			SettingNullValue: TValue;

			GettingNullValue: TValue;

			DataValue: TValue;

			Bind(
				sourceBinding: Eto.Forms.DirectBinding$1<TValue>,
				mode?: Eto.Forms.DualBindingMode,
			): Eto.Forms.DualBinding$1<TValue>;

			BindDataContext(
				dataContextBinding: Eto.Forms.IndirectBinding$1<TValue>,
				mode?: Eto.Forms.DualBindingMode,
				defaultControlValue?: TValue,
				defaultContextValue?: TValue,
			): Eto.Forms.DualBinding$1<TValue>;

			BindDataContext<TObject>(
				getValue: (arg1: TObject) => TValue,
				setValue: (arg1: TObject, arg2: TValue) => void,
				addChangeEvent?: (arg1: TObject, arg2: unknown) => void,
				removeChangeEvent?: (arg1: TObject, arg2: unknown) => void,
				mode?: Eto.Forms.DualBindingMode,
				defaultGetValue?: TValue,
				defaultSetValue?: TValue,
			): Eto.Forms.DualBinding$1<TValue>;

			BindDataContext(
				propertyName: string,
				mode?: Eto.Forms.DualBindingMode,
			): Eto.Forms.DualBinding$1<TValue>;

			BindDataContext<TObject>(
				propertyExpression: unknown,
				mode?: Eto.Forms.DualBindingMode,
			): Eto.Forms.DualBinding$1<TValue>;

			Convert<TNewValue>(
				toValue: (arg1: TValue) => TNewValue,
				fromValue?: (arg1: TNewValue) => TValue,
			): Eto.Forms.BindableBinding$2<T, TNewValue>;

			Cast<TNewValue>(): Eto.Forms.BindableBinding$2<T, TNewValue>;

			Child<TNewValue>(property: unknown): Eto.Forms.BindableBinding$2<T, TNewValue>;

			Child<TNewValue>(binding: Eto.Forms.IndirectBinding$1<TNewValue>): Eto.Forms.BindableBinding$2<T, TNewValue>;

			CatchException(exceptionHandler?: (arg1: unknown) => boolean): Eto.Forms.BindableBinding$2<T, TValue>;

			CatchException<TException>(exceptionHandler?: (arg1: TException) => boolean): Eto.Forms.BindableBinding$2<T, TValue>;

			TriggerDataValueChanged(): void;

			Unbind(): void;

			Bind(
				getValue: () => TValue,
				setValue?: (arg1: TValue) => void,
				addChangeEvent?: (arg1: unknown) => void,
				removeChangeEvent?: (arg1: unknown) => void,
				mode?: Eto.Forms.DualBindingMode,
			): Eto.Forms.DualBinding$1<TValue>;

			Bind<TObject>(
				objectValue: TObject,
				objectBinding: Eto.Forms.IndirectBinding$1<TValue>,
				mode?: Eto.Forms.DualBindingMode,
			): Eto.Forms.DualBinding$1<TValue>;

			Bind(
				objectValue: unknown,
				propertyName: string,
				mode?: Eto.Forms.DualBindingMode,
			): Eto.Forms.DualBinding$1<TValue>;

			Bind<TObject>(
				objectValue: TObject,
				propertyExpression: unknown,
				mode?: Eto.Forms.DualBindingMode,
			): Eto.Forms.DualBinding$1<TValue>;

			ToString(): string;

			Convert<TValue>(
				toValue: (arg1: TValue) => TValue,
				fromValue?: (arg1: TValue) => TValue,
			): Eto.Forms.DirectBinding$1<TValue>;

			Cast<TValue>(): Eto.Forms.DirectBinding$1<TValue>;

			Child<TValue>(property: unknown): Eto.Forms.DirectBinding$1<TValue>;

			Child<TValue>(binding: Eto.Forms.IndirectBinding$1<TValue>): Eto.Forms.DirectBinding$1<TValue>;

			ToBool(
				trueValue: TValue,
				falseValue: TValue,
				nullValue: TValue,
			): Eto.Forms.DirectBinding$1<boolean | undefined>;

			ToBool(
				trueValue: TValue,
				falseValue: TValue,
			): Eto.Forms.DirectBinding$1<boolean | undefined>;

			ToBool(trueValue: TValue): Eto.Forms.DirectBinding$1<boolean | undefined>;

			ToType<TType>(
				invalidGetValue?: (arg1: TValue) => TType,
				invalidSetValue?: (arg1: TType) => TValue,
			): Eto.Forms.DirectBinding$1<TType>;

			CatchException(exceptionHandler?: (arg1: unknown) => boolean): Eto.Forms.DirectBinding$1<TValue>;

			CatchException<TException>(exceptionHandler?: (arg1: TException) => boolean): Eto.Forms.DirectBinding$1<TValue>;

			/**
			 * Updates the bound target object's value
			 *
			 * Typically the source would be your custom class and the destination would be a UI
			 * control, but this is not always the case.
			 */
			Update(mode?: Eto.Forms.BindingUpdateMode): void;
		}
	}

	export namespace Eto.Forms {
		/** Possible values for how images can be positioned in {@link Eto.Forms.Button} s. */
		export enum ButtonImagePosition {
			/** Positions the image to the left of the text. */
			Left = 0,

			/** Positions the image to the right of the text. */
			Right = 1,

			/** Positions the image above of the text. */
			Above = 2,

			/** Positions the image below the text. */
			Below = 3,

			/** Positions the image behind the text. */
			Overlay = 4,
		}
	}

	export namespace Eto.Forms {
		/** A standard button control. */
		export class Button implements
			Eto.IHandlerSource,
			Eto.Forms.IBindable,
			Eto.Forms.IMouseInputSource,
			Eto.Forms.IKeyboardInputSource {
			/** Initializes a new instance of the {@link Eto.Forms.Button} class. */
			constructor();

			/**
			 * Initializes a new instance of the {@link Eto.Forms.Button} class with the specified
			 * `click` handler.
			 *
			 * This is a convenience constructor to set up the {@link Eto.Forms.Button.Click} event.
			 */
			constructor(click: unknown);

			/**
			 * Gets or sets the command to invoke when the button is pressed.
			 *
			 * This will invoke the specified command when the button is pressed. The
			 * {@link System.Windows.Input.ICommand.CanExecute(System.Object)} will also be used to
			 * set the {@link Eto.Forms.Control.Enabled} state of the button.
			 */
			Command: unknown;

			/**
			 * Gets or sets the parameter to pass to the {@link Eto.Forms.Button.Command} when
			 * executing or determining its
			 * {@link System.Windows.Input.ICommand.CanExecute(System.Object)} state.
			 */
			CommandParameter: unknown;

			/** Gets or sets the image to display on the button. */
			Image: Eto.Drawing.Image;

			/** Gets or sets the position of the image relative to the text. */
			ImagePosition: Eto.Forms.ButtonImagePosition;

			/**
			 * Gets or sets the minimum size for the button.
			 *
			 * Each platform may have a different initial minimum size set for buttons to match their
			 * standard sizes.  Setting this to {@link Eto.Drawing.Size.Empty} is useful when you
			 * want the button to shrink to fit the size of the specified
			 * {@link Eto.Forms.Button.Image} and/or {@link Eto.Forms.TextControl.Text}.
			 */
			MinimumSize: Eto.Drawing.Size;

			/**
			 * Gets or sets the size of the control. Use -1 to specify auto sizing for either the
			 * width and/or height.
			 */
			Size: Eto.Drawing.Size;

			/** Gets or sets the width of the control size. */
			Width: number;

			/** Gets or sets the height of the control size. */
			Height: number;

			/**
			 * Gets or sets the text of the control.
			 *
			 * Usually, the caret and selection will be set to the end of the string after its set.
			 */
			Text: string;

			/**
			 * Gets or sets the color of the text.
			 *
			 * By default, the text will get a color based on the user's theme. However, this is
			 * usually black.
			 */
			TextColor: Eto.Drawing.Color;

			/** Gets the binding for the {@link Eto.Forms.TextControl.Text} property. */
			readonly TextBinding: Eto.Forms.BindableBinding$2<Eto.Forms.TextControl, string>;

			/** Gets or sets the font for the text of the control */
			Font: Eto.Drawing.Font;

			/**
			 * Gets a value indicating that the control is loaded onto a form, that is it has been
			 * created, added to a parent, and shown
			 *
			 * The {@link Eto.Forms.Control.OnLoad(System.EventArgs)} method sets this value to true
			 * after cascading to all children (for a {@link Eto.Forms.Container} ) and calling the
			 * platform handler's implementation.  It is called after adding to a loaded form, or
			 * when showing a new form.  The {@link Eto.Forms.Control.OnUnLoad(System.EventArgs)}
			 * method will set this value to false when the control is removed from its parent
			 */
			readonly Loaded: boolean;

			/**
			 * Gets an enumeration of controls that are in the visual tree.
			 *
			 * This is used to specify which controls are contained by this instance that are part of
			 * the visual tree. This should include all controls including non-logical Eto controls
			 * used for layout.
			 */
			readonly VisualControls: Iterable<Eto.Forms.Control>;

			/**
			 * Gets or sets a user-defined object that contains data about the control
			 *
			 * A common use of the tag property is to store data that is associated with the control
			 * that you can later retrieve.
			 */
			Tag: unknown;

			/**
			 * Gets the logical parent control.
			 *
			 * When the control is part of the visual tree (
				 * {@link Eto.Forms.Control.IsVisualControl} is true), this returns the logical parent
				 * that contains this control. Otherwise this is the same as
				 * {@link Eto.Forms.Control.Parent}.
				 */
				readonly LogicalParent: Eto.Forms.Container;

			/** Gets a value indicating this {@link Eto.Forms.Control} is part of the visual tree. */
			IsVisualControl: boolean;

			/**
			 * Gets a value indicating this control currently has mouse capture
			 *
			 * Mouse capture can happen during a handled MouseDown event until MouseUp, or it can be
			 * captured explicitly via {@link Eto.Forms.Control.CaptureMouse}.
			 */
			readonly IsMouseCaptured: boolean;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Forms.Control} (or its
			 * children) are enabled and accept user input.
			 *
			 * Typically when a control is disabled, the user cannot do anything with the control or
			 * any of its children. Including for example, selecting text in a text control. Certain
			 * controls can have a 'Read Only' mode, such as {@link Eto.Forms.TextBox.ReadOnly} which
			 * allow the user to  select text, but not change its contents.
			 */
			Enabled: boolean;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Forms.Control} is visible to
			 * the user.
			 *
			 * When the visibility of a control is set to false, it will not occupy space in the
			 * layout.
			 */
			Visible: boolean;

			/** Gets the container which this control has been added to, if any */
			readonly Parent: Eto.Forms.Container;

			/**
			 * Gets the visual container of this control, if any.
			 *
			 * Some containers may use other Eto controls to layout its children, such as the
			 * {@link Eto.Forms.StackLayout}. This will return the parent control that visually
			 * contains this control as opposed to {@link Eto.Forms.Control.Parent} which will return
			 * the logical parent.
			 */
			VisualParent: Eto.Forms.Container;

			/** Gets a value indicating this control has been attached to a native container */
			readonly IsAttached: boolean;

			/**
			 * Gets or sets the color for the background of the control
			 *
			 * Note that on some platforms (e.g. Mac), setting the background color of a control can
			 * change the performance characteristics of the control and its children, since it must
			 * enable layers to do so.
			 */
			BackgroundColor: Eto.Drawing.Color;

			/** Gets a value indicating whether this instance has the keyboard input focus. */
			readonly HasFocus: boolean;

			/** Gets a value indicating whether the layout of child controls is suspended. */
			readonly IsSuspended: boolean;

			/** Gets the window this control is contained in */
			readonly ParentWindow: Eto.Forms.Window;

			/**
			 * Gets the supported platform commands that can be used to hook up system functions to
			 * user defined logic
			 *
			 * This lists all available commands that can be mapped using the
			 * {@link Eto.Forms.Control.MapPlatformCommand(System.String,Eto.Forms.Command)} method
			 * of the control.
			 */
			readonly SupportedPlatformCommands: Iterable<string>;

			/** Gets the bounding rectangle of this control relative to its container */
			readonly Bounds: Eto.Drawing.Rectangle;

			/**
			 * Gets the location of the control as positioned by the container
			 *
			 * A control's location is set by the container. This can be used to determine where the
			 * control is for overlaying floating windows, menus, etc.
			 */
			readonly Location: Eto.Drawing.Point;

			/** Gets or sets the type of cursor to use when the mouse is hovering over the control */
			Cursor: Eto.Forms.Cursor;

			/** Gets or sets the tool tip to show when the mouse is hovered over the control */
			ToolTip: string;

			/**
			 * Gets or sets the tab index order for this control within its container.
			 *
			 * This sets the order when using the tab key to cycle through controls  Note that some
			 * platforms (Gtk and WinForms) may not support setting the context of the tab order to
			 * StackLayout  or DynamicLayout containers and may not behave exactly as expected. Use
			 * the {@link Eto.PlatformFeatures.TabIndexWithCustomContainers} flag to determine if it
			 * is supported.
			 */
			TabIndex: number;

			/** Gets or sets a value indicating whether this control can serve as drop target. */
			AllowDrop: boolean;

			/**
			 * Gets or sets the parent widget which this widget has been added to, if any
			 *
			 * When implementing child widgets that can participate in the context based binding
			 * (MVVM), You can set this to the parent widget when it is added or removed to it
			 * (usually via a collection).  Note that you should typically provide a public new
			 * [ParentWidget] Parent { get; } property  so that consumers of your API cannot set the
			 * parent to an invalid value.
			 */
			Parent: Eto.Widget;

			/**
			 * Gets an enumeration of all parent widgets in the heirarchy by traversing the
			 * {@link Eto.Forms.BindableWidget.Parent} property.
			 */
			readonly Parents: Iterable<Eto.Widget>;

			/**
			 * Gets or sets the data context for this widget for binding
			 *
			 * Subclasses may override the standard behaviour so that hierarchy of widgets can be
			 * taken into account.  For example, a Control may return the data context of a parent,
			 * if it is not set explicitly.
			 */
			DataContext: unknown;

			/** Gets the collection of bindings that are attached to this widget */
			readonly Bindings: Eto.Forms.BindingCollection;

			/**
			 * Gets a value indicating that the {@link Eto.Forms.BindableWidget.DataContext} property
			 * is changing.
			 *
			 * This can be used to determine when to allow certain logic during the update of the
			 * data context.  It is used to disable binding setters on the model when the data
			 * context changes so that a binding does not cause the view model to be updated when the
			 * state hasn't been fully set yet.
			 */
			IsDataContextChanging: boolean;

			/**
			 * Gets the platform that was used to create the {@link Eto.Widget.Handler} for this
			 * widget
			 *
			 * This gets set to the current {@link Eto.Platform.Instance} during the construction of
			 * the object
			 */
			readonly Platform: Eto.Platform;

			/** Gets the platform-specific handler for this widget */
			Handler: unknown;

			/** Gets the native platform-specific handle for integration purposes */
			readonly NativeHandle: unknown;

			/** Gets the dictionary of properties for this widget */
			readonly Properties: Eto.PropertyStore;

			/** Gets or sets the ID of this widget */
			ID: string;

			/**
			 * Gets or sets the style of this widget
			 *
			 * Styles allow you to attach custom platform-specific logic to a widget. In your
			 * platform-specific assembly, use {@link Style.Add{H}(string, StyleHandler{H})} to add
			 * the style logic with the same id.
			 */
			Style: string;

			/**
			 * Gets the instance of the platform-specific object
			 *
			 * This can sometimes be useful to get the platform-specific object. Some handlers may
			 * not have any backing object for its functionality, so this may be null.  It is more
			 * preferred to use the {@link Eto.Widget.Handler} and cast that to the platform-specific
			 * handler class which can give you additional methods and helpers to do common tasks.
			 * For example, the {@link Eto.Forms.Application} object's handler for OS X has a
			 * AddFullScreenMenuItem property to specify if you want full screen support in your app.
			 */
			readonly ControlObject: unknown;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Widget} has been disposed.
			 *
			 * When the widget is disposed, it can no longer be used.
			 */
			IsDisposed: boolean;

			/**
			 * Triggers the {@link Eto.Forms.Button.Click} event for the button, if the button is
			 * visible and enabled.
			 */
			PerformClick(): void;

			/**
			 * Queues a repaint of the entire control on the screen and any of its children.
			 *
			 * This is only useful when the control is visible.
			 */
			Invalidate(): void;

			/**
			 * Queues a repaint of the entire control on the screen
			 *
			 * This is only useful when the control is visible.
			 */
			Invalidate(invalidateChildren: boolean): void;

			/**
			 * Queues a repaint of the specified `rect` of the control and any children.
			 *
			 * This is only useful when the control is visible.
			 */
			Invalidate(rect: Eto.Drawing.Rectangle): void;

			/**
			 * Queues a repaint of the specified `rect` of the control
			 *
			 * This is only useful when the control is visible.
			 */
			Invalidate(
				rect: Eto.Drawing.Rectangle,
				invalidateChildren: boolean,
			): void;

			/**
			 * Updates the layout of this control if necessary.
			 *
			 * This will ensure the control has had all of its layout applied so you can use its
			 * position and size right after this call. Most platforms (except WinForms) use a
			 * deferred layout system so that after adding your control to the form dynamically it
			 * won't get laid out until the next idle loop. This is useful when you need to know the
			 * dimensions of the control immediately. Note that this can be an expensive operation,
			 * so it is recommended to only call this method when necessary and after all of the
			 * controls have been added/updated.
			 */
			UpdateLayout(): void;

			/** Gets the preferred size of this control given infinite space available. */
			GetPreferredSize(): Eto.Drawing.SizeF;

			/** Gets the preferred size of this control given the specified `availableSize`. */
			GetPreferredSize(availableSize: Eto.Drawing.SizeF): Eto.Drawing.SizeF;

			/**
			 * Captures all mouse events to this control.
			 *
			 * This captures all mouse events until {@link Eto.Forms.Control.ReleaseMouseCapture} is
			 * called.  Note that not all platforms will allow a mouse capture unless the mouse is
			 * currently down.
			 */
			CaptureMouse(): boolean;

			/** Releases the mouse capture after a call to {@link Eto.Forms.Control.CaptureMouse}. */
			ReleaseMouseCapture(): void;

			/**
			 * Finds a control in the parent hierarchy with the specified type and
			 * {@link Eto.Widget.ID} if specified
			 */
			FindParent(
				type: unknown,
				id?: string,
			): Eto.Forms.Container;

			/** Finds a control in the parent hierarchy with the specified `id` */
			FindParent(id: string): Eto.Forms.Container;

			/**
			 * Detaches the control by removing it from its parent
			 *
			 * This is essentially a shortcut to myControl.Parent.Remove(myControl);
			 */
			Detach(): void;

			/**
			 * Attaches the control for direct use in a native application
			 *
			 * Use this to use a control directly in a native application.  Note that the native
			 * application must be running the same framework as the current platform.  E.g. a
			 * WinForms application can use an Eto.Forms control when using the Eto.WinForms
			 * platform.  This prepares the control by firing the {@link Eto.Forms.Control.PreLoad},
			 * {@link Eto.Forms.Control.Load}, etc. events.
			 */
			AttachNative(): void;

			/**
			 * Detaches the control when it is used in a native application, when you want to reuse
			 * the control.
			 *
			 * This should only be called after {@link Eto.Forms.Control.AttachNative} has been
			 * called, which is usually done by calling to ToNative(true) .
			 */
			DetachNative(): void;

			/**
			 * Attempts to set the keyboard input focus to this control, or the first child that
			 * accepts focus. For Windows, this will bring it to front and activate it.
			 */
			Focus(): void;

			/**
			 * Suspends the layout of child controls
			 *
			 * This can be used to optimize some platforms while adding, removing, or changing many
			 * child controls at once. It disables the calculation of control positioning until
			 * {@link Eto.Forms.Control.ResumeLayout} is called. Each call to SuspendLayout() must be
			 * balanced with a call to {@link Eto.Forms.Control.ResumeLayout}.
			 */
			SuspendLayout(): void;

			/**
			 * Resumes the layout after it has been suspended, and performs a layout
			 *
			 * This can be used to optimize some platforms while adding, removing, or changing many
			 * child controls at once. Each call to ResumeLayout() must be balanced with a call to
			 * {@link Eto.Forms.Control.SuspendLayout} before it.
			 */
			ResumeLayout(): void;

			/**
			 * Specifies a command to execute for a platform-specific command
			 *
			 * Some platforms have specific system-defined commands that can be associated with a
			 * control. For example, the Mac platform's cut/copy/paste functionality is defined by
			 * the system, and if you want to hook into it, you can use this to map it to your own
			 * defined logic. The valid values of the `systemCommand` parameter are defined by each
			 * platform, and a list can be retrieved using
			 * {@link Eto.Forms.Control.SupportedPlatformCommands}
			 */
			MapPlatformCommand(
				systemCommand: string,
				command: Eto.Forms.Command,
			): void;

			/** Converts a point from screen space to control space. */
			PointFromScreen(point: Eto.Drawing.PointF): Eto.Drawing.PointF;

			/** Converts a point from control space to screen space */
			PointToScreen(point: Eto.Drawing.PointF): Eto.Drawing.PointF;

			/** Converts a rectangle from screen space to control space. */
			RectangleToScreen(rect: Eto.Drawing.RectangleF): Eto.Drawing.RectangleF;

			/** Converts a rectangle from control space to screen space */
			RectangleFromScreen(rect: Eto.Drawing.RectangleF): Eto.Drawing.RectangleF;

			/**
			 * Starts drag operation using this control as drag source.
			 *
			 * This method can be blocking on some platforms (Wpf, WinForms), and non-blocking on
			 * others (Mac, Gtk). Use the {@link Eto.Forms.Control.DragEnd} event to determine when
			 * the drag operation is completed and get its resulting DragEffects.
			 */
			DoDragDrop(
				data: Eto.Forms.DataObject,
				allowedEffects: Eto.Forms.DragEffects,
			): void;

			/**
			 * Starts drag operation using this control as drag source.
			 *
			 * This method can be blocking on some platforms (Wpf, WinForms), and non-blocking on
			 * others (Mac, Gtk). Use the {@link Eto.Forms.Control.DragEnd} event to determine when
			 * the drag operation is completed and get its resulting DragEffects.
			 */
			DoDragDrop(
				data: Eto.Forms.DataObject,
				allowedEffects: Eto.Forms.DragEffects,
				image: Eto.Drawing.Image,
				cursorOffset: Eto.Drawing.PointF,
			): void;

			/**
			 * Triggers the StyleChanged event and re-applies the styles to this control and its
			 * children.
			 */
			TriggerStyleChanged(): void;

			/** Shows a print dialog to print the specified control */
			Print(): void;

			/**
			 * Finds a control in the parent hierarchy with the specified type and
			 * {@link Eto.Widget.ID} if specified
			 */
			FindParent<T>(id?: string): T;

			/**
			 * Finds a control in the parent hierarchy with the specified type and
			 * {@link Eto.Widget.ID} if specified
			 */
			FindParent(
				type: unknown,
				id?: string,
			): Eto.Widget;

			/** Finds a control in the parent hierarchy with the specified `id` */
			FindParent(id: string): Eto.Widget;

			/**
			 * Unbinds any bindings in the {@link Eto.Forms.BindableWidget.Bindings} collection and
			 * removes the bindings
			 *
			 * When you implement {@link Eto.Forms.IBindableWidgetContainer}, this will also unbind
			 * any of its children.
			 */
			Unbind(): void;

			/**
			 * Updates all bindings in this widget
			 *
			 * When you implement {@link Eto.Forms.IBindableWidgetContainer}, this will also update
			 * bindings for all of its children.
			 */
			UpdateBindings(mode?: Eto.Forms.BindingUpdateMode): void;

			/** Disposes of this widget, supressing the finalizer */
			dispose(): void;

			/** Gets a string that represents the current object with its ID if specified. */
			ToString(): string;
		}
	}

	export namespace Eto.Forms.Button {
		export interface ICallback extends
			Eto.Forms.TextControl.ICallback,
			Eto.Forms.Control.ICallback,
			Eto.Widget.ICallback {
			OnClick(
				widget: Eto.Forms.Button,
				e: unknown,
			): void;
		}
	}

	export namespace Eto.Forms.Button {
		export interface IHandler extends
			Eto.Forms.TextControl.IHandler,
			Eto.Forms.CommonControl.IHandler,
			Eto.Forms.Control.IHandler,
			Eto.Widget.IHandler {
			Image: Eto.Drawing.Image;

			ImagePosition: Eto.Forms.ButtonImagePosition;

			MinimumSize: Eto.Drawing.Size;
		}
	}

	export namespace Eto.Forms {
		/** Possible modes for the {@link Eto.Forms.Calendar} control. */
		export enum CalendarMode {
			/** Calendar allows only a single date to be selected. */
			Single = 0,

			/**
			 * Can select a range of dates. In some platforms, two calendars will be shown to select
			 * the start and end dates of the range.
			 */
			Range = 1,
		}
	}

	export namespace Eto.Forms {
		/**
		 * Control to show a Calendar, where the user can select either a single date or a range
		 * of dates.
		 */
		export class Calendar implements
			Eto.IHandlerSource,
			Eto.Forms.IBindable,
			Eto.Forms.IMouseInputSource,
			Eto.Forms.IKeyboardInputSource {
			/** Initializes a new instance of the {@link Eto.Forms.Calendar} class. */
			constructor();

			/** Gets or sets the minimum date entered. */
			MinDate: DateTime;

			/** Gets or sets the maximum date entered. */
			MaxDate: DateTime;

			/**
			 * Gets or sets the selected date.
			 *
			 * If {@link Eto.Forms.Calendar.Mode} is {@link Eto.Forms.CalendarMode.Range}, then this
			 * will be most recent date the user selected. To get the selected range, use
			 * {@link Eto.Forms.Calendar.SelectedRange} instead.
			 */
			SelectedDate: DateTime;

			/**
			 * Gets or sets the selected range.
			 *
			 * The {@link Eto.Forms.Calendar.SelectedRange} will have the same start/end dates when
			 * {@link Eto.Forms.Calendar.Mode} is {@link Eto.Forms.CalendarMode.Single}.
			 */
			SelectedRange: Eto.Forms.Range$1<DateTime>;

			/** Gets or sets the mode of the {@link Eto.Forms.Calendar}. */
			Mode: Eto.Forms.CalendarMode;

			/**
			 * Gets a value indicating that the control is loaded onto a form, that is it has been
			 * created, added to a parent, and shown
			 *
			 * The {@link Eto.Forms.Control.OnLoad(System.EventArgs)} method sets this value to true
			 * after cascading to all children (for a {@link Eto.Forms.Container} ) and calling the
			 * platform handler's implementation.  It is called after adding to a loaded form, or
			 * when showing a new form.  The {@link Eto.Forms.Control.OnUnLoad(System.EventArgs)}
			 * method will set this value to false when the control is removed from its parent
			 */
			readonly Loaded: boolean;

			/**
			 * Gets an enumeration of controls that are in the visual tree.
			 *
			 * This is used to specify which controls are contained by this instance that are part of
			 * the visual tree. This should include all controls including non-logical Eto controls
			 * used for layout.
			 */
			readonly VisualControls: Iterable<Eto.Forms.Control>;

			/**
			 * Gets or sets a user-defined object that contains data about the control
			 *
			 * A common use of the tag property is to store data that is associated with the control
			 * that you can later retrieve.
			 */
			Tag: unknown;

			/**
			 * Gets the logical parent control.
			 *
			 * When the control is part of the visual tree (
				 * {@link Eto.Forms.Control.IsVisualControl} is true), this returns the logical parent
				 * that contains this control. Otherwise this is the same as
				 * {@link Eto.Forms.Control.Parent}.
				 */
				readonly LogicalParent: Eto.Forms.Container;

			/** Gets a value indicating this {@link Eto.Forms.Control} is part of the visual tree. */
			IsVisualControl: boolean;

			/**
			 * Gets or sets the size of the control. Use -1 to specify auto sizing for either the
			 * width and/or height.
			 *
			 * Setting the size of controls is entirely optional as most controls will size
			 * themselves appropriately. When specifying a size, it will be used as the desired size
			 * of the control.  The container will reposition and resize the control depending on the
			 * available size.  For a {@link Eto.Forms.Window}, it is preferred to set the
			 * {@link Eto.Forms.Container.ClientSize} instead, as various platforms have different
			 * sizes of window decorations, toolbars, etc.
			 */
			Size: Eto.Drawing.Size;

			/**
			 * Gets a value indicating this control currently has mouse capture
			 *
			 * Mouse capture can happen during a handled MouseDown event until MouseUp, or it can be
			 * captured explicitly via {@link Eto.Forms.Control.CaptureMouse}.
			 */
			readonly IsMouseCaptured: boolean;

			/** Gets or sets the width of the control size. */
			Width: number;

			/** Gets or sets the height of the control size. */
			Height: number;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Forms.Control} (or its
			 * children) are enabled and accept user input.
			 *
			 * Typically when a control is disabled, the user cannot do anything with the control or
			 * any of its children. Including for example, selecting text in a text control. Certain
			 * controls can have a 'Read Only' mode, such as {@link Eto.Forms.TextBox.ReadOnly} which
			 * allow the user to  select text, but not change its contents.
			 */
			Enabled: boolean;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Forms.Control} is visible to
			 * the user.
			 *
			 * When the visibility of a control is set to false, it will not occupy space in the
			 * layout.
			 */
			Visible: boolean;

			/** Gets the container which this control has been added to, if any */
			readonly Parent: Eto.Forms.Container;

			/**
			 * Gets the visual container of this control, if any.
			 *
			 * Some containers may use other Eto controls to layout its children, such as the
			 * {@link Eto.Forms.StackLayout}. This will return the parent control that visually
			 * contains this control as opposed to {@link Eto.Forms.Control.Parent} which will return
			 * the logical parent.
			 */
			VisualParent: Eto.Forms.Container;

			/** Gets a value indicating this control has been attached to a native container */
			readonly IsAttached: boolean;

			/**
			 * Gets or sets the color for the background of the control
			 *
			 * Note that on some platforms (e.g. Mac), setting the background color of a control can
			 * change the performance characteristics of the control and its children, since it must
			 * enable layers to do so.
			 */
			BackgroundColor: Eto.Drawing.Color;

			/** Gets a value indicating whether this instance has the keyboard input focus. */
			readonly HasFocus: boolean;

			/** Gets a value indicating whether the layout of child controls is suspended. */
			readonly IsSuspended: boolean;

			/** Gets the window this control is contained in */
			readonly ParentWindow: Eto.Forms.Window;

			/**
			 * Gets the supported platform commands that can be used to hook up system functions to
			 * user defined logic
			 *
			 * This lists all available commands that can be mapped using the
			 * {@link Eto.Forms.Control.MapPlatformCommand(System.String,Eto.Forms.Command)} method
			 * of the control.
			 */
			readonly SupportedPlatformCommands: Iterable<string>;

			/** Gets the bounding rectangle of this control relative to its container */
			readonly Bounds: Eto.Drawing.Rectangle;

			/**
			 * Gets the location of the control as positioned by the container
			 *
			 * A control's location is set by the container. This can be used to determine where the
			 * control is for overlaying floating windows, menus, etc.
			 */
			readonly Location: Eto.Drawing.Point;

			/** Gets or sets the type of cursor to use when the mouse is hovering over the control */
			Cursor: Eto.Forms.Cursor;

			/** Gets or sets the tool tip to show when the mouse is hovered over the control */
			ToolTip: string;

			/**
			 * Gets or sets the tab index order for this control within its container.
			 *
			 * This sets the order when using the tab key to cycle through controls  Note that some
			 * platforms (Gtk and WinForms) may not support setting the context of the tab order to
			 * StackLayout  or DynamicLayout containers and may not behave exactly as expected. Use
			 * the {@link Eto.PlatformFeatures.TabIndexWithCustomContainers} flag to determine if it
			 * is supported.
			 */
			TabIndex: number;

			/** Gets or sets a value indicating whether this control can serve as drop target. */
			AllowDrop: boolean;

			/**
			 * Gets or sets the parent widget which this widget has been added to, if any
			 *
			 * When implementing child widgets that can participate in the context based binding
			 * (MVVM), You can set this to the parent widget when it is added or removed to it
			 * (usually via a collection).  Note that you should typically provide a public new
			 * [ParentWidget] Parent { get; } property  so that consumers of your API cannot set the
			 * parent to an invalid value.
			 */
			Parent: Eto.Widget;

			/**
			 * Gets an enumeration of all parent widgets in the heirarchy by traversing the
			 * {@link Eto.Forms.BindableWidget.Parent} property.
			 */
			readonly Parents: Iterable<Eto.Widget>;

			/**
			 * Gets or sets the data context for this widget for binding
			 *
			 * Subclasses may override the standard behaviour so that hierarchy of widgets can be
			 * taken into account.  For example, a Control may return the data context of a parent,
			 * if it is not set explicitly.
			 */
			DataContext: unknown;

			/** Gets the collection of bindings that are attached to this widget */
			readonly Bindings: Eto.Forms.BindingCollection;

			/**
			 * Gets a value indicating that the {@link Eto.Forms.BindableWidget.DataContext} property
			 * is changing.
			 *
			 * This can be used to determine when to allow certain logic during the update of the
			 * data context.  It is used to disable binding setters on the model when the data
			 * context changes so that a binding does not cause the view model to be updated when the
			 * state hasn't been fully set yet.
			 */
			IsDataContextChanging: boolean;

			/**
			 * Gets the platform that was used to create the {@link Eto.Widget.Handler} for this
			 * widget
			 *
			 * This gets set to the current {@link Eto.Platform.Instance} during the construction of
			 * the object
			 */
			readonly Platform: Eto.Platform;

			/** Gets the platform-specific handler for this widget */
			Handler: unknown;

			/** Gets the native platform-specific handle for integration purposes */
			readonly NativeHandle: unknown;

			/** Gets the dictionary of properties for this widget */
			readonly Properties: Eto.PropertyStore;

			/** Gets or sets the ID of this widget */
			ID: string;

			/**
			 * Gets or sets the style of this widget
			 *
			 * Styles allow you to attach custom platform-specific logic to a widget. In your
			 * platform-specific assembly, use {@link Style.Add{H}(string, StyleHandler{H})} to add
			 * the style logic with the same id.
			 */
			Style: string;

			/**
			 * Gets the instance of the platform-specific object
			 *
			 * This can sometimes be useful to get the platform-specific object. Some handlers may
			 * not have any backing object for its functionality, so this may be null.  It is more
			 * preferred to use the {@link Eto.Widget.Handler} and cast that to the platform-specific
			 * handler class which can give you additional methods and helpers to do common tasks.
			 * For example, the {@link Eto.Forms.Application} object's handler for OS X has a
			 * AddFullScreenMenuItem property to specify if you want full screen support in your app.
			 */
			readonly ControlObject: unknown;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Widget} has been disposed.
			 *
			 * When the widget is disposed, it can no longer be used.
			 */
			IsDisposed: boolean;

			/**
			 * Queues a repaint of the entire control on the screen and any of its children.
			 *
			 * This is only useful when the control is visible.
			 */
			Invalidate(): void;

			/**
			 * Queues a repaint of the entire control on the screen
			 *
			 * This is only useful when the control is visible.
			 */
			Invalidate(invalidateChildren: boolean): void;

			/**
			 * Queues a repaint of the specified `rect` of the control and any children.
			 *
			 * This is only useful when the control is visible.
			 */
			Invalidate(rect: Eto.Drawing.Rectangle): void;

			/**
			 * Queues a repaint of the specified `rect` of the control
			 *
			 * This is only useful when the control is visible.
			 */
			Invalidate(
				rect: Eto.Drawing.Rectangle,
				invalidateChildren: boolean,
			): void;

			/**
			 * Updates the layout of this control if necessary.
			 *
			 * This will ensure the control has had all of its layout applied so you can use its
			 * position and size right after this call. Most platforms (except WinForms) use a
			 * deferred layout system so that after adding your control to the form dynamically it
			 * won't get laid out until the next idle loop. This is useful when you need to know the
			 * dimensions of the control immediately. Note that this can be an expensive operation,
			 * so it is recommended to only call this method when necessary and after all of the
			 * controls have been added/updated.
			 */
			UpdateLayout(): void;

			/** Gets the preferred size of this control given infinite space available. */
			GetPreferredSize(): Eto.Drawing.SizeF;

			/** Gets the preferred size of this control given the specified `availableSize`. */
			GetPreferredSize(availableSize: Eto.Drawing.SizeF): Eto.Drawing.SizeF;

			/**
			 * Captures all mouse events to this control.
			 *
			 * This captures all mouse events until {@link Eto.Forms.Control.ReleaseMouseCapture} is
			 * called.  Note that not all platforms will allow a mouse capture unless the mouse is
			 * currently down.
			 */
			CaptureMouse(): boolean;

			/** Releases the mouse capture after a call to {@link Eto.Forms.Control.CaptureMouse}. */
			ReleaseMouseCapture(): void;

			/**
			 * Finds a control in the parent hierarchy with the specified type and
			 * {@link Eto.Widget.ID} if specified
			 */
			FindParent(
				type: unknown,
				id?: string,
			): Eto.Forms.Container;

			/** Finds a control in the parent hierarchy with the specified `id` */
			FindParent(id: string): Eto.Forms.Container;

			/**
			 * Detaches the control by removing it from its parent
			 *
			 * This is essentially a shortcut to myControl.Parent.Remove(myControl);
			 */
			Detach(): void;

			/**
			 * Attaches the control for direct use in a native application
			 *
			 * Use this to use a control directly in a native application.  Note that the native
			 * application must be running the same framework as the current platform.  E.g. a
			 * WinForms application can use an Eto.Forms control when using the Eto.WinForms
			 * platform.  This prepares the control by firing the {@link Eto.Forms.Control.PreLoad},
			 * {@link Eto.Forms.Control.Load}, etc. events.
			 */
			AttachNative(): void;

			/**
			 * Detaches the control when it is used in a native application, when you want to reuse
			 * the control.
			 *
			 * This should only be called after {@link Eto.Forms.Control.AttachNative} has been
			 * called, which is usually done by calling to ToNative(true) .
			 */
			DetachNative(): void;

			/**
			 * Attempts to set the keyboard input focus to this control, or the first child that
			 * accepts focus. For Windows, this will bring it to front and activate it.
			 */
			Focus(): void;

			/**
			 * Suspends the layout of child controls
			 *
			 * This can be used to optimize some platforms while adding, removing, or changing many
			 * child controls at once. It disables the calculation of control positioning until
			 * {@link Eto.Forms.Control.ResumeLayout} is called. Each call to SuspendLayout() must be
			 * balanced with a call to {@link Eto.Forms.Control.ResumeLayout}.
			 */
			SuspendLayout(): void;

			/**
			 * Resumes the layout after it has been suspended, and performs a layout
			 *
			 * This can be used to optimize some platforms while adding, removing, or changing many
			 * child controls at once. Each call to ResumeLayout() must be balanced with a call to
			 * {@link Eto.Forms.Control.SuspendLayout} before it.
			 */
			ResumeLayout(): void;

			/**
			 * Specifies a command to execute for a platform-specific command
			 *
			 * Some platforms have specific system-defined commands that can be associated with a
			 * control. For example, the Mac platform's cut/copy/paste functionality is defined by
			 * the system, and if you want to hook into it, you can use this to map it to your own
			 * defined logic. The valid values of the `systemCommand` parameter are defined by each
			 * platform, and a list can be retrieved using
			 * {@link Eto.Forms.Control.SupportedPlatformCommands}
			 */
			MapPlatformCommand(
				systemCommand: string,
				command: Eto.Forms.Command,
			): void;

			/** Converts a point from screen space to control space. */
			PointFromScreen(point: Eto.Drawing.PointF): Eto.Drawing.PointF;

			/** Converts a point from control space to screen space */
			PointToScreen(point: Eto.Drawing.PointF): Eto.Drawing.PointF;

			/** Converts a rectangle from screen space to control space. */
			RectangleToScreen(rect: Eto.Drawing.RectangleF): Eto.Drawing.RectangleF;

			/** Converts a rectangle from control space to screen space */
			RectangleFromScreen(rect: Eto.Drawing.RectangleF): Eto.Drawing.RectangleF;

			/**
			 * Starts drag operation using this control as drag source.
			 *
			 * This method can be blocking on some platforms (Wpf, WinForms), and non-blocking on
			 * others (Mac, Gtk). Use the {@link Eto.Forms.Control.DragEnd} event to determine when
			 * the drag operation is completed and get its resulting DragEffects.
			 */
			DoDragDrop(
				data: Eto.Forms.DataObject,
				allowedEffects: Eto.Forms.DragEffects,
			): void;

			/**
			 * Starts drag operation using this control as drag source.
			 *
			 * This method can be blocking on some platforms (Wpf, WinForms), and non-blocking on
			 * others (Mac, Gtk). Use the {@link Eto.Forms.Control.DragEnd} event to determine when
			 * the drag operation is completed and get its resulting DragEffects.
			 */
			DoDragDrop(
				data: Eto.Forms.DataObject,
				allowedEffects: Eto.Forms.DragEffects,
				image: Eto.Drawing.Image,
				cursorOffset: Eto.Drawing.PointF,
			): void;

			/**
			 * Triggers the StyleChanged event and re-applies the styles to this control and its
			 * children.
			 */
			TriggerStyleChanged(): void;

			/** Shows a print dialog to print the specified control */
			Print(): void;

			/**
			 * Finds a control in the parent hierarchy with the specified type and
			 * {@link Eto.Widget.ID} if specified
			 */
			FindParent<T>(id?: string): T;

			/**
			 * Finds a control in the parent hierarchy with the specified type and
			 * {@link Eto.Widget.ID} if specified
			 */
			FindParent(
				type: unknown,
				id?: string,
			): Eto.Widget;

			/** Finds a control in the parent hierarchy with the specified `id` */
			FindParent(id: string): Eto.Widget;

			/**
			 * Unbinds any bindings in the {@link Eto.Forms.BindableWidget.Bindings} collection and
			 * removes the bindings
			 *
			 * When you implement {@link Eto.Forms.IBindableWidgetContainer}, this will also unbind
			 * any of its children.
			 */
			Unbind(): void;

			/**
			 * Updates all bindings in this widget
			 *
			 * When you implement {@link Eto.Forms.IBindableWidgetContainer}, this will also update
			 * bindings for all of its children.
			 */
			UpdateBindings(mode?: Eto.Forms.BindingUpdateMode): void;

			/** Disposes of this widget, supressing the finalizer */
			dispose(): void;

			/** Gets a string that represents the current object with its ID if specified. */
			ToString(): string;
		}
	}

	export namespace Eto.Forms.Calendar {
		export interface ICallback extends
			Eto.Forms.Control.ICallback,
			Eto.Widget.ICallback {
			OnSelectedDateChanged(
				widget: Eto.Forms.Calendar,
				e: unknown,
			): void;

			OnSelectedRangeChanged(
				widget: Eto.Forms.Calendar,
				e: unknown,
			): void;
		}
	}

	export namespace Eto.Forms.Calendar {
		export interface IHandler extends
			Eto.Forms.Control.IHandler,
			Eto.Widget.IHandler {
			MinDate: DateTime;

			MaxDate: DateTime;

			SelectedRange: Eto.Forms.Range$1<DateTime>;

			SelectedDate: DateTime;

			Mode: Eto.Forms.CalendarMode;
		}
	}

	export namespace Eto.Forms {
		/**
		 * A control that shows a two or three state check box.
		 *
		 * A two state check box is either checked ( `true` ) or unchecked ( `false` ).  A three
		 * state check box can also have an additional `null` value.
		 */
		export class CheckBox implements
			Eto.IHandlerSource,
			Eto.Forms.IBindable,
			Eto.Forms.IMouseInputSource,
			Eto.Forms.IKeyboardInputSource {
			constructor();

			/**
			 * Gets or sets the checked state.
			 *
			 * When {@link Eto.Forms.CheckBox.ThreeState} is `true`, `null` signifies an
			 * indeterminate value.
			 */
			Checked?: boolean;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Forms.CheckBox} allows three
			 * states: `true`, `false`, or `null`.
			 */
			ThreeState: boolean;

			/** Gets a binding for the {@link Eto.Forms.CheckBox.Checked} property. */
			readonly CheckedBinding: Eto.Forms.BindableBinding$2<Eto.Forms.CheckBox, boolean | undefined>;

			/**
			 * Gets or sets the text of the control.
			 *
			 * Usually, the caret and selection will be set to the end of the string after its set.
			 */
			Text: string;

			/**
			 * Gets or sets the color of the text.
			 *
			 * By default, the text will get a color based on the user's theme. However, this is
			 * usually black.
			 */
			TextColor: Eto.Drawing.Color;

			/** Gets the binding for the {@link Eto.Forms.TextControl.Text} property. */
			readonly TextBinding: Eto.Forms.BindableBinding$2<Eto.Forms.TextControl, string>;

			/** Gets or sets the font for the text of the control */
			Font: Eto.Drawing.Font;

			/**
			 * Gets a value indicating that the control is loaded onto a form, that is it has been
			 * created, added to a parent, and shown
			 *
			 * The {@link Eto.Forms.Control.OnLoad(System.EventArgs)} method sets this value to true
			 * after cascading to all children (for a {@link Eto.Forms.Container} ) and calling the
			 * platform handler's implementation.  It is called after adding to a loaded form, or
			 * when showing a new form.  The {@link Eto.Forms.Control.OnUnLoad(System.EventArgs)}
			 * method will set this value to false when the control is removed from its parent
			 */
			readonly Loaded: boolean;

			/**
			 * Gets an enumeration of controls that are in the visual tree.
			 *
			 * This is used to specify which controls are contained by this instance that are part of
			 * the visual tree. This should include all controls including non-logical Eto controls
			 * used for layout.
			 */
			readonly VisualControls: Iterable<Eto.Forms.Control>;

			/**
			 * Gets or sets a user-defined object that contains data about the control
			 *
			 * A common use of the tag property is to store data that is associated with the control
			 * that you can later retrieve.
			 */
			Tag: unknown;

			/**
			 * Gets the logical parent control.
			 *
			 * When the control is part of the visual tree (
				 * {@link Eto.Forms.Control.IsVisualControl} is true), this returns the logical parent
				 * that contains this control. Otherwise this is the same as
				 * {@link Eto.Forms.Control.Parent}.
				 */
				readonly LogicalParent: Eto.Forms.Container;

			/** Gets a value indicating this {@link Eto.Forms.Control} is part of the visual tree. */
			IsVisualControl: boolean;

			/**
			 * Gets or sets the size of the control. Use -1 to specify auto sizing for either the
			 * width and/or height.
			 *
			 * Setting the size of controls is entirely optional as most controls will size
			 * themselves appropriately. When specifying a size, it will be used as the desired size
			 * of the control.  The container will reposition and resize the control depending on the
			 * available size.  For a {@link Eto.Forms.Window}, it is preferred to set the
			 * {@link Eto.Forms.Container.ClientSize} instead, as various platforms have different
			 * sizes of window decorations, toolbars, etc.
			 */
			Size: Eto.Drawing.Size;

			/**
			 * Gets a value indicating this control currently has mouse capture
			 *
			 * Mouse capture can happen during a handled MouseDown event until MouseUp, or it can be
			 * captured explicitly via {@link Eto.Forms.Control.CaptureMouse}.
			 */
			readonly IsMouseCaptured: boolean;

			/** Gets or sets the width of the control size. */
			Width: number;

			/** Gets or sets the height of the control size. */
			Height: number;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Forms.Control} (or its
			 * children) are enabled and accept user input.
			 *
			 * Typically when a control is disabled, the user cannot do anything with the control or
			 * any of its children. Including for example, selecting text in a text control. Certain
			 * controls can have a 'Read Only' mode, such as {@link Eto.Forms.TextBox.ReadOnly} which
			 * allow the user to  select text, but not change its contents.
			 */
			Enabled: boolean;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Forms.Control} is visible to
			 * the user.
			 *
			 * When the visibility of a control is set to false, it will not occupy space in the
			 * layout.
			 */
			Visible: boolean;

			/** Gets the container which this control has been added to, if any */
			readonly Parent: Eto.Forms.Container;

			/**
			 * Gets the visual container of this control, if any.
			 *
			 * Some containers may use other Eto controls to layout its children, such as the
			 * {@link Eto.Forms.StackLayout}. This will return the parent control that visually
			 * contains this control as opposed to {@link Eto.Forms.Control.Parent} which will return
			 * the logical parent.
			 */
			VisualParent: Eto.Forms.Container;

			/** Gets a value indicating this control has been attached to a native container */
			readonly IsAttached: boolean;

			/**
			 * Gets or sets the color for the background of the control
			 *
			 * Note that on some platforms (e.g. Mac), setting the background color of a control can
			 * change the performance characteristics of the control and its children, since it must
			 * enable layers to do so.
			 */
			BackgroundColor: Eto.Drawing.Color;

			/** Gets a value indicating whether this instance has the keyboard input focus. */
			readonly HasFocus: boolean;

			/** Gets a value indicating whether the layout of child controls is suspended. */
			readonly IsSuspended: boolean;

			/** Gets the window this control is contained in */
			readonly ParentWindow: Eto.Forms.Window;

			/**
			 * Gets the supported platform commands that can be used to hook up system functions to
			 * user defined logic
			 *
			 * This lists all available commands that can be mapped using the
			 * {@link Eto.Forms.Control.MapPlatformCommand(System.String,Eto.Forms.Command)} method
			 * of the control.
			 */
			readonly SupportedPlatformCommands: Iterable<string>;

			/** Gets the bounding rectangle of this control relative to its container */
			readonly Bounds: Eto.Drawing.Rectangle;

			/**
			 * Gets the location of the control as positioned by the container
			 *
			 * A control's location is set by the container. This can be used to determine where the
			 * control is for overlaying floating windows, menus, etc.
			 */
			readonly Location: Eto.Drawing.Point;

			/** Gets or sets the type of cursor to use when the mouse is hovering over the control */
			Cursor: Eto.Forms.Cursor;

			/** Gets or sets the tool tip to show when the mouse is hovered over the control */
			ToolTip: string;

			/**
			 * Gets or sets the tab index order for this control within its container.
			 *
			 * This sets the order when using the tab key to cycle through controls  Note that some
			 * platforms (Gtk and WinForms) may not support setting the context of the tab order to
			 * StackLayout  or DynamicLayout containers and may not behave exactly as expected. Use
			 * the {@link Eto.PlatformFeatures.TabIndexWithCustomContainers} flag to determine if it
			 * is supported.
			 */
			TabIndex: number;

			/** Gets or sets a value indicating whether this control can serve as drop target. */
			AllowDrop: boolean;

			/**
			 * Gets or sets the parent widget which this widget has been added to, if any
			 *
			 * When implementing child widgets that can participate in the context based binding
			 * (MVVM), You can set this to the parent widget when it is added or removed to it
			 * (usually via a collection).  Note that you should typically provide a public new
			 * [ParentWidget] Parent { get; } property  so that consumers of your API cannot set the
			 * parent to an invalid value.
			 */
			Parent: Eto.Widget;

			/**
			 * Gets an enumeration of all parent widgets in the heirarchy by traversing the
			 * {@link Eto.Forms.BindableWidget.Parent} property.
			 */
			readonly Parents: Iterable<Eto.Widget>;

			/**
			 * Gets or sets the data context for this widget for binding
			 *
			 * Subclasses may override the standard behaviour so that hierarchy of widgets can be
			 * taken into account.  For example, a Control may return the data context of a parent,
			 * if it is not set explicitly.
			 */
			DataContext: unknown;

			/** Gets the collection of bindings that are attached to this widget */
			readonly Bindings: Eto.Forms.BindingCollection;

			/**
			 * Gets a value indicating that the {@link Eto.Forms.BindableWidget.DataContext} property
			 * is changing.
			 *
			 * This can be used to determine when to allow certain logic during the update of the
			 * data context.  It is used to disable binding setters on the model when the data
			 * context changes so that a binding does not cause the view model to be updated when the
			 * state hasn't been fully set yet.
			 */
			IsDataContextChanging: boolean;

			/**
			 * Gets the platform that was used to create the {@link Eto.Widget.Handler} for this
			 * widget
			 *
			 * This gets set to the current {@link Eto.Platform.Instance} during the construction of
			 * the object
			 */
			readonly Platform: Eto.Platform;

			/** Gets the platform-specific handler for this widget */
			Handler: unknown;

			/** Gets the native platform-specific handle for integration purposes */
			readonly NativeHandle: unknown;

			/** Gets the dictionary of properties for this widget */
			readonly Properties: Eto.PropertyStore;

			/** Gets or sets the ID of this widget */
			ID: string;

			/**
			 * Gets or sets the style of this widget
			 *
			 * Styles allow you to attach custom platform-specific logic to a widget. In your
			 * platform-specific assembly, use {@link Style.Add{H}(string, StyleHandler{H})} to add
			 * the style logic with the same id.
			 */
			Style: string;

			/**
			 * Gets the instance of the platform-specific object
			 *
			 * This can sometimes be useful to get the platform-specific object. Some handlers may
			 * not have any backing object for its functionality, so this may be null.  It is more
			 * preferred to use the {@link Eto.Widget.Handler} and cast that to the platform-specific
			 * handler class which can give you additional methods and helpers to do common tasks.
			 * For example, the {@link Eto.Forms.Application} object's handler for OS X has a
			 * AddFullScreenMenuItem property to specify if you want full screen support in your app.
			 */
			readonly ControlObject: unknown;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Widget} has been disposed.
			 *
			 * When the widget is disposed, it can no longer be used.
			 */
			IsDisposed: boolean;

			/**
			 * Queues a repaint of the entire control on the screen and any of its children.
			 *
			 * This is only useful when the control is visible.
			 */
			Invalidate(): void;

			/**
			 * Queues a repaint of the entire control on the screen
			 *
			 * This is only useful when the control is visible.
			 */
			Invalidate(invalidateChildren: boolean): void;

			/**
			 * Queues a repaint of the specified `rect` of the control and any children.
			 *
			 * This is only useful when the control is visible.
			 */
			Invalidate(rect: Eto.Drawing.Rectangle): void;

			/**
			 * Queues a repaint of the specified `rect` of the control
			 *
			 * This is only useful when the control is visible.
			 */
			Invalidate(
				rect: Eto.Drawing.Rectangle,
				invalidateChildren: boolean,
			): void;

			/**
			 * Updates the layout of this control if necessary.
			 *
			 * This will ensure the control has had all of its layout applied so you can use its
			 * position and size right after this call. Most platforms (except WinForms) use a
			 * deferred layout system so that after adding your control to the form dynamically it
			 * won't get laid out until the next idle loop. This is useful when you need to know the
			 * dimensions of the control immediately. Note that this can be an expensive operation,
			 * so it is recommended to only call this method when necessary and after all of the
			 * controls have been added/updated.
			 */
			UpdateLayout(): void;

			/** Gets the preferred size of this control given infinite space available. */
			GetPreferredSize(): Eto.Drawing.SizeF;

			/** Gets the preferred size of this control given the specified `availableSize`. */
			GetPreferredSize(availableSize: Eto.Drawing.SizeF): Eto.Drawing.SizeF;

			/**
			 * Captures all mouse events to this control.
			 *
			 * This captures all mouse events until {@link Eto.Forms.Control.ReleaseMouseCapture} is
			 * called.  Note that not all platforms will allow a mouse capture unless the mouse is
			 * currently down.
			 */
			CaptureMouse(): boolean;

			/** Releases the mouse capture after a call to {@link Eto.Forms.Control.CaptureMouse}. */
			ReleaseMouseCapture(): void;

			/**
			 * Finds a control in the parent hierarchy with the specified type and
			 * {@link Eto.Widget.ID} if specified
			 */
			FindParent(
				type: unknown,
				id?: string,
			): Eto.Forms.Container;

			/** Finds a control in the parent hierarchy with the specified `id` */
			FindParent(id: string): Eto.Forms.Container;

			/**
			 * Detaches the control by removing it from its parent
			 *
			 * This is essentially a shortcut to myControl.Parent.Remove(myControl);
			 */
			Detach(): void;

			/**
			 * Attaches the control for direct use in a native application
			 *
			 * Use this to use a control directly in a native application.  Note that the native
			 * application must be running the same framework as the current platform.  E.g. a
			 * WinForms application can use an Eto.Forms control when using the Eto.WinForms
			 * platform.  This prepares the control by firing the {@link Eto.Forms.Control.PreLoad},
			 * {@link Eto.Forms.Control.Load}, etc. events.
			 */
			AttachNative(): void;

			/**
			 * Detaches the control when it is used in a native application, when you want to reuse
			 * the control.
			 *
			 * This should only be called after {@link Eto.Forms.Control.AttachNative} has been
			 * called, which is usually done by calling to ToNative(true) .
			 */
			DetachNative(): void;

			/**
			 * Attempts to set the keyboard input focus to this control, or the first child that
			 * accepts focus. For Windows, this will bring it to front and activate it.
			 */
			Focus(): void;

			/**
			 * Suspends the layout of child controls
			 *
			 * This can be used to optimize some platforms while adding, removing, or changing many
			 * child controls at once. It disables the calculation of control positioning until
			 * {@link Eto.Forms.Control.ResumeLayout} is called. Each call to SuspendLayout() must be
			 * balanced with a call to {@link Eto.Forms.Control.ResumeLayout}.
			 */
			SuspendLayout(): void;

			/**
			 * Resumes the layout after it has been suspended, and performs a layout
			 *
			 * This can be used to optimize some platforms while adding, removing, or changing many
			 * child controls at once. Each call to ResumeLayout() must be balanced with a call to
			 * {@link Eto.Forms.Control.SuspendLayout} before it.
			 */
			ResumeLayout(): void;

			/**
			 * Specifies a command to execute for a platform-specific command
			 *
			 * Some platforms have specific system-defined commands that can be associated with a
			 * control. For example, the Mac platform's cut/copy/paste functionality is defined by
			 * the system, and if you want to hook into it, you can use this to map it to your own
			 * defined logic. The valid values of the `systemCommand` parameter are defined by each
			 * platform, and a list can be retrieved using
			 * {@link Eto.Forms.Control.SupportedPlatformCommands}
			 */
			MapPlatformCommand(
				systemCommand: string,
				command: Eto.Forms.Command,
			): void;

			/** Converts a point from screen space to control space. */
			PointFromScreen(point: Eto.Drawing.PointF): Eto.Drawing.PointF;

			/** Converts a point from control space to screen space */
			PointToScreen(point: Eto.Drawing.PointF): Eto.Drawing.PointF;

			/** Converts a rectangle from screen space to control space. */
			RectangleToScreen(rect: Eto.Drawing.RectangleF): Eto.Drawing.RectangleF;

			/** Converts a rectangle from control space to screen space */
			RectangleFromScreen(rect: Eto.Drawing.RectangleF): Eto.Drawing.RectangleF;

			/**
			 * Starts drag operation using this control as drag source.
			 *
			 * This method can be blocking on some platforms (Wpf, WinForms), and non-blocking on
			 * others (Mac, Gtk). Use the {@link Eto.Forms.Control.DragEnd} event to determine when
			 * the drag operation is completed and get its resulting DragEffects.
			 */
			DoDragDrop(
				data: Eto.Forms.DataObject,
				allowedEffects: Eto.Forms.DragEffects,
			): void;

			/**
			 * Starts drag operation using this control as drag source.
			 *
			 * This method can be blocking on some platforms (Wpf, WinForms), and non-blocking on
			 * others (Mac, Gtk). Use the {@link Eto.Forms.Control.DragEnd} event to determine when
			 * the drag operation is completed and get its resulting DragEffects.
			 */
			DoDragDrop(
				data: Eto.Forms.DataObject,
				allowedEffects: Eto.Forms.DragEffects,
				image: Eto.Drawing.Image,
				cursorOffset: Eto.Drawing.PointF,
			): void;

			/**
			 * Triggers the StyleChanged event and re-applies the styles to this control and its
			 * children.
			 */
			TriggerStyleChanged(): void;

			/** Shows a print dialog to print the specified control */
			Print(): void;

			/**
			 * Finds a control in the parent hierarchy with the specified type and
			 * {@link Eto.Widget.ID} if specified
			 */
			FindParent<T>(id?: string): T;

			/**
			 * Finds a control in the parent hierarchy with the specified type and
			 * {@link Eto.Widget.ID} if specified
			 */
			FindParent(
				type: unknown,
				id?: string,
			): Eto.Widget;

			/** Finds a control in the parent hierarchy with the specified `id` */
			FindParent(id: string): Eto.Widget;

			/**
			 * Unbinds any bindings in the {@link Eto.Forms.BindableWidget.Bindings} collection and
			 * removes the bindings
			 *
			 * When you implement {@link Eto.Forms.IBindableWidgetContainer}, this will also unbind
			 * any of its children.
			 */
			Unbind(): void;

			/**
			 * Updates all bindings in this widget
			 *
			 * When you implement {@link Eto.Forms.IBindableWidgetContainer}, this will also update
			 * bindings for all of its children.
			 */
			UpdateBindings(mode?: Eto.Forms.BindingUpdateMode): void;

			/** Disposes of this widget, supressing the finalizer */
			dispose(): void;

			/** Gets a string that represents the current object with its ID if specified. */
			ToString(): string;
		}
	}

	export namespace Eto.Forms.CheckBox {
		export interface ICallback extends
			Eto.Forms.TextControl.ICallback,
			Eto.Forms.Control.ICallback,
			Eto.Widget.ICallback {
			OnCheckedChanged(
				widget: Eto.Forms.CheckBox,
				e: unknown,
			): void;
		}
	}

	export namespace Eto.Forms.CheckBox {
		export interface IHandler extends
			Eto.Forms.TextControl.IHandler,
			Eto.Forms.CommonControl.IHandler,
			Eto.Forms.Control.IHandler,
			Eto.Widget.IHandler {
			Checked?: boolean;

			ThreeState: boolean;
		}
	}

	export namespace Eto.Forms {
		/**
		 * A control that shows a list of check boxes.
		 *
		 * The list of items can be added manually by using {@link Eto.Forms.CheckBoxList.Items}.
		 *  Use {@link Eto.Forms.CheckBoxList.DataStore} to have a dynamic list of items
		 * controlled by a custom collection.
		 */
		export class CheckBoxList implements
			Eto.IHandlerSource,
			Eto.Forms.IBindable,
			Eto.Forms.IMouseInputSource,
			Eto.Forms.IKeyboardInputSource {
			/** Initializes a new instance of the {@link Eto.Forms.CheckBoxList} class. */
			constructor();

			/**
			 * Gets or sets the binding to get the text for each check box.
			 *
			 * By default, this will bind to a "Text" property, or {@link Eto.Forms.IListItem.Text}
			 * when implemented.
			 */
			ItemTextBinding: Eto.Forms.IIndirectBinding$1<string>;

			/** Gets or sets the binding to get the tooltip for each check box. */
			ItemToolTipBinding: Eto.Forms.IIndirectBinding$1<string>;

			/**
			 * Gets or sets the binding to get the key for each check box.
			 *
			 * By default, this will bind to a "Key" property, or {@link Eto.Forms.IListItem.Key}
			 * when implemented.
			 */
			ItemKeyBinding: Eto.Forms.IIndirectBinding$1<string>;

			/**
			 * Gets or sets the selected key of the currently selected item using
			 * {@link Eto.Forms.CheckBoxList.ItemKeyBinding}.
			 */
			SelectedKeys: Iterable<string>;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Forms.CheckBoxList} is
			 * enabled.
			 *
			 * When the control is disabled, the user will not be able to change the selected check
			 * box. However, you can still programatically change the selection.
			 */
			Enabled: boolean;

			/**
			 * Gets or sets the selected values, which are {@link Eto.Forms.ListItem} s or objects in
			 * your custom data store.
			 */
			SelectedValues: Iterable<unknown>;

			/** Gets or sets the color of the check box text. */
			TextColor: Eto.Drawing.Color;

			/** Gets or sets the orientation of the check boxes. */
			Orientation: Eto.Forms.Orientation;

			/** Gets or sets the spacing between each check box. */
			Spacing: Eto.Drawing.Size;

			/**
			 * Gets the item collection, when adding items programatically.
			 *
			 * This is used when you want to add items manually. Use
			 * {@link Eto.Forms.CheckBoxList.DataStore} when you have an existing collection you want
			 * to bind to directly.
			 */
			readonly Items: Eto.Forms.ListItemCollection;

			/**
			 * Gets or sets the data store of the items shown in the list.
			 *
			 * When using a custom object collection, you can use the
			 * {@link Eto.Forms.CheckBoxList.ItemTextBinding} and
			 * {@link Eto.Forms.CheckBoxList.ItemKeyBinding} to specify how to get the text/key
			 * values for each item.
			 */
			DataStore: Iterable<unknown>;

			/** Gets a binding to the {@link Eto.Forms.CheckBoxList.SelectedValues} property. */
			readonly SelectedValuesBinding: Eto.Forms.BindableBinding$2<Eto.Forms.CheckBoxList, Iterable<unknown>>;

			/** Gets a binding to the {@link Eto.Forms.CheckBoxList.SelectedKeys} property. */
			readonly SelectedKeysBinding: Eto.Forms.BindableBinding$2<Eto.Forms.CheckBoxList, Iterable<string>>;

			/** Gets an enumeration of controls that are directly contained by this container */
			readonly Controls: Iterable<Eto.Forms.Control>;

			/** Gets or sets the padding around the {@link Eto.Forms.Panel.Content} of the panel. */
			Padding: Eto.Drawing.Padding;

			/** Gets or sets the minimum size of the panel. */
			MinimumSize: Eto.Drawing.Size;

			/**
			 * Gets or sets the context menu for the panel.
			 *
			 * The context menu is usually shown when the user right clicks the control, or in mobile
			 * platforms when the user taps and holds their finger down on the control.
			 */
			ContextMenu: Eto.Forms.ContextMenu;

			/**
			 * Gets or sets the main content of the panel.
			 *
			 * The main content will be offset by the {@link Eto.Forms.Panel.Padding} value
			 * specified, and will take up the entire content area of the control. Some controls may
			 * have decorations that will surround the content, such as a {@link Eto.Forms.GroupBox},
			 * {@link Eto.Forms.TabControl}, or {@link Eto.Forms.Window}
			 */
			Content: Eto.Forms.Control;

			/**
			 * Gets or sets the size for the client area of the control
			 *
			 * The client size differs from the {@link Eto.Forms.Control.Size} in that it excludes
			 * the decorations of the container, such as the title bar and border around a
			 * {@link Eto.Forms.Window}, or the title and line  around a {@link Eto.Forms.GroupBox}.
			 */
			ClientSize: Eto.Drawing.Size;

			/**
			 * Gets an enumeration of all contained child controls, including controls within child
			 * containers
			 */
			readonly Children: Iterable<Eto.Forms.Control>;

			/**
			 * Gets an enumeration of all contained child controls in the visual tree, including
			 * controls within child containers.
			 */
			readonly VisualChildren: Iterable<Eto.Forms.Control>;

			/**
			 * Gets or sets the style provider for this container.
			 *
			 * The style provider is used to style this container and its children.
			 */
			StyleProvider: Eto.IStyleProvider;

			/**
			 * Gets the default style provider for this container.
			 *
			 * Use this to apply styles to any child controls of this container. By default, styles
			 * will apply to all children, including children of children unless
			 * {@link Eto.DefaultStyleProvider.Inherit} is set to false .  Typically, you would set
			 * Inherit to false when creating composite controls that already have all their styles
			 * applied and you don't want any other styles to be inherited.
			 */
			readonly Styles: Eto.DefaultStyleProvider;

			/**
			 * Gets a value indicating that the control is loaded onto a form, that is it has been
			 * created, added to a parent, and shown
			 *
			 * The {@link Eto.Forms.Control.OnLoad(System.EventArgs)} method sets this value to true
			 * after cascading to all children (for a {@link Eto.Forms.Container} ) and calling the
			 * platform handler's implementation.  It is called after adding to a loaded form, or
			 * when showing a new form.  The {@link Eto.Forms.Control.OnUnLoad(System.EventArgs)}
			 * method will set this value to false when the control is removed from its parent
			 */
			readonly Loaded: boolean;

			/**
			 * Gets an enumeration of controls that are in the visual tree.
			 *
			 * This is used to specify which controls are contained by this instance that are part of
			 * the visual tree. This should include all controls including non-logical Eto controls
			 * used for layout.
			 */
			readonly VisualControls: Iterable<Eto.Forms.Control>;

			/**
			 * Gets or sets a user-defined object that contains data about the control
			 *
			 * A common use of the tag property is to store data that is associated with the control
			 * that you can later retrieve.
			 */
			Tag: unknown;

			/**
			 * Gets the logical parent control.
			 *
			 * When the control is part of the visual tree (
				 * {@link Eto.Forms.Control.IsVisualControl} is true), this returns the logical parent
				 * that contains this control. Otherwise this is the same as
				 * {@link Eto.Forms.Control.Parent}.
				 */
				readonly LogicalParent: Eto.Forms.Container;

			/** Gets a value indicating this {@link Eto.Forms.Control} is part of the visual tree. */
			IsVisualControl: boolean;

			/**
			 * Gets or sets the size of the control. Use -1 to specify auto sizing for either the
			 * width and/or height.
			 *
			 * Setting the size of controls is entirely optional as most controls will size
			 * themselves appropriately. When specifying a size, it will be used as the desired size
			 * of the control.  The container will reposition and resize the control depending on the
			 * available size.  For a {@link Eto.Forms.Window}, it is preferred to set the
			 * {@link Eto.Forms.Container.ClientSize} instead, as various platforms have different
			 * sizes of window decorations, toolbars, etc.
			 */
			Size: Eto.Drawing.Size;

			/**
			 * Gets a value indicating this control currently has mouse capture
			 *
			 * Mouse capture can happen during a handled MouseDown event until MouseUp, or it can be
			 * captured explicitly via {@link Eto.Forms.Control.CaptureMouse}.
			 */
			readonly IsMouseCaptured: boolean;

			/** Gets or sets the width of the control size. */
			Width: number;

			/** Gets or sets the height of the control size. */
			Height: number;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Forms.Control} is visible to
			 * the user.
			 *
			 * When the visibility of a control is set to false, it will not occupy space in the
			 * layout.
			 */
			Visible: boolean;

			/** Gets the container which this control has been added to, if any */
			readonly Parent: Eto.Forms.Container;

			/**
			 * Gets the visual container of this control, if any.
			 *
			 * Some containers may use other Eto controls to layout its children, such as the
			 * {@link Eto.Forms.StackLayout}. This will return the parent control that visually
			 * contains this control as opposed to {@link Eto.Forms.Control.Parent} which will return
			 * the logical parent.
			 */
			VisualParent: Eto.Forms.Container;

			/** Gets a value indicating this control has been attached to a native container */
			readonly IsAttached: boolean;

			/**
			 * Gets or sets the color for the background of the control
			 *
			 * Note that on some platforms (e.g. Mac), setting the background color of a control can
			 * change the performance characteristics of the control and its children, since it must
			 * enable layers to do so.
			 */
			BackgroundColor: Eto.Drawing.Color;

			/** Gets a value indicating whether this instance has the keyboard input focus. */
			readonly HasFocus: boolean;

			/** Gets a value indicating whether the layout of child controls is suspended. */
			readonly IsSuspended: boolean;

			/** Gets the window this control is contained in */
			readonly ParentWindow: Eto.Forms.Window;

			/**
			 * Gets the supported platform commands that can be used to hook up system functions to
			 * user defined logic
			 *
			 * This lists all available commands that can be mapped using the
			 * {@link Eto.Forms.Control.MapPlatformCommand(System.String,Eto.Forms.Command)} method
			 * of the control.
			 */
			readonly SupportedPlatformCommands: Iterable<string>;

			/** Gets the bounding rectangle of this control relative to its container */
			readonly Bounds: Eto.Drawing.Rectangle;

			/**
			 * Gets the location of the control as positioned by the container
			 *
			 * A control's location is set by the container. This can be used to determine where the
			 * control is for overlaying floating windows, menus, etc.
			 */
			readonly Location: Eto.Drawing.Point;

			/** Gets or sets the type of cursor to use when the mouse is hovering over the control */
			Cursor: Eto.Forms.Cursor;

			/** Gets or sets the tool tip to show when the mouse is hovered over the control */
			ToolTip: string;

			/**
			 * Gets or sets the tab index order for this control within its container.
			 *
			 * This sets the order when using the tab key to cycle through controls  Note that some
			 * platforms (Gtk and WinForms) may not support setting the context of the tab order to
			 * StackLayout  or DynamicLayout containers and may not behave exactly as expected. Use
			 * the {@link Eto.PlatformFeatures.TabIndexWithCustomContainers} flag to determine if it
			 * is supported.
			 */
			TabIndex: number;

			/** Gets or sets a value indicating whether this control can serve as drop target. */
			AllowDrop: boolean;

			/**
			 * Gets or sets the parent widget which this widget has been added to, if any
			 *
			 * When implementing child widgets that can participate in the context based binding
			 * (MVVM), You can set this to the parent widget when it is added or removed to it
			 * (usually via a collection).  Note that you should typically provide a public new
			 * [ParentWidget] Parent { get; } property  so that consumers of your API cannot set the
			 * parent to an invalid value.
			 */
			Parent: Eto.Widget;

			/**
			 * Gets an enumeration of all parent widgets in the heirarchy by traversing the
			 * {@link Eto.Forms.BindableWidget.Parent} property.
			 */
			readonly Parents: Iterable<Eto.Widget>;

			/**
			 * Gets or sets the data context for this widget for binding
			 *
			 * Subclasses may override the standard behaviour so that hierarchy of widgets can be
			 * taken into account.  For example, a Control may return the data context of a parent,
			 * if it is not set explicitly.
			 */
			DataContext: unknown;

			/** Gets the collection of bindings that are attached to this widget */
			readonly Bindings: Eto.Forms.BindingCollection;

			/**
			 * Gets a value indicating that the {@link Eto.Forms.BindableWidget.DataContext} property
			 * is changing.
			 *
			 * This can be used to determine when to allow certain logic during the update of the
			 * data context.  It is used to disable binding setters on the model when the data
			 * context changes so that a binding does not cause the view model to be updated when the
			 * state hasn't been fully set yet.
			 */
			IsDataContextChanging: boolean;

			/**
			 * Gets the platform that was used to create the {@link Eto.Widget.Handler} for this
			 * widget
			 *
			 * This gets set to the current {@link Eto.Platform.Instance} during the construction of
			 * the object
			 */
			readonly Platform: Eto.Platform;

			/** Gets the platform-specific handler for this widget */
			Handler: unknown;

			/** Gets the native platform-specific handle for integration purposes */
			readonly NativeHandle: unknown;

			/** Gets the dictionary of properties for this widget */
			readonly Properties: Eto.PropertyStore;

			/** Gets or sets the ID of this widget */
			ID: string;

			/**
			 * Gets or sets the style of this widget
			 *
			 * Styles allow you to attach custom platform-specific logic to a widget. In your
			 * platform-specific assembly, use {@link Style.Add{H}(string, StyleHandler{H})} to add
			 * the style logic with the same id.
			 */
			Style: string;

			/**
			 * Gets the instance of the platform-specific object
			 *
			 * This can sometimes be useful to get the platform-specific object. Some handlers may
			 * not have any backing object for its functionality, so this may be null.  It is more
			 * preferred to use the {@link Eto.Widget.Handler} and cast that to the platform-specific
			 * handler class which can give you additional methods and helpers to do common tasks.
			 * For example, the {@link Eto.Forms.Application} object's handler for OS X has a
			 * AddFullScreenMenuItem property to specify if you want full screen support in your app.
			 */
			readonly ControlObject: unknown;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Widget} has been disposed.
			 *
			 * When the widget is disposed, it can no longer be used.
			 */
			IsDisposed: boolean;

			/** Removes the specified child from the container */
			Remove(child: Eto.Forms.Control): void;

			/** Remove the specified `controls` from this container */
			Remove(controls: Iterable<Eto.Forms.Control>): void;

			/** Removes all controls from this container */
			RemoveAll(): void;

			/**
			 * Finds a child control in this container or any of its child containers with the
			 * specified `id`
			 */
			FindChild<T>(id?: string): T;

			/**
			 * Finds a child control in this container or any of its child containers with the
			 * specified `type`
			 */
			FindChild(
				type: unknown,
				id?: string,
			): Eto.Forms.Control;

			/**
			 * Finds a child control in this container or any of its child containers with the
			 * specified `id`.
			 */
			FindChild(id: string): Eto.Forms.Control;

			/**
			 * Queues a repaint of the entire control on the screen and any of its children.
			 *
			 * This is only useful when the control is visible.
			 */
			Invalidate(): void;

			/**
			 * Queues a repaint of the entire control on the screen
			 *
			 * This is only useful when the control is visible.
			 */
			Invalidate(invalidateChildren: boolean): void;

			/**
			 * Queues a repaint of the specified `rect` of the control and any children.
			 *
			 * This is only useful when the control is visible.
			 */
			Invalidate(rect: Eto.Drawing.Rectangle): void;

			/**
			 * Queues a repaint of the specified `rect` of the control
			 *
			 * This is only useful when the control is visible.
			 */
			Invalidate(
				rect: Eto.Drawing.Rectangle,
				invalidateChildren: boolean,
			): void;

			/**
			 * Updates the layout of this control if necessary.
			 *
			 * This will ensure the control has had all of its layout applied so you can use its
			 * position and size right after this call. Most platforms (except WinForms) use a
			 * deferred layout system so that after adding your control to the form dynamically it
			 * won't get laid out until the next idle loop. This is useful when you need to know the
			 * dimensions of the control immediately. Note that this can be an expensive operation,
			 * so it is recommended to only call this method when necessary and after all of the
			 * controls have been added/updated.
			 */
			UpdateLayout(): void;

			/** Gets the preferred size of this control given infinite space available. */
			GetPreferredSize(): Eto.Drawing.SizeF;

			/** Gets the preferred size of this control given the specified `availableSize`. */
			GetPreferredSize(availableSize: Eto.Drawing.SizeF): Eto.Drawing.SizeF;

			/**
			 * Captures all mouse events to this control.
			 *
			 * This captures all mouse events until {@link Eto.Forms.Control.ReleaseMouseCapture} is
			 * called.  Note that not all platforms will allow a mouse capture unless the mouse is
			 * currently down.
			 */
			CaptureMouse(): boolean;

			/** Releases the mouse capture after a call to {@link Eto.Forms.Control.CaptureMouse}. */
			ReleaseMouseCapture(): void;

			/**
			 * Finds a control in the parent hierarchy with the specified type and
			 * {@link Eto.Widget.ID} if specified
			 */
			FindParent(
				type: unknown,
				id?: string,
			): Eto.Forms.Container;

			/** Finds a control in the parent hierarchy with the specified `id` */
			FindParent(id: string): Eto.Forms.Container;

			/**
			 * Detaches the control by removing it from its parent
			 *
			 * This is essentially a shortcut to myControl.Parent.Remove(myControl);
			 */
			Detach(): void;

			/**
			 * Attaches the control for direct use in a native application
			 *
			 * Use this to use a control directly in a native application.  Note that the native
			 * application must be running the same framework as the current platform.  E.g. a
			 * WinForms application can use an Eto.Forms control when using the Eto.WinForms
			 * platform.  This prepares the control by firing the {@link Eto.Forms.Control.PreLoad},
			 * {@link Eto.Forms.Control.Load}, etc. events.
			 */
			AttachNative(): void;

			/**
			 * Detaches the control when it is used in a native application, when you want to reuse
			 * the control.
			 *
			 * This should only be called after {@link Eto.Forms.Control.AttachNative} has been
			 * called, which is usually done by calling to ToNative(true) .
			 */
			DetachNative(): void;

			/**
			 * Attempts to set the keyboard input focus to this control, or the first child that
			 * accepts focus. For Windows, this will bring it to front and activate it.
			 */
			Focus(): void;

			/**
			 * Suspends the layout of child controls
			 *
			 * This can be used to optimize some platforms while adding, removing, or changing many
			 * child controls at once. It disables the calculation of control positioning until
			 * {@link Eto.Forms.Control.ResumeLayout} is called. Each call to SuspendLayout() must be
			 * balanced with a call to {@link Eto.Forms.Control.ResumeLayout}.
			 */
			SuspendLayout(): void;

			/**
			 * Resumes the layout after it has been suspended, and performs a layout
			 *
			 * This can be used to optimize some platforms while adding, removing, or changing many
			 * child controls at once. Each call to ResumeLayout() must be balanced with a call to
			 * {@link Eto.Forms.Control.SuspendLayout} before it.
			 */
			ResumeLayout(): void;

			/**
			 * Specifies a command to execute for a platform-specific command
			 *
			 * Some platforms have specific system-defined commands that can be associated with a
			 * control. For example, the Mac platform's cut/copy/paste functionality is defined by
			 * the system, and if you want to hook into it, you can use this to map it to your own
			 * defined logic. The valid values of the `systemCommand` parameter are defined by each
			 * platform, and a list can be retrieved using
			 * {@link Eto.Forms.Control.SupportedPlatformCommands}
			 */
			MapPlatformCommand(
				systemCommand: string,
				command: Eto.Forms.Command,
			): void;

			/** Converts a point from screen space to control space. */
			PointFromScreen(point: Eto.Drawing.PointF): Eto.Drawing.PointF;

			/** Converts a point from control space to screen space */
			PointToScreen(point: Eto.Drawing.PointF): Eto.Drawing.PointF;

			/** Converts a rectangle from screen space to control space. */
			RectangleToScreen(rect: Eto.Drawing.RectangleF): Eto.Drawing.RectangleF;

			/** Converts a rectangle from control space to screen space */
			RectangleFromScreen(rect: Eto.Drawing.RectangleF): Eto.Drawing.RectangleF;

			/**
			 * Starts drag operation using this control as drag source.
			 *
			 * This method can be blocking on some platforms (Wpf, WinForms), and non-blocking on
			 * others (Mac, Gtk). Use the {@link Eto.Forms.Control.DragEnd} event to determine when
			 * the drag operation is completed and get its resulting DragEffects.
			 */
			DoDragDrop(
				data: Eto.Forms.DataObject,
				allowedEffects: Eto.Forms.DragEffects,
			): void;

			/**
			 * Starts drag operation using this control as drag source.
			 *
			 * This method can be blocking on some platforms (Wpf, WinForms), and non-blocking on
			 * others (Mac, Gtk). Use the {@link Eto.Forms.Control.DragEnd} event to determine when
			 * the drag operation is completed and get its resulting DragEffects.
			 */
			DoDragDrop(
				data: Eto.Forms.DataObject,
				allowedEffects: Eto.Forms.DragEffects,
				image: Eto.Drawing.Image,
				cursorOffset: Eto.Drawing.PointF,
			): void;

			/**
			 * Triggers the StyleChanged event and re-applies the styles to this control and its
			 * children.
			 */
			TriggerStyleChanged(): void;

			/** Shows a print dialog to print the specified control */
			Print(): void;

			/**
			 * Finds a control in the parent hierarchy with the specified type and
			 * {@link Eto.Widget.ID} if specified
			 */
			FindParent<T>(id?: string): T;

			/**
			 * Finds a control in the parent hierarchy with the specified type and
			 * {@link Eto.Widget.ID} if specified
			 */
			FindParent(
				type: unknown,
				id?: string,
			): Eto.Widget;

			/** Finds a control in the parent hierarchy with the specified `id` */
			FindParent(id: string): Eto.Widget;

			/**
			 * Unbinds any bindings in the {@link Eto.Forms.BindableWidget.Bindings} collection and
			 * removes the bindings
			 *
			 * When you implement {@link Eto.Forms.IBindableWidgetContainer}, this will also unbind
			 * any of its children.
			 */
			Unbind(): void;

			/**
			 * Updates all bindings in this widget
			 *
			 * When you implement {@link Eto.Forms.IBindableWidgetContainer}, this will also update
			 * bindings for all of its children.
			 */
			UpdateBindings(mode?: Eto.Forms.BindingUpdateMode): void;

			/** Disposes of this widget, supressing the finalizer */
			dispose(): void;

			/** Gets a string that represents the current object with its ID if specified. */
			ToString(): string;
		}
	}

	export namespace Eto.Forms {
		/**
		 * Control to edit a collection of objects
		 *
		 * This control allows the user to edit the specified
		 * {@link Eto.Forms.CollectionEditor.DataStore} by adding and removing entries of
		 * {@link Eto.Forms.CollectionEditor.ElementType}.
		 */
		export class CollectionEditor implements
			Eto.IHandlerSource,
			Eto.Forms.IBindable,
			Eto.Forms.IMouseInputSource,
			Eto.Forms.IKeyboardInputSource {
			constructor();

			/** Data store of the items to edit */
			DataStore: Iterable<unknown>;

			/**
			 * Gets or sets the type of element to create when adding new elements to the data store
			 */
			ElementType: unknown;

			/**
			 * Gets a value indicating that the control is loaded onto a form, that is it has been
			 * created, added to a parent, and shown
			 *
			 * The {@link Eto.Forms.Control.OnLoad(System.EventArgs)} method sets this value to true
			 * after cascading to all children (for a {@link Eto.Forms.Container} ) and calling the
			 * platform handler's implementation.  It is called after adding to a loaded form, or
			 * when showing a new form.  The {@link Eto.Forms.Control.OnUnLoad(System.EventArgs)}
			 * method will set this value to false when the control is removed from its parent
			 */
			readonly Loaded: boolean;

			/**
			 * Gets an enumeration of controls that are in the visual tree.
			 *
			 * This is used to specify which controls are contained by this instance that are part of
			 * the visual tree. This should include all controls including non-logical Eto controls
			 * used for layout.
			 */
			readonly VisualControls: Iterable<Eto.Forms.Control>;

			/**
			 * Gets or sets a user-defined object that contains data about the control
			 *
			 * A common use of the tag property is to store data that is associated with the control
			 * that you can later retrieve.
			 */
			Tag: unknown;

			/**
			 * Gets the logical parent control.
			 *
			 * When the control is part of the visual tree (
				 * {@link Eto.Forms.Control.IsVisualControl} is true), this returns the logical parent
				 * that contains this control. Otherwise this is the same as
				 * {@link Eto.Forms.Control.Parent}.
				 */
				readonly LogicalParent: Eto.Forms.Container;

			/** Gets a value indicating this {@link Eto.Forms.Control} is part of the visual tree. */
			IsVisualControl: boolean;

			/**
			 * Gets or sets the size of the control. Use -1 to specify auto sizing for either the
			 * width and/or height.
			 *
			 * Setting the size of controls is entirely optional as most controls will size
			 * themselves appropriately. When specifying a size, it will be used as the desired size
			 * of the control.  The container will reposition and resize the control depending on the
			 * available size.  For a {@link Eto.Forms.Window}, it is preferred to set the
			 * {@link Eto.Forms.Container.ClientSize} instead, as various platforms have different
			 * sizes of window decorations, toolbars, etc.
			 */
			Size: Eto.Drawing.Size;

			/**
			 * Gets a value indicating this control currently has mouse capture
			 *
			 * Mouse capture can happen during a handled MouseDown event until MouseUp, or it can be
			 * captured explicitly via {@link Eto.Forms.Control.CaptureMouse}.
			 */
			readonly IsMouseCaptured: boolean;

			/** Gets or sets the width of the control size. */
			Width: number;

			/** Gets or sets the height of the control size. */
			Height: number;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Forms.Control} (or its
			 * children) are enabled and accept user input.
			 *
			 * Typically when a control is disabled, the user cannot do anything with the control or
			 * any of its children. Including for example, selecting text in a text control. Certain
			 * controls can have a 'Read Only' mode, such as {@link Eto.Forms.TextBox.ReadOnly} which
			 * allow the user to  select text, but not change its contents.
			 */
			Enabled: boolean;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Forms.Control} is visible to
			 * the user.
			 *
			 * When the visibility of a control is set to false, it will not occupy space in the
			 * layout.
			 */
			Visible: boolean;

			/** Gets the container which this control has been added to, if any */
			readonly Parent: Eto.Forms.Container;

			/**
			 * Gets the visual container of this control, if any.
			 *
			 * Some containers may use other Eto controls to layout its children, such as the
			 * {@link Eto.Forms.StackLayout}. This will return the parent control that visually
			 * contains this control as opposed to {@link Eto.Forms.Control.Parent} which will return
			 * the logical parent.
			 */
			VisualParent: Eto.Forms.Container;

			/** Gets a value indicating this control has been attached to a native container */
			readonly IsAttached: boolean;

			/**
			 * Gets or sets the color for the background of the control
			 *
			 * Note that on some platforms (e.g. Mac), setting the background color of a control can
			 * change the performance characteristics of the control and its children, since it must
			 * enable layers to do so.
			 */
			BackgroundColor: Eto.Drawing.Color;

			/** Gets a value indicating whether this instance has the keyboard input focus. */
			readonly HasFocus: boolean;

			/** Gets a value indicating whether the layout of child controls is suspended. */
			readonly IsSuspended: boolean;

			/** Gets the window this control is contained in */
			readonly ParentWindow: Eto.Forms.Window;

			/**
			 * Gets the supported platform commands that can be used to hook up system functions to
			 * user defined logic
			 *
			 * This lists all available commands that can be mapped using the
			 * {@link Eto.Forms.Control.MapPlatformCommand(System.String,Eto.Forms.Command)} method
			 * of the control.
			 */
			readonly SupportedPlatformCommands: Iterable<string>;

			/** Gets the bounding rectangle of this control relative to its container */
			readonly Bounds: Eto.Drawing.Rectangle;

			/**
			 * Gets the location of the control as positioned by the container
			 *
			 * A control's location is set by the container. This can be used to determine where the
			 * control is for overlaying floating windows, menus, etc.
			 */
			readonly Location: Eto.Drawing.Point;

			/** Gets or sets the type of cursor to use when the mouse is hovering over the control */
			Cursor: Eto.Forms.Cursor;

			/** Gets or sets the tool tip to show when the mouse is hovered over the control */
			ToolTip: string;

			/**
			 * Gets or sets the tab index order for this control within its container.
			 *
			 * This sets the order when using the tab key to cycle through controls  Note that some
			 * platforms (Gtk and WinForms) may not support setting the context of the tab order to
			 * StackLayout  or DynamicLayout containers and may not behave exactly as expected. Use
			 * the {@link Eto.PlatformFeatures.TabIndexWithCustomContainers} flag to determine if it
			 * is supported.
			 */
			TabIndex: number;

			/** Gets or sets a value indicating whether this control can serve as drop target. */
			AllowDrop: boolean;

			/**
			 * Gets or sets the parent widget which this widget has been added to, if any
			 *
			 * When implementing child widgets that can participate in the context based binding
			 * (MVVM), You can set this to the parent widget when it is added or removed to it
			 * (usually via a collection).  Note that you should typically provide a public new
			 * [ParentWidget] Parent { get; } property  so that consumers of your API cannot set the
			 * parent to an invalid value.
			 */
			Parent: Eto.Widget;

			/**
			 * Gets an enumeration of all parent widgets in the heirarchy by traversing the
			 * {@link Eto.Forms.BindableWidget.Parent} property.
			 */
			readonly Parents: Iterable<Eto.Widget>;

			/**
			 * Gets or sets the data context for this widget for binding
			 *
			 * Subclasses may override the standard behaviour so that hierarchy of widgets can be
			 * taken into account.  For example, a Control may return the data context of a parent,
			 * if it is not set explicitly.
			 */
			DataContext: unknown;

			/** Gets the collection of bindings that are attached to this widget */
			readonly Bindings: Eto.Forms.BindingCollection;

			/**
			 * Gets a value indicating that the {@link Eto.Forms.BindableWidget.DataContext} property
			 * is changing.
			 *
			 * This can be used to determine when to allow certain logic during the update of the
			 * data context.  It is used to disable binding setters on the model when the data
			 * context changes so that a binding does not cause the view model to be updated when the
			 * state hasn't been fully set yet.
			 */
			IsDataContextChanging: boolean;

			/**
			 * Gets the platform that was used to create the {@link Eto.Widget.Handler} for this
			 * widget
			 *
			 * This gets set to the current {@link Eto.Platform.Instance} during the construction of
			 * the object
			 */
			readonly Platform: Eto.Platform;

			/** Gets the platform-specific handler for this widget */
			Handler: unknown;

			/** Gets the native platform-specific handle for integration purposes */
			readonly NativeHandle: unknown;

			/** Gets the dictionary of properties for this widget */
			readonly Properties: Eto.PropertyStore;

			/** Gets or sets the ID of this widget */
			ID: string;

			/**
			 * Gets or sets the style of this widget
			 *
			 * Styles allow you to attach custom platform-specific logic to a widget. In your
			 * platform-specific assembly, use {@link Style.Add{H}(string, StyleHandler{H})} to add
			 * the style logic with the same id.
			 */
			Style: string;

			/**
			 * Gets the instance of the platform-specific object
			 *
			 * This can sometimes be useful to get the platform-specific object. Some handlers may
			 * not have any backing object for its functionality, so this may be null.  It is more
			 * preferred to use the {@link Eto.Widget.Handler} and cast that to the platform-specific
			 * handler class which can give you additional methods and helpers to do common tasks.
			 * For example, the {@link Eto.Forms.Application} object's handler for OS X has a
			 * AddFullScreenMenuItem property to specify if you want full screen support in your app.
			 */
			readonly ControlObject: unknown;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Widget} has been disposed.
			 *
			 * When the widget is disposed, it can no longer be used.
			 */
			IsDisposed: boolean;

			/**
			 * Queues a repaint of the entire control on the screen and any of its children.
			 *
			 * This is only useful when the control is visible.
			 */
			Invalidate(): void;

			/**
			 * Queues a repaint of the entire control on the screen
			 *
			 * This is only useful when the control is visible.
			 */
			Invalidate(invalidateChildren: boolean): void;

			/**
			 * Queues a repaint of the specified `rect` of the control and any children.
			 *
			 * This is only useful when the control is visible.
			 */
			Invalidate(rect: Eto.Drawing.Rectangle): void;

			/**
			 * Queues a repaint of the specified `rect` of the control
			 *
			 * This is only useful when the control is visible.
			 */
			Invalidate(
				rect: Eto.Drawing.Rectangle,
				invalidateChildren: boolean,
			): void;

			/**
			 * Updates the layout of this control if necessary.
			 *
			 * This will ensure the control has had all of its layout applied so you can use its
			 * position and size right after this call. Most platforms (except WinForms) use a
			 * deferred layout system so that after adding your control to the form dynamically it
			 * won't get laid out until the next idle loop. This is useful when you need to know the
			 * dimensions of the control immediately. Note that this can be an expensive operation,
			 * so it is recommended to only call this method when necessary and after all of the
			 * controls have been added/updated.
			 */
			UpdateLayout(): void;

			/** Gets the preferred size of this control given infinite space available. */
			GetPreferredSize(): Eto.Drawing.SizeF;

			/** Gets the preferred size of this control given the specified `availableSize`. */
			GetPreferredSize(availableSize: Eto.Drawing.SizeF): Eto.Drawing.SizeF;

			/**
			 * Captures all mouse events to this control.
			 *
			 * This captures all mouse events until {@link Eto.Forms.Control.ReleaseMouseCapture} is
			 * called.  Note that not all platforms will allow a mouse capture unless the mouse is
			 * currently down.
			 */
			CaptureMouse(): boolean;

			/** Releases the mouse capture after a call to {@link Eto.Forms.Control.CaptureMouse}. */
			ReleaseMouseCapture(): void;

			/**
			 * Finds a control in the parent hierarchy with the specified type and
			 * {@link Eto.Widget.ID} if specified
			 */
			FindParent(
				type: unknown,
				id?: string,
			): Eto.Forms.Container;

			/** Finds a control in the parent hierarchy with the specified `id` */
			FindParent(id: string): Eto.Forms.Container;

			/**
			 * Detaches the control by removing it from its parent
			 *
			 * This is essentially a shortcut to myControl.Parent.Remove(myControl);
			 */
			Detach(): void;

			/**
			 * Attaches the control for direct use in a native application
			 *
			 * Use this to use a control directly in a native application.  Note that the native
			 * application must be running the same framework as the current platform.  E.g. a
			 * WinForms application can use an Eto.Forms control when using the Eto.WinForms
			 * platform.  This prepares the control by firing the {@link Eto.Forms.Control.PreLoad},
			 * {@link Eto.Forms.Control.Load}, etc. events.
			 */
			AttachNative(): void;

			/**
			 * Detaches the control when it is used in a native application, when you want to reuse
			 * the control.
			 *
			 * This should only be called after {@link Eto.Forms.Control.AttachNative} has been
			 * called, which is usually done by calling to ToNative(true) .
			 */
			DetachNative(): void;

			/**
			 * Attempts to set the keyboard input focus to this control, or the first child that
			 * accepts focus. For Windows, this will bring it to front and activate it.
			 */
			Focus(): void;

			/**
			 * Suspends the layout of child controls
			 *
			 * This can be used to optimize some platforms while adding, removing, or changing many
			 * child controls at once. It disables the calculation of control positioning until
			 * {@link Eto.Forms.Control.ResumeLayout} is called. Each call to SuspendLayout() must be
			 * balanced with a call to {@link Eto.Forms.Control.ResumeLayout}.
			 */
			SuspendLayout(): void;

			/**
			 * Resumes the layout after it has been suspended, and performs a layout
			 *
			 * This can be used to optimize some platforms while adding, removing, or changing many
			 * child controls at once. Each call to ResumeLayout() must be balanced with a call to
			 * {@link Eto.Forms.Control.SuspendLayout} before it.
			 */
			ResumeLayout(): void;

			/**
			 * Specifies a command to execute for a platform-specific command
			 *
			 * Some platforms have specific system-defined commands that can be associated with a
			 * control. For example, the Mac platform's cut/copy/paste functionality is defined by
			 * the system, and if you want to hook into it, you can use this to map it to your own
			 * defined logic. The valid values of the `systemCommand` parameter are defined by each
			 * platform, and a list can be retrieved using
			 * {@link Eto.Forms.Control.SupportedPlatformCommands}
			 */
			MapPlatformCommand(
				systemCommand: string,
				command: Eto.Forms.Command,
			): void;

			/** Converts a point from screen space to control space. */
			PointFromScreen(point: Eto.Drawing.PointF): Eto.Drawing.PointF;

			/** Converts a point from control space to screen space */
			PointToScreen(point: Eto.Drawing.PointF): Eto.Drawing.PointF;

			/** Converts a rectangle from screen space to control space. */
			RectangleToScreen(rect: Eto.Drawing.RectangleF): Eto.Drawing.RectangleF;

			/** Converts a rectangle from control space to screen space */
			RectangleFromScreen(rect: Eto.Drawing.RectangleF): Eto.Drawing.RectangleF;

			/**
			 * Starts drag operation using this control as drag source.
			 *
			 * This method can be blocking on some platforms (Wpf, WinForms), and non-blocking on
			 * others (Mac, Gtk). Use the {@link Eto.Forms.Control.DragEnd} event to determine when
			 * the drag operation is completed and get its resulting DragEffects.
			 */
			DoDragDrop(
				data: Eto.Forms.DataObject,
				allowedEffects: Eto.Forms.DragEffects,
			): void;

			/**
			 * Starts drag operation using this control as drag source.
			 *
			 * This method can be blocking on some platforms (Wpf, WinForms), and non-blocking on
			 * others (Mac, Gtk). Use the {@link Eto.Forms.Control.DragEnd} event to determine when
			 * the drag operation is completed and get its resulting DragEffects.
			 */
			DoDragDrop(
				data: Eto.Forms.DataObject,
				allowedEffects: Eto.Forms.DragEffects,
				image: Eto.Drawing.Image,
				cursorOffset: Eto.Drawing.PointF,
			): void;

			/**
			 * Triggers the StyleChanged event and re-applies the styles to this control and its
			 * children.
			 */
			TriggerStyleChanged(): void;

			/** Shows a print dialog to print the specified control */
			Print(): void;

			/**
			 * Finds a control in the parent hierarchy with the specified type and
			 * {@link Eto.Widget.ID} if specified
			 */
			FindParent<T>(id?: string): T;

			/**
			 * Finds a control in the parent hierarchy with the specified type and
			 * {@link Eto.Widget.ID} if specified
			 */
			FindParent(
				type: unknown,
				id?: string,
			): Eto.Widget;

			/** Finds a control in the parent hierarchy with the specified `id` */
			FindParent(id: string): Eto.Widget;

			/**
			 * Unbinds any bindings in the {@link Eto.Forms.BindableWidget.Bindings} collection and
			 * removes the bindings
			 *
			 * When you implement {@link Eto.Forms.IBindableWidgetContainer}, this will also unbind
			 * any of its children.
			 */
			Unbind(): void;

			/**
			 * Updates all bindings in this widget
			 *
			 * When you implement {@link Eto.Forms.IBindableWidgetContainer}, this will also update
			 * bindings for all of its children.
			 */
			UpdateBindings(mode?: Eto.Forms.BindingUpdateMode): void;

			/** Disposes of this widget, supressing the finalizer */
			dispose(): void;

			/** Gets a string that represents the current object with its ID if specified. */
			ToString(): string;
		}
	}

	export namespace Eto.Forms.CollectionEditor {
		export interface IHandler extends
			Eto.Forms.Control.IHandler,
			Eto.Widget.IHandler {
			DataStore: Iterable<unknown>;

			ElementType: unknown;
		}
	}

	export namespace Eto.Forms {
		/** A control to show and pick a color. */
		export class ColorPicker implements
			Eto.IHandlerSource,
			Eto.Forms.IBindable,
			Eto.Forms.IMouseInputSource,
			Eto.Forms.IKeyboardInputSource {
			constructor();

			/** Gets or sets the selected {@link Eto.Drawing.Color} value. */
			Value: Eto.Drawing.Color;

			/**
			 * Gets or sets a value indicating whether the user can adjust the Alpha component of the
			 * {@link Eto.Drawing.Color}.
			 *
			 * This may or may not be supported in all platforms (e.g. WinForms).   Use
			 * {@link Eto.Forms.ColorPicker.SupportsAllowAlpha} to determine if the current platform
			 * supports this feature.
			 */
			AllowAlpha: boolean;

			/**
			 * Gets a value indicating that the current platform supports the
			 * {@link Eto.Forms.ColorPicker.AllowAlpha} property.
			 *
			 * If not supported, the setting will be ignored.
			 */
			readonly SupportsAllowAlpha: boolean;

			/** Gets a binding to the {@link Eto.Forms.ColorPicker.Value} property. */
			readonly ValueBinding: Eto.Forms.BindableBinding$2<Eto.Forms.ColorPicker, Eto.Drawing.Color>;

			/**
			 * Gets a value indicating that the control is loaded onto a form, that is it has been
			 * created, added to a parent, and shown
			 *
			 * The {@link Eto.Forms.Control.OnLoad(System.EventArgs)} method sets this value to true
			 * after cascading to all children (for a {@link Eto.Forms.Container} ) and calling the
			 * platform handler's implementation.  It is called after adding to a loaded form, or
			 * when showing a new form.  The {@link Eto.Forms.Control.OnUnLoad(System.EventArgs)}
			 * method will set this value to false when the control is removed from its parent
			 */
			readonly Loaded: boolean;

			/**
			 * Gets an enumeration of controls that are in the visual tree.
			 *
			 * This is used to specify which controls are contained by this instance that are part of
			 * the visual tree. This should include all controls including non-logical Eto controls
			 * used for layout.
			 */
			readonly VisualControls: Iterable<Eto.Forms.Control>;

			/**
			 * Gets or sets a user-defined object that contains data about the control
			 *
			 * A common use of the tag property is to store data that is associated with the control
			 * that you can later retrieve.
			 */
			Tag: unknown;

			/**
			 * Gets the logical parent control.
			 *
			 * When the control is part of the visual tree (
				 * {@link Eto.Forms.Control.IsVisualControl} is true), this returns the logical parent
				 * that contains this control. Otherwise this is the same as
				 * {@link Eto.Forms.Control.Parent}.
				 */
				readonly LogicalParent: Eto.Forms.Container;

			/** Gets a value indicating this {@link Eto.Forms.Control} is part of the visual tree. */
			IsVisualControl: boolean;

			/**
			 * Gets or sets the size of the control. Use -1 to specify auto sizing for either the
			 * width and/or height.
			 *
			 * Setting the size of controls is entirely optional as most controls will size
			 * themselves appropriately. When specifying a size, it will be used as the desired size
			 * of the control.  The container will reposition and resize the control depending on the
			 * available size.  For a {@link Eto.Forms.Window}, it is preferred to set the
			 * {@link Eto.Forms.Container.ClientSize} instead, as various platforms have different
			 * sizes of window decorations, toolbars, etc.
			 */
			Size: Eto.Drawing.Size;

			/**
			 * Gets a value indicating this control currently has mouse capture
			 *
			 * Mouse capture can happen during a handled MouseDown event until MouseUp, or it can be
			 * captured explicitly via {@link Eto.Forms.Control.CaptureMouse}.
			 */
			readonly IsMouseCaptured: boolean;

			/** Gets or sets the width of the control size. */
			Width: number;

			/** Gets or sets the height of the control size. */
			Height: number;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Forms.Control} (or its
			 * children) are enabled and accept user input.
			 *
			 * Typically when a control is disabled, the user cannot do anything with the control or
			 * any of its children. Including for example, selecting text in a text control. Certain
			 * controls can have a 'Read Only' mode, such as {@link Eto.Forms.TextBox.ReadOnly} which
			 * allow the user to  select text, but not change its contents.
			 */
			Enabled: boolean;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Forms.Control} is visible to
			 * the user.
			 *
			 * When the visibility of a control is set to false, it will not occupy space in the
			 * layout.
			 */
			Visible: boolean;

			/** Gets the container which this control has been added to, if any */
			readonly Parent: Eto.Forms.Container;

			/**
			 * Gets the visual container of this control, if any.
			 *
			 * Some containers may use other Eto controls to layout its children, such as the
			 * {@link Eto.Forms.StackLayout}. This will return the parent control that visually
			 * contains this control as opposed to {@link Eto.Forms.Control.Parent} which will return
			 * the logical parent.
			 */
			VisualParent: Eto.Forms.Container;

			/** Gets a value indicating this control has been attached to a native container */
			readonly IsAttached: boolean;

			/**
			 * Gets or sets the color for the background of the control
			 *
			 * Note that on some platforms (e.g. Mac), setting the background color of a control can
			 * change the performance characteristics of the control and its children, since it must
			 * enable layers to do so.
			 */
			BackgroundColor: Eto.Drawing.Color;

			/** Gets a value indicating whether this instance has the keyboard input focus. */
			readonly HasFocus: boolean;

			/** Gets a value indicating whether the layout of child controls is suspended. */
			readonly IsSuspended: boolean;

			/** Gets the window this control is contained in */
			readonly ParentWindow: Eto.Forms.Window;

			/**
			 * Gets the supported platform commands that can be used to hook up system functions to
			 * user defined logic
			 *
			 * This lists all available commands that can be mapped using the
			 * {@link Eto.Forms.Control.MapPlatformCommand(System.String,Eto.Forms.Command)} method
			 * of the control.
			 */
			readonly SupportedPlatformCommands: Iterable<string>;

			/** Gets the bounding rectangle of this control relative to its container */
			readonly Bounds: Eto.Drawing.Rectangle;

			/**
			 * Gets the location of the control as positioned by the container
			 *
			 * A control's location is set by the container. This can be used to determine where the
			 * control is for overlaying floating windows, menus, etc.
			 */
			readonly Location: Eto.Drawing.Point;

			/** Gets or sets the type of cursor to use when the mouse is hovering over the control */
			Cursor: Eto.Forms.Cursor;

			/** Gets or sets the tool tip to show when the mouse is hovered over the control */
			ToolTip: string;

			/**
			 * Gets or sets the tab index order for this control within its container.
			 *
			 * This sets the order when using the tab key to cycle through controls  Note that some
			 * platforms (Gtk and WinForms) may not support setting the context of the tab order to
			 * StackLayout  or DynamicLayout containers and may not behave exactly as expected. Use
			 * the {@link Eto.PlatformFeatures.TabIndexWithCustomContainers} flag to determine if it
			 * is supported.
			 */
			TabIndex: number;

			/** Gets or sets a value indicating whether this control can serve as drop target. */
			AllowDrop: boolean;

			/**
			 * Gets or sets the parent widget which this widget has been added to, if any
			 *
			 * When implementing child widgets that can participate in the context based binding
			 * (MVVM), You can set this to the parent widget when it is added or removed to it
			 * (usually via a collection).  Note that you should typically provide a public new
			 * [ParentWidget] Parent { get; } property  so that consumers of your API cannot set the
			 * parent to an invalid value.
			 */
			Parent: Eto.Widget;

			/**
			 * Gets an enumeration of all parent widgets in the heirarchy by traversing the
			 * {@link Eto.Forms.BindableWidget.Parent} property.
			 */
			readonly Parents: Iterable<Eto.Widget>;

			/**
			 * Gets or sets the data context for this widget for binding
			 *
			 * Subclasses may override the standard behaviour so that hierarchy of widgets can be
			 * taken into account.  For example, a Control may return the data context of a parent,
			 * if it is not set explicitly.
			 */
			DataContext: unknown;

			/** Gets the collection of bindings that are attached to this widget */
			readonly Bindings: Eto.Forms.BindingCollection;

			/**
			 * Gets a value indicating that the {@link Eto.Forms.BindableWidget.DataContext} property
			 * is changing.
			 *
			 * This can be used to determine when to allow certain logic during the update of the
			 * data context.  It is used to disable binding setters on the model when the data
			 * context changes so that a binding does not cause the view model to be updated when the
			 * state hasn't been fully set yet.
			 */
			IsDataContextChanging: boolean;

			/**
			 * Gets the platform that was used to create the {@link Eto.Widget.Handler} for this
			 * widget
			 *
			 * This gets set to the current {@link Eto.Platform.Instance} during the construction of
			 * the object
			 */
			readonly Platform: Eto.Platform;

			/** Gets the platform-specific handler for this widget */
			Handler: unknown;

			/** Gets the native platform-specific handle for integration purposes */
			readonly NativeHandle: unknown;

			/** Gets the dictionary of properties for this widget */
			readonly Properties: Eto.PropertyStore;

			/** Gets or sets the ID of this widget */
			ID: string;

			/**
			 * Gets or sets the style of this widget
			 *
			 * Styles allow you to attach custom platform-specific logic to a widget. In your
			 * platform-specific assembly, use {@link Style.Add{H}(string, StyleHandler{H})} to add
			 * the style logic with the same id.
			 */
			Style: string;

			/**
			 * Gets the instance of the platform-specific object
			 *
			 * This can sometimes be useful to get the platform-specific object. Some handlers may
			 * not have any backing object for its functionality, so this may be null.  It is more
			 * preferred to use the {@link Eto.Widget.Handler} and cast that to the platform-specific
			 * handler class which can give you additional methods and helpers to do common tasks.
			 * For example, the {@link Eto.Forms.Application} object's handler for OS X has a
			 * AddFullScreenMenuItem property to specify if you want full screen support in your app.
			 */
			readonly ControlObject: unknown;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Widget} has been disposed.
			 *
			 * When the widget is disposed, it can no longer be used.
			 */
			IsDisposed: boolean;

			/**
			 * Queues a repaint of the entire control on the screen and any of its children.
			 *
			 * This is only useful when the control is visible.
			 */
			Invalidate(): void;

			/**
			 * Queues a repaint of the entire control on the screen
			 *
			 * This is only useful when the control is visible.
			 */
			Invalidate(invalidateChildren: boolean): void;

			/**
			 * Queues a repaint of the specified `rect` of the control and any children.
			 *
			 * This is only useful when the control is visible.
			 */
			Invalidate(rect: Eto.Drawing.Rectangle): void;

			/**
			 * Queues a repaint of the specified `rect` of the control
			 *
			 * This is only useful when the control is visible.
			 */
			Invalidate(
				rect: Eto.Drawing.Rectangle,
				invalidateChildren: boolean,
			): void;

			/**
			 * Updates the layout of this control if necessary.
			 *
			 * This will ensure the control has had all of its layout applied so you can use its
			 * position and size right after this call. Most platforms (except WinForms) use a
			 * deferred layout system so that after adding your control to the form dynamically it
			 * won't get laid out until the next idle loop. This is useful when you need to know the
			 * dimensions of the control immediately. Note that this can be an expensive operation,
			 * so it is recommended to only call this method when necessary and after all of the
			 * controls have been added/updated.
			 */
			UpdateLayout(): void;

			/** Gets the preferred size of this control given infinite space available. */
			GetPreferredSize(): Eto.Drawing.SizeF;

			/** Gets the preferred size of this control given the specified `availableSize`. */
			GetPreferredSize(availableSize: Eto.Drawing.SizeF): Eto.Drawing.SizeF;

			/**
			 * Captures all mouse events to this control.
			 *
			 * This captures all mouse events until {@link Eto.Forms.Control.ReleaseMouseCapture} is
			 * called.  Note that not all platforms will allow a mouse capture unless the mouse is
			 * currently down.
			 */
			CaptureMouse(): boolean;

			/** Releases the mouse capture after a call to {@link Eto.Forms.Control.CaptureMouse}. */
			ReleaseMouseCapture(): void;

			/**
			 * Finds a control in the parent hierarchy with the specified type and
			 * {@link Eto.Widget.ID} if specified
			 */
			FindParent(
				type: unknown,
				id?: string,
			): Eto.Forms.Container;

			/** Finds a control in the parent hierarchy with the specified `id` */
			FindParent(id: string): Eto.Forms.Container;

			/**
			 * Detaches the control by removing it from its parent
			 *
			 * This is essentially a shortcut to myControl.Parent.Remove(myControl);
			 */
			Detach(): void;

			/**
			 * Attaches the control for direct use in a native application
			 *
			 * Use this to use a control directly in a native application.  Note that the native
			 * application must be running the same framework as the current platform.  E.g. a
			 * WinForms application can use an Eto.Forms control when using the Eto.WinForms
			 * platform.  This prepares the control by firing the {@link Eto.Forms.Control.PreLoad},
			 * {@link Eto.Forms.Control.Load}, etc. events.
			 */
			AttachNative(): void;

			/**
			 * Detaches the control when it is used in a native application, when you want to reuse
			 * the control.
			 *
			 * This should only be called after {@link Eto.Forms.Control.AttachNative} has been
			 * called, which is usually done by calling to ToNative(true) .
			 */
			DetachNative(): void;

			/**
			 * Attempts to set the keyboard input focus to this control, or the first child that
			 * accepts focus. For Windows, this will bring it to front and activate it.
			 */
			Focus(): void;

			/**
			 * Suspends the layout of child controls
			 *
			 * This can be used to optimize some platforms while adding, removing, or changing many
			 * child controls at once. It disables the calculation of control positioning until
			 * {@link Eto.Forms.Control.ResumeLayout} is called. Each call to SuspendLayout() must be
			 * balanced with a call to {@link Eto.Forms.Control.ResumeLayout}.
			 */
			SuspendLayout(): void;

			/**
			 * Resumes the layout after it has been suspended, and performs a layout
			 *
			 * This can be used to optimize some platforms while adding, removing, or changing many
			 * child controls at once. Each call to ResumeLayout() must be balanced with a call to
			 * {@link Eto.Forms.Control.SuspendLayout} before it.
			 */
			ResumeLayout(): void;

			/**
			 * Specifies a command to execute for a platform-specific command
			 *
			 * Some platforms have specific system-defined commands that can be associated with a
			 * control. For example, the Mac platform's cut/copy/paste functionality is defined by
			 * the system, and if you want to hook into it, you can use this to map it to your own
			 * defined logic. The valid values of the `systemCommand` parameter are defined by each
			 * platform, and a list can be retrieved using
			 * {@link Eto.Forms.Control.SupportedPlatformCommands}
			 */
			MapPlatformCommand(
				systemCommand: string,
				command: Eto.Forms.Command,
			): void;

			/** Converts a point from screen space to control space. */
			PointFromScreen(point: Eto.Drawing.PointF): Eto.Drawing.PointF;

			/** Converts a point from control space to screen space */
			PointToScreen(point: Eto.Drawing.PointF): Eto.Drawing.PointF;

			/** Converts a rectangle from screen space to control space. */
			RectangleToScreen(rect: Eto.Drawing.RectangleF): Eto.Drawing.RectangleF;

			/** Converts a rectangle from control space to screen space */
			RectangleFromScreen(rect: Eto.Drawing.RectangleF): Eto.Drawing.RectangleF;

			/**
			 * Starts drag operation using this control as drag source.
			 *
			 * This method can be blocking on some platforms (Wpf, WinForms), and non-blocking on
			 * others (Mac, Gtk). Use the {@link Eto.Forms.Control.DragEnd} event to determine when
			 * the drag operation is completed and get its resulting DragEffects.
			 */
			DoDragDrop(
				data: Eto.Forms.DataObject,
				allowedEffects: Eto.Forms.DragEffects,
			): void;

			/**
			 * Starts drag operation using this control as drag source.
			 *
			 * This method can be blocking on some platforms (Wpf, WinForms), and non-blocking on
			 * others (Mac, Gtk). Use the {@link Eto.Forms.Control.DragEnd} event to determine when
			 * the drag operation is completed and get its resulting DragEffects.
			 */
			DoDragDrop(
				data: Eto.Forms.DataObject,
				allowedEffects: Eto.Forms.DragEffects,
				image: Eto.Drawing.Image,
				cursorOffset: Eto.Drawing.PointF,
			): void;

			/**
			 * Triggers the StyleChanged event and re-applies the styles to this control and its
			 * children.
			 */
			TriggerStyleChanged(): void;

			/** Shows a print dialog to print the specified control */
			Print(): void;

			/**
			 * Finds a control in the parent hierarchy with the specified type and
			 * {@link Eto.Widget.ID} if specified
			 */
			FindParent<T>(id?: string): T;

			/**
			 * Finds a control in the parent hierarchy with the specified type and
			 * {@link Eto.Widget.ID} if specified
			 */
			FindParent(
				type: unknown,
				id?: string,
			): Eto.Widget;

			/** Finds a control in the parent hierarchy with the specified `id` */
			FindParent(id: string): Eto.Widget;

			/**
			 * Unbinds any bindings in the {@link Eto.Forms.BindableWidget.Bindings} collection and
			 * removes the bindings
			 *
			 * When you implement {@link Eto.Forms.IBindableWidgetContainer}, this will also unbind
			 * any of its children.
			 */
			Unbind(): void;

			/**
			 * Updates all bindings in this widget
			 *
			 * When you implement {@link Eto.Forms.IBindableWidgetContainer}, this will also update
			 * bindings for all of its children.
			 */
			UpdateBindings(mode?: Eto.Forms.BindingUpdateMode): void;

			/** Disposes of this widget, supressing the finalizer */
			dispose(): void;

			/** Gets a string that represents the current object with its ID if specified. */
			ToString(): string;
		}
	}

	export namespace Eto.Forms.ColorPicker {
		export interface ICallback extends
			Eto.Forms.Control.ICallback,
			Eto.Widget.ICallback {
			OnColorChanged(
				widget: Eto.Forms.ColorPicker,
				e: unknown,
			): void;
		}
	}

	export namespace Eto.Forms.ColorPicker {
		export interface IHandler extends
			Eto.Forms.Control.IHandler,
			Eto.Widget.IHandler {
			Color: Eto.Drawing.Color;

			AllowAlpha: boolean;

			readonly SupportsAllowAlpha: boolean;
		}
	}

	export namespace Eto.Forms {
		/**
		 * Presents a combination of an editable text box and drop down to select from a list of
		 * items and enter text.
		 */
		export class ComboBox implements
			Eto.IHandlerSource,
			Eto.Forms.IBindable,
			Eto.Forms.IMouseInputSource,
			Eto.Forms.IKeyboardInputSource {
			/** Initializes a new instance of the {@link Eto.Forms.ComboBox} class. */
			constructor();

			/** Gets or sets the text of the combo box. */
			Text: string;

			/**
			 * Gets or sets whether the user can change the text in the combo box.
			 *
			 * When `true`, the user will still be able to select/copy the text or select items from
			 * the drop down. They will only be unable to type in different text.  To fully disable
			 * the control, use the {@link Eto.Forms.Control.Enabled} property.
			 */
			ReadOnly: boolean;

			/**
			 * Gets or sets a value indicating that the text should autocomplete when the user types
			 * in a value.
			 *
			 * The autocomplete will be based off of the available items in the combo box.
			 */
			AutoComplete: boolean;

			/**
			 * Gets or sets the binding to get the image for each item.
			 *
			 * By default this looks for the Image property of the item, and also works if you use
			 * {@link Eto.Forms.ImageListItem}.  This will be ignored when creating a
			 * {@link Eto.Forms.ComboBox}, and is only supported with the {@link Eto.Forms.DropDown}
			 * directly.
			 */
			ItemImageBinding: Eto.Forms.IIndirectBinding$1<Eto.Drawing.Image>;

			/**
			 * Gets or sets a value indicating whether to show the control's border.
			 *
			 * This is a hint to omit the border of the control and show it as plainly as possible.
			 * Typically used when you want to show the control within a cell of the
			 * {@link Eto.Forms.GridView}.
			 */
			ShowBorder: boolean;

			/** Gets or sets the binding for the text value of each item. */
			ItemTextBinding: Eto.Forms.IIndirectBinding$1<string>;

			/** Gets or sets the binding for the key value of each item. */
			ItemKeyBinding: Eto.Forms.IIndirectBinding$1<string>;

			/** Gets or sets the binding for the text value of each item. */
			TextBinding: Eto.Forms.IIndirectBinding$1<string>;

			/** Gets or sets the binding for the key value of each item. */
			KeyBinding: Eto.Forms.IIndirectBinding$1<string>;

			/**
			 * Gets the list of items in the control.
			 *
			 * This is an alternate to using {@link Eto.Forms.ListControl.DataStore} to easily add
			 * items to the list, when you do not want to use custom objects as the source for the
			 * list. This will set the {@link Eto.Forms.ListControl.DataStore} to a new instance of a
			 * {@link Eto.Forms.ListItemCollection}.
			 */
			readonly Items: Eto.Forms.ListItemCollection;

			/** Gets or sets the data store for the items of the list control. */
			DataStore: Iterable<unknown>;

			/**
			 * Gets or sets the index of the currently selected item in the
			 * {@link Eto.Forms.ListControl.DataStore}
			 */
			SelectedIndex: number;

			/**
			 * Gets or sets the selected object value of the item in
			 * {@link Eto.Forms.ListControl.DataStore}
			 */
			SelectedValue: unknown;

			/**
			 * Gets or sets the key of the selected item in the
			 * {@link Eto.Forms.ListControl.DataStore}.
			 *
			 * This uses the {@link Eto.Forms.ListControl.ItemKeyBinding} to map the key for each
			 * item in the list.
			 */
			SelectedKey: string;

			/**
			 * Gets or sets the color of the text.
			 *
			 * By default, the text will get a color based on the user's theme. However, this is
			 * usually black.
			 */
			TextColor: Eto.Drawing.Color;

			/** Gets the binding to the {@link Eto.Forms.ListControl.SelectedIndex} property. */
			readonly SelectedIndexBinding: Eto.Forms.BindableBinding$2<Eto.Forms.ListControl, number>;

			/** Gets the binding to the {@link Eto.Forms.ListControl.SelectedKey} property. */
			readonly SelectedKeyBinding: Eto.Forms.BindableBinding$2<Eto.Forms.ListControl, string>;

			/** Gets the binding to the {@link Eto.Forms.ListControl.SelectedValue} property. */
			readonly SelectedValueBinding: Eto.Forms.BindableBinding$2<Eto.Forms.ListControl, unknown>;

			/** Gets or sets the font for the text of the control */
			Font: Eto.Drawing.Font;

			/**
			 * Gets a value indicating that the control is loaded onto a form, that is it has been
			 * created, added to a parent, and shown
			 *
			 * The {@link Eto.Forms.Control.OnLoad(System.EventArgs)} method sets this value to true
			 * after cascading to all children (for a {@link Eto.Forms.Container} ) and calling the
			 * platform handler's implementation.  It is called after adding to a loaded form, or
			 * when showing a new form.  The {@link Eto.Forms.Control.OnUnLoad(System.EventArgs)}
			 * method will set this value to false when the control is removed from its parent
			 */
			readonly Loaded: boolean;

			/**
			 * Gets an enumeration of controls that are in the visual tree.
			 *
			 * This is used to specify which controls are contained by this instance that are part of
			 * the visual tree. This should include all controls including non-logical Eto controls
			 * used for layout.
			 */
			readonly VisualControls: Iterable<Eto.Forms.Control>;

			/**
			 * Gets or sets a user-defined object that contains data about the control
			 *
			 * A common use of the tag property is to store data that is associated with the control
			 * that you can later retrieve.
			 */
			Tag: unknown;

			/**
			 * Gets the logical parent control.
			 *
			 * When the control is part of the visual tree (
				 * {@link Eto.Forms.Control.IsVisualControl} is true), this returns the logical parent
				 * that contains this control. Otherwise this is the same as
				 * {@link Eto.Forms.Control.Parent}.
				 */
				readonly LogicalParent: Eto.Forms.Container;

			/** Gets a value indicating this {@link Eto.Forms.Control} is part of the visual tree. */
			IsVisualControl: boolean;

			/**
			 * Gets or sets the size of the control. Use -1 to specify auto sizing for either the
			 * width and/or height.
			 *
			 * Setting the size of controls is entirely optional as most controls will size
			 * themselves appropriately. When specifying a size, it will be used as the desired size
			 * of the control.  The container will reposition and resize the control depending on the
			 * available size.  For a {@link Eto.Forms.Window}, it is preferred to set the
			 * {@link Eto.Forms.Container.ClientSize} instead, as various platforms have different
			 * sizes of window decorations, toolbars, etc.
			 */
			Size: Eto.Drawing.Size;

			/**
			 * Gets a value indicating this control currently has mouse capture
			 *
			 * Mouse capture can happen during a handled MouseDown event until MouseUp, or it can be
			 * captured explicitly via {@link Eto.Forms.Control.CaptureMouse}.
			 */
			readonly IsMouseCaptured: boolean;

			/** Gets or sets the width of the control size. */
			Width: number;

			/** Gets or sets the height of the control size. */
			Height: number;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Forms.Control} (or its
			 * children) are enabled and accept user input.
			 *
			 * Typically when a control is disabled, the user cannot do anything with the control or
			 * any of its children. Including for example, selecting text in a text control. Certain
			 * controls can have a 'Read Only' mode, such as {@link Eto.Forms.TextBox.ReadOnly} which
			 * allow the user to  select text, but not change its contents.
			 */
			Enabled: boolean;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Forms.Control} is visible to
			 * the user.
			 *
			 * When the visibility of a control is set to false, it will not occupy space in the
			 * layout.
			 */
			Visible: boolean;

			/** Gets the container which this control has been added to, if any */
			readonly Parent: Eto.Forms.Container;

			/**
			 * Gets the visual container of this control, if any.
			 *
			 * Some containers may use other Eto controls to layout its children, such as the
			 * {@link Eto.Forms.StackLayout}. This will return the parent control that visually
			 * contains this control as opposed to {@link Eto.Forms.Control.Parent} which will return
			 * the logical parent.
			 */
			VisualParent: Eto.Forms.Container;

			/** Gets a value indicating this control has been attached to a native container */
			readonly IsAttached: boolean;

			/**
			 * Gets or sets the color for the background of the control
			 *
			 * Note that on some platforms (e.g. Mac), setting the background color of a control can
			 * change the performance characteristics of the control and its children, since it must
			 * enable layers to do so.
			 */
			BackgroundColor: Eto.Drawing.Color;

			/** Gets a value indicating whether this instance has the keyboard input focus. */
			readonly HasFocus: boolean;

			/** Gets a value indicating whether the layout of child controls is suspended. */
			readonly IsSuspended: boolean;

			/** Gets the window this control is contained in */
			readonly ParentWindow: Eto.Forms.Window;

			/**
			 * Gets the supported platform commands that can be used to hook up system functions to
			 * user defined logic
			 *
			 * This lists all available commands that can be mapped using the
			 * {@link Eto.Forms.Control.MapPlatformCommand(System.String,Eto.Forms.Command)} method
			 * of the control.
			 */
			readonly SupportedPlatformCommands: Iterable<string>;

			/** Gets the bounding rectangle of this control relative to its container */
			readonly Bounds: Eto.Drawing.Rectangle;

			/**
			 * Gets the location of the control as positioned by the container
			 *
			 * A control's location is set by the container. This can be used to determine where the
			 * control is for overlaying floating windows, menus, etc.
			 */
			readonly Location: Eto.Drawing.Point;

			/** Gets or sets the type of cursor to use when the mouse is hovering over the control */
			Cursor: Eto.Forms.Cursor;

			/** Gets or sets the tool tip to show when the mouse is hovered over the control */
			ToolTip: string;

			/**
			 * Gets or sets the tab index order for this control within its container.
			 *
			 * This sets the order when using the tab key to cycle through controls  Note that some
			 * platforms (Gtk and WinForms) may not support setting the context of the tab order to
			 * StackLayout  or DynamicLayout containers and may not behave exactly as expected. Use
			 * the {@link Eto.PlatformFeatures.TabIndexWithCustomContainers} flag to determine if it
			 * is supported.
			 */
			TabIndex: number;

			/** Gets or sets a value indicating whether this control can serve as drop target. */
			AllowDrop: boolean;

			/**
			 * Gets or sets the parent widget which this widget has been added to, if any
			 *
			 * When implementing child widgets that can participate in the context based binding
			 * (MVVM), You can set this to the parent widget when it is added or removed to it
			 * (usually via a collection).  Note that you should typically provide a public new
			 * [ParentWidget] Parent { get; } property  so that consumers of your API cannot set the
			 * parent to an invalid value.
			 */
			Parent: Eto.Widget;

			/**
			 * Gets an enumeration of all parent widgets in the heirarchy by traversing the
			 * {@link Eto.Forms.BindableWidget.Parent} property.
			 */
			readonly Parents: Iterable<Eto.Widget>;

			/**
			 * Gets or sets the data context for this widget for binding
			 *
			 * Subclasses may override the standard behaviour so that hierarchy of widgets can be
			 * taken into account.  For example, a Control may return the data context of a parent,
			 * if it is not set explicitly.
			 */
			DataContext: unknown;

			/** Gets the collection of bindings that are attached to this widget */
			readonly Bindings: Eto.Forms.BindingCollection;

			/**
			 * Gets a value indicating that the {@link Eto.Forms.BindableWidget.DataContext} property
			 * is changing.
			 *
			 * This can be used to determine when to allow certain logic during the update of the
			 * data context.  It is used to disable binding setters on the model when the data
			 * context changes so that a binding does not cause the view model to be updated when the
			 * state hasn't been fully set yet.
			 */
			IsDataContextChanging: boolean;

			/**
			 * Gets the platform that was used to create the {@link Eto.Widget.Handler} for this
			 * widget
			 *
			 * This gets set to the current {@link Eto.Platform.Instance} during the construction of
			 * the object
			 */
			readonly Platform: Eto.Platform;

			/** Gets the platform-specific handler for this widget */
			Handler: unknown;

			/** Gets the native platform-specific handle for integration purposes */
			readonly NativeHandle: unknown;

			/** Gets the dictionary of properties for this widget */
			readonly Properties: Eto.PropertyStore;

			/** Gets or sets the ID of this widget */
			ID: string;

			/**
			 * Gets or sets the style of this widget
			 *
			 * Styles allow you to attach custom platform-specific logic to a widget. In your
			 * platform-specific assembly, use {@link Style.Add{H}(string, StyleHandler{H})} to add
			 * the style logic with the same id.
			 */
			Style: string;

			/**
			 * Gets the instance of the platform-specific object
			 *
			 * This can sometimes be useful to get the platform-specific object. Some handlers may
			 * not have any backing object for its functionality, so this may be null.  It is more
			 * preferred to use the {@link Eto.Widget.Handler} and cast that to the platform-specific
			 * handler class which can give you additional methods and helpers to do common tasks.
			 * For example, the {@link Eto.Forms.Application} object's handler for OS X has a
			 * AddFullScreenMenuItem property to specify if you want full screen support in your app.
			 */
			readonly ControlObject: unknown;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Widget} has been disposed.
			 *
			 * When the widget is disposed, it can no longer be used.
			 */
			IsDisposed: boolean;

			/**
			 * Queues a repaint of the entire control on the screen and any of its children.
			 *
			 * This is only useful when the control is visible.
			 */
			Invalidate(): void;

			/**
			 * Queues a repaint of the entire control on the screen
			 *
			 * This is only useful when the control is visible.
			 */
			Invalidate(invalidateChildren: boolean): void;

			/**
			 * Queues a repaint of the specified `rect` of the control and any children.
			 *
			 * This is only useful when the control is visible.
			 */
			Invalidate(rect: Eto.Drawing.Rectangle): void;

			/**
			 * Queues a repaint of the specified `rect` of the control
			 *
			 * This is only useful when the control is visible.
			 */
			Invalidate(
				rect: Eto.Drawing.Rectangle,
				invalidateChildren: boolean,
			): void;

			/**
			 * Updates the layout of this control if necessary.
			 *
			 * This will ensure the control has had all of its layout applied so you can use its
			 * position and size right after this call. Most platforms (except WinForms) use a
			 * deferred layout system so that after adding your control to the form dynamically it
			 * won't get laid out until the next idle loop. This is useful when you need to know the
			 * dimensions of the control immediately. Note that this can be an expensive operation,
			 * so it is recommended to only call this method when necessary and after all of the
			 * controls have been added/updated.
			 */
			UpdateLayout(): void;

			/** Gets the preferred size of this control given infinite space available. */
			GetPreferredSize(): Eto.Drawing.SizeF;

			/** Gets the preferred size of this control given the specified `availableSize`. */
			GetPreferredSize(availableSize: Eto.Drawing.SizeF): Eto.Drawing.SizeF;

			/**
			 * Captures all mouse events to this control.
			 *
			 * This captures all mouse events until {@link Eto.Forms.Control.ReleaseMouseCapture} is
			 * called.  Note that not all platforms will allow a mouse capture unless the mouse is
			 * currently down.
			 */
			CaptureMouse(): boolean;

			/** Releases the mouse capture after a call to {@link Eto.Forms.Control.CaptureMouse}. */
			ReleaseMouseCapture(): void;

			/**
			 * Finds a control in the parent hierarchy with the specified type and
			 * {@link Eto.Widget.ID} if specified
			 */
			FindParent(
				type: unknown,
				id?: string,
			): Eto.Forms.Container;

			/** Finds a control in the parent hierarchy with the specified `id` */
			FindParent(id: string): Eto.Forms.Container;

			/**
			 * Detaches the control by removing it from its parent
			 *
			 * This is essentially a shortcut to myControl.Parent.Remove(myControl);
			 */
			Detach(): void;

			/**
			 * Attaches the control for direct use in a native application
			 *
			 * Use this to use a control directly in a native application.  Note that the native
			 * application must be running the same framework as the current platform.  E.g. a
			 * WinForms application can use an Eto.Forms control when using the Eto.WinForms
			 * platform.  This prepares the control by firing the {@link Eto.Forms.Control.PreLoad},
			 * {@link Eto.Forms.Control.Load}, etc. events.
			 */
			AttachNative(): void;

			/**
			 * Detaches the control when it is used in a native application, when you want to reuse
			 * the control.
			 *
			 * This should only be called after {@link Eto.Forms.Control.AttachNative} has been
			 * called, which is usually done by calling to ToNative(true) .
			 */
			DetachNative(): void;

			/**
			 * Attempts to set the keyboard input focus to this control, or the first child that
			 * accepts focus. For Windows, this will bring it to front and activate it.
			 */
			Focus(): void;

			/**
			 * Suspends the layout of child controls
			 *
			 * This can be used to optimize some platforms while adding, removing, or changing many
			 * child controls at once. It disables the calculation of control positioning until
			 * {@link Eto.Forms.Control.ResumeLayout} is called. Each call to SuspendLayout() must be
			 * balanced with a call to {@link Eto.Forms.Control.ResumeLayout}.
			 */
			SuspendLayout(): void;

			/**
			 * Resumes the layout after it has been suspended, and performs a layout
			 *
			 * This can be used to optimize some platforms while adding, removing, or changing many
			 * child controls at once. Each call to ResumeLayout() must be balanced with a call to
			 * {@link Eto.Forms.Control.SuspendLayout} before it.
			 */
			ResumeLayout(): void;

			/**
			 * Specifies a command to execute for a platform-specific command
			 *
			 * Some platforms have specific system-defined commands that can be associated with a
			 * control. For example, the Mac platform's cut/copy/paste functionality is defined by
			 * the system, and if you want to hook into it, you can use this to map it to your own
			 * defined logic. The valid values of the `systemCommand` parameter are defined by each
			 * platform, and a list can be retrieved using
			 * {@link Eto.Forms.Control.SupportedPlatformCommands}
			 */
			MapPlatformCommand(
				systemCommand: string,
				command: Eto.Forms.Command,
			): void;

			/** Converts a point from screen space to control space. */
			PointFromScreen(point: Eto.Drawing.PointF): Eto.Drawing.PointF;

			/** Converts a point from control space to screen space */
			PointToScreen(point: Eto.Drawing.PointF): Eto.Drawing.PointF;

			/** Converts a rectangle from screen space to control space. */
			RectangleToScreen(rect: Eto.Drawing.RectangleF): Eto.Drawing.RectangleF;

			/** Converts a rectangle from control space to screen space */
			RectangleFromScreen(rect: Eto.Drawing.RectangleF): Eto.Drawing.RectangleF;

			/**
			 * Starts drag operation using this control as drag source.
			 *
			 * This method can be blocking on some platforms (Wpf, WinForms), and non-blocking on
			 * others (Mac, Gtk). Use the {@link Eto.Forms.Control.DragEnd} event to determine when
			 * the drag operation is completed and get its resulting DragEffects.
			 */
			DoDragDrop(
				data: Eto.Forms.DataObject,
				allowedEffects: Eto.Forms.DragEffects,
			): void;

			/**
			 * Starts drag operation using this control as drag source.
			 *
			 * This method can be blocking on some platforms (Wpf, WinForms), and non-blocking on
			 * others (Mac, Gtk). Use the {@link Eto.Forms.Control.DragEnd} event to determine when
			 * the drag operation is completed and get its resulting DragEffects.
			 */
			DoDragDrop(
				data: Eto.Forms.DataObject,
				allowedEffects: Eto.Forms.DragEffects,
				image: Eto.Drawing.Image,
				cursorOffset: Eto.Drawing.PointF,
			): void;

			/**
			 * Triggers the StyleChanged event and re-applies the styles to this control and its
			 * children.
			 */
			TriggerStyleChanged(): void;

			/** Shows a print dialog to print the specified control */
			Print(): void;

			/**
			 * Finds a control in the parent hierarchy with the specified type and
			 * {@link Eto.Widget.ID} if specified
			 */
			FindParent<T>(id?: string): T;

			/**
			 * Finds a control in the parent hierarchy with the specified type and
			 * {@link Eto.Widget.ID} if specified
			 */
			FindParent(
				type: unknown,
				id?: string,
			): Eto.Widget;

			/** Finds a control in the parent hierarchy with the specified `id` */
			FindParent(id: string): Eto.Widget;

			/**
			 * Unbinds any bindings in the {@link Eto.Forms.BindableWidget.Bindings} collection and
			 * removes the bindings
			 *
			 * When you implement {@link Eto.Forms.IBindableWidgetContainer}, this will also unbind
			 * any of its children.
			 */
			Unbind(): void;

			/**
			 * Updates all bindings in this widget
			 *
			 * When you implement {@link Eto.Forms.IBindableWidgetContainer}, this will also update
			 * bindings for all of its children.
			 */
			UpdateBindings(mode?: Eto.Forms.BindingUpdateMode): void;

			/** Disposes of this widget, supressing the finalizer */
			dispose(): void;

			/** Gets a string that represents the current object with its ID if specified. */
			ToString(): string;
		}
	}

	export namespace Eto.Forms.ComboBox {
		export interface ICallback extends
			Eto.Forms.DropDown.ICallback,
			Eto.Forms.ListControl.ICallback,
			Eto.Forms.Control.ICallback,
			Eto.Widget.ICallback {
			OnTextChanged(
				widget: Eto.Forms.ComboBox,
				e: unknown,
			): void;
		}
	}

	export namespace Eto.Forms.ComboBox {
		export interface IHandler extends
			Eto.Forms.DropDown.IHandler,
			Eto.Forms.ListControl.IHandler,
			Eto.Forms.CommonControl.IHandler,
			Eto.Forms.Control.IHandler,
			Eto.Widget.IHandler {
			Text: string;

			ReadOnly: boolean;

			AutoComplete: boolean;
		}
	}

	export namespace Eto.Forms {
		/**
		 * Base class for controls with common functionality
		 *
		 * Currently provides a way to change the font for controls.  Any control with textual
		 * input or display should derive from this class. Any container or specialized control
		 * where there are multiple fonts, etc should define their own properties.
		 */
		export class CommonControl implements
			Eto.IHandlerSource,
			Eto.Forms.IBindable,
			Eto.Forms.IMouseInputSource,
			Eto.Forms.IKeyboardInputSource {
			/** Gets or sets the font for the text of the control */
			Font: Eto.Drawing.Font;

			/**
			 * Gets a value indicating that the control is loaded onto a form, that is it has been
			 * created, added to a parent, and shown
			 *
			 * The {@link Eto.Forms.Control.OnLoad(System.EventArgs)} method sets this value to true
			 * after cascading to all children (for a {@link Eto.Forms.Container} ) and calling the
			 * platform handler's implementation.  It is called after adding to a loaded form, or
			 * when showing a new form.  The {@link Eto.Forms.Control.OnUnLoad(System.EventArgs)}
			 * method will set this value to false when the control is removed from its parent
			 */
			readonly Loaded: boolean;

			/**
			 * Gets an enumeration of controls that are in the visual tree.
			 *
			 * This is used to specify which controls are contained by this instance that are part of
			 * the visual tree. This should include all controls including non-logical Eto controls
			 * used for layout.
			 */
			readonly VisualControls: Iterable<Eto.Forms.Control>;

			/**
			 * Gets or sets a user-defined object that contains data about the control
			 *
			 * A common use of the tag property is to store data that is associated with the control
			 * that you can later retrieve.
			 */
			Tag: unknown;

			/**
			 * Gets the logical parent control.
			 *
			 * When the control is part of the visual tree (
				 * {@link Eto.Forms.Control.IsVisualControl} is true), this returns the logical parent
				 * that contains this control. Otherwise this is the same as
				 * {@link Eto.Forms.Control.Parent}.
				 */
				readonly LogicalParent: Eto.Forms.Container;

			/** Gets a value indicating this {@link Eto.Forms.Control} is part of the visual tree. */
			IsVisualControl: boolean;

			/**
			 * Gets or sets the size of the control. Use -1 to specify auto sizing for either the
			 * width and/or height.
			 *
			 * Setting the size of controls is entirely optional as most controls will size
			 * themselves appropriately. When specifying a size, it will be used as the desired size
			 * of the control.  The container will reposition and resize the control depending on the
			 * available size.  For a {@link Eto.Forms.Window}, it is preferred to set the
			 * {@link Eto.Forms.Container.ClientSize} instead, as various platforms have different
			 * sizes of window decorations, toolbars, etc.
			 */
			Size: Eto.Drawing.Size;

			/**
			 * Gets a value indicating this control currently has mouse capture
			 *
			 * Mouse capture can happen during a handled MouseDown event until MouseUp, or it can be
			 * captured explicitly via {@link Eto.Forms.Control.CaptureMouse}.
			 */
			readonly IsMouseCaptured: boolean;

			/** Gets or sets the width of the control size. */
			Width: number;

			/** Gets or sets the height of the control size. */
			Height: number;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Forms.Control} (or its
			 * children) are enabled and accept user input.
			 *
			 * Typically when a control is disabled, the user cannot do anything with the control or
			 * any of its children. Including for example, selecting text in a text control. Certain
			 * controls can have a 'Read Only' mode, such as {@link Eto.Forms.TextBox.ReadOnly} which
			 * allow the user to  select text, but not change its contents.
			 */
			Enabled: boolean;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Forms.Control} is visible to
			 * the user.
			 *
			 * When the visibility of a control is set to false, it will not occupy space in the
			 * layout.
			 */
			Visible: boolean;

			/** Gets the container which this control has been added to, if any */
			readonly Parent: Eto.Forms.Container;

			/**
			 * Gets the visual container of this control, if any.
			 *
			 * Some containers may use other Eto controls to layout its children, such as the
			 * {@link Eto.Forms.StackLayout}. This will return the parent control that visually
			 * contains this control as opposed to {@link Eto.Forms.Control.Parent} which will return
			 * the logical parent.
			 */
			VisualParent: Eto.Forms.Container;

			/** Gets a value indicating this control has been attached to a native container */
			readonly IsAttached: boolean;

			/**
			 * Gets or sets the color for the background of the control
			 *
			 * Note that on some platforms (e.g. Mac), setting the background color of a control can
			 * change the performance characteristics of the control and its children, since it must
			 * enable layers to do so.
			 */
			BackgroundColor: Eto.Drawing.Color;

			/** Gets a value indicating whether this instance has the keyboard input focus. */
			readonly HasFocus: boolean;

			/** Gets a value indicating whether the layout of child controls is suspended. */
			readonly IsSuspended: boolean;

			/** Gets the window this control is contained in */
			readonly ParentWindow: Eto.Forms.Window;

			/**
			 * Gets the supported platform commands that can be used to hook up system functions to
			 * user defined logic
			 *
			 * This lists all available commands that can be mapped using the
			 * {@link Eto.Forms.Control.MapPlatformCommand(System.String,Eto.Forms.Command)} method
			 * of the control.
			 */
			readonly SupportedPlatformCommands: Iterable<string>;

			/** Gets the bounding rectangle of this control relative to its container */
			readonly Bounds: Eto.Drawing.Rectangle;

			/**
			 * Gets the location of the control as positioned by the container
			 *
			 * A control's location is set by the container. This can be used to determine where the
			 * control is for overlaying floating windows, menus, etc.
			 */
			readonly Location: Eto.Drawing.Point;

			/** Gets or sets the type of cursor to use when the mouse is hovering over the control */
			Cursor: Eto.Forms.Cursor;

			/** Gets or sets the tool tip to show when the mouse is hovered over the control */
			ToolTip: string;

			/**
			 * Gets or sets the tab index order for this control within its container.
			 *
			 * This sets the order when using the tab key to cycle through controls  Note that some
			 * platforms (Gtk and WinForms) may not support setting the context of the tab order to
			 * StackLayout  or DynamicLayout containers and may not behave exactly as expected. Use
			 * the {@link Eto.PlatformFeatures.TabIndexWithCustomContainers} flag to determine if it
			 * is supported.
			 */
			TabIndex: number;

			/** Gets or sets a value indicating whether this control can serve as drop target. */
			AllowDrop: boolean;

			/**
			 * Gets or sets the parent widget which this widget has been added to, if any
			 *
			 * When implementing child widgets that can participate in the context based binding
			 * (MVVM), You can set this to the parent widget when it is added or removed to it
			 * (usually via a collection).  Note that you should typically provide a public new
			 * [ParentWidget] Parent { get; } property  so that consumers of your API cannot set the
			 * parent to an invalid value.
			 */
			Parent: Eto.Widget;

			/**
			 * Gets an enumeration of all parent widgets in the heirarchy by traversing the
			 * {@link Eto.Forms.BindableWidget.Parent} property.
			 */
			readonly Parents: Iterable<Eto.Widget>;

			/**
			 * Gets or sets the data context for this widget for binding
			 *
			 * Subclasses may override the standard behaviour so that hierarchy of widgets can be
			 * taken into account.  For example, a Control may return the data context of a parent,
			 * if it is not set explicitly.
			 */
			DataContext: unknown;

			/** Gets the collection of bindings that are attached to this widget */
			readonly Bindings: Eto.Forms.BindingCollection;

			/**
			 * Gets a value indicating that the {@link Eto.Forms.BindableWidget.DataContext} property
			 * is changing.
			 *
			 * This can be used to determine when to allow certain logic during the update of the
			 * data context.  It is used to disable binding setters on the model when the data
			 * context changes so that a binding does not cause the view model to be updated when the
			 * state hasn't been fully set yet.
			 */
			IsDataContextChanging: boolean;

			/**
			 * Gets the platform that was used to create the {@link Eto.Widget.Handler} for this
			 * widget
			 *
			 * This gets set to the current {@link Eto.Platform.Instance} during the construction of
			 * the object
			 */
			readonly Platform: Eto.Platform;

			/** Gets the platform-specific handler for this widget */
			Handler: unknown;

			/** Gets the native platform-specific handle for integration purposes */
			readonly NativeHandle: unknown;

			/** Gets the dictionary of properties for this widget */
			readonly Properties: Eto.PropertyStore;

			/** Gets or sets the ID of this widget */
			ID: string;

			/**
			 * Gets or sets the style of this widget
			 *
			 * Styles allow you to attach custom platform-specific logic to a widget. In your
			 * platform-specific assembly, use {@link Style.Add{H}(string, StyleHandler{H})} to add
			 * the style logic with the same id.
			 */
			Style: string;

			/**
			 * Gets the instance of the platform-specific object
			 *
			 * This can sometimes be useful to get the platform-specific object. Some handlers may
			 * not have any backing object for its functionality, so this may be null.  It is more
			 * preferred to use the {@link Eto.Widget.Handler} and cast that to the platform-specific
			 * handler class which can give you additional methods and helpers to do common tasks.
			 * For example, the {@link Eto.Forms.Application} object's handler for OS X has a
			 * AddFullScreenMenuItem property to specify if you want full screen support in your app.
			 */
			readonly ControlObject: unknown;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Widget} has been disposed.
			 *
			 * When the widget is disposed, it can no longer be used.
			 */
			IsDisposed: boolean;

			/**
			 * Queues a repaint of the entire control on the screen and any of its children.
			 *
			 * This is only useful when the control is visible.
			 */
			Invalidate(): void;

			/**
			 * Queues a repaint of the entire control on the screen
			 *
			 * This is only useful when the control is visible.
			 */
			Invalidate(invalidateChildren: boolean): void;

			/**
			 * Queues a repaint of the specified `rect` of the control and any children.
			 *
			 * This is only useful when the control is visible.
			 */
			Invalidate(rect: Eto.Drawing.Rectangle): void;

			/**
			 * Queues a repaint of the specified `rect` of the control
			 *
			 * This is only useful when the control is visible.
			 */
			Invalidate(
				rect: Eto.Drawing.Rectangle,
				invalidateChildren: boolean,
			): void;

			/**
			 * Updates the layout of this control if necessary.
			 *
			 * This will ensure the control has had all of its layout applied so you can use its
			 * position and size right after this call. Most platforms (except WinForms) use a
			 * deferred layout system so that after adding your control to the form dynamically it
			 * won't get laid out until the next idle loop. This is useful when you need to know the
			 * dimensions of the control immediately. Note that this can be an expensive operation,
			 * so it is recommended to only call this method when necessary and after all of the
			 * controls have been added/updated.
			 */
			UpdateLayout(): void;

			/** Gets the preferred size of this control given infinite space available. */
			GetPreferredSize(): Eto.Drawing.SizeF;

			/** Gets the preferred size of this control given the specified `availableSize`. */
			GetPreferredSize(availableSize: Eto.Drawing.SizeF): Eto.Drawing.SizeF;

			/**
			 * Captures all mouse events to this control.
			 *
			 * This captures all mouse events until {@link Eto.Forms.Control.ReleaseMouseCapture} is
			 * called.  Note that not all platforms will allow a mouse capture unless the mouse is
			 * currently down.
			 */
			CaptureMouse(): boolean;

			/** Releases the mouse capture after a call to {@link Eto.Forms.Control.CaptureMouse}. */
			ReleaseMouseCapture(): void;

			/**
			 * Finds a control in the parent hierarchy with the specified type and
			 * {@link Eto.Widget.ID} if specified
			 */
			FindParent(
				type: unknown,
				id?: string,
			): Eto.Forms.Container;

			/** Finds a control in the parent hierarchy with the specified `id` */
			FindParent(id: string): Eto.Forms.Container;

			/**
			 * Detaches the control by removing it from its parent
			 *
			 * This is essentially a shortcut to myControl.Parent.Remove(myControl);
			 */
			Detach(): void;

			/**
			 * Attaches the control for direct use in a native application
			 *
			 * Use this to use a control directly in a native application.  Note that the native
			 * application must be running the same framework as the current platform.  E.g. a
			 * WinForms application can use an Eto.Forms control when using the Eto.WinForms
			 * platform.  This prepares the control by firing the {@link Eto.Forms.Control.PreLoad},
			 * {@link Eto.Forms.Control.Load}, etc. events.
			 */
			AttachNative(): void;

			/**
			 * Detaches the control when it is used in a native application, when you want to reuse
			 * the control.
			 *
			 * This should only be called after {@link Eto.Forms.Control.AttachNative} has been
			 * called, which is usually done by calling to ToNative(true) .
			 */
			DetachNative(): void;

			/**
			 * Attempts to set the keyboard input focus to this control, or the first child that
			 * accepts focus. For Windows, this will bring it to front and activate it.
			 */
			Focus(): void;

			/**
			 * Suspends the layout of child controls
			 *
			 * This can be used to optimize some platforms while adding, removing, or changing many
			 * child controls at once. It disables the calculation of control positioning until
			 * {@link Eto.Forms.Control.ResumeLayout} is called. Each call to SuspendLayout() must be
			 * balanced with a call to {@link Eto.Forms.Control.ResumeLayout}.
			 */
			SuspendLayout(): void;

			/**
			 * Resumes the layout after it has been suspended, and performs a layout
			 *
			 * This can be used to optimize some platforms while adding, removing, or changing many
			 * child controls at once. Each call to ResumeLayout() must be balanced with a call to
			 * {@link Eto.Forms.Control.SuspendLayout} before it.
			 */
			ResumeLayout(): void;

			/**
			 * Specifies a command to execute for a platform-specific command
			 *
			 * Some platforms have specific system-defined commands that can be associated with a
			 * control. For example, the Mac platform's cut/copy/paste functionality is defined by
			 * the system, and if you want to hook into it, you can use this to map it to your own
			 * defined logic. The valid values of the `systemCommand` parameter are defined by each
			 * platform, and a list can be retrieved using
			 * {@link Eto.Forms.Control.SupportedPlatformCommands}
			 */
			MapPlatformCommand(
				systemCommand: string,
				command: Eto.Forms.Command,
			): void;

			/** Converts a point from screen space to control space. */
			PointFromScreen(point: Eto.Drawing.PointF): Eto.Drawing.PointF;

			/** Converts a point from control space to screen space */
			PointToScreen(point: Eto.Drawing.PointF): Eto.Drawing.PointF;

			/** Converts a rectangle from screen space to control space. */
			RectangleToScreen(rect: Eto.Drawing.RectangleF): Eto.Drawing.RectangleF;

			/** Converts a rectangle from control space to screen space */
			RectangleFromScreen(rect: Eto.Drawing.RectangleF): Eto.Drawing.RectangleF;

			/**
			 * Starts drag operation using this control as drag source.
			 *
			 * This method can be blocking on some platforms (Wpf, WinForms), and non-blocking on
			 * others (Mac, Gtk). Use the {@link Eto.Forms.Control.DragEnd} event to determine when
			 * the drag operation is completed and get its resulting DragEffects.
			 */
			DoDragDrop(
				data: Eto.Forms.DataObject,
				allowedEffects: Eto.Forms.DragEffects,
			): void;

			/**
			 * Starts drag operation using this control as drag source.
			 *
			 * This method can be blocking on some platforms (Wpf, WinForms), and non-blocking on
			 * others (Mac, Gtk). Use the {@link Eto.Forms.Control.DragEnd} event to determine when
			 * the drag operation is completed and get its resulting DragEffects.
			 */
			DoDragDrop(
				data: Eto.Forms.DataObject,
				allowedEffects: Eto.Forms.DragEffects,
				image: Eto.Drawing.Image,
				cursorOffset: Eto.Drawing.PointF,
			): void;

			/**
			 * Triggers the StyleChanged event and re-applies the styles to this control and its
			 * children.
			 */
			TriggerStyleChanged(): void;

			/** Shows a print dialog to print the specified control */
			Print(): void;

			/**
			 * Finds a control in the parent hierarchy with the specified type and
			 * {@link Eto.Widget.ID} if specified
			 */
			FindParent<T>(id?: string): T;

			/**
			 * Finds a control in the parent hierarchy with the specified type and
			 * {@link Eto.Widget.ID} if specified
			 */
			FindParent(
				type: unknown,
				id?: string,
			): Eto.Widget;

			/** Finds a control in the parent hierarchy with the specified `id` */
			FindParent(id: string): Eto.Widget;

			/**
			 * Unbinds any bindings in the {@link Eto.Forms.BindableWidget.Bindings} collection and
			 * removes the bindings
			 *
			 * When you implement {@link Eto.Forms.IBindableWidgetContainer}, this will also unbind
			 * any of its children.
			 */
			Unbind(): void;

			/**
			 * Updates all bindings in this widget
			 *
			 * When you implement {@link Eto.Forms.IBindableWidgetContainer}, this will also update
			 * bindings for all of its children.
			 */
			UpdateBindings(mode?: Eto.Forms.BindingUpdateMode): void;

			/** Disposes of this widget, supressing the finalizer */
			dispose(): void;

			/** Gets a string that represents the current object with its ID if specified. */
			ToString(): string;
		}
	}

	export namespace Eto.Forms.CommonControl {
		export interface IHandler extends
			Eto.Forms.Control.IHandler,
			Eto.Widget.IHandler {
			Font: Eto.Drawing.Font;
		}
	}

	export namespace Eto.Forms {
		/**
		 * Base for all visual UI elements
		 *
		 * All visual user interface elements should inherit from this class to provide common
		 * functionality like binding, load/unload, and common events.
		 */
		export class Control implements
			Eto.IHandlerSource,
			Eto.Forms.IBindable,
			Eto.Forms.IMouseInputSource,
			Eto.Forms.IKeyboardInputSource {
			constructor(handler: Eto.Forms.Control.IHandler);

			/**
			 * Gets a value indicating that the control is loaded onto a form, that is it has been
			 * created, added to a parent, and shown
			 *
			 * The {@link Eto.Forms.Control.OnLoad(System.EventArgs)} method sets this value to true
			 * after cascading to all children (for a {@link Eto.Forms.Container} ) and calling the
			 * platform handler's implementation.  It is called after adding to a loaded form, or
			 * when showing a new form.  The {@link Eto.Forms.Control.OnUnLoad(System.EventArgs)}
			 * method will set this value to false when the control is removed from its parent
			 */
			Loaded: boolean;

			/**
			 * Gets an enumeration of controls that are in the visual tree.
			 *
			 * This is used to specify which controls are contained by this instance that are part of
			 * the visual tree. This should include all controls including non-logical Eto controls
			 * used for layout.
			 */
			readonly VisualControls: Iterable<Eto.Forms.Control>;

			/**
			 * Gets or sets a user-defined object that contains data about the control
			 *
			 * A common use of the tag property is to store data that is associated with the control
			 * that you can later retrieve.
			 */
			Tag: unknown;

			/**
			 * Gets the logical parent control.
			 *
			 * When the control is part of the visual tree (
				 * {@link Eto.Forms.Control.IsVisualControl} is true), this returns the logical parent
				 * that contains this control. Otherwise this is the same as
				 * {@link Eto.Forms.Control.Parent}.
				 */
				readonly LogicalParent: Eto.Forms.Container;

			/** Gets a value indicating this {@link Eto.Forms.Control} is part of the visual tree. */
			IsVisualControl: boolean;

			/**
			 * Gets or sets the size of the control. Use -1 to specify auto sizing for either the
			 * width and/or height.
			 *
			 * Setting the size of controls is entirely optional as most controls will size
			 * themselves appropriately. When specifying a size, it will be used as the desired size
			 * of the control.  The container will reposition and resize the control depending on the
			 * available size.  For a {@link Eto.Forms.Window}, it is preferred to set the
			 * {@link Eto.Forms.Container.ClientSize} instead, as various platforms have different
			 * sizes of window decorations, toolbars, etc.
			 */
			Size: Eto.Drawing.Size;

			/**
			 * Gets a value indicating this control currently has mouse capture
			 *
			 * Mouse capture can happen during a handled MouseDown event until MouseUp, or it can be
			 * captured explicitly via {@link Eto.Forms.Control.CaptureMouse}.
			 */
			readonly IsMouseCaptured: boolean;

			/** Gets or sets the width of the control size. */
			Width: number;

			/** Gets or sets the height of the control size. */
			Height: number;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Forms.Control} (or its
			 * children) are enabled and accept user input.
			 *
			 * Typically when a control is disabled, the user cannot do anything with the control or
			 * any of its children. Including for example, selecting text in a text control. Certain
			 * controls can have a 'Read Only' mode, such as {@link Eto.Forms.TextBox.ReadOnly} which
			 * allow the user to  select text, but not change its contents.
			 */
			Enabled: boolean;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Forms.Control} is visible to
			 * the user.
			 *
			 * When the visibility of a control is set to false, it will not occupy space in the
			 * layout.
			 */
			Visible: boolean;

			/** Gets the container which this control has been added to, if any */
			readonly Parent: Eto.Forms.Container;

			/**
			 * Gets the visual container of this control, if any.
			 *
			 * Some containers may use other Eto controls to layout its children, such as the
			 * {@link Eto.Forms.StackLayout}. This will return the parent control that visually
			 * contains this control as opposed to {@link Eto.Forms.Control.Parent} which will return
			 * the logical parent.
			 */
			VisualParent: Eto.Forms.Container;

			/** Gets a value indicating this control has been attached to a native container */
			IsAttached: boolean;

			/**
			 * Gets or sets the color for the background of the control
			 *
			 * Note that on some platforms (e.g. Mac), setting the background color of a control can
			 * change the performance characteristics of the control and its children, since it must
			 * enable layers to do so.
			 */
			BackgroundColor: Eto.Drawing.Color;

			/** Gets a value indicating whether this instance has the keyboard input focus. */
			readonly HasFocus: boolean;

			/** Gets a value indicating whether the layout of child controls is suspended. */
			readonly IsSuspended: boolean;

			/** Gets the window this control is contained in */
			readonly ParentWindow: Eto.Forms.Window;

			/**
			 * Gets the supported platform commands that can be used to hook up system functions to
			 * user defined logic
			 *
			 * This lists all available commands that can be mapped using the
			 * {@link Eto.Forms.Control.MapPlatformCommand(System.String,Eto.Forms.Command)} method
			 * of the control.
			 */
			readonly SupportedPlatformCommands: Iterable<string>;

			/** Gets the bounding rectangle of this control relative to its container */
			readonly Bounds: Eto.Drawing.Rectangle;

			/**
			 * Gets the location of the control as positioned by the container
			 *
			 * A control's location is set by the container. This can be used to determine where the
			 * control is for overlaying floating windows, menus, etc.
			 */
			readonly Location: Eto.Drawing.Point;

			/** Gets or sets the type of cursor to use when the mouse is hovering over the control */
			Cursor: Eto.Forms.Cursor;

			/** Gets or sets the tool tip to show when the mouse is hovered over the control */
			ToolTip: string;

			/**
			 * Gets or sets the tab index order for this control within its container.
			 *
			 * This sets the order when using the tab key to cycle through controls  Note that some
			 * platforms (Gtk and WinForms) may not support setting the context of the tab order to
			 * StackLayout  or DynamicLayout containers and may not behave exactly as expected. Use
			 * the {@link Eto.PlatformFeatures.TabIndexWithCustomContainers} flag to determine if it
			 * is supported.
			 */
			TabIndex: number;

			/** Gets or sets a value indicating whether this control can serve as drop target. */
			AllowDrop: boolean;

			/**
			 * Gets or sets the parent widget which this widget has been added to, if any
			 *
			 * When implementing child widgets that can participate in the context based binding
			 * (MVVM), You can set this to the parent widget when it is added or removed to it
			 * (usually via a collection).  Note that you should typically provide a public new
			 * [ParentWidget] Parent { get; } property  so that consumers of your API cannot set the
			 * parent to an invalid value.
			 */
			Parent: Eto.Widget;

			/**
			 * Gets an enumeration of all parent widgets in the heirarchy by traversing the
			 * {@link Eto.Forms.BindableWidget.Parent} property.
			 */
			readonly Parents: Iterable<Eto.Widget>;

			/**
			 * Gets or sets the data context for this widget for binding
			 *
			 * Subclasses may override the standard behaviour so that hierarchy of widgets can be
			 * taken into account.  For example, a Control may return the data context of a parent,
			 * if it is not set explicitly.
			 */
			DataContext: unknown;

			/** Gets the collection of bindings that are attached to this widget */
			readonly Bindings: Eto.Forms.BindingCollection;

			/**
			 * Gets a value indicating that the {@link Eto.Forms.BindableWidget.DataContext} property
			 * is changing.
			 *
			 * This can be used to determine when to allow certain logic during the update of the
			 * data context.  It is used to disable binding setters on the model when the data
			 * context changes so that a binding does not cause the view model to be updated when the
			 * state hasn't been fully set yet.
			 */
			IsDataContextChanging: boolean;

			/**
			 * Gets the platform that was used to create the {@link Eto.Widget.Handler} for this
			 * widget
			 *
			 * This gets set to the current {@link Eto.Platform.Instance} during the construction of
			 * the object
			 */
			readonly Platform: Eto.Platform;

			/** Gets the platform-specific handler for this widget */
			Handler: unknown;

			/** Gets the native platform-specific handle for integration purposes */
			readonly NativeHandle: unknown;

			/** Gets the dictionary of properties for this widget */
			readonly Properties: Eto.PropertyStore;

			/** Gets or sets the ID of this widget */
			ID: string;

			/**
			 * Gets or sets the style of this widget
			 *
			 * Styles allow you to attach custom platform-specific logic to a widget. In your
			 * platform-specific assembly, use {@link Style.Add{H}(string, StyleHandler{H})} to add
			 * the style logic with the same id.
			 */
			Style: string;

			/**
			 * Gets the instance of the platform-specific object
			 *
			 * This can sometimes be useful to get the platform-specific object. Some handlers may
			 * not have any backing object for its functionality, so this may be null.  It is more
			 * preferred to use the {@link Eto.Widget.Handler} and cast that to the platform-specific
			 * handler class which can give you additional methods and helpers to do common tasks.
			 * For example, the {@link Eto.Forms.Application} object's handler for OS X has a
			 * AddFullScreenMenuItem property to specify if you want full screen support in your app.
			 */
			readonly ControlObject: unknown;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Widget} has been disposed.
			 *
			 * When the widget is disposed, it can no longer be used.
			 */
			IsDisposed: boolean;

			/**
			 * Queues a repaint of the entire control on the screen and any of its children.
			 *
			 * This is only useful when the control is visible.
			 */
			Invalidate(): void;

			/**
			 * Queues a repaint of the entire control on the screen
			 *
			 * This is only useful when the control is visible.
			 */
			Invalidate(invalidateChildren: boolean): void;

			/**
			 * Queues a repaint of the specified `rect` of the control and any children.
			 *
			 * This is only useful when the control is visible.
			 */
			Invalidate(rect: Eto.Drawing.Rectangle): void;

			/**
			 * Queues a repaint of the specified `rect` of the control
			 *
			 * This is only useful when the control is visible.
			 */
			Invalidate(
				rect: Eto.Drawing.Rectangle,
				invalidateChildren: boolean,
			): void;

			/**
			 * Updates the layout of this control if necessary.
			 *
			 * This will ensure the control has had all of its layout applied so you can use its
			 * position and size right after this call. Most platforms (except WinForms) use a
			 * deferred layout system so that after adding your control to the form dynamically it
			 * won't get laid out until the next idle loop. This is useful when you need to know the
			 * dimensions of the control immediately. Note that this can be an expensive operation,
			 * so it is recommended to only call this method when necessary and after all of the
			 * controls have been added/updated.
			 */
			UpdateLayout(): void;

			/** Gets the preferred size of this control given infinite space available. */
			GetPreferredSize(): Eto.Drawing.SizeF;

			/** Gets the preferred size of this control given the specified `availableSize`. */
			GetPreferredSize(availableSize: Eto.Drawing.SizeF): Eto.Drawing.SizeF;

			/**
			 * Captures all mouse events to this control.
			 *
			 * This captures all mouse events until {@link Eto.Forms.Control.ReleaseMouseCapture} is
			 * called.  Note that not all platforms will allow a mouse capture unless the mouse is
			 * currently down.
			 */
			CaptureMouse(): boolean;

			/** Releases the mouse capture after a call to {@link Eto.Forms.Control.CaptureMouse}. */
			ReleaseMouseCapture(): void;

			/**
			 * Finds a control in the parent hierarchy with the specified type and
			 * {@link Eto.Widget.ID} if specified
			 */
			FindParent(
				type: unknown,
				id?: string,
			): Eto.Forms.Container;

			/** Finds a control in the parent hierarchy with the specified `id` */
			FindParent(id: string): Eto.Forms.Container;

			/**
			 * Detaches the control by removing it from its parent
			 *
			 * This is essentially a shortcut to myControl.Parent.Remove(myControl);
			 */
			Detach(): void;

			/**
			 * Attaches the control for direct use in a native application
			 *
			 * Use this to use a control directly in a native application.  Note that the native
			 * application must be running the same framework as the current platform.  E.g. a
			 * WinForms application can use an Eto.Forms control when using the Eto.WinForms
			 * platform.  This prepares the control by firing the {@link Eto.Forms.Control.PreLoad},
			 * {@link Eto.Forms.Control.Load}, etc. events.
			 */
			AttachNative(): void;

			/**
			 * Detaches the control when it is used in a native application, when you want to reuse
			 * the control.
			 *
			 * This should only be called after {@link Eto.Forms.Control.AttachNative} has been
			 * called, which is usually done by calling to ToNative(true) .
			 */
			DetachNative(): void;

			/**
			 * Attempts to set the keyboard input focus to this control, or the first child that
			 * accepts focus. For Windows, this will bring it to front and activate it.
			 */
			Focus(): void;

			/**
			 * Suspends the layout of child controls
			 *
			 * This can be used to optimize some platforms while adding, removing, or changing many
			 * child controls at once. It disables the calculation of control positioning until
			 * {@link Eto.Forms.Control.ResumeLayout} is called. Each call to SuspendLayout() must be
			 * balanced with a call to {@link Eto.Forms.Control.ResumeLayout}.
			 */
			SuspendLayout(): void;

			/**
			 * Resumes the layout after it has been suspended, and performs a layout
			 *
			 * This can be used to optimize some platforms while adding, removing, or changing many
			 * child controls at once. Each call to ResumeLayout() must be balanced with a call to
			 * {@link Eto.Forms.Control.SuspendLayout} before it.
			 */
			ResumeLayout(): void;

			/**
			 * Specifies a command to execute for a platform-specific command
			 *
			 * Some platforms have specific system-defined commands that can be associated with a
			 * control. For example, the Mac platform's cut/copy/paste functionality is defined by
			 * the system, and if you want to hook into it, you can use this to map it to your own
			 * defined logic. The valid values of the `systemCommand` parameter are defined by each
			 * platform, and a list can be retrieved using
			 * {@link Eto.Forms.Control.SupportedPlatformCommands}
			 */
			MapPlatformCommand(
				systemCommand: string,
				command: Eto.Forms.Command,
			): void;

			/** Converts a point from screen space to control space. */
			PointFromScreen(point: Eto.Drawing.PointF): Eto.Drawing.PointF;

			/** Converts a point from control space to screen space */
			PointToScreen(point: Eto.Drawing.PointF): Eto.Drawing.PointF;

			/** Converts a rectangle from screen space to control space. */
			RectangleToScreen(rect: Eto.Drawing.RectangleF): Eto.Drawing.RectangleF;

			/** Converts a rectangle from control space to screen space */
			RectangleFromScreen(rect: Eto.Drawing.RectangleF): Eto.Drawing.RectangleF;

			/**
			 * Starts drag operation using this control as drag source.
			 *
			 * This method can be blocking on some platforms (Wpf, WinForms), and non-blocking on
			 * others (Mac, Gtk). Use the {@link Eto.Forms.Control.DragEnd} event to determine when
			 * the drag operation is completed and get its resulting DragEffects.
			 */
			DoDragDrop(
				data: Eto.Forms.DataObject,
				allowedEffects: Eto.Forms.DragEffects,
			): void;

			/**
			 * Starts drag operation using this control as drag source.
			 *
			 * This method can be blocking on some platforms (Wpf, WinForms), and non-blocking on
			 * others (Mac, Gtk). Use the {@link Eto.Forms.Control.DragEnd} event to determine when
			 * the drag operation is completed and get its resulting DragEffects.
			 */
			DoDragDrop(
				data: Eto.Forms.DataObject,
				allowedEffects: Eto.Forms.DragEffects,
				image: Eto.Drawing.Image,
				cursorOffset: Eto.Drawing.PointF,
			): void;

			/**
			 * Triggers the StyleChanged event and re-applies the styles to this control and its
			 * children.
			 */
			TriggerStyleChanged(): void;

			/** Shows a print dialog to print the specified control */
			Print(): void;

			/**
			 * Finds a control in the parent hierarchy with the specified type and
			 * {@link Eto.Widget.ID} if specified
			 */
			FindParent<T>(id?: string): T;

			/**
			 * Finds a control in the parent hierarchy with the specified type and
			 * {@link Eto.Widget.ID} if specified
			 */
			FindParent(
				type: unknown,
				id?: string,
			): Eto.Widget;

			/** Finds a control in the parent hierarchy with the specified `id` */
			FindParent(id: string): Eto.Widget;

			/**
			 * Unbinds any bindings in the {@link Eto.Forms.BindableWidget.Bindings} collection and
			 * removes the bindings
			 *
			 * When you implement {@link Eto.Forms.IBindableWidgetContainer}, this will also unbind
			 * any of its children.
			 */
			Unbind(): void;

			/**
			 * Updates all bindings in this widget
			 *
			 * When you implement {@link Eto.Forms.IBindableWidgetContainer}, this will also update
			 * bindings for all of its children.
			 */
			UpdateBindings(mode?: Eto.Forms.BindingUpdateMode): void;

			/** Disposes of this widget, supressing the finalizer */
			dispose(): void;

			/** Gets a string that represents the current object with its ID if specified. */
			ToString(): string;
		}
	}

	export namespace Eto.Forms.Control {
		export interface ICallback extends Eto.Widget.ICallback {
			OnKeyDown(
				widget: Eto.Forms.Control,
				e: Eto.Forms.KeyEventArgs,
			): void;

			OnKeyUp(
				widget: Eto.Forms.Control,
				e: Eto.Forms.KeyEventArgs,
			): void;

			OnMouseDown(
				widget: Eto.Forms.Control,
				e: Eto.Forms.MouseEventArgs,
			): void;

			OnMouseUp(
				widget: Eto.Forms.Control,
				e: Eto.Forms.MouseEventArgs,
			): void;

			OnMouseMove(
				widget: Eto.Forms.Control,
				e: Eto.Forms.MouseEventArgs,
			): void;

			OnMouseLeave(
				widget: Eto.Forms.Control,
				e: Eto.Forms.MouseEventArgs,
			): void;

			OnMouseEnter(
				widget: Eto.Forms.Control,
				e: Eto.Forms.MouseEventArgs,
			): void;

			OnTextInput(
				widget: Eto.Forms.Control,
				e: Eto.Forms.TextInputEventArgs,
			): void;

			OnSizeChanged(
				widget: Eto.Forms.Control,
				e: unknown,
			): void;

			OnMouseDoubleClick(
				widget: Eto.Forms.Control,
				e: Eto.Forms.MouseEventArgs,
			): void;

			OnMouseWheel(
				widget: Eto.Forms.Control,
				e: Eto.Forms.MouseEventArgs,
			): void;

			OnGotFocus(
				widget: Eto.Forms.Control,
				e: unknown,
			): void;

			OnLostFocus(
				widget: Eto.Forms.Control,
				e: unknown,
			): void;

			OnShown(
				widget: Eto.Forms.Control,
				e: unknown,
			): void;

			OnDragDrop(
				widget: Eto.Forms.Control,
				e: Eto.Forms.DragEventArgs,
			): void;

			OnDragOver(
				widget: Eto.Forms.Control,
				e: Eto.Forms.DragEventArgs,
			): void;

			OnDragEnter(
				widget: Eto.Forms.Control,
				e: Eto.Forms.DragEventArgs,
			): void;

			OnDragLeave(
				widget: Eto.Forms.Control,
				e: Eto.Forms.DragEventArgs,
			): void;

			OnDragEnd(
				widget: Eto.Forms.Control,
				e: Eto.Forms.DragEventArgs,
			): void;

			OnEnabledChanged(
				widget: Eto.Forms.Control,
				e: unknown,
			): void;
		}
	}

	export namespace Eto.Forms.Control {
		export interface IHandler extends Eto.Widget.IHandler {
			BackgroundColor: Eto.Drawing.Color;

			Size: Eto.Drawing.Size;

			Width: number;

			Height: number;

			Enabled: boolean;

			readonly HasFocus: boolean;

			Visible: boolean;

			readonly SupportedPlatformCommands: Iterable<string>;

			readonly Location: Eto.Drawing.Point;

			ToolTip: string;

			Cursor: Eto.Forms.Cursor;

			TabIndex: number;

			readonly VisualControls: Iterable<Eto.Forms.Control>;

			AllowDrop: boolean;

			readonly IsMouseCaptured: boolean;

			Invalidate(invalidateChildren: boolean): void;

			Invalidate(
				rect: Eto.Drawing.Rectangle,
				invalidateChildren: boolean,
			): void;

			SuspendLayout(): void;

			ResumeLayout(): void;

			Focus(): void;

			OnPreLoad(e: unknown): void;

			OnLoad(e: unknown): void;

			OnLoadComplete(e: unknown): void;

			OnUnLoad(e: unknown): void;

			SetParent(
				oldParent: Eto.Forms.Container,
				newParent: Eto.Forms.Container,
			): void;

			MapPlatformCommand(
				systemCommand: string,
				command: Eto.Forms.Command,
			): void;

			PointFromScreen(point: Eto.Drawing.PointF): Eto.Drawing.PointF;

			PointToScreen(point: Eto.Drawing.PointF): Eto.Drawing.PointF;

			DoDragDrop(
				data: Eto.Forms.DataObject,
				allowedEffects: Eto.Forms.DragEffects,
				image: Eto.Drawing.Image,
				cursorOffset: Eto.Drawing.PointF,
			): void;

			GetNativeParentWindow(): Eto.Forms.Window;

			GetPreferredSize(availableSize: Eto.Drawing.SizeF): Eto.Drawing.SizeF;

			UpdateLayout(): void;

			CaptureMouse(): boolean;

			ReleaseMouseCapture(): void;
		}
	}

	export namespace Eto.Forms {
		/** Extension methods for the {@link Eto.Forms.IDataStore<>} */
		export namespace DataStoreExtensions {
			/**
			 * Gets the expanded row count of the specified IDataStore&lt;ITreeItem&gt;, taking into
			 * account the expanded state of each child.
			 *
			 * Note that this has to traverse the entire tree up to the `index`, so it will get
			 * slower for large trees
			 */
			export function GetExpandedRowCount<T>(
				store: Eto.Forms.IDataStore$1<T>,
				index?: number,
			): number;

			/** Gets the row of a path of indecies for each level in a IDataStore&lt;ITreeItem&gt; */
			export function GetRowOfIndexPath<T>(
				store: Eto.Forms.IDataStore$1<T>,
				indexPath: number[],
			): number;
		}
	}

	export namespace Eto.Forms {
		/** Available modes for how a {@link Eto.Forms.DateTimePicker} can be displayed. */
		export enum DateTimePickerMode {
			/** Only the date component will be shown. */
			Date = 1,

			/** Only the time component will be shown. */
			Time = 2,

			/** Both the date and time components will be shown. */
			DateTime = 3,
		}
	}

	export namespace Eto.Forms {
		/** A control that allows the user to select a date and/or a time. */
		export class DateTimePicker implements
			Eto.IHandlerSource,
			Eto.Forms.IBindable,
			Eto.Forms.IMouseInputSource,
			Eto.Forms.IKeyboardInputSource {
			constructor();

			/** Gets or sets the minimum date that is allowed to be entered. */
			MinDate: DateTime;

			/** Gets or sets the maximum date that is allowed to be entered. */
			MaxDate: DateTime;

			/**
			 * Gets or sets the value of the date/time picker. `null` to display blank or with a
			 * unchecked checkbox.
			 */
			Value?: DateTime;

			/** Gets a binding to the {@link Eto.Forms.DateTimePicker.Value} property. */
			readonly ValueBinding: Eto.Forms.BindableBinding$2<Eto.Forms.DateTimePicker, DateTime | undefined>;

			/** Gets or sets the mode of how the date/time picker will be displayed. */
			Mode: Eto.Forms.DateTimePickerMode;

			TextColor: Eto.Drawing.Color;

			/**
			 * Gets or sets a value indicating whether to show the control's border.
			 *
			 * This is a hint to omit the border of the control and show it as plainly as possible.
			 * Typically used when you want to show the control within a cell of the
			 * {@link Eto.Forms.GridView}.
			 */
			ShowBorder: boolean;

			/** Gets or sets the font for the text of the control */
			Font: Eto.Drawing.Font;

			/**
			 * Gets a value indicating that the control is loaded onto a form, that is it has been
			 * created, added to a parent, and shown
			 *
			 * The {@link Eto.Forms.Control.OnLoad(System.EventArgs)} method sets this value to true
			 * after cascading to all children (for a {@link Eto.Forms.Container} ) and calling the
			 * platform handler's implementation.  It is called after adding to a loaded form, or
			 * when showing a new form.  The {@link Eto.Forms.Control.OnUnLoad(System.EventArgs)}
			 * method will set this value to false when the control is removed from its parent
			 */
			readonly Loaded: boolean;

			/**
			 * Gets an enumeration of controls that are in the visual tree.
			 *
			 * This is used to specify which controls are contained by this instance that are part of
			 * the visual tree. This should include all controls including non-logical Eto controls
			 * used for layout.
			 */
			readonly VisualControls: Iterable<Eto.Forms.Control>;

			/**
			 * Gets or sets a user-defined object that contains data about the control
			 *
			 * A common use of the tag property is to store data that is associated with the control
			 * that you can later retrieve.
			 */
			Tag: unknown;

			/**
			 * Gets the logical parent control.
			 *
			 * When the control is part of the visual tree (
				 * {@link Eto.Forms.Control.IsVisualControl} is true), this returns the logical parent
				 * that contains this control. Otherwise this is the same as
				 * {@link Eto.Forms.Control.Parent}.
				 */
				readonly LogicalParent: Eto.Forms.Container;

			/** Gets a value indicating this {@link Eto.Forms.Control} is part of the visual tree. */
			IsVisualControl: boolean;

			/**
			 * Gets or sets the size of the control. Use -1 to specify auto sizing for either the
			 * width and/or height.
			 *
			 * Setting the size of controls is entirely optional as most controls will size
			 * themselves appropriately. When specifying a size, it will be used as the desired size
			 * of the control.  The container will reposition and resize the control depending on the
			 * available size.  For a {@link Eto.Forms.Window}, it is preferred to set the
			 * {@link Eto.Forms.Container.ClientSize} instead, as various platforms have different
			 * sizes of window decorations, toolbars, etc.
			 */
			Size: Eto.Drawing.Size;

			/**
			 * Gets a value indicating this control currently has mouse capture
			 *
			 * Mouse capture can happen during a handled MouseDown event until MouseUp, or it can be
			 * captured explicitly via {@link Eto.Forms.Control.CaptureMouse}.
			 */
			readonly IsMouseCaptured: boolean;

			/** Gets or sets the width of the control size. */
			Width: number;

			/** Gets or sets the height of the control size. */
			Height: number;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Forms.Control} (or its
			 * children) are enabled and accept user input.
			 *
			 * Typically when a control is disabled, the user cannot do anything with the control or
			 * any of its children. Including for example, selecting text in a text control. Certain
			 * controls can have a 'Read Only' mode, such as {@link Eto.Forms.TextBox.ReadOnly} which
			 * allow the user to  select text, but not change its contents.
			 */
			Enabled: boolean;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Forms.Control} is visible to
			 * the user.
			 *
			 * When the visibility of a control is set to false, it will not occupy space in the
			 * layout.
			 */
			Visible: boolean;

			/** Gets the container which this control has been added to, if any */
			readonly Parent: Eto.Forms.Container;

			/**
			 * Gets the visual container of this control, if any.
			 *
			 * Some containers may use other Eto controls to layout its children, such as the
			 * {@link Eto.Forms.StackLayout}. This will return the parent control that visually
			 * contains this control as opposed to {@link Eto.Forms.Control.Parent} which will return
			 * the logical parent.
			 */
			VisualParent: Eto.Forms.Container;

			/** Gets a value indicating this control has been attached to a native container */
			readonly IsAttached: boolean;

			/**
			 * Gets or sets the color for the background of the control
			 *
			 * Note that on some platforms (e.g. Mac), setting the background color of a control can
			 * change the performance characteristics of the control and its children, since it must
			 * enable layers to do so.
			 */
			BackgroundColor: Eto.Drawing.Color;

			/** Gets a value indicating whether this instance has the keyboard input focus. */
			readonly HasFocus: boolean;

			/** Gets a value indicating whether the layout of child controls is suspended. */
			readonly IsSuspended: boolean;

			/** Gets the window this control is contained in */
			readonly ParentWindow: Eto.Forms.Window;

			/**
			 * Gets the supported platform commands that can be used to hook up system functions to
			 * user defined logic
			 *
			 * This lists all available commands that can be mapped using the
			 * {@link Eto.Forms.Control.MapPlatformCommand(System.String,Eto.Forms.Command)} method
			 * of the control.
			 */
			readonly SupportedPlatformCommands: Iterable<string>;

			/** Gets the bounding rectangle of this control relative to its container */
			readonly Bounds: Eto.Drawing.Rectangle;

			/**
			 * Gets the location of the control as positioned by the container
			 *
			 * A control's location is set by the container. This can be used to determine where the
			 * control is for overlaying floating windows, menus, etc.
			 */
			readonly Location: Eto.Drawing.Point;

			/** Gets or sets the type of cursor to use when the mouse is hovering over the control */
			Cursor: Eto.Forms.Cursor;

			/** Gets or sets the tool tip to show when the mouse is hovered over the control */
			ToolTip: string;

			/**
			 * Gets or sets the tab index order for this control within its container.
			 *
			 * This sets the order when using the tab key to cycle through controls  Note that some
			 * platforms (Gtk and WinForms) may not support setting the context of the tab order to
			 * StackLayout  or DynamicLayout containers and may not behave exactly as expected. Use
			 * the {@link Eto.PlatformFeatures.TabIndexWithCustomContainers} flag to determine if it
			 * is supported.
			 */
			TabIndex: number;

			/** Gets or sets a value indicating whether this control can serve as drop target. */
			AllowDrop: boolean;

			/**
			 * Gets or sets the parent widget which this widget has been added to, if any
			 *
			 * When implementing child widgets that can participate in the context based binding
			 * (MVVM), You can set this to the parent widget when it is added or removed to it
			 * (usually via a collection).  Note that you should typically provide a public new
			 * [ParentWidget] Parent { get; } property  so that consumers of your API cannot set the
			 * parent to an invalid value.
			 */
			Parent: Eto.Widget;

			/**
			 * Gets an enumeration of all parent widgets in the heirarchy by traversing the
			 * {@link Eto.Forms.BindableWidget.Parent} property.
			 */
			readonly Parents: Iterable<Eto.Widget>;

			/**
			 * Gets or sets the data context for this widget for binding
			 *
			 * Subclasses may override the standard behaviour so that hierarchy of widgets can be
			 * taken into account.  For example, a Control may return the data context of a parent,
			 * if it is not set explicitly.
			 */
			DataContext: unknown;

			/** Gets the collection of bindings that are attached to this widget */
			readonly Bindings: Eto.Forms.BindingCollection;

			/**
			 * Gets a value indicating that the {@link Eto.Forms.BindableWidget.DataContext} property
			 * is changing.
			 *
			 * This can be used to determine when to allow certain logic during the update of the
			 * data context.  It is used to disable binding setters on the model when the data
			 * context changes so that a binding does not cause the view model to be updated when the
			 * state hasn't been fully set yet.
			 */
			IsDataContextChanging: boolean;

			/**
			 * Gets the platform that was used to create the {@link Eto.Widget.Handler} for this
			 * widget
			 *
			 * This gets set to the current {@link Eto.Platform.Instance} during the construction of
			 * the object
			 */
			readonly Platform: Eto.Platform;

			/** Gets the platform-specific handler for this widget */
			Handler: unknown;

			/** Gets the native platform-specific handle for integration purposes */
			readonly NativeHandle: unknown;

			/** Gets the dictionary of properties for this widget */
			readonly Properties: Eto.PropertyStore;

			/** Gets or sets the ID of this widget */
			ID: string;

			/**
			 * Gets or sets the style of this widget
			 *
			 * Styles allow you to attach custom platform-specific logic to a widget. In your
			 * platform-specific assembly, use {@link Style.Add{H}(string, StyleHandler{H})} to add
			 * the style logic with the same id.
			 */
			Style: string;

			/**
			 * Gets the instance of the platform-specific object
			 *
			 * This can sometimes be useful to get the platform-specific object. Some handlers may
			 * not have any backing object for its functionality, so this may be null.  It is more
			 * preferred to use the {@link Eto.Widget.Handler} and cast that to the platform-specific
			 * handler class which can give you additional methods and helpers to do common tasks.
			 * For example, the {@link Eto.Forms.Application} object's handler for OS X has a
			 * AddFullScreenMenuItem property to specify if you want full screen support in your app.
			 */
			readonly ControlObject: unknown;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Widget} has been disposed.
			 *
			 * When the widget is disposed, it can no longer be used.
			 */
			IsDisposed: boolean;

			/**
			 * Queues a repaint of the entire control on the screen and any of its children.
			 *
			 * This is only useful when the control is visible.
			 */
			Invalidate(): void;

			/**
			 * Queues a repaint of the entire control on the screen
			 *
			 * This is only useful when the control is visible.
			 */
			Invalidate(invalidateChildren: boolean): void;

			/**
			 * Queues a repaint of the specified `rect` of the control and any children.
			 *
			 * This is only useful when the control is visible.
			 */
			Invalidate(rect: Eto.Drawing.Rectangle): void;

			/**
			 * Queues a repaint of the specified `rect` of the control
			 *
			 * This is only useful when the control is visible.
			 */
			Invalidate(
				rect: Eto.Drawing.Rectangle,
				invalidateChildren: boolean,
			): void;

			/**
			 * Updates the layout of this control if necessary.
			 *
			 * This will ensure the control has had all of its layout applied so you can use its
			 * position and size right after this call. Most platforms (except WinForms) use a
			 * deferred layout system so that after adding your control to the form dynamically it
			 * won't get laid out until the next idle loop. This is useful when you need to know the
			 * dimensions of the control immediately. Note that this can be an expensive operation,
			 * so it is recommended to only call this method when necessary and after all of the
			 * controls have been added/updated.
			 */
			UpdateLayout(): void;

			/** Gets the preferred size of this control given infinite space available. */
			GetPreferredSize(): Eto.Drawing.SizeF;

			/** Gets the preferred size of this control given the specified `availableSize`. */
			GetPreferredSize(availableSize: Eto.Drawing.SizeF): Eto.Drawing.SizeF;

			/**
			 * Captures all mouse events to this control.
			 *
			 * This captures all mouse events until {@link Eto.Forms.Control.ReleaseMouseCapture} is
			 * called.  Note that not all platforms will allow a mouse capture unless the mouse is
			 * currently down.
			 */
			CaptureMouse(): boolean;

			/** Releases the mouse capture after a call to {@link Eto.Forms.Control.CaptureMouse}. */
			ReleaseMouseCapture(): void;

			/**
			 * Finds a control in the parent hierarchy with the specified type and
			 * {@link Eto.Widget.ID} if specified
			 */
			FindParent(
				type: unknown,
				id?: string,
			): Eto.Forms.Container;

			/** Finds a control in the parent hierarchy with the specified `id` */
			FindParent(id: string): Eto.Forms.Container;

			/**
			 * Detaches the control by removing it from its parent
			 *
			 * This is essentially a shortcut to myControl.Parent.Remove(myControl);
			 */
			Detach(): void;

			/**
			 * Attaches the control for direct use in a native application
			 *
			 * Use this to use a control directly in a native application.  Note that the native
			 * application must be running the same framework as the current platform.  E.g. a
			 * WinForms application can use an Eto.Forms control when using the Eto.WinForms
			 * platform.  This prepares the control by firing the {@link Eto.Forms.Control.PreLoad},
			 * {@link Eto.Forms.Control.Load}, etc. events.
			 */
			AttachNative(): void;

			/**
			 * Detaches the control when it is used in a native application, when you want to reuse
			 * the control.
			 *
			 * This should only be called after {@link Eto.Forms.Control.AttachNative} has been
			 * called, which is usually done by calling to ToNative(true) .
			 */
			DetachNative(): void;

			/**
			 * Attempts to set the keyboard input focus to this control, or the first child that
			 * accepts focus. For Windows, this will bring it to front and activate it.
			 */
			Focus(): void;

			/**
			 * Suspends the layout of child controls
			 *
			 * This can be used to optimize some platforms while adding, removing, or changing many
			 * child controls at once. It disables the calculation of control positioning until
			 * {@link Eto.Forms.Control.ResumeLayout} is called. Each call to SuspendLayout() must be
			 * balanced with a call to {@link Eto.Forms.Control.ResumeLayout}.
			 */
			SuspendLayout(): void;

			/**
			 * Resumes the layout after it has been suspended, and performs a layout
			 *
			 * This can be used to optimize some platforms while adding, removing, or changing many
			 * child controls at once. Each call to ResumeLayout() must be balanced with a call to
			 * {@link Eto.Forms.Control.SuspendLayout} before it.
			 */
			ResumeLayout(): void;

			/**
			 * Specifies a command to execute for a platform-specific command
			 *
			 * Some platforms have specific system-defined commands that can be associated with a
			 * control. For example, the Mac platform's cut/copy/paste functionality is defined by
			 * the system, and if you want to hook into it, you can use this to map it to your own
			 * defined logic. The valid values of the `systemCommand` parameter are defined by each
			 * platform, and a list can be retrieved using
			 * {@link Eto.Forms.Control.SupportedPlatformCommands}
			 */
			MapPlatformCommand(
				systemCommand: string,
				command: Eto.Forms.Command,
			): void;

			/** Converts a point from screen space to control space. */
			PointFromScreen(point: Eto.Drawing.PointF): Eto.Drawing.PointF;

			/** Converts a point from control space to screen space */
			PointToScreen(point: Eto.Drawing.PointF): Eto.Drawing.PointF;

			/** Converts a rectangle from screen space to control space. */
			RectangleToScreen(rect: Eto.Drawing.RectangleF): Eto.Drawing.RectangleF;

			/** Converts a rectangle from control space to screen space */
			RectangleFromScreen(rect: Eto.Drawing.RectangleF): Eto.Drawing.RectangleF;

			/**
			 * Starts drag operation using this control as drag source.
			 *
			 * This method can be blocking on some platforms (Wpf, WinForms), and non-blocking on
			 * others (Mac, Gtk). Use the {@link Eto.Forms.Control.DragEnd} event to determine when
			 * the drag operation is completed and get its resulting DragEffects.
			 */
			DoDragDrop(
				data: Eto.Forms.DataObject,
				allowedEffects: Eto.Forms.DragEffects,
			): void;

			/**
			 * Starts drag operation using this control as drag source.
			 *
			 * This method can be blocking on some platforms (Wpf, WinForms), and non-blocking on
			 * others (Mac, Gtk). Use the {@link Eto.Forms.Control.DragEnd} event to determine when
			 * the drag operation is completed and get its resulting DragEffects.
			 */
			DoDragDrop(
				data: Eto.Forms.DataObject,
				allowedEffects: Eto.Forms.DragEffects,
				image: Eto.Drawing.Image,
				cursorOffset: Eto.Drawing.PointF,
			): void;

			/**
			 * Triggers the StyleChanged event and re-applies the styles to this control and its
			 * children.
			 */
			TriggerStyleChanged(): void;

			/** Shows a print dialog to print the specified control */
			Print(): void;

			/**
			 * Finds a control in the parent hierarchy with the specified type and
			 * {@link Eto.Widget.ID} if specified
			 */
			FindParent<T>(id?: string): T;

			/**
			 * Finds a control in the parent hierarchy with the specified type and
			 * {@link Eto.Widget.ID} if specified
			 */
			FindParent(
				type: unknown,
				id?: string,
			): Eto.Widget;

			/** Finds a control in the parent hierarchy with the specified `id` */
			FindParent(id: string): Eto.Widget;

			/**
			 * Unbinds any bindings in the {@link Eto.Forms.BindableWidget.Bindings} collection and
			 * removes the bindings
			 *
			 * When you implement {@link Eto.Forms.IBindableWidgetContainer}, this will also unbind
			 * any of its children.
			 */
			Unbind(): void;

			/**
			 * Updates all bindings in this widget
			 *
			 * When you implement {@link Eto.Forms.IBindableWidgetContainer}, this will also update
			 * bindings for all of its children.
			 */
			UpdateBindings(mode?: Eto.Forms.BindingUpdateMode): void;

			/** Disposes of this widget, supressing the finalizer */
			dispose(): void;

			/** Gets a string that represents the current object with its ID if specified. */
			ToString(): string;
		}
	}

	export namespace Eto.Forms.DateTimePicker {
		export interface ICallback extends
			Eto.Forms.Control.ICallback,
			Eto.Widget.ICallback {
			OnValueChanged(
				widget: Eto.Forms.DateTimePicker,
				e: unknown,
			): void;
		}
	}

	export namespace Eto.Forms.DateTimePicker {
		export interface IHandler extends
			Eto.Forms.CommonControl.IHandler,
			Eto.Forms.Control.IHandler,
			Eto.Widget.IHandler {
			Value?: DateTime;

			MinDate: DateTime;

			MaxDate: DateTime;

			Mode: Eto.Forms.DateTimePickerMode;

			TextColor: Eto.Drawing.Color;

			ShowBorder: boolean;
		}
	}

	export namespace Eto.Forms {
		/** Arguments for the {@link Eto.Forms.DocumentControl} to get the current page. */
		export class DocumentPageEventArgs {
			/** Initializes a new instance of the {@link Eto.Forms.DocumentPageEventArgs} class. */
			constructor(page: Eto.Forms.DocumentPage);

			/** Gets the document page. */
			Page: Eto.Forms.DocumentPage;
		}
	}

	export namespace Eto.Forms {
		/** Arguments for the {@link Eto.Forms.DocumentControl} to get the current page. */
		export class DocumentPageClosingEventArgs {
			/**
			 * Initializes a new instance of the {@link Eto.Forms.DocumentPageClosingEventArgs}
			 * class.
			 */
			constructor(page: Eto.Forms.DocumentPage);

			/** Gets the document page. */
			Page: Eto.Forms.DocumentPage;
		}
	}

	export namespace Eto.Forms {
		/** Arguments for the {@link Eto.Forms.DocumentControl} when reordering pages. */
		export class DocumentPageReorderEventArgs {
			/**
			 * Initializes a new instance of the {@link Eto.Forms.DocumentPageReorderEventArgs}
			 * class.
			 */
			constructor(
				page: Eto.Forms.DocumentPage,
				oldIndex: number,
				newIndex: number,
			);

			/** Gets the previous index of the page */
			readonly OldIndex: number;

			/** Gets the new index of the page. */
			readonly NewIndex: number;

			/** Gets the document page. */
			readonly Page: Eto.Forms.DocumentPage;
		}
	}

	export namespace Eto.Forms {
		/**
		 * Control to present multiple pages with tab selection and optional reordering and tab
		 * closing.
		 */
		export class DocumentControl implements
			Eto.IHandlerSource,
			Eto.Forms.IBindable,
			Eto.Forms.IMouseInputSource,
			Eto.Forms.IKeyboardInputSource {
			/** Initializes a new instance of the {@link Eto.Forms.DocumentControl} class. */
			constructor();

			/** Gets an enumeration of controls that are directly contained by this container */
			readonly Controls: Iterable<Eto.Forms.Control>;

			/** Gets or sets the index of the selected page. */
			SelectedIndex: number;

			/** Gets or sets the currently selected page. */
			SelectedPage: Eto.Forms.DocumentPage;

			/** Gets the collection of tab pages. */
			readonly Pages: Eto.Forms.DocumentPage[];

			/** Gets or sets a value indicating the tabs can be reordered. */
			AllowReordering: boolean;

			/** Gets the binding for the {@link Eto.Forms.DocumentControl.SelectedIndex} property. */
			readonly SelectedIndexBinding: Eto.Forms.BindableBinding$2<Eto.Forms.DocumentControl, number>;

			/**
			 * Gets or sets the size for the client area of the control
			 *
			 * The client size differs from the {@link Eto.Forms.Control.Size} in that it excludes
			 * the decorations of the container, such as the title bar and border around a
			 * {@link Eto.Forms.Window}, or the title and line  around a {@link Eto.Forms.GroupBox}.
			 */
			ClientSize: Eto.Drawing.Size;

			/**
			 * Gets an enumeration of all contained child controls, including controls within child
			 * containers
			 */
			readonly Children: Iterable<Eto.Forms.Control>;

			/**
			 * Gets an enumeration of all contained child controls in the visual tree, including
			 * controls within child containers.
			 */
			readonly VisualChildren: Iterable<Eto.Forms.Control>;

			/**
			 * Gets or sets the style provider for this container.
			 *
			 * The style provider is used to style this container and its children.
			 */
			StyleProvider: Eto.IStyleProvider;

			/**
			 * Gets the default style provider for this container.
			 *
			 * Use this to apply styles to any child controls of this container. By default, styles
			 * will apply to all children, including children of children unless
			 * {@link Eto.DefaultStyleProvider.Inherit} is set to false .  Typically, you would set
			 * Inherit to false when creating composite controls that already have all their styles
			 * applied and you don't want any other styles to be inherited.
			 */
			readonly Styles: Eto.DefaultStyleProvider;

			/**
			 * Gets a value indicating that the control is loaded onto a form, that is it has been
			 * created, added to a parent, and shown
			 *
			 * The {@link Eto.Forms.Control.OnLoad(System.EventArgs)} method sets this value to true
			 * after cascading to all children (for a {@link Eto.Forms.Container} ) and calling the
			 * platform handler's implementation.  It is called after adding to a loaded form, or
			 * when showing a new form.  The {@link Eto.Forms.Control.OnUnLoad(System.EventArgs)}
			 * method will set this value to false when the control is removed from its parent
			 */
			readonly Loaded: boolean;

			/**
			 * Gets an enumeration of controls that are in the visual tree.
			 *
			 * This is used to specify which controls are contained by this instance that are part of
			 * the visual tree. This should include all controls including non-logical Eto controls
			 * used for layout.
			 */
			readonly VisualControls: Iterable<Eto.Forms.Control>;

			/**
			 * Gets or sets a user-defined object that contains data about the control
			 *
			 * A common use of the tag property is to store data that is associated with the control
			 * that you can later retrieve.
			 */
			Tag: unknown;

			/**
			 * Gets the logical parent control.
			 *
			 * When the control is part of the visual tree (
				 * {@link Eto.Forms.Control.IsVisualControl} is true), this returns the logical parent
				 * that contains this control. Otherwise this is the same as
				 * {@link Eto.Forms.Control.Parent}.
				 */
				readonly LogicalParent: Eto.Forms.Container;

			/** Gets a value indicating this {@link Eto.Forms.Control} is part of the visual tree. */
			IsVisualControl: boolean;

			/**
			 * Gets or sets the size of the control. Use -1 to specify auto sizing for either the
			 * width and/or height.
			 *
			 * Setting the size of controls is entirely optional as most controls will size
			 * themselves appropriately. When specifying a size, it will be used as the desired size
			 * of the control.  The container will reposition and resize the control depending on the
			 * available size.  For a {@link Eto.Forms.Window}, it is preferred to set the
			 * {@link Eto.Forms.Container.ClientSize} instead, as various platforms have different
			 * sizes of window decorations, toolbars, etc.
			 */
			Size: Eto.Drawing.Size;

			/**
			 * Gets a value indicating this control currently has mouse capture
			 *
			 * Mouse capture can happen during a handled MouseDown event until MouseUp, or it can be
			 * captured explicitly via {@link Eto.Forms.Control.CaptureMouse}.
			 */
			readonly IsMouseCaptured: boolean;

			/** Gets or sets the width of the control size. */
			Width: number;

			/** Gets or sets the height of the control size. */
			Height: number;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Forms.Control} (or its
			 * children) are enabled and accept user input.
			 *
			 * Typically when a control is disabled, the user cannot do anything with the control or
			 * any of its children. Including for example, selecting text in a text control. Certain
			 * controls can have a 'Read Only' mode, such as {@link Eto.Forms.TextBox.ReadOnly} which
			 * allow the user to  select text, but not change its contents.
			 */
			Enabled: boolean;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Forms.Control} is visible to
			 * the user.
			 *
			 * When the visibility of a control is set to false, it will not occupy space in the
			 * layout.
			 */
			Visible: boolean;

			/** Gets the container which this control has been added to, if any */
			readonly Parent: Eto.Forms.Container;

			/**
			 * Gets the visual container of this control, if any.
			 *
			 * Some containers may use other Eto controls to layout its children, such as the
			 * {@link Eto.Forms.StackLayout}. This will return the parent control that visually
			 * contains this control as opposed to {@link Eto.Forms.Control.Parent} which will return
			 * the logical parent.
			 */
			VisualParent: Eto.Forms.Container;

			/** Gets a value indicating this control has been attached to a native container */
			readonly IsAttached: boolean;

			/**
			 * Gets or sets the color for the background of the control
			 *
			 * Note that on some platforms (e.g. Mac), setting the background color of a control can
			 * change the performance characteristics of the control and its children, since it must
			 * enable layers to do so.
			 */
			BackgroundColor: Eto.Drawing.Color;

			/** Gets a value indicating whether this instance has the keyboard input focus. */
			readonly HasFocus: boolean;

			/** Gets a value indicating whether the layout of child controls is suspended. */
			readonly IsSuspended: boolean;

			/** Gets the window this control is contained in */
			readonly ParentWindow: Eto.Forms.Window;

			/**
			 * Gets the supported platform commands that can be used to hook up system functions to
			 * user defined logic
			 *
			 * This lists all available commands that can be mapped using the
			 * {@link Eto.Forms.Control.MapPlatformCommand(System.String,Eto.Forms.Command)} method
			 * of the control.
			 */
			readonly SupportedPlatformCommands: Iterable<string>;

			/** Gets the bounding rectangle of this control relative to its container */
			readonly Bounds: Eto.Drawing.Rectangle;

			/**
			 * Gets the location of the control as positioned by the container
			 *
			 * A control's location is set by the container. This can be used to determine where the
			 * control is for overlaying floating windows, menus, etc.
			 */
			readonly Location: Eto.Drawing.Point;

			/** Gets or sets the type of cursor to use when the mouse is hovering over the control */
			Cursor: Eto.Forms.Cursor;

			/** Gets or sets the tool tip to show when the mouse is hovered over the control */
			ToolTip: string;

			/**
			 * Gets or sets the tab index order for this control within its container.
			 *
			 * This sets the order when using the tab key to cycle through controls  Note that some
			 * platforms (Gtk and WinForms) may not support setting the context of the tab order to
			 * StackLayout  or DynamicLayout containers and may not behave exactly as expected. Use
			 * the {@link Eto.PlatformFeatures.TabIndexWithCustomContainers} flag to determine if it
			 * is supported.
			 */
			TabIndex: number;

			/** Gets or sets a value indicating whether this control can serve as drop target. */
			AllowDrop: boolean;

			/**
			 * Gets or sets the parent widget which this widget has been added to, if any
			 *
			 * When implementing child widgets that can participate in the context based binding
			 * (MVVM), You can set this to the parent widget when it is added or removed to it
			 * (usually via a collection).  Note that you should typically provide a public new
			 * [ParentWidget] Parent { get; } property  so that consumers of your API cannot set the
			 * parent to an invalid value.
			 */
			Parent: Eto.Widget;

			/**
			 * Gets an enumeration of all parent widgets in the heirarchy by traversing the
			 * {@link Eto.Forms.BindableWidget.Parent} property.
			 */
			readonly Parents: Iterable<Eto.Widget>;

			/**
			 * Gets or sets the data context for this widget for binding
			 *
			 * Subclasses may override the standard behaviour so that hierarchy of widgets can be
			 * taken into account.  For example, a Control may return the data context of a parent,
			 * if it is not set explicitly.
			 */
			DataContext: unknown;

			/** Gets the collection of bindings that are attached to this widget */
			readonly Bindings: Eto.Forms.BindingCollection;

			/**
			 * Gets a value indicating that the {@link Eto.Forms.BindableWidget.DataContext} property
			 * is changing.
			 *
			 * This can be used to determine when to allow certain logic during the update of the
			 * data context.  It is used to disable binding setters on the model when the data
			 * context changes so that a binding does not cause the view model to be updated when the
			 * state hasn't been fully set yet.
			 */
			IsDataContextChanging: boolean;

			/**
			 * Gets the platform that was used to create the {@link Eto.Widget.Handler} for this
			 * widget
			 *
			 * This gets set to the current {@link Eto.Platform.Instance} during the construction of
			 * the object
			 */
			readonly Platform: Eto.Platform;

			/** Gets the platform-specific handler for this widget */
			Handler: unknown;

			/** Gets the native platform-specific handle for integration purposes */
			readonly NativeHandle: unknown;

			/** Gets the dictionary of properties for this widget */
			readonly Properties: Eto.PropertyStore;

			/** Gets or sets the ID of this widget */
			ID: string;

			/**
			 * Gets or sets the style of this widget
			 *
			 * Styles allow you to attach custom platform-specific logic to a widget. In your
			 * platform-specific assembly, use {@link Style.Add{H}(string, StyleHandler{H})} to add
			 * the style logic with the same id.
			 */
			Style: string;

			/**
			 * Gets the instance of the platform-specific object
			 *
			 * This can sometimes be useful to get the platform-specific object. Some handlers may
			 * not have any backing object for its functionality, so this may be null.  It is more
			 * preferred to use the {@link Eto.Widget.Handler} and cast that to the platform-specific
			 * handler class which can give you additional methods and helpers to do common tasks.
			 * For example, the {@link Eto.Forms.Application} object's handler for OS X has a
			 * AddFullScreenMenuItem property to specify if you want full screen support in your app.
			 */
			readonly ControlObject: unknown;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Widget} has been disposed.
			 *
			 * When the widget is disposed, it can no longer be used.
			 */
			IsDisposed: boolean;

			/** Remove the specified child from the container. */
			Remove(child: Eto.Forms.Control): void;

			/** Remove the specified `controls` from this container */
			Remove(controls: Iterable<Eto.Forms.Control>): void;

			/** Removes all controls from this container */
			RemoveAll(): void;

			/**
			 * Finds a child control in this container or any of its child containers with the
			 * specified `id`
			 */
			FindChild<T>(id?: string): T;

			/**
			 * Finds a child control in this container or any of its child containers with the
			 * specified `type`
			 */
			FindChild(
				type: unknown,
				id?: string,
			): Eto.Forms.Control;

			/**
			 * Finds a child control in this container or any of its child containers with the
			 * specified `id`.
			 */
			FindChild(id: string): Eto.Forms.Control;

			/**
			 * Queues a repaint of the entire control on the screen and any of its children.
			 *
			 * This is only useful when the control is visible.
			 */
			Invalidate(): void;

			/**
			 * Queues a repaint of the entire control on the screen
			 *
			 * This is only useful when the control is visible.
			 */
			Invalidate(invalidateChildren: boolean): void;

			/**
			 * Queues a repaint of the specified `rect` of the control and any children.
			 *
			 * This is only useful when the control is visible.
			 */
			Invalidate(rect: Eto.Drawing.Rectangle): void;

			/**
			 * Queues a repaint of the specified `rect` of the control
			 *
			 * This is only useful when the control is visible.
			 */
			Invalidate(
				rect: Eto.Drawing.Rectangle,
				invalidateChildren: boolean,
			): void;

			/**
			 * Updates the layout of this control if necessary.
			 *
			 * This will ensure the control has had all of its layout applied so you can use its
			 * position and size right after this call. Most platforms (except WinForms) use a
			 * deferred layout system so that after adding your control to the form dynamically it
			 * won't get laid out until the next idle loop. This is useful when you need to know the
			 * dimensions of the control immediately. Note that this can be an expensive operation,
			 * so it is recommended to only call this method when necessary and after all of the
			 * controls have been added/updated.
			 */
			UpdateLayout(): void;

			/** Gets the preferred size of this control given infinite space available. */
			GetPreferredSize(): Eto.Drawing.SizeF;

			/** Gets the preferred size of this control given the specified `availableSize`. */
			GetPreferredSize(availableSize: Eto.Drawing.SizeF): Eto.Drawing.SizeF;

			/**
			 * Captures all mouse events to this control.
			 *
			 * This captures all mouse events until {@link Eto.Forms.Control.ReleaseMouseCapture} is
			 * called.  Note that not all platforms will allow a mouse capture unless the mouse is
			 * currently down.
			 */
			CaptureMouse(): boolean;

			/** Releases the mouse capture after a call to {@link Eto.Forms.Control.CaptureMouse}. */
			ReleaseMouseCapture(): void;

			/**
			 * Finds a control in the parent hierarchy with the specified type and
			 * {@link Eto.Widget.ID} if specified
			 */
			FindParent(
				type: unknown,
				id?: string,
			): Eto.Forms.Container;

			/** Finds a control in the parent hierarchy with the specified `id` */
			FindParent(id: string): Eto.Forms.Container;

			/**
			 * Detaches the control by removing it from its parent
			 *
			 * This is essentially a shortcut to myControl.Parent.Remove(myControl);
			 */
			Detach(): void;

			/**
			 * Attaches the control for direct use in a native application
			 *
			 * Use this to use a control directly in a native application.  Note that the native
			 * application must be running the same framework as the current platform.  E.g. a
			 * WinForms application can use an Eto.Forms control when using the Eto.WinForms
			 * platform.  This prepares the control by firing the {@link Eto.Forms.Control.PreLoad},
			 * {@link Eto.Forms.Control.Load}, etc. events.
			 */
			AttachNative(): void;

			/**
			 * Detaches the control when it is used in a native application, when you want to reuse
			 * the control.
			 *
			 * This should only be called after {@link Eto.Forms.Control.AttachNative} has been
			 * called, which is usually done by calling to ToNative(true) .
			 */
			DetachNative(): void;

			/**
			 * Attempts to set the keyboard input focus to this control, or the first child that
			 * accepts focus. For Windows, this will bring it to front and activate it.
			 */
			Focus(): void;

			/**
			 * Suspends the layout of child controls
			 *
			 * This can be used to optimize some platforms while adding, removing, or changing many
			 * child controls at once. It disables the calculation of control positioning until
			 * {@link Eto.Forms.Control.ResumeLayout} is called. Each call to SuspendLayout() must be
			 * balanced with a call to {@link Eto.Forms.Control.ResumeLayout}.
			 */
			SuspendLayout(): void;

			/**
			 * Resumes the layout after it has been suspended, and performs a layout
			 *
			 * This can be used to optimize some platforms while adding, removing, or changing many
			 * child controls at once. Each call to ResumeLayout() must be balanced with a call to
			 * {@link Eto.Forms.Control.SuspendLayout} before it.
			 */
			ResumeLayout(): void;

			/**
			 * Specifies a command to execute for a platform-specific command
			 *
			 * Some platforms have specific system-defined commands that can be associated with a
			 * control. For example, the Mac platform's cut/copy/paste functionality is defined by
			 * the system, and if you want to hook into it, you can use this to map it to your own
			 * defined logic. The valid values of the `systemCommand` parameter are defined by each
			 * platform, and a list can be retrieved using
			 * {@link Eto.Forms.Control.SupportedPlatformCommands}
			 */
			MapPlatformCommand(
				systemCommand: string,
				command: Eto.Forms.Command,
			): void;

			/** Converts a point from screen space to control space. */
			PointFromScreen(point: Eto.Drawing.PointF): Eto.Drawing.PointF;

			/** Converts a point from control space to screen space */
			PointToScreen(point: Eto.Drawing.PointF): Eto.Drawing.PointF;

			/** Converts a rectangle from screen space to control space. */
			RectangleToScreen(rect: Eto.Drawing.RectangleF): Eto.Drawing.RectangleF;

			/** Converts a rectangle from control space to screen space */
			RectangleFromScreen(rect: Eto.Drawing.RectangleF): Eto.Drawing.RectangleF;

			/**
			 * Starts drag operation using this control as drag source.
			 *
			 * This method can be blocking on some platforms (Wpf, WinForms), and non-blocking on
			 * others (Mac, Gtk). Use the {@link Eto.Forms.Control.DragEnd} event to determine when
			 * the drag operation is completed and get its resulting DragEffects.
			 */
			DoDragDrop(
				data: Eto.Forms.DataObject,
				allowedEffects: Eto.Forms.DragEffects,
			): void;

			/**
			 * Starts drag operation using this control as drag source.
			 *
			 * This method can be blocking on some platforms (Wpf, WinForms), and non-blocking on
			 * others (Mac, Gtk). Use the {@link Eto.Forms.Control.DragEnd} event to determine when
			 * the drag operation is completed and get its resulting DragEffects.
			 */
			DoDragDrop(
				data: Eto.Forms.DataObject,
				allowedEffects: Eto.Forms.DragEffects,
				image: Eto.Drawing.Image,
				cursorOffset: Eto.Drawing.PointF,
			): void;

			/**
			 * Triggers the StyleChanged event and re-applies the styles to this control and its
			 * children.
			 */
			TriggerStyleChanged(): void;

			/** Shows a print dialog to print the specified control */
			Print(): void;

			/**
			 * Finds a control in the parent hierarchy with the specified type and
			 * {@link Eto.Widget.ID} if specified
			 */
			FindParent<T>(id?: string): T;

			/**
			 * Finds a control in the parent hierarchy with the specified type and
			 * {@link Eto.Widget.ID} if specified
			 */
			FindParent(
				type: unknown,
				id?: string,
			): Eto.Widget;

			/** Finds a control in the parent hierarchy with the specified `id` */
			FindParent(id: string): Eto.Widget;

			/**
			 * Unbinds any bindings in the {@link Eto.Forms.BindableWidget.Bindings} collection and
			 * removes the bindings
			 *
			 * When you implement {@link Eto.Forms.IBindableWidgetContainer}, this will also unbind
			 * any of its children.
			 */
			Unbind(): void;

			/**
			 * Updates all bindings in this widget
			 *
			 * When you implement {@link Eto.Forms.IBindableWidgetContainer}, this will also update
			 * bindings for all of its children.
			 */
			UpdateBindings(mode?: Eto.Forms.BindingUpdateMode): void;

			/** Disposes of this widget, supressing the finalizer */
			dispose(): void;

			/** Gets a string that represents the current object with its ID if specified. */
			ToString(): string;
		}
	}

	export namespace Eto.Forms.DocumentControl {
		export interface ICallback extends
			Eto.Forms.Control.ICallback,
			Eto.Widget.ICallback {
			OnPageClosed(
				widget: Eto.Forms.DocumentControl,
				e: Eto.Forms.DocumentPageEventArgs,
			): void;

			OnPageClosing(
				widget: Eto.Forms.DocumentControl,
				e: Eto.Forms.DocumentPageClosingEventArgs,
			): void;

			OnSelectedIndexChanged(
				widget: Eto.Forms.DocumentControl,
				e: unknown,
			): void;

			OnPageReordered(
				widget: Eto.Forms.DocumentControl,
				e: Eto.Forms.DocumentPageReorderEventArgs,
			): void;
		}
	}

	export namespace Eto.Forms.DocumentControl {
		export interface IHandler extends
			Eto.Forms.Container.IHandler,
			Eto.Forms.Control.IHandler,
			Eto.Widget.IHandler {
			SelectedIndex: number;

			AllowReordering: boolean;

			InsertPage(
				index: number,
				page: Eto.Forms.DocumentPage,
			): void;

			GetPage(index: number): Eto.Forms.DocumentPage;

			GetPageCount(): number;

			RemovePage(index: number): void;
		}
	}

	export namespace Eto.Forms {
		/** Control for a page in a {@link Eto.Forms.DocumentControl} */
		export class DocumentPage implements
			Eto.IHandlerSource,
			Eto.Forms.IBindable,
			Eto.Forms.IMouseInputSource,
			Eto.Forms.IKeyboardInputSource {
			/** Initializes a new instance of the {@link Eto.Forms.DocumentPage} class. */
			constructor(
				control: Eto.Forms.Control,
				padding?: Eto.Drawing.Padding,
			);

			/** Initializes a new instance of the {@link Eto.Forms.DocumentPage} class. */
			constructor();

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Forms.DocumentPage} is
			 * closable.
			 */
			Closable: boolean;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Forms.DocumentPage} has
			 * unsaved changes.
			 */
			HasUnsavedChanges: boolean;

			/**
			 * Gets or sets the image of the page.
			 *
			 * It is usally good to use an {@link Eto.Drawing.Icon} for the image with multiple
			 * sizes, so that scaling won't be needed to fit the image in the space. Usually you'd
			 * need 16x16 (desktop), 32x32 (iOS), and 64x64 (iOS Retina) variations.
			 */
			Image: Eto.Drawing.Image;

			/** Gets or sets the title text of the page. */
			Text: string;

			/** Gets an enumeration of controls that are directly contained by this container */
			readonly Controls: Iterable<Eto.Forms.Control>;

			/** Gets or sets the padding around the {@link Eto.Forms.Panel.Content} of the panel. */
			Padding: Eto.Drawing.Padding;

			/** Gets or sets the minimum size of the panel. */
			MinimumSize: Eto.Drawing.Size;

			/**
			 * Gets or sets the context menu for the panel.
			 *
			 * The context menu is usually shown when the user right clicks the control, or in mobile
			 * platforms when the user taps and holds their finger down on the control.
			 */
			ContextMenu: Eto.Forms.ContextMenu;

			/**
			 * Gets or sets the main content of the panel.
			 *
			 * The main content will be offset by the {@link Eto.Forms.Panel.Padding} value
			 * specified, and will take up the entire content area of the control. Some controls may
			 * have decorations that will surround the content, such as a {@link Eto.Forms.GroupBox},
			 * {@link Eto.Forms.TabControl}, or {@link Eto.Forms.Window}
			 */
			Content: Eto.Forms.Control;

			/**
			 * Gets or sets the size for the client area of the control
			 *
			 * The client size differs from the {@link Eto.Forms.Control.Size} in that it excludes
			 * the decorations of the container, such as the title bar and border around a
			 * {@link Eto.Forms.Window}, or the title and line  around a {@link Eto.Forms.GroupBox}.
			 */
			ClientSize: Eto.Drawing.Size;

			/**
			 * Gets an enumeration of all contained child controls, including controls within child
			 * containers
			 */
			readonly Children: Iterable<Eto.Forms.Control>;

			/**
			 * Gets an enumeration of all contained child controls in the visual tree, including
			 * controls within child containers.
			 */
			readonly VisualChildren: Iterable<Eto.Forms.Control>;

			/**
			 * Gets or sets the style provider for this container.
			 *
			 * The style provider is used to style this container and its children.
			 */
			StyleProvider: Eto.IStyleProvider;

			/**
			 * Gets the default style provider for this container.
			 *
			 * Use this to apply styles to any child controls of this container. By default, styles
			 * will apply to all children, including children of children unless
			 * {@link Eto.DefaultStyleProvider.Inherit} is set to false .  Typically, you would set
			 * Inherit to false when creating composite controls that already have all their styles
			 * applied and you don't want any other styles to be inherited.
			 */
			readonly Styles: Eto.DefaultStyleProvider;

			/**
			 * Gets a value indicating that the control is loaded onto a form, that is it has been
			 * created, added to a parent, and shown
			 *
			 * The {@link Eto.Forms.Control.OnLoad(System.EventArgs)} method sets this value to true
			 * after cascading to all children (for a {@link Eto.Forms.Container} ) and calling the
			 * platform handler's implementation.  It is called after adding to a loaded form, or
			 * when showing a new form.  The {@link Eto.Forms.Control.OnUnLoad(System.EventArgs)}
			 * method will set this value to false when the control is removed from its parent
			 */
			readonly Loaded: boolean;

			/**
			 * Gets an enumeration of controls that are in the visual tree.
			 *
			 * This is used to specify which controls are contained by this instance that are part of
			 * the visual tree. This should include all controls including non-logical Eto controls
			 * used for layout.
			 */
			readonly VisualControls: Iterable<Eto.Forms.Control>;

			/**
			 * Gets or sets a user-defined object that contains data about the control
			 *
			 * A common use of the tag property is to store data that is associated with the control
			 * that you can later retrieve.
			 */
			Tag: unknown;

			/**
			 * Gets the logical parent control.
			 *
			 * When the control is part of the visual tree (
				 * {@link Eto.Forms.Control.IsVisualControl} is true), this returns the logical parent
				 * that contains this control. Otherwise this is the same as
				 * {@link Eto.Forms.Control.Parent}.
				 */
				readonly LogicalParent: Eto.Forms.Container;

			/** Gets a value indicating this {@link Eto.Forms.Control} is part of the visual tree. */
			IsVisualControl: boolean;

			/**
			 * Gets or sets the size of the control. Use -1 to specify auto sizing for either the
			 * width and/or height.
			 *
			 * Setting the size of controls is entirely optional as most controls will size
			 * themselves appropriately. When specifying a size, it will be used as the desired size
			 * of the control.  The container will reposition and resize the control depending on the
			 * available size.  For a {@link Eto.Forms.Window}, it is preferred to set the
			 * {@link Eto.Forms.Container.ClientSize} instead, as various platforms have different
			 * sizes of window decorations, toolbars, etc.
			 */
			Size: Eto.Drawing.Size;

			/**
			 * Gets a value indicating this control currently has mouse capture
			 *
			 * Mouse capture can happen during a handled MouseDown event until MouseUp, or it can be
			 * captured explicitly via {@link Eto.Forms.Control.CaptureMouse}.
			 */
			readonly IsMouseCaptured: boolean;

			/** Gets or sets the width of the control size. */
			Width: number;

			/** Gets or sets the height of the control size. */
			Height: number;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Forms.Control} (or its
			 * children) are enabled and accept user input.
			 *
			 * Typically when a control is disabled, the user cannot do anything with the control or
			 * any of its children. Including for example, selecting text in a text control. Certain
			 * controls can have a 'Read Only' mode, such as {@link Eto.Forms.TextBox.ReadOnly} which
			 * allow the user to  select text, but not change its contents.
			 */
			Enabled: boolean;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Forms.Control} is visible to
			 * the user.
			 *
			 * When the visibility of a control is set to false, it will not occupy space in the
			 * layout.
			 */
			Visible: boolean;

			/** Gets the container which this control has been added to, if any */
			readonly Parent: Eto.Forms.Container;

			/**
			 * Gets the visual container of this control, if any.
			 *
			 * Some containers may use other Eto controls to layout its children, such as the
			 * {@link Eto.Forms.StackLayout}. This will return the parent control that visually
			 * contains this control as opposed to {@link Eto.Forms.Control.Parent} which will return
			 * the logical parent.
			 */
			VisualParent: Eto.Forms.Container;

			/** Gets a value indicating this control has been attached to a native container */
			readonly IsAttached: boolean;

			/**
			 * Gets or sets the color for the background of the control
			 *
			 * Note that on some platforms (e.g. Mac), setting the background color of a control can
			 * change the performance characteristics of the control and its children, since it must
			 * enable layers to do so.
			 */
			BackgroundColor: Eto.Drawing.Color;

			/** Gets a value indicating whether this instance has the keyboard input focus. */
			readonly HasFocus: boolean;

			/** Gets a value indicating whether the layout of child controls is suspended. */
			readonly IsSuspended: boolean;

			/** Gets the window this control is contained in */
			readonly ParentWindow: Eto.Forms.Window;

			/**
			 * Gets the supported platform commands that can be used to hook up system functions to
			 * user defined logic
			 *
			 * This lists all available commands that can be mapped using the
			 * {@link Eto.Forms.Control.MapPlatformCommand(System.String,Eto.Forms.Command)} method
			 * of the control.
			 */
			readonly SupportedPlatformCommands: Iterable<string>;

			/** Gets the bounding rectangle of this control relative to its container */
			readonly Bounds: Eto.Drawing.Rectangle;

			/**
			 * Gets the location of the control as positioned by the container
			 *
			 * A control's location is set by the container. This can be used to determine where the
			 * control is for overlaying floating windows, menus, etc.
			 */
			readonly Location: Eto.Drawing.Point;

			/** Gets or sets the type of cursor to use when the mouse is hovering over the control */
			Cursor: Eto.Forms.Cursor;

			/** Gets or sets the tool tip to show when the mouse is hovered over the control */
			ToolTip: string;

			/**
			 * Gets or sets the tab index order for this control within its container.
			 *
			 * This sets the order when using the tab key to cycle through controls  Note that some
			 * platforms (Gtk and WinForms) may not support setting the context of the tab order to
			 * StackLayout  or DynamicLayout containers and may not behave exactly as expected. Use
			 * the {@link Eto.PlatformFeatures.TabIndexWithCustomContainers} flag to determine if it
			 * is supported.
			 */
			TabIndex: number;

			/** Gets or sets a value indicating whether this control can serve as drop target. */
			AllowDrop: boolean;

			/**
			 * Gets or sets the parent widget which this widget has been added to, if any
			 *
			 * When implementing child widgets that can participate in the context based binding
			 * (MVVM), You can set this to the parent widget when it is added or removed to it
			 * (usually via a collection).  Note that you should typically provide a public new
			 * [ParentWidget] Parent { get; } property  so that consumers of your API cannot set the
			 * parent to an invalid value.
			 */
			Parent: Eto.Widget;

			/**
			 * Gets an enumeration of all parent widgets in the heirarchy by traversing the
			 * {@link Eto.Forms.BindableWidget.Parent} property.
			 */
			readonly Parents: Iterable<Eto.Widget>;

			/**
			 * Gets or sets the data context for this widget for binding
			 *
			 * Subclasses may override the standard behaviour so that hierarchy of widgets can be
			 * taken into account.  For example, a Control may return the data context of a parent,
			 * if it is not set explicitly.
			 */
			DataContext: unknown;

			/** Gets the collection of bindings that are attached to this widget */
			readonly Bindings: Eto.Forms.BindingCollection;

			/**
			 * Gets a value indicating that the {@link Eto.Forms.BindableWidget.DataContext} property
			 * is changing.
			 *
			 * This can be used to determine when to allow certain logic during the update of the
			 * data context.  It is used to disable binding setters on the model when the data
			 * context changes so that a binding does not cause the view model to be updated when the
			 * state hasn't been fully set yet.
			 */
			IsDataContextChanging: boolean;

			/**
			 * Gets the platform that was used to create the {@link Eto.Widget.Handler} for this
			 * widget
			 *
			 * This gets set to the current {@link Eto.Platform.Instance} during the construction of
			 * the object
			 */
			readonly Platform: Eto.Platform;

			/** Gets the platform-specific handler for this widget */
			Handler: unknown;

			/** Gets the native platform-specific handle for integration purposes */
			readonly NativeHandle: unknown;

			/** Gets the dictionary of properties for this widget */
			readonly Properties: Eto.PropertyStore;

			/** Gets or sets the ID of this widget */
			ID: string;

			/**
			 * Gets or sets the style of this widget
			 *
			 * Styles allow you to attach custom platform-specific logic to a widget. In your
			 * platform-specific assembly, use {@link Style.Add{H}(string, StyleHandler{H})} to add
			 * the style logic with the same id.
			 */
			Style: string;

			/**
			 * Gets the instance of the platform-specific object
			 *
			 * This can sometimes be useful to get the platform-specific object. Some handlers may
			 * not have any backing object for its functionality, so this may be null.  It is more
			 * preferred to use the {@link Eto.Widget.Handler} and cast that to the platform-specific
			 * handler class which can give you additional methods and helpers to do common tasks.
			 * For example, the {@link Eto.Forms.Application} object's handler for OS X has a
			 * AddFullScreenMenuItem property to specify if you want full screen support in your app.
			 */
			readonly ControlObject: unknown;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Widget} has been disposed.
			 *
			 * When the widget is disposed, it can no longer be used.
			 */
			IsDisposed: boolean;

			/** Removes the specified child from the container */
			Remove(child: Eto.Forms.Control): void;

			/** Remove the specified `controls` from this container */
			Remove(controls: Iterable<Eto.Forms.Control>): void;

			/** Removes all controls from this container */
			RemoveAll(): void;

			/**
			 * Finds a child control in this container or any of its child containers with the
			 * specified `id`
			 */
			FindChild<T>(id?: string): T;

			/**
			 * Finds a child control in this container or any of its child containers with the
			 * specified `type`
			 */
			FindChild(
				type: unknown,
				id?: string,
			): Eto.Forms.Control;

			/**
			 * Finds a child control in this container or any of its child containers with the
			 * specified `id`.
			 */
			FindChild(id: string): Eto.Forms.Control;

			/**
			 * Queues a repaint of the entire control on the screen and any of its children.
			 *
			 * This is only useful when the control is visible.
			 */
			Invalidate(): void;

			/**
			 * Queues a repaint of the entire control on the screen
			 *
			 * This is only useful when the control is visible.
			 */
			Invalidate(invalidateChildren: boolean): void;

			/**
			 * Queues a repaint of the specified `rect` of the control and any children.
			 *
			 * This is only useful when the control is visible.
			 */
			Invalidate(rect: Eto.Drawing.Rectangle): void;

			/**
			 * Queues a repaint of the specified `rect` of the control
			 *
			 * This is only useful when the control is visible.
			 */
			Invalidate(
				rect: Eto.Drawing.Rectangle,
				invalidateChildren: boolean,
			): void;

			/**
			 * Updates the layout of this control if necessary.
			 *
			 * This will ensure the control has had all of its layout applied so you can use its
			 * position and size right after this call. Most platforms (except WinForms) use a
			 * deferred layout system so that after adding your control to the form dynamically it
			 * won't get laid out until the next idle loop. This is useful when you need to know the
			 * dimensions of the control immediately. Note that this can be an expensive operation,
			 * so it is recommended to only call this method when necessary and after all of the
			 * controls have been added/updated.
			 */
			UpdateLayout(): void;

			/** Gets the preferred size of this control given infinite space available. */
			GetPreferredSize(): Eto.Drawing.SizeF;

			/** Gets the preferred size of this control given the specified `availableSize`. */
			GetPreferredSize(availableSize: Eto.Drawing.SizeF): Eto.Drawing.SizeF;

			/**
			 * Captures all mouse events to this control.
			 *
			 * This captures all mouse events until {@link Eto.Forms.Control.ReleaseMouseCapture} is
			 * called.  Note that not all platforms will allow a mouse capture unless the mouse is
			 * currently down.
			 */
			CaptureMouse(): boolean;

			/** Releases the mouse capture after a call to {@link Eto.Forms.Control.CaptureMouse}. */
			ReleaseMouseCapture(): void;

			/**
			 * Finds a control in the parent hierarchy with the specified type and
			 * {@link Eto.Widget.ID} if specified
			 */
			FindParent(
				type: unknown,
				id?: string,
			): Eto.Forms.Container;

			/** Finds a control in the parent hierarchy with the specified `id` */
			FindParent(id: string): Eto.Forms.Container;

			/**
			 * Detaches the control by removing it from its parent
			 *
			 * This is essentially a shortcut to myControl.Parent.Remove(myControl);
			 */
			Detach(): void;

			/**
			 * Attaches the control for direct use in a native application
			 *
			 * Use this to use a control directly in a native application.  Note that the native
			 * application must be running the same framework as the current platform.  E.g. a
			 * WinForms application can use an Eto.Forms control when using the Eto.WinForms
			 * platform.  This prepares the control by firing the {@link Eto.Forms.Control.PreLoad},
			 * {@link Eto.Forms.Control.Load}, etc. events.
			 */
			AttachNative(): void;

			/**
			 * Detaches the control when it is used in a native application, when you want to reuse
			 * the control.
			 *
			 * This should only be called after {@link Eto.Forms.Control.AttachNative} has been
			 * called, which is usually done by calling to ToNative(true) .
			 */
			DetachNative(): void;

			/**
			 * Attempts to set the keyboard input focus to this control, or the first child that
			 * accepts focus. For Windows, this will bring it to front and activate it.
			 */
			Focus(): void;

			/**
			 * Suspends the layout of child controls
			 *
			 * This can be used to optimize some platforms while adding, removing, or changing many
			 * child controls at once. It disables the calculation of control positioning until
			 * {@link Eto.Forms.Control.ResumeLayout} is called. Each call to SuspendLayout() must be
			 * balanced with a call to {@link Eto.Forms.Control.ResumeLayout}.
			 */
			SuspendLayout(): void;

			/**
			 * Resumes the layout after it has been suspended, and performs a layout
			 *
			 * This can be used to optimize some platforms while adding, removing, or changing many
			 * child controls at once. Each call to ResumeLayout() must be balanced with a call to
			 * {@link Eto.Forms.Control.SuspendLayout} before it.
			 */
			ResumeLayout(): void;

			/**
			 * Specifies a command to execute for a platform-specific command
			 *
			 * Some platforms have specific system-defined commands that can be associated with a
			 * control. For example, the Mac platform's cut/copy/paste functionality is defined by
			 * the system, and if you want to hook into it, you can use this to map it to your own
			 * defined logic. The valid values of the `systemCommand` parameter are defined by each
			 * platform, and a list can be retrieved using
			 * {@link Eto.Forms.Control.SupportedPlatformCommands}
			 */
			MapPlatformCommand(
				systemCommand: string,
				command: Eto.Forms.Command,
			): void;

			/** Converts a point from screen space to control space. */
			PointFromScreen(point: Eto.Drawing.PointF): Eto.Drawing.PointF;

			/** Converts a point from control space to screen space */
			PointToScreen(point: Eto.Drawing.PointF): Eto.Drawing.PointF;

			/** Converts a rectangle from screen space to control space. */
			RectangleToScreen(rect: Eto.Drawing.RectangleF): Eto.Drawing.RectangleF;

			/** Converts a rectangle from control space to screen space */
			RectangleFromScreen(rect: Eto.Drawing.RectangleF): Eto.Drawing.RectangleF;

			/**
			 * Starts drag operation using this control as drag source.
			 *
			 * This method can be blocking on some platforms (Wpf, WinForms), and non-blocking on
			 * others (Mac, Gtk). Use the {@link Eto.Forms.Control.DragEnd} event to determine when
			 * the drag operation is completed and get its resulting DragEffects.
			 */
			DoDragDrop(
				data: Eto.Forms.DataObject,
				allowedEffects: Eto.Forms.DragEffects,
			): void;

			/**
			 * Starts drag operation using this control as drag source.
			 *
			 * This method can be blocking on some platforms (Wpf, WinForms), and non-blocking on
			 * others (Mac, Gtk). Use the {@link Eto.Forms.Control.DragEnd} event to determine when
			 * the drag operation is completed and get its resulting DragEffects.
			 */
			DoDragDrop(
				data: Eto.Forms.DataObject,
				allowedEffects: Eto.Forms.DragEffects,
				image: Eto.Drawing.Image,
				cursorOffset: Eto.Drawing.PointF,
			): void;

			/**
			 * Triggers the StyleChanged event and re-applies the styles to this control and its
			 * children.
			 */
			TriggerStyleChanged(): void;

			/** Shows a print dialog to print the specified control */
			Print(): void;

			/**
			 * Finds a control in the parent hierarchy with the specified type and
			 * {@link Eto.Widget.ID} if specified
			 */
			FindParent<T>(id?: string): T;

			/**
			 * Finds a control in the parent hierarchy with the specified type and
			 * {@link Eto.Widget.ID} if specified
			 */
			FindParent(
				type: unknown,
				id?: string,
			): Eto.Widget;

			/** Finds a control in the parent hierarchy with the specified `id` */
			FindParent(id: string): Eto.Widget;

			/**
			 * Unbinds any bindings in the {@link Eto.Forms.BindableWidget.Bindings} collection and
			 * removes the bindings
			 *
			 * When you implement {@link Eto.Forms.IBindableWidgetContainer}, this will also unbind
			 * any of its children.
			 */
			Unbind(): void;

			/**
			 * Updates all bindings in this widget
			 *
			 * When you implement {@link Eto.Forms.IBindableWidgetContainer}, this will also update
			 * bindings for all of its children.
			 */
			UpdateBindings(mode?: Eto.Forms.BindingUpdateMode): void;

			/** Disposes of this widget, supressing the finalizer */
			dispose(): void;

			/** Gets a string that represents the current object with its ID if specified. */
			ToString(): string;
		}
	}

	export namespace Eto.Forms.DocumentPage {
		export interface IHandler extends
			Eto.Forms.Panel.IHandler,
			Eto.Forms.Container.IHandler,
			Eto.Forms.Control.IHandler,
			Eto.Widget.IHandler,
			Eto.Forms.IContextMenuHost {
			Closable: boolean;

			HasUnsavedChanges: boolean;

			Image: Eto.Drawing.Image;

			Text: string;
		}
	}

	export namespace Eto.Forms {
		/** Enumeration of drag actions. */
		export enum DragEffects {
			/** No drag operation. */
			None = 0,

			/** Copy data operation. */
			Copy = 1,

			/** Move data operation. */
			Move = 2,

			/** Link data operation. */
			Link = 4,

			/** All data operations. */
			All = 7,
		}
	}

	export namespace Eto.Forms {
		/** Drag/Drop event arguments. */
		export class DragEventArgs {
			/** Initializes a new instance of the {@link Eto.Forms.DragEventArgs} class. */
			constructor(
				source: Eto.Forms.Control,
				data: Eto.Forms.DataObject,
				allowedEffects: Eto.Forms.DragEffects,
				location: Eto.Drawing.PointF,
				modifiers: Eto.Forms.Keys,
				buttons: Eto.Forms.MouseButtons,
				controlObject?: unknown,
			);

			/** Gets source control of drag operation. */
			readonly Source: Eto.Forms.Control;

			/** Gets drag data. */
			readonly Data: Eto.Forms.DataObject;

			/** Gets allowed drag/drop operation. */
			readonly AllowedEffects: Eto.Forms.DragEffects;

			/** Gets or sets target drag/drop operation. */
			Effects: Eto.Forms.DragEffects;

			/** Location of the cursor in control coordinates */
			readonly Location: Eto.Drawing.PointF;

			/** Modifier keys pressed */
			readonly Modifiers: Eto.Forms.Keys;

			/** The mouse buttons pressed during the drag */
			readonly Buttons: Eto.Forms.MouseButtons;

			/**
			 * Gets the instance of the platform-specific object associated with the drag event
			 *
			 * This can be used by platform implementations to store additional information about the
			 * drag operation,  such as the parent object and child index for
			 * {@link Eto.Forms.TreeGridView.GetDragInfo(Eto.Forms.DragEventArgs)}.
			 */
			readonly ControlObject: unknown;

			/**
			 * Gets a value indicating that the
			 * {@link Eto.Forms.DragEventArgs.SetDropDescription(System.String,System.String)} method
			 * is supported for the current drag/drop operation.
			 */
			readonly SupportsDropDescription: boolean;

			/**
			 * Sets the drop description when dragging overtop your control to specify additional
			 * context of what will be done.
			 *
			 * Note that some platforms may not support this, as it is only a hint for drag/drop
			 * operations. Use {@link Eto.Forms.DragEventArgs.SupportsDropDescription} to determine
			 * if the platform supports it. Currently works only in Wpf, and WinForms.
			 */
			SetDropDescription(
				format: string,
				inner?: string,
			): void;
		}
	}

	export namespace Eto.Forms {
		/** Event arguments when painting using the {@link Eto.Forms.Drawable.Paint} event */
		export class PaintEventArgs {
			/** Initializes a new instance of the {@link Eto.Forms.PaintEventArgs} class. */
			constructor(
				graphics: Eto.Drawing.Graphics,
				clipRectangle: Eto.Drawing.RectangleF,
			);

			/** Gets the graphics for the paint operation */
			Graphics: Eto.Drawing.Graphics;

			/**
			 * Gets the rectangle of the region being painted
			 *
			 * This should be used to optimize what is drawn by only drawing content that intersects
			 * with this rectangle.
			 */
			ClipRectangle: Eto.Drawing.RectangleF;
		}
	}

	export namespace Eto.Forms {
		/**
		 * Control with a paintable user interface
		 *
		 * The drawable control is used to perform custom painting.
		 */
		export class Drawable implements
			Eto.IHandlerSource,
			Eto.Forms.IBindable,
			Eto.Forms.IMouseInputSource,
			Eto.Forms.IKeyboardInputSource {
			/** Initializes a new instance of the {@link Eto.Forms.Drawable} class. */
			constructor();

			/**
			 * Initializes a new instance of the {@link Eto.Forms.Drawable} class with a hint whether
			 * it is intended for a large canvas
			 *
			 * Some platforms can optimize large canvases, such as mobile platforms by tiling the
			 * painting of the canvas.  A large canvas is one that is larger than the intended screen
			 * size.  Platforms are not required to change the behaviour of the drawable depending on
			 * this value.  Desktop platforms typically do not change their behaviour based on this.
			 */
			constructor(largeCanvas: boolean);

			/**
			 * Gets a value indicating whether this {@link Eto.Forms.Drawable} supports the
			 * {@link Eto.Forms.Drawable.CreateGraphics} method
			 */
			readonly SupportsCreateGraphics: boolean;

			/**
			 * Gets or sets a value indicating whether this instance can recieve the input/keyboard
			 * focus
			 *
			 * If this is true, by default all platforms will focus the control automatically when it
			 * is clicked.
			 */
			CanFocus: boolean;

			/** Gets an enumeration of controls that are directly contained by this container */
			readonly Controls: Iterable<Eto.Forms.Control>;

			/** Gets or sets the padding around the {@link Eto.Forms.Panel.Content} of the panel. */
			Padding: Eto.Drawing.Padding;

			/** Gets or sets the minimum size of the panel. */
			MinimumSize: Eto.Drawing.Size;

			/**
			 * Gets or sets the context menu for the panel.
			 *
			 * The context menu is usually shown when the user right clicks the control, or in mobile
			 * platforms when the user taps and holds their finger down on the control.
			 */
			ContextMenu: Eto.Forms.ContextMenu;

			/**
			 * Gets or sets the main content of the panel.
			 *
			 * The main content will be offset by the {@link Eto.Forms.Panel.Padding} value
			 * specified, and will take up the entire content area of the control. Some controls may
			 * have decorations that will surround the content, such as a {@link Eto.Forms.GroupBox},
			 * {@link Eto.Forms.TabControl}, or {@link Eto.Forms.Window}
			 */
			Content: Eto.Forms.Control;

			/**
			 * Gets or sets the size for the client area of the control
			 *
			 * The client size differs from the {@link Eto.Forms.Control.Size} in that it excludes
			 * the decorations of the container, such as the title bar and border around a
			 * {@link Eto.Forms.Window}, or the title and line  around a {@link Eto.Forms.GroupBox}.
			 */
			ClientSize: Eto.Drawing.Size;

			/**
			 * Gets an enumeration of all contained child controls, including controls within child
			 * containers
			 */
			readonly Children: Iterable<Eto.Forms.Control>;

			/**
			 * Gets an enumeration of all contained child controls in the visual tree, including
			 * controls within child containers.
			 */
			readonly VisualChildren: Iterable<Eto.Forms.Control>;

			/**
			 * Gets or sets the style provider for this container.
			 *
			 * The style provider is used to style this container and its children.
			 */
			StyleProvider: Eto.IStyleProvider;

			/**
			 * Gets the default style provider for this container.
			 *
			 * Use this to apply styles to any child controls of this container. By default, styles
			 * will apply to all children, including children of children unless
			 * {@link Eto.DefaultStyleProvider.Inherit} is set to false .  Typically, you would set
			 * Inherit to false when creating composite controls that already have all their styles
			 * applied and you don't want any other styles to be inherited.
			 */
			readonly Styles: Eto.DefaultStyleProvider;

			/**
			 * Gets a value indicating that the control is loaded onto a form, that is it has been
			 * created, added to a parent, and shown
			 *
			 * The {@link Eto.Forms.Control.OnLoad(System.EventArgs)} method sets this value to true
			 * after cascading to all children (for a {@link Eto.Forms.Container} ) and calling the
			 * platform handler's implementation.  It is called after adding to a loaded form, or
			 * when showing a new form.  The {@link Eto.Forms.Control.OnUnLoad(System.EventArgs)}
			 * method will set this value to false when the control is removed from its parent
			 */
			readonly Loaded: boolean;

			/**
			 * Gets an enumeration of controls that are in the visual tree.
			 *
			 * This is used to specify which controls are contained by this instance that are part of
			 * the visual tree. This should include all controls including non-logical Eto controls
			 * used for layout.
			 */
			readonly VisualControls: Iterable<Eto.Forms.Control>;

			/**
			 * Gets or sets a user-defined object that contains data about the control
			 *
			 * A common use of the tag property is to store data that is associated with the control
			 * that you can later retrieve.
			 */
			Tag: unknown;

			/**
			 * Gets the logical parent control.
			 *
			 * When the control is part of the visual tree (
				 * {@link Eto.Forms.Control.IsVisualControl} is true), this returns the logical parent
				 * that contains this control. Otherwise this is the same as
				 * {@link Eto.Forms.Control.Parent}.
				 */
				readonly LogicalParent: Eto.Forms.Container;

			/** Gets a value indicating this {@link Eto.Forms.Control} is part of the visual tree. */
			IsVisualControl: boolean;

			/**
			 * Gets or sets the size of the control. Use -1 to specify auto sizing for either the
			 * width and/or height.
			 *
			 * Setting the size of controls is entirely optional as most controls will size
			 * themselves appropriately. When specifying a size, it will be used as the desired size
			 * of the control.  The container will reposition and resize the control depending on the
			 * available size.  For a {@link Eto.Forms.Window}, it is preferred to set the
			 * {@link Eto.Forms.Container.ClientSize} instead, as various platforms have different
			 * sizes of window decorations, toolbars, etc.
			 */
			Size: Eto.Drawing.Size;

			/**
			 * Gets a value indicating this control currently has mouse capture
			 *
			 * Mouse capture can happen during a handled MouseDown event until MouseUp, or it can be
			 * captured explicitly via {@link Eto.Forms.Control.CaptureMouse}.
			 */
			readonly IsMouseCaptured: boolean;

			/** Gets or sets the width of the control size. */
			Width: number;

			/** Gets or sets the height of the control size. */
			Height: number;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Forms.Control} (or its
			 * children) are enabled and accept user input.
			 *
			 * Typically when a control is disabled, the user cannot do anything with the control or
			 * any of its children. Including for example, selecting text in a text control. Certain
			 * controls can have a 'Read Only' mode, such as {@link Eto.Forms.TextBox.ReadOnly} which
			 * allow the user to  select text, but not change its contents.
			 */
			Enabled: boolean;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Forms.Control} is visible to
			 * the user.
			 *
			 * When the visibility of a control is set to false, it will not occupy space in the
			 * layout.
			 */
			Visible: boolean;

			/** Gets the container which this control has been added to, if any */
			readonly Parent: Eto.Forms.Container;

			/**
			 * Gets the visual container of this control, if any.
			 *
			 * Some containers may use other Eto controls to layout its children, such as the
			 * {@link Eto.Forms.StackLayout}. This will return the parent control that visually
			 * contains this control as opposed to {@link Eto.Forms.Control.Parent} which will return
			 * the logical parent.
			 */
			VisualParent: Eto.Forms.Container;

			/** Gets a value indicating this control has been attached to a native container */
			readonly IsAttached: boolean;

			/**
			 * Gets or sets the color for the background of the control
			 *
			 * Note that on some platforms (e.g. Mac), setting the background color of a control can
			 * change the performance characteristics of the control and its children, since it must
			 * enable layers to do so.
			 */
			BackgroundColor: Eto.Drawing.Color;

			/** Gets a value indicating whether this instance has the keyboard input focus. */
			readonly HasFocus: boolean;

			/** Gets a value indicating whether the layout of child controls is suspended. */
			readonly IsSuspended: boolean;

			/** Gets the window this control is contained in */
			readonly ParentWindow: Eto.Forms.Window;

			/**
			 * Gets the supported platform commands that can be used to hook up system functions to
			 * user defined logic
			 *
			 * This lists all available commands that can be mapped using the
			 * {@link Eto.Forms.Control.MapPlatformCommand(System.String,Eto.Forms.Command)} method
			 * of the control.
			 */
			readonly SupportedPlatformCommands: Iterable<string>;

			/** Gets the bounding rectangle of this control relative to its container */
			readonly Bounds: Eto.Drawing.Rectangle;

			/**
			 * Gets the location of the control as positioned by the container
			 *
			 * A control's location is set by the container. This can be used to determine where the
			 * control is for overlaying floating windows, menus, etc.
			 */
			readonly Location: Eto.Drawing.Point;

			/** Gets or sets the type of cursor to use when the mouse is hovering over the control */
			Cursor: Eto.Forms.Cursor;

			/** Gets or sets the tool tip to show when the mouse is hovered over the control */
			ToolTip: string;

			/**
			 * Gets or sets the tab index order for this control within its container.
			 *
			 * This sets the order when using the tab key to cycle through controls  Note that some
			 * platforms (Gtk and WinForms) may not support setting the context of the tab order to
			 * StackLayout  or DynamicLayout containers and may not behave exactly as expected. Use
			 * the {@link Eto.PlatformFeatures.TabIndexWithCustomContainers} flag to determine if it
			 * is supported.
			 */
			TabIndex: number;

			/** Gets or sets a value indicating whether this control can serve as drop target. */
			AllowDrop: boolean;

			/**
			 * Gets or sets the parent widget which this widget has been added to, if any
			 *
			 * When implementing child widgets that can participate in the context based binding
			 * (MVVM), You can set this to the parent widget when it is added or removed to it
			 * (usually via a collection).  Note that you should typically provide a public new
			 * [ParentWidget] Parent { get; } property  so that consumers of your API cannot set the
			 * parent to an invalid value.
			 */
			Parent: Eto.Widget;

			/**
			 * Gets an enumeration of all parent widgets in the heirarchy by traversing the
			 * {@link Eto.Forms.BindableWidget.Parent} property.
			 */
			readonly Parents: Iterable<Eto.Widget>;

			/**
			 * Gets or sets the data context for this widget for binding
			 *
			 * Subclasses may override the standard behaviour so that hierarchy of widgets can be
			 * taken into account.  For example, a Control may return the data context of a parent,
			 * if it is not set explicitly.
			 */
			DataContext: unknown;

			/** Gets the collection of bindings that are attached to this widget */
			readonly Bindings: Eto.Forms.BindingCollection;

			/**
			 * Gets a value indicating that the {@link Eto.Forms.BindableWidget.DataContext} property
			 * is changing.
			 *
			 * This can be used to determine when to allow certain logic during the update of the
			 * data context.  It is used to disable binding setters on the model when the data
			 * context changes so that a binding does not cause the view model to be updated when the
			 * state hasn't been fully set yet.
			 */
			IsDataContextChanging: boolean;

			/**
			 * Gets the platform that was used to create the {@link Eto.Widget.Handler} for this
			 * widget
			 *
			 * This gets set to the current {@link Eto.Platform.Instance} during the construction of
			 * the object
			 */
			readonly Platform: Eto.Platform;

			/** Gets the platform-specific handler for this widget */
			Handler: unknown;

			/** Gets the native platform-specific handle for integration purposes */
			readonly NativeHandle: unknown;

			/** Gets the dictionary of properties for this widget */
			readonly Properties: Eto.PropertyStore;

			/** Gets or sets the ID of this widget */
			ID: string;

			/**
			 * Gets or sets the style of this widget
			 *
			 * Styles allow you to attach custom platform-specific logic to a widget. In your
			 * platform-specific assembly, use {@link Style.Add{H}(string, StyleHandler{H})} to add
			 * the style logic with the same id.
			 */
			Style: string;

			/**
			 * Gets the instance of the platform-specific object
			 *
			 * This can sometimes be useful to get the platform-specific object. Some handlers may
			 * not have any backing object for its functionality, so this may be null.  It is more
			 * preferred to use the {@link Eto.Widget.Handler} and cast that to the platform-specific
			 * handler class which can give you additional methods and helpers to do common tasks.
			 * For example, the {@link Eto.Forms.Application} object's handler for OS X has a
			 * AddFullScreenMenuItem property to specify if you want full screen support in your app.
			 */
			readonly ControlObject: unknown;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Widget} has been disposed.
			 *
			 * When the widget is disposed, it can no longer be used.
			 */
			IsDisposed: boolean;

			/**
			 * Creates a graphics context for this control
			 *
			 * This can be used to draw directly onto the control. Ensure you dispose the graphics
			 * object after performing any painting. Note that not all platforms support drawing
			 * directly on the control, use {@link Eto.Forms.Drawable.SupportsCreateGraphics}.
			 */
			CreateGraphics(): Eto.Drawing.Graphics;

			/**
			 * Update the specified `region` directly
			 *
			 * This forces the region to be painted immediately.  On some platforms, this will be
			 * similar to calling {@link Eto.Forms.Control.Invalidate(Eto.Drawing.Rectangle)}, and
			 * queue the repaint instead of blocking until it is painted.
			 */
			Update(region: Eto.Drawing.Rectangle): void;

			/** Removes the specified child from the container */
			Remove(child: Eto.Forms.Control): void;

			/** Remove the specified `controls` from this container */
			Remove(controls: Iterable<Eto.Forms.Control>): void;

			/** Removes all controls from this container */
			RemoveAll(): void;

			/**
			 * Finds a child control in this container or any of its child containers with the
			 * specified `id`
			 */
			FindChild<T>(id?: string): T;

			/**
			 * Finds a child control in this container or any of its child containers with the
			 * specified `type`
			 */
			FindChild(
				type: unknown,
				id?: string,
			): Eto.Forms.Control;

			/**
			 * Finds a child control in this container or any of its child containers with the
			 * specified `id`.
			 */
			FindChild(id: string): Eto.Forms.Control;

			/**
			 * Queues a repaint of the entire control on the screen and any of its children.
			 *
			 * This is only useful when the control is visible.
			 */
			Invalidate(): void;

			/**
			 * Queues a repaint of the entire control on the screen
			 *
			 * This is only useful when the control is visible.
			 */
			Invalidate(invalidateChildren: boolean): void;

			/**
			 * Queues a repaint of the specified `rect` of the control and any children.
			 *
			 * This is only useful when the control is visible.
			 */
			Invalidate(rect: Eto.Drawing.Rectangle): void;

			/**
			 * Queues a repaint of the specified `rect` of the control
			 *
			 * This is only useful when the control is visible.
			 */
			Invalidate(
				rect: Eto.Drawing.Rectangle,
				invalidateChildren: boolean,
			): void;

			/**
			 * Updates the layout of this control if necessary.
			 *
			 * This will ensure the control has had all of its layout applied so you can use its
			 * position and size right after this call. Most platforms (except WinForms) use a
			 * deferred layout system so that after adding your control to the form dynamically it
			 * won't get laid out until the next idle loop. This is useful when you need to know the
			 * dimensions of the control immediately. Note that this can be an expensive operation,
			 * so it is recommended to only call this method when necessary and after all of the
			 * controls have been added/updated.
			 */
			UpdateLayout(): void;

			/** Gets the preferred size of this control given infinite space available. */
			GetPreferredSize(): Eto.Drawing.SizeF;

			/** Gets the preferred size of this control given the specified `availableSize`. */
			GetPreferredSize(availableSize: Eto.Drawing.SizeF): Eto.Drawing.SizeF;

			/**
			 * Captures all mouse events to this control.
			 *
			 * This captures all mouse events until {@link Eto.Forms.Control.ReleaseMouseCapture} is
			 * called.  Note that not all platforms will allow a mouse capture unless the mouse is
			 * currently down.
			 */
			CaptureMouse(): boolean;

			/** Releases the mouse capture after a call to {@link Eto.Forms.Control.CaptureMouse}. */
			ReleaseMouseCapture(): void;

			/**
			 * Finds a control in the parent hierarchy with the specified type and
			 * {@link Eto.Widget.ID} if specified
			 */
			FindParent(
				type: unknown,
				id?: string,
			): Eto.Forms.Container;

			/** Finds a control in the parent hierarchy with the specified `id` */
			FindParent(id: string): Eto.Forms.Container;

			/**
			 * Detaches the control by removing it from its parent
			 *
			 * This is essentially a shortcut to myControl.Parent.Remove(myControl);
			 */
			Detach(): void;

			/**
			 * Attaches the control for direct use in a native application
			 *
			 * Use this to use a control directly in a native application.  Note that the native
			 * application must be running the same framework as the current platform.  E.g. a
			 * WinForms application can use an Eto.Forms control when using the Eto.WinForms
			 * platform.  This prepares the control by firing the {@link Eto.Forms.Control.PreLoad},
			 * {@link Eto.Forms.Control.Load}, etc. events.
			 */
			AttachNative(): void;

			/**
			 * Detaches the control when it is used in a native application, when you want to reuse
			 * the control.
			 *
			 * This should only be called after {@link Eto.Forms.Control.AttachNative} has been
			 * called, which is usually done by calling to ToNative(true) .
			 */
			DetachNative(): void;

			/**
			 * Attempts to set the keyboard input focus to this control, or the first child that
			 * accepts focus. For Windows, this will bring it to front and activate it.
			 */
			Focus(): void;

			/**
			 * Suspends the layout of child controls
			 *
			 * This can be used to optimize some platforms while adding, removing, or changing many
			 * child controls at once. It disables the calculation of control positioning until
			 * {@link Eto.Forms.Control.ResumeLayout} is called. Each call to SuspendLayout() must be
			 * balanced with a call to {@link Eto.Forms.Control.ResumeLayout}.
			 */
			SuspendLayout(): void;

			/**
			 * Resumes the layout after it has been suspended, and performs a layout
			 *
			 * This can be used to optimize some platforms while adding, removing, or changing many
			 * child controls at once. Each call to ResumeLayout() must be balanced with a call to
			 * {@link Eto.Forms.Control.SuspendLayout} before it.
			 */
			ResumeLayout(): void;

			/**
			 * Specifies a command to execute for a platform-specific command
			 *
			 * Some platforms have specific system-defined commands that can be associated with a
			 * control. For example, the Mac platform's cut/copy/paste functionality is defined by
			 * the system, and if you want to hook into it, you can use this to map it to your own
			 * defined logic. The valid values of the `systemCommand` parameter are defined by each
			 * platform, and a list can be retrieved using
			 * {@link Eto.Forms.Control.SupportedPlatformCommands}
			 */
			MapPlatformCommand(
				systemCommand: string,
				command: Eto.Forms.Command,
			): void;

			/** Converts a point from screen space to control space. */
			PointFromScreen(point: Eto.Drawing.PointF): Eto.Drawing.PointF;

			/** Converts a point from control space to screen space */
			PointToScreen(point: Eto.Drawing.PointF): Eto.Drawing.PointF;

			/** Converts a rectangle from screen space to control space. */
			RectangleToScreen(rect: Eto.Drawing.RectangleF): Eto.Drawing.RectangleF;

			/** Converts a rectangle from control space to screen space */
			RectangleFromScreen(rect: Eto.Drawing.RectangleF): Eto.Drawing.RectangleF;

			/**
			 * Starts drag operation using this control as drag source.
			 *
			 * This method can be blocking on some platforms (Wpf, WinForms), and non-blocking on
			 * others (Mac, Gtk). Use the {@link Eto.Forms.Control.DragEnd} event to determine when
			 * the drag operation is completed and get its resulting DragEffects.
			 */
			DoDragDrop(
				data: Eto.Forms.DataObject,
				allowedEffects: Eto.Forms.DragEffects,
			): void;

			/**
			 * Starts drag operation using this control as drag source.
			 *
			 * This method can be blocking on some platforms (Wpf, WinForms), and non-blocking on
			 * others (Mac, Gtk). Use the {@link Eto.Forms.Control.DragEnd} event to determine when
			 * the drag operation is completed and get its resulting DragEffects.
			 */
			DoDragDrop(
				data: Eto.Forms.DataObject,
				allowedEffects: Eto.Forms.DragEffects,
				image: Eto.Drawing.Image,
				cursorOffset: Eto.Drawing.PointF,
			): void;

			/**
			 * Triggers the StyleChanged event and re-applies the styles to this control and its
			 * children.
			 */
			TriggerStyleChanged(): void;

			/** Shows a print dialog to print the specified control */
			Print(): void;

			/**
			 * Finds a control in the parent hierarchy with the specified type and
			 * {@link Eto.Widget.ID} if specified
			 */
			FindParent<T>(id?: string): T;

			/**
			 * Finds a control in the parent hierarchy with the specified type and
			 * {@link Eto.Widget.ID} if specified
			 */
			FindParent(
				type: unknown,
				id?: string,
			): Eto.Widget;

			/** Finds a control in the parent hierarchy with the specified `id` */
			FindParent(id: string): Eto.Widget;

			/**
			 * Unbinds any bindings in the {@link Eto.Forms.BindableWidget.Bindings} collection and
			 * removes the bindings
			 *
			 * When you implement {@link Eto.Forms.IBindableWidgetContainer}, this will also unbind
			 * any of its children.
			 */
			Unbind(): void;

			/**
			 * Updates all bindings in this widget
			 *
			 * When you implement {@link Eto.Forms.IBindableWidgetContainer}, this will also update
			 * bindings for all of its children.
			 */
			UpdateBindings(mode?: Eto.Forms.BindingUpdateMode): void;

			/** Disposes of this widget, supressing the finalizer */
			dispose(): void;

			/** Gets a string that represents the current object with its ID if specified. */
			ToString(): string;
		}
	}

	export namespace Eto.Forms.Drawable {
		export interface ICallback extends
			Eto.Forms.Control.ICallback,
			Eto.Widget.ICallback {
			OnPaint(
				widget: Eto.Forms.Drawable,
				e: Eto.Forms.PaintEventArgs,
			): void;
		}
	}

	export namespace Eto.Forms.Drawable {
		export interface IHandler extends
			Eto.Forms.Panel.IHandler,
			Eto.Forms.Container.IHandler,
			Eto.Forms.Control.IHandler,
			Eto.Widget.IHandler,
			Eto.Forms.IContextMenuHost {
			readonly SupportsCreateGraphics: boolean;

			CanFocus: boolean;

			Create(): void;

			Create(largeCanvas: boolean): void;

			Update(region: Eto.Drawing.Rectangle): void;

			CreateGraphics(): Eto.Drawing.Graphics;
		}
	}

	export namespace Eto.Forms {
		/**
		 * Arguments for formatting items in a drop down using the
		 * {@link Eto.Forms.DropDown.FormatItem} event.
		 */
		export class DropDownFormatEventArgs {
			/** Initializes a new instance of the DropDownFormatEventArgs class. */
			constructor(
				item: unknown,
				row: number,
				font: Eto.Drawing.Font,
			);

			/** Gets or sets the font to use for this item. */
			Font: Eto.Drawing.Font;

			/**
			 * Gets a value indicating that the font was set during the FormatItem event.
			 *
			 * This is useful for handler implementations to determine if something needs to be done
			 * to format the item.
			 */
			IsFontSet: boolean;

			/** Item to specify the format for. */
			readonly Item: unknown;

			/** Row number in the list of items to format for. */
			readonly Row: number;
		}
	}

	export namespace Eto.Forms {
		/** Presents a drop down to select from a list of items. */
		export class DropDown implements
			Eto.IHandlerSource,
			Eto.Forms.IBindable,
			Eto.Forms.IMouseInputSource,
			Eto.Forms.IKeyboardInputSource {
			/** Initializes a new instance of the {@link Eto.Forms.DropDown} class. */
			constructor();

			/**
			 * Gets or sets the binding to get the image for each item.
			 *
			 * By default this looks for the Image property of the item, and also works if you use
			 * {@link Eto.Forms.ImageListItem}.  This will be ignored when creating a
			 * {@link Eto.Forms.ComboBox}, and is only supported with the {@link Eto.Forms.DropDown}
			 * directly.
			 */
			ItemImageBinding: Eto.Forms.IIndirectBinding$1<Eto.Drawing.Image>;

			/**
			 * Gets or sets a value indicating whether to show the control's border.
			 *
			 * This is a hint to omit the border of the control and show it as plainly as possible.
			 * Typically used when you want to show the control within a cell of the
			 * {@link Eto.Forms.GridView}.
			 */
			ShowBorder: boolean;

			/** Gets or sets the binding for the text value of each item. */
			ItemTextBinding: Eto.Forms.IIndirectBinding$1<string>;

			/** Gets or sets the binding for the key value of each item. */
			ItemKeyBinding: Eto.Forms.IIndirectBinding$1<string>;

			/** Gets or sets the binding for the text value of each item. */
			TextBinding: Eto.Forms.IIndirectBinding$1<string>;

			/** Gets or sets the binding for the key value of each item. */
			KeyBinding: Eto.Forms.IIndirectBinding$1<string>;

			/**
			 * Gets the list of items in the control.
			 *
			 * This is an alternate to using {@link Eto.Forms.ListControl.DataStore} to easily add
			 * items to the list, when you do not want to use custom objects as the source for the
			 * list. This will set the {@link Eto.Forms.ListControl.DataStore} to a new instance of a
			 * {@link Eto.Forms.ListItemCollection}.
			 */
			readonly Items: Eto.Forms.ListItemCollection;

			/** Gets or sets the data store for the items of the list control. */
			DataStore: Iterable<unknown>;

			/**
			 * Gets or sets the index of the currently selected item in the
			 * {@link Eto.Forms.ListControl.DataStore}
			 */
			SelectedIndex: number;

			/**
			 * Gets or sets the selected object value of the item in
			 * {@link Eto.Forms.ListControl.DataStore}
			 */
			SelectedValue: unknown;

			/**
			 * Gets or sets the key of the selected item in the
			 * {@link Eto.Forms.ListControl.DataStore}.
			 *
			 * This uses the {@link Eto.Forms.ListControl.ItemKeyBinding} to map the key for each
			 * item in the list.
			 */
			SelectedKey: string;

			/**
			 * Gets or sets the color of the text.
			 *
			 * By default, the text will get a color based on the user's theme. However, this is
			 * usually black.
			 */
			TextColor: Eto.Drawing.Color;

			/** Gets the binding to the {@link Eto.Forms.ListControl.SelectedIndex} property. */
			readonly SelectedIndexBinding: Eto.Forms.BindableBinding$2<Eto.Forms.ListControl, number>;

			/** Gets the binding to the {@link Eto.Forms.ListControl.SelectedKey} property. */
			readonly SelectedKeyBinding: Eto.Forms.BindableBinding$2<Eto.Forms.ListControl, string>;

			/** Gets the binding to the {@link Eto.Forms.ListControl.SelectedValue} property. */
			readonly SelectedValueBinding: Eto.Forms.BindableBinding$2<Eto.Forms.ListControl, unknown>;

			/** Gets or sets the font for the text of the control */
			Font: Eto.Drawing.Font;

			/**
			 * Gets a value indicating that the control is loaded onto a form, that is it has been
			 * created, added to a parent, and shown
			 *
			 * The {@link Eto.Forms.Control.OnLoad(System.EventArgs)} method sets this value to true
			 * after cascading to all children (for a {@link Eto.Forms.Container} ) and calling the
			 * platform handler's implementation.  It is called after adding to a loaded form, or
			 * when showing a new form.  The {@link Eto.Forms.Control.OnUnLoad(System.EventArgs)}
			 * method will set this value to false when the control is removed from its parent
			 */
			readonly Loaded: boolean;

			/**
			 * Gets an enumeration of controls that are in the visual tree.
			 *
			 * This is used to specify which controls are contained by this instance that are part of
			 * the visual tree. This should include all controls including non-logical Eto controls
			 * used for layout.
			 */
			readonly VisualControls: Iterable<Eto.Forms.Control>;

			/**
			 * Gets or sets a user-defined object that contains data about the control
			 *
			 * A common use of the tag property is to store data that is associated with the control
			 * that you can later retrieve.
			 */
			Tag: unknown;

			/**
			 * Gets the logical parent control.
			 *
			 * When the control is part of the visual tree (
				 * {@link Eto.Forms.Control.IsVisualControl} is true), this returns the logical parent
				 * that contains this control. Otherwise this is the same as
				 * {@link Eto.Forms.Control.Parent}.
				 */
				readonly LogicalParent: Eto.Forms.Container;

			/** Gets a value indicating this {@link Eto.Forms.Control} is part of the visual tree. */
			IsVisualControl: boolean;

			/**
			 * Gets or sets the size of the control. Use -1 to specify auto sizing for either the
			 * width and/or height.
			 *
			 * Setting the size of controls is entirely optional as most controls will size
			 * themselves appropriately. When specifying a size, it will be used as the desired size
			 * of the control.  The container will reposition and resize the control depending on the
			 * available size.  For a {@link Eto.Forms.Window}, it is preferred to set the
			 * {@link Eto.Forms.Container.ClientSize} instead, as various platforms have different
			 * sizes of window decorations, toolbars, etc.
			 */
			Size: Eto.Drawing.Size;

			/**
			 * Gets a value indicating this control currently has mouse capture
			 *
			 * Mouse capture can happen during a handled MouseDown event until MouseUp, or it can be
			 * captured explicitly via {@link Eto.Forms.Control.CaptureMouse}.
			 */
			readonly IsMouseCaptured: boolean;

			/** Gets or sets the width of the control size. */
			Width: number;

			/** Gets or sets the height of the control size. */
			Height: number;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Forms.Control} (or its
			 * children) are enabled and accept user input.
			 *
			 * Typically when a control is disabled, the user cannot do anything with the control or
			 * any of its children. Including for example, selecting text in a text control. Certain
			 * controls can have a 'Read Only' mode, such as {@link Eto.Forms.TextBox.ReadOnly} which
			 * allow the user to  select text, but not change its contents.
			 */
			Enabled: boolean;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Forms.Control} is visible to
			 * the user.
			 *
			 * When the visibility of a control is set to false, it will not occupy space in the
			 * layout.
			 */
			Visible: boolean;

			/** Gets the container which this control has been added to, if any */
			readonly Parent: Eto.Forms.Container;

			/**
			 * Gets the visual container of this control, if any.
			 *
			 * Some containers may use other Eto controls to layout its children, such as the
			 * {@link Eto.Forms.StackLayout}. This will return the parent control that visually
			 * contains this control as opposed to {@link Eto.Forms.Control.Parent} which will return
			 * the logical parent.
			 */
			VisualParent: Eto.Forms.Container;

			/** Gets a value indicating this control has been attached to a native container */
			readonly IsAttached: boolean;

			/**
			 * Gets or sets the color for the background of the control
			 *
			 * Note that on some platforms (e.g. Mac), setting the background color of a control can
			 * change the performance characteristics of the control and its children, since it must
			 * enable layers to do so.
			 */
			BackgroundColor: Eto.Drawing.Color;

			/** Gets a value indicating whether this instance has the keyboard input focus. */
			readonly HasFocus: boolean;

			/** Gets a value indicating whether the layout of child controls is suspended. */
			readonly IsSuspended: boolean;

			/** Gets the window this control is contained in */
			readonly ParentWindow: Eto.Forms.Window;

			/**
			 * Gets the supported platform commands that can be used to hook up system functions to
			 * user defined logic
			 *
			 * This lists all available commands that can be mapped using the
			 * {@link Eto.Forms.Control.MapPlatformCommand(System.String,Eto.Forms.Command)} method
			 * of the control.
			 */
			readonly SupportedPlatformCommands: Iterable<string>;

			/** Gets the bounding rectangle of this control relative to its container */
			readonly Bounds: Eto.Drawing.Rectangle;

			/**
			 * Gets the location of the control as positioned by the container
			 *
			 * A control's location is set by the container. This can be used to determine where the
			 * control is for overlaying floating windows, menus, etc.
			 */
			readonly Location: Eto.Drawing.Point;

			/** Gets or sets the type of cursor to use when the mouse is hovering over the control */
			Cursor: Eto.Forms.Cursor;

			/** Gets or sets the tool tip to show when the mouse is hovered over the control */
			ToolTip: string;

			/**
			 * Gets or sets the tab index order for this control within its container.
			 *
			 * This sets the order when using the tab key to cycle through controls  Note that some
			 * platforms (Gtk and WinForms) may not support setting the context of the tab order to
			 * StackLayout  or DynamicLayout containers and may not behave exactly as expected. Use
			 * the {@link Eto.PlatformFeatures.TabIndexWithCustomContainers} flag to determine if it
			 * is supported.
			 */
			TabIndex: number;

			/** Gets or sets a value indicating whether this control can serve as drop target. */
			AllowDrop: boolean;

			/**
			 * Gets or sets the parent widget which this widget has been added to, if any
			 *
			 * When implementing child widgets that can participate in the context based binding
			 * (MVVM), You can set this to the parent widget when it is added or removed to it
			 * (usually via a collection).  Note that you should typically provide a public new
			 * [ParentWidget] Parent { get; } property  so that consumers of your API cannot set the
			 * parent to an invalid value.
			 */
			Parent: Eto.Widget;

			/**
			 * Gets an enumeration of all parent widgets in the heirarchy by traversing the
			 * {@link Eto.Forms.BindableWidget.Parent} property.
			 */
			readonly Parents: Iterable<Eto.Widget>;

			/**
			 * Gets or sets the data context for this widget for binding
			 *
			 * Subclasses may override the standard behaviour so that hierarchy of widgets can be
			 * taken into account.  For example, a Control may return the data context of a parent,
			 * if it is not set explicitly.
			 */
			DataContext: unknown;

			/** Gets the collection of bindings that are attached to this widget */
			readonly Bindings: Eto.Forms.BindingCollection;

			/**
			 * Gets a value indicating that the {@link Eto.Forms.BindableWidget.DataContext} property
			 * is changing.
			 *
			 * This can be used to determine when to allow certain logic during the update of the
			 * data context.  It is used to disable binding setters on the model when the data
			 * context changes so that a binding does not cause the view model to be updated when the
			 * state hasn't been fully set yet.
			 */
			IsDataContextChanging: boolean;

			/**
			 * Gets the platform that was used to create the {@link Eto.Widget.Handler} for this
			 * widget
			 *
			 * This gets set to the current {@link Eto.Platform.Instance} during the construction of
			 * the object
			 */
			readonly Platform: Eto.Platform;

			/** Gets the platform-specific handler for this widget */
			Handler: unknown;

			/** Gets the native platform-specific handle for integration purposes */
			readonly NativeHandle: unknown;

			/** Gets the dictionary of properties for this widget */
			readonly Properties: Eto.PropertyStore;

			/** Gets or sets the ID of this widget */
			ID: string;

			/**
			 * Gets or sets the style of this widget
			 *
			 * Styles allow you to attach custom platform-specific logic to a widget. In your
			 * platform-specific assembly, use {@link Style.Add{H}(string, StyleHandler{H})} to add
			 * the style logic with the same id.
			 */
			Style: string;

			/**
			 * Gets the instance of the platform-specific object
			 *
			 * This can sometimes be useful to get the platform-specific object. Some handlers may
			 * not have any backing object for its functionality, so this may be null.  It is more
			 * preferred to use the {@link Eto.Widget.Handler} and cast that to the platform-specific
			 * handler class which can give you additional methods and helpers to do common tasks.
			 * For example, the {@link Eto.Forms.Application} object's handler for OS X has a
			 * AddFullScreenMenuItem property to specify if you want full screen support in your app.
			 */
			readonly ControlObject: unknown;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Widget} has been disposed.
			 *
			 * When the widget is disposed, it can no longer be used.
			 */
			IsDisposed: boolean;

			/**
			 * Queues a repaint of the entire control on the screen and any of its children.
			 *
			 * This is only useful when the control is visible.
			 */
			Invalidate(): void;

			/**
			 * Queues a repaint of the entire control on the screen
			 *
			 * This is only useful when the control is visible.
			 */
			Invalidate(invalidateChildren: boolean): void;

			/**
			 * Queues a repaint of the specified `rect` of the control and any children.
			 *
			 * This is only useful when the control is visible.
			 */
			Invalidate(rect: Eto.Drawing.Rectangle): void;

			/**
			 * Queues a repaint of the specified `rect` of the control
			 *
			 * This is only useful when the control is visible.
			 */
			Invalidate(
				rect: Eto.Drawing.Rectangle,
				invalidateChildren: boolean,
			): void;

			/**
			 * Updates the layout of this control if necessary.
			 *
			 * This will ensure the control has had all of its layout applied so you can use its
			 * position and size right after this call. Most platforms (except WinForms) use a
			 * deferred layout system so that after adding your control to the form dynamically it
			 * won't get laid out until the next idle loop. This is useful when you need to know the
			 * dimensions of the control immediately. Note that this can be an expensive operation,
			 * so it is recommended to only call this method when necessary and after all of the
			 * controls have been added/updated.
			 */
			UpdateLayout(): void;

			/** Gets the preferred size of this control given infinite space available. */
			GetPreferredSize(): Eto.Drawing.SizeF;

			/** Gets the preferred size of this control given the specified `availableSize`. */
			GetPreferredSize(availableSize: Eto.Drawing.SizeF): Eto.Drawing.SizeF;

			/**
			 * Captures all mouse events to this control.
			 *
			 * This captures all mouse events until {@link Eto.Forms.Control.ReleaseMouseCapture} is
			 * called.  Note that not all platforms will allow a mouse capture unless the mouse is
			 * currently down.
			 */
			CaptureMouse(): boolean;

			/** Releases the mouse capture after a call to {@link Eto.Forms.Control.CaptureMouse}. */
			ReleaseMouseCapture(): void;

			/**
			 * Finds a control in the parent hierarchy with the specified type and
			 * {@link Eto.Widget.ID} if specified
			 */
			FindParent(
				type: unknown,
				id?: string,
			): Eto.Forms.Container;

			/** Finds a control in the parent hierarchy with the specified `id` */
			FindParent(id: string): Eto.Forms.Container;

			/**
			 * Detaches the control by removing it from its parent
			 *
			 * This is essentially a shortcut to myControl.Parent.Remove(myControl);
			 */
			Detach(): void;

			/**
			 * Attaches the control for direct use in a native application
			 *
			 * Use this to use a control directly in a native application.  Note that the native
			 * application must be running the same framework as the current platform.  E.g. a
			 * WinForms application can use an Eto.Forms control when using the Eto.WinForms
			 * platform.  This prepares the control by firing the {@link Eto.Forms.Control.PreLoad},
			 * {@link Eto.Forms.Control.Load}, etc. events.
			 */
			AttachNative(): void;

			/**
			 * Detaches the control when it is used in a native application, when you want to reuse
			 * the control.
			 *
			 * This should only be called after {@link Eto.Forms.Control.AttachNative} has been
			 * called, which is usually done by calling to ToNative(true) .
			 */
			DetachNative(): void;

			/**
			 * Attempts to set the keyboard input focus to this control, or the first child that
			 * accepts focus. For Windows, this will bring it to front and activate it.
			 */
			Focus(): void;

			/**
			 * Suspends the layout of child controls
			 *
			 * This can be used to optimize some platforms while adding, removing, or changing many
			 * child controls at once. It disables the calculation of control positioning until
			 * {@link Eto.Forms.Control.ResumeLayout} is called. Each call to SuspendLayout() must be
			 * balanced with a call to {@link Eto.Forms.Control.ResumeLayout}.
			 */
			SuspendLayout(): void;

			/**
			 * Resumes the layout after it has been suspended, and performs a layout
			 *
			 * This can be used to optimize some platforms while adding, removing, or changing many
			 * child controls at once. Each call to ResumeLayout() must be balanced with a call to
			 * {@link Eto.Forms.Control.SuspendLayout} before it.
			 */
			ResumeLayout(): void;

			/**
			 * Specifies a command to execute for a platform-specific command
			 *
			 * Some platforms have specific system-defined commands that can be associated with a
			 * control. For example, the Mac platform's cut/copy/paste functionality is defined by
			 * the system, and if you want to hook into it, you can use this to map it to your own
			 * defined logic. The valid values of the `systemCommand` parameter are defined by each
			 * platform, and a list can be retrieved using
			 * {@link Eto.Forms.Control.SupportedPlatformCommands}
			 */
			MapPlatformCommand(
				systemCommand: string,
				command: Eto.Forms.Command,
			): void;

			/** Converts a point from screen space to control space. */
			PointFromScreen(point: Eto.Drawing.PointF): Eto.Drawing.PointF;

			/** Converts a point from control space to screen space */
			PointToScreen(point: Eto.Drawing.PointF): Eto.Drawing.PointF;

			/** Converts a rectangle from screen space to control space. */
			RectangleToScreen(rect: Eto.Drawing.RectangleF): Eto.Drawing.RectangleF;

			/** Converts a rectangle from control space to screen space */
			RectangleFromScreen(rect: Eto.Drawing.RectangleF): Eto.Drawing.RectangleF;

			/**
			 * Starts drag operation using this control as drag source.
			 *
			 * This method can be blocking on some platforms (Wpf, WinForms), and non-blocking on
			 * others (Mac, Gtk). Use the {@link Eto.Forms.Control.DragEnd} event to determine when
			 * the drag operation is completed and get its resulting DragEffects.
			 */
			DoDragDrop(
				data: Eto.Forms.DataObject,
				allowedEffects: Eto.Forms.DragEffects,
			): void;

			/**
			 * Starts drag operation using this control as drag source.
			 *
			 * This method can be blocking on some platforms (Wpf, WinForms), and non-blocking on
			 * others (Mac, Gtk). Use the {@link Eto.Forms.Control.DragEnd} event to determine when
			 * the drag operation is completed and get its resulting DragEffects.
			 */
			DoDragDrop(
				data: Eto.Forms.DataObject,
				allowedEffects: Eto.Forms.DragEffects,
				image: Eto.Drawing.Image,
				cursorOffset: Eto.Drawing.PointF,
			): void;

			/**
			 * Triggers the StyleChanged event and re-applies the styles to this control and its
			 * children.
			 */
			TriggerStyleChanged(): void;

			/** Shows a print dialog to print the specified control */
			Print(): void;

			/**
			 * Finds a control in the parent hierarchy with the specified type and
			 * {@link Eto.Widget.ID} if specified
			 */
			FindParent<T>(id?: string): T;

			/**
			 * Finds a control in the parent hierarchy with the specified type and
			 * {@link Eto.Widget.ID} if specified
			 */
			FindParent(
				type: unknown,
				id?: string,
			): Eto.Widget;

			/** Finds a control in the parent hierarchy with the specified `id` */
			FindParent(id: string): Eto.Widget;

			/**
			 * Unbinds any bindings in the {@link Eto.Forms.BindableWidget.Bindings} collection and
			 * removes the bindings
			 *
			 * When you implement {@link Eto.Forms.IBindableWidgetContainer}, this will also unbind
			 * any of its children.
			 */
			Unbind(): void;

			/**
			 * Updates all bindings in this widget
			 *
			 * When you implement {@link Eto.Forms.IBindableWidgetContainer}, this will also update
			 * bindings for all of its children.
			 */
			UpdateBindings(mode?: Eto.Forms.BindingUpdateMode): void;

			/** Disposes of this widget, supressing the finalizer */
			dispose(): void;

			/** Gets a string that represents the current object with its ID if specified. */
			ToString(): string;
		}
	}

	export namespace Eto.Forms.DropDown {
		export interface ICallback extends
			Eto.Forms.ListControl.ICallback,
			Eto.Forms.Control.ICallback,
			Eto.Widget.ICallback {
			OnDropDownOpening(
				widget: Eto.Forms.DropDown,
				e: unknown,
			): void;

			OnDropDownClosed(
				widget: Eto.Forms.DropDown,
				e: unknown,
			): void;

			OnFormatItem(
				widget: Eto.Forms.DropDown,
				e: Eto.Forms.DropDownFormatEventArgs,
			): void;
		}
	}

	export namespace Eto.Forms.DropDown {
		export interface IHandler extends
			Eto.Forms.ListControl.IHandler,
			Eto.Forms.CommonControl.IHandler,
			Eto.Forms.Control.IHandler,
			Eto.Widget.IHandler {
			ShowBorder: boolean;
		}
	}

	export namespace Eto.Forms {
		/** [Generic type factory] Check box list based on an enumeration */
		export function EnumCheckBoxList$(T: IType): typeof EnumCheckBoxList$1<any>;

		/** Check box list based on an enumeration */
		export class EnumCheckBoxList$1<T> implements
			Eto.IHandlerSource,
			Eto.Forms.IBindable,
			Eto.Forms.IMouseInputSource,
			Eto.Forms.IKeyboardInputSource {
			/** Initializes a new instance of the {@link Eto.Forms.EnumCheckBoxList<>} class. */
			new(): EnumCheckBoxList$1<T>;

			/** Gets or sets the currently selected enumeration value */
			SelectedValues: Iterable<T>;

			/**
			 * Gets or sets a value indicating whether to include a 'None' when the enumeration has
			 * the [Flags] attribute.
			 */
			IncludeNoneFlag: boolean;

			/**
			 * Gets or sets a delegate used to get the text value for each item.
			 *
			 * You can use this delegate to provide translated or custom text for each enumeration.
			 * Otherwise, the name of the enum is used.
			 */
			GetText: (arg1: T) => string;

			/**
			 * Gets or sets a value indicating that the items in the list are sorted alphabetically,
			 * instead of by numerical value of the enumeration
			 */
			SortAlphabetically: boolean;

			/**
			 * Gets a binding to the {@link Eto.Forms.EnumCheckBoxList`1.SelectedValues} property.
			 */
			readonly SelectedValuesBinding: Eto.Forms.BindableBinding$2<Eto.Forms.EnumCheckBoxList$1<T>, Iterable<T>>;

			/**
			 * Gets or sets the binding to get the text for each check box.
			 *
			 * By default, this will bind to a "Text" property, or {@link Eto.Forms.IListItem.Text}
			 * when implemented.
			 */
			ItemTextBinding: Eto.Forms.IIndirectBinding$1<string>;

			/** Gets or sets the binding to get the tooltip for each check box. */
			ItemToolTipBinding: Eto.Forms.IIndirectBinding$1<string>;

			/**
			 * Gets or sets the binding to get the key for each check box.
			 *
			 * By default, this will bind to a "Key" property, or {@link Eto.Forms.IListItem.Key}
			 * when implemented.
			 */
			ItemKeyBinding: Eto.Forms.IIndirectBinding$1<string>;

			/**
			 * Gets or sets the selected key of the currently selected item using
			 * {@link Eto.Forms.CheckBoxList.ItemKeyBinding}.
			 */
			SelectedKeys: Iterable<string>;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Forms.CheckBoxList} is
			 * enabled.
			 *
			 * When the control is disabled, the user will not be able to change the selected check
			 * box. However, you can still programatically change the selection.
			 */
			Enabled: boolean;

			/**
			 * Gets or sets the selected values, which are {@link Eto.Forms.ListItem} s or objects in
			 * your custom data store.
			 */
			SelectedValues: Iterable<unknown>;

			/** Gets or sets the color of the check box text. */
			TextColor: Eto.Drawing.Color;

			/** Gets or sets the orientation of the check boxes. */
			Orientation: Eto.Forms.Orientation;

			/** Gets or sets the spacing between each check box. */
			Spacing: Eto.Drawing.Size;

			/**
			 * Gets the item collection, when adding items programatically.
			 *
			 * This is used when you want to add items manually. Use
			 * {@link Eto.Forms.CheckBoxList.DataStore} when you have an existing collection you want
			 * to bind to directly.
			 */
			readonly Items: Eto.Forms.ListItemCollection;

			/**
			 * Gets or sets the data store of the items shown in the list.
			 *
			 * When using a custom object collection, you can use the
			 * {@link Eto.Forms.CheckBoxList.ItemTextBinding} and
			 * {@link Eto.Forms.CheckBoxList.ItemKeyBinding} to specify how to get the text/key
			 * values for each item.
			 */
			DataStore: Iterable<unknown>;

			/** Gets a binding to the {@link Eto.Forms.CheckBoxList.SelectedValues} property. */
			readonly SelectedValuesBinding: Eto.Forms.BindableBinding$2<Eto.Forms.CheckBoxList, Iterable<unknown>>;

			/** Gets a binding to the {@link Eto.Forms.CheckBoxList.SelectedKeys} property. */
			readonly SelectedKeysBinding: Eto.Forms.BindableBinding$2<Eto.Forms.CheckBoxList, Iterable<string>>;

			/** Gets an enumeration of controls that are directly contained by this container */
			readonly Controls: Iterable<Eto.Forms.Control>;

			/** Gets or sets the padding around the {@link Eto.Forms.Panel.Content} of the panel. */
			Padding: Eto.Drawing.Padding;

			/** Gets or sets the minimum size of the panel. */
			MinimumSize: Eto.Drawing.Size;

			/**
			 * Gets or sets the context menu for the panel.
			 *
			 * The context menu is usually shown when the user right clicks the control, or in mobile
			 * platforms when the user taps and holds their finger down on the control.
			 */
			ContextMenu: Eto.Forms.ContextMenu;

			/**
			 * Gets or sets the main content of the panel.
			 *
			 * The main content will be offset by the {@link Eto.Forms.Panel.Padding} value
			 * specified, and will take up the entire content area of the control. Some controls may
			 * have decorations that will surround the content, such as a {@link Eto.Forms.GroupBox},
			 * {@link Eto.Forms.TabControl}, or {@link Eto.Forms.Window}
			 */
			Content: Eto.Forms.Control;

			/**
			 * Gets or sets the size for the client area of the control
			 *
			 * The client size differs from the {@link Eto.Forms.Control.Size} in that it excludes
			 * the decorations of the container, such as the title bar and border around a
			 * {@link Eto.Forms.Window}, or the title and line  around a {@link Eto.Forms.GroupBox}.
			 */
			ClientSize: Eto.Drawing.Size;

			/**
			 * Gets an enumeration of all contained child controls, including controls within child
			 * containers
			 */
			readonly Children: Iterable<Eto.Forms.Control>;

			/**
			 * Gets an enumeration of all contained child controls in the visual tree, including
			 * controls within child containers.
			 */
			readonly VisualChildren: Iterable<Eto.Forms.Control>;

			/**
			 * Gets or sets the style provider for this container.
			 *
			 * The style provider is used to style this container and its children.
			 */
			StyleProvider: Eto.IStyleProvider;

			/**
			 * Gets the default style provider for this container.
			 *
			 * Use this to apply styles to any child controls of this container. By default, styles
			 * will apply to all children, including children of children unless
			 * {@link Eto.DefaultStyleProvider.Inherit} is set to false .  Typically, you would set
			 * Inherit to false when creating composite controls that already have all their styles
			 * applied and you don't want any other styles to be inherited.
			 */
			readonly Styles: Eto.DefaultStyleProvider;

			/**
			 * Gets a value indicating that the control is loaded onto a form, that is it has been
			 * created, added to a parent, and shown
			 *
			 * The {@link Eto.Forms.Control.OnLoad(System.EventArgs)} method sets this value to true
			 * after cascading to all children (for a {@link Eto.Forms.Container} ) and calling the
			 * platform handler's implementation.  It is called after adding to a loaded form, or
			 * when showing a new form.  The {@link Eto.Forms.Control.OnUnLoad(System.EventArgs)}
			 * method will set this value to false when the control is removed from its parent
			 */
			readonly Loaded: boolean;

			/**
			 * Gets an enumeration of controls that are in the visual tree.
			 *
			 * This is used to specify which controls are contained by this instance that are part of
			 * the visual tree. This should include all controls including non-logical Eto controls
			 * used for layout.
			 */
			readonly VisualControls: Iterable<Eto.Forms.Control>;

			/**
			 * Gets or sets a user-defined object that contains data about the control
			 *
			 * A common use of the tag property is to store data that is associated with the control
			 * that you can later retrieve.
			 */
			Tag: unknown;

			/**
			 * Gets the logical parent control.
			 *
			 * When the control is part of the visual tree (
				 * {@link Eto.Forms.Control.IsVisualControl} is true), this returns the logical parent
				 * that contains this control. Otherwise this is the same as
				 * {@link Eto.Forms.Control.Parent}.
				 */
				readonly LogicalParent: Eto.Forms.Container;

			/** Gets a value indicating this {@link Eto.Forms.Control} is part of the visual tree. */
			IsVisualControl: boolean;

			/**
			 * Gets or sets the size of the control. Use -1 to specify auto sizing for either the
			 * width and/or height.
			 *
			 * Setting the size of controls is entirely optional as most controls will size
			 * themselves appropriately. When specifying a size, it will be used as the desired size
			 * of the control.  The container will reposition and resize the control depending on the
			 * available size.  For a {@link Eto.Forms.Window}, it is preferred to set the
			 * {@link Eto.Forms.Container.ClientSize} instead, as various platforms have different
			 * sizes of window decorations, toolbars, etc.
			 */
			Size: Eto.Drawing.Size;

			/**
			 * Gets a value indicating this control currently has mouse capture
			 *
			 * Mouse capture can happen during a handled MouseDown event until MouseUp, or it can be
			 * captured explicitly via {@link Eto.Forms.Control.CaptureMouse}.
			 */
			readonly IsMouseCaptured: boolean;

			/** Gets or sets the width of the control size. */
			Width: number;

			/** Gets or sets the height of the control size. */
			Height: number;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Forms.Control} is visible to
			 * the user.
			 *
			 * When the visibility of a control is set to false, it will not occupy space in the
			 * layout.
			 */
			Visible: boolean;

			/** Gets the container which this control has been added to, if any */
			readonly Parent: Eto.Forms.Container;

			/**
			 * Gets the visual container of this control, if any.
			 *
			 * Some containers may use other Eto controls to layout its children, such as the
			 * {@link Eto.Forms.StackLayout}. This will return the parent control that visually
			 * contains this control as opposed to {@link Eto.Forms.Control.Parent} which will return
			 * the logical parent.
			 */
			VisualParent: Eto.Forms.Container;

			/** Gets a value indicating this control has been attached to a native container */
			readonly IsAttached: boolean;

			/**
			 * Gets or sets the color for the background of the control
			 *
			 * Note that on some platforms (e.g. Mac), setting the background color of a control can
			 * change the performance characteristics of the control and its children, since it must
			 * enable layers to do so.
			 */
			BackgroundColor: Eto.Drawing.Color;

			/** Gets a value indicating whether this instance has the keyboard input focus. */
			readonly HasFocus: boolean;

			/** Gets a value indicating whether the layout of child controls is suspended. */
			readonly IsSuspended: boolean;

			/** Gets the window this control is contained in */
			readonly ParentWindow: Eto.Forms.Window;

			/**
			 * Gets the supported platform commands that can be used to hook up system functions to
			 * user defined logic
			 *
			 * This lists all available commands that can be mapped using the
			 * {@link Eto.Forms.Control.MapPlatformCommand(System.String,Eto.Forms.Command)} method
			 * of the control.
			 */
			readonly SupportedPlatformCommands: Iterable<string>;

			/** Gets the bounding rectangle of this control relative to its container */
			readonly Bounds: Eto.Drawing.Rectangle;

			/**
			 * Gets the location of the control as positioned by the container
			 *
			 * A control's location is set by the container. This can be used to determine where the
			 * control is for overlaying floating windows, menus, etc.
			 */
			readonly Location: Eto.Drawing.Point;

			/** Gets or sets the type of cursor to use when the mouse is hovering over the control */
			Cursor: Eto.Forms.Cursor;

			/** Gets or sets the tool tip to show when the mouse is hovered over the control */
			ToolTip: string;

			/**
			 * Gets or sets the tab index order for this control within its container.
			 *
			 * This sets the order when using the tab key to cycle through controls  Note that some
			 * platforms (Gtk and WinForms) may not support setting the context of the tab order to
			 * StackLayout  or DynamicLayout containers and may not behave exactly as expected. Use
			 * the {@link Eto.PlatformFeatures.TabIndexWithCustomContainers} flag to determine if it
			 * is supported.
			 */
			TabIndex: number;

			/** Gets or sets a value indicating whether this control can serve as drop target. */
			AllowDrop: boolean;

			/**
			 * Gets or sets the parent widget which this widget has been added to, if any
			 *
			 * When implementing child widgets that can participate in the context based binding
			 * (MVVM), You can set this to the parent widget when it is added or removed to it
			 * (usually via a collection).  Note that you should typically provide a public new
			 * [ParentWidget] Parent { get; } property  so that consumers of your API cannot set the
			 * parent to an invalid value.
			 */
			Parent: Eto.Widget;

			/**
			 * Gets an enumeration of all parent widgets in the heirarchy by traversing the
			 * {@link Eto.Forms.BindableWidget.Parent} property.
			 */
			readonly Parents: Iterable<Eto.Widget>;

			/**
			 * Gets or sets the data context for this widget for binding
			 *
			 * Subclasses may override the standard behaviour so that hierarchy of widgets can be
			 * taken into account.  For example, a Control may return the data context of a parent,
			 * if it is not set explicitly.
			 */
			DataContext: unknown;

			/** Gets the collection of bindings that are attached to this widget */
			readonly Bindings: Eto.Forms.BindingCollection;

			/**
			 * Gets a value indicating that the {@link Eto.Forms.BindableWidget.DataContext} property
			 * is changing.
			 *
			 * This can be used to determine when to allow certain logic during the update of the
			 * data context.  It is used to disable binding setters on the model when the data
			 * context changes so that a binding does not cause the view model to be updated when the
			 * state hasn't been fully set yet.
			 */
			IsDataContextChanging: boolean;

			/**
			 * Gets the platform that was used to create the {@link Eto.Widget.Handler} for this
			 * widget
			 *
			 * This gets set to the current {@link Eto.Platform.Instance} during the construction of
			 * the object
			 */
			readonly Platform: Eto.Platform;

			/** Gets the platform-specific handler for this widget */
			Handler: unknown;

			/** Gets the native platform-specific handle for integration purposes */
			readonly NativeHandle: unknown;

			/** Gets the dictionary of properties for this widget */
			readonly Properties: Eto.PropertyStore;

			/** Gets or sets the ID of this widget */
			ID: string;

			/**
			 * Gets or sets the style of this widget
			 *
			 * Styles allow you to attach custom platform-specific logic to a widget. In your
			 * platform-specific assembly, use {@link Style.Add{H}(string, StyleHandler{H})} to add
			 * the style logic with the same id.
			 */
			Style: string;

			/**
			 * Gets the instance of the platform-specific object
			 *
			 * This can sometimes be useful to get the platform-specific object. Some handlers may
			 * not have any backing object for its functionality, so this may be null.  It is more
			 * preferred to use the {@link Eto.Widget.Handler} and cast that to the platform-specific
			 * handler class which can give you additional methods and helpers to do common tasks.
			 * For example, the {@link Eto.Forms.Application} object's handler for OS X has a
			 * AddFullScreenMenuItem property to specify if you want full screen support in your app.
			 */
			readonly ControlObject: unknown;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Widget} has been disposed.
			 *
			 * When the widget is disposed, it can no longer be used.
			 */
			IsDisposed: boolean;

			/** Removes the specified child from the container */
			Remove(child: Eto.Forms.Control): void;

			/** Remove the specified `controls` from this container */
			Remove(controls: Iterable<Eto.Forms.Control>): void;

			/** Removes all controls from this container */
			RemoveAll(): void;

			/**
			 * Finds a child control in this container or any of its child containers with the
			 * specified `id`
			 */
			FindChild<T>(id?: string): T;

			/**
			 * Finds a child control in this container or any of its child containers with the
			 * specified `type`
			 */
			FindChild(
				type: unknown,
				id?: string,
			): Eto.Forms.Control;

			/**
			 * Finds a child control in this container or any of its child containers with the
			 * specified `id`.
			 */
			FindChild(id: string): Eto.Forms.Control;

			/**
			 * Queues a repaint of the entire control on the screen and any of its children.
			 *
			 * This is only useful when the control is visible.
			 */
			Invalidate(): void;

			/**
			 * Queues a repaint of the entire control on the screen
			 *
			 * This is only useful when the control is visible.
			 */
			Invalidate(invalidateChildren: boolean): void;

			/**
			 * Queues a repaint of the specified `rect` of the control and any children.
			 *
			 * This is only useful when the control is visible.
			 */
			Invalidate(rect: Eto.Drawing.Rectangle): void;

			/**
			 * Queues a repaint of the specified `rect` of the control
			 *
			 * This is only useful when the control is visible.
			 */
			Invalidate(
				rect: Eto.Drawing.Rectangle,
				invalidateChildren: boolean,
			): void;

			/**
			 * Updates the layout of this control if necessary.
			 *
			 * This will ensure the control has had all of its layout applied so you can use its
			 * position and size right after this call. Most platforms (except WinForms) use a
			 * deferred layout system so that after adding your control to the form dynamically it
			 * won't get laid out until the next idle loop. This is useful when you need to know the
			 * dimensions of the control immediately. Note that this can be an expensive operation,
			 * so it is recommended to only call this method when necessary and after all of the
			 * controls have been added/updated.
			 */
			UpdateLayout(): void;

			/** Gets the preferred size of this control given infinite space available. */
			GetPreferredSize(): Eto.Drawing.SizeF;

			/** Gets the preferred size of this control given the specified `availableSize`. */
			GetPreferredSize(availableSize: Eto.Drawing.SizeF): Eto.Drawing.SizeF;

			/**
			 * Captures all mouse events to this control.
			 *
			 * This captures all mouse events until {@link Eto.Forms.Control.ReleaseMouseCapture} is
			 * called.  Note that not all platforms will allow a mouse capture unless the mouse is
			 * currently down.
			 */
			CaptureMouse(): boolean;

			/** Releases the mouse capture after a call to {@link Eto.Forms.Control.CaptureMouse}. */
			ReleaseMouseCapture(): void;

			/**
			 * Finds a control in the parent hierarchy with the specified type and
			 * {@link Eto.Widget.ID} if specified
			 */
			FindParent(
				type: unknown,
				id?: string,
			): Eto.Forms.Container;

			/** Finds a control in the parent hierarchy with the specified `id` */
			FindParent(id: string): Eto.Forms.Container;

			/**
			 * Detaches the control by removing it from its parent
			 *
			 * This is essentially a shortcut to myControl.Parent.Remove(myControl);
			 */
			Detach(): void;

			/**
			 * Attaches the control for direct use in a native application
			 *
			 * Use this to use a control directly in a native application.  Note that the native
			 * application must be running the same framework as the current platform.  E.g. a
			 * WinForms application can use an Eto.Forms control when using the Eto.WinForms
			 * platform.  This prepares the control by firing the {@link Eto.Forms.Control.PreLoad},
			 * {@link Eto.Forms.Control.Load}, etc. events.
			 */
			AttachNative(): void;

			/**
			 * Detaches the control when it is used in a native application, when you want to reuse
			 * the control.
			 *
			 * This should only be called after {@link Eto.Forms.Control.AttachNative} has been
			 * called, which is usually done by calling to ToNative(true) .
			 */
			DetachNative(): void;

			/**
			 * Attempts to set the keyboard input focus to this control, or the first child that
			 * accepts focus. For Windows, this will bring it to front and activate it.
			 */
			Focus(): void;

			/**
			 * Suspends the layout of child controls
			 *
			 * This can be used to optimize some platforms while adding, removing, or changing many
			 * child controls at once. It disables the calculation of control positioning until
			 * {@link Eto.Forms.Control.ResumeLayout} is called. Each call to SuspendLayout() must be
			 * balanced with a call to {@link Eto.Forms.Control.ResumeLayout}.
			 */
			SuspendLayout(): void;

			/**
			 * Resumes the layout after it has been suspended, and performs a layout
			 *
			 * This can be used to optimize some platforms while adding, removing, or changing many
			 * child controls at once. Each call to ResumeLayout() must be balanced with a call to
			 * {@link Eto.Forms.Control.SuspendLayout} before it.
			 */
			ResumeLayout(): void;

			/**
			 * Specifies a command to execute for a platform-specific command
			 *
			 * Some platforms have specific system-defined commands that can be associated with a
			 * control. For example, the Mac platform's cut/copy/paste functionality is defined by
			 * the system, and if you want to hook into it, you can use this to map it to your own
			 * defined logic. The valid values of the `systemCommand` parameter are defined by each
			 * platform, and a list can be retrieved using
			 * {@link Eto.Forms.Control.SupportedPlatformCommands}
			 */
			MapPlatformCommand(
				systemCommand: string,
				command: Eto.Forms.Command,
			): void;

			/** Converts a point from screen space to control space. */
			PointFromScreen(point: Eto.Drawing.PointF): Eto.Drawing.PointF;

			/** Converts a point from control space to screen space */
			PointToScreen(point: Eto.Drawing.PointF): Eto.Drawing.PointF;

			/** Converts a rectangle from screen space to control space. */
			RectangleToScreen(rect: Eto.Drawing.RectangleF): Eto.Drawing.RectangleF;

			/** Converts a rectangle from control space to screen space */
			RectangleFromScreen(rect: Eto.Drawing.RectangleF): Eto.Drawing.RectangleF;

			/**
			 * Starts drag operation using this control as drag source.
			 *
			 * This method can be blocking on some platforms (Wpf, WinForms), and non-blocking on
			 * others (Mac, Gtk). Use the {@link Eto.Forms.Control.DragEnd} event to determine when
			 * the drag operation is completed and get its resulting DragEffects.
			 */
			DoDragDrop(
				data: Eto.Forms.DataObject,
				allowedEffects: Eto.Forms.DragEffects,
			): void;

			/**
			 * Starts drag operation using this control as drag source.
			 *
			 * This method can be blocking on some platforms (Wpf, WinForms), and non-blocking on
			 * others (Mac, Gtk). Use the {@link Eto.Forms.Control.DragEnd} event to determine when
			 * the drag operation is completed and get its resulting DragEffects.
			 */
			DoDragDrop(
				data: Eto.Forms.DataObject,
				allowedEffects: Eto.Forms.DragEffects,
				image: Eto.Drawing.Image,
				cursorOffset: Eto.Drawing.PointF,
			): void;

			/**
			 * Triggers the StyleChanged event and re-applies the styles to this control and its
			 * children.
			 */
			TriggerStyleChanged(): void;

			/** Shows a print dialog to print the specified control */
			Print(): void;

			/**
			 * Finds a control in the parent hierarchy with the specified type and
			 * {@link Eto.Widget.ID} if specified
			 */
			FindParent<T>(id?: string): T;

			/**
			 * Finds a control in the parent hierarchy with the specified type and
			 * {@link Eto.Widget.ID} if specified
			 */
			FindParent(
				type: unknown,
				id?: string,
			): Eto.Widget;

			/** Finds a control in the parent hierarchy with the specified `id` */
			FindParent(id: string): Eto.Widget;

			/**
			 * Unbinds any bindings in the {@link Eto.Forms.BindableWidget.Bindings} collection and
			 * removes the bindings
			 *
			 * When you implement {@link Eto.Forms.IBindableWidgetContainer}, this will also unbind
			 * any of its children.
			 */
			Unbind(): void;

			/**
			 * Updates all bindings in this widget
			 *
			 * When you implement {@link Eto.Forms.IBindableWidgetContainer}, this will also update
			 * bindings for all of its children.
			 */
			UpdateBindings(mode?: Eto.Forms.BindingUpdateMode): void;

			/** Disposes of this widget, supressing the finalizer */
			dispose(): void;

			/** Gets a string that represents the current object with its ID if specified. */
			ToString(): string;
		}
	}

	export namespace Eto.Forms {
		/**
		 * [Generic type factory] Arguments for controlling whether values should be added to a
		 * list or control
		 */
		export function AddValueEventArgs$(T: IType): typeof AddValueEventArgs$1<any>;

		/** Arguments for controlling whether values should be added to a list or control */
		export class AddValueEventArgs$1<T> {
			/** Initializes a new instance of the AddValueEventArgs class */
			new(
				value: T,
				shouldAdd: boolean,
			): AddValueEventArgs$1<T>;

			/** Value being added to the combo box */
			Value: T;

			/** True if the value should be added, false otherwise */
			ShouldAdd: boolean;
		}
	}

	export namespace Eto.Forms {
		/** [Generic type factory] Combo box for an enumeration */
		export function EnumDropDown$(T: IType): typeof EnumDropDown$1<any>;

		/** Combo box for an enumeration */
		export class EnumDropDown$1<T> implements
			Eto.IHandlerSource,
			Eto.Forms.IBindable,
			Eto.Forms.IMouseInputSource,
			Eto.Forms.IKeyboardInputSource {
			new(): EnumDropDown$1<T>;

			/** Gets or sets the currently selected enumeration value */
			SelectedValue: T;

			/**
			 * Gets or sets a delegate used to get the text value for each item.
			 *
			 * You can use this delegate to provide translated or custom text for each enumeration.
			 * Otherwise, the name of the enum is used.
			 */
			GetText: (arg1: T) => string;

			/**
			 * Gets or sets a value indicating that the items in the list are sorted alphabetically,
			 * instead of by numerical value of the enumeration
			 */
			SortAlphabetically: boolean;

			/**
			 * Gets a new binding for the {@link Eto.Forms.EnumDropDown`1.SelectedValue} property.
			 */
			readonly SelectedValueBinding: Eto.Forms.BindableBinding$2<Eto.Forms.EnumDropDown$1<T>, T>;

			/**
			 * Gets or sets the binding to get the image for each item.
			 *
			 * By default this looks for the Image property of the item, and also works if you use
			 * {@link Eto.Forms.ImageListItem}.  This will be ignored when creating a
			 * {@link Eto.Forms.ComboBox}, and is only supported with the {@link Eto.Forms.DropDown}
			 * directly.
			 */
			ItemImageBinding: Eto.Forms.IIndirectBinding$1<Eto.Drawing.Image>;

			/**
			 * Gets or sets a value indicating whether to show the control's border.
			 *
			 * This is a hint to omit the border of the control and show it as plainly as possible.
			 * Typically used when you want to show the control within a cell of the
			 * {@link Eto.Forms.GridView}.
			 */
			ShowBorder: boolean;

			/** Gets or sets the binding for the text value of each item. */
			ItemTextBinding: Eto.Forms.IIndirectBinding$1<string>;

			/** Gets or sets the binding for the key value of each item. */
			ItemKeyBinding: Eto.Forms.IIndirectBinding$1<string>;

			/** Gets or sets the binding for the text value of each item. */
			TextBinding: Eto.Forms.IIndirectBinding$1<string>;

			/** Gets or sets the binding for the key value of each item. */
			KeyBinding: Eto.Forms.IIndirectBinding$1<string>;

			/**
			 * Gets the list of items in the control.
			 *
			 * This is an alternate to using {@link Eto.Forms.ListControl.DataStore} to easily add
			 * items to the list, when you do not want to use custom objects as the source for the
			 * list. This will set the {@link Eto.Forms.ListControl.DataStore} to a new instance of a
			 * {@link Eto.Forms.ListItemCollection}.
			 */
			readonly Items: Eto.Forms.ListItemCollection;

			/** Gets or sets the data store for the items of the list control. */
			DataStore: Iterable<unknown>;

			/**
			 * Gets or sets the index of the currently selected item in the
			 * {@link Eto.Forms.ListControl.DataStore}
			 */
			SelectedIndex: number;

			/**
			 * Gets or sets the selected object value of the item in
			 * {@link Eto.Forms.ListControl.DataStore}
			 */
			SelectedValue: unknown;

			/**
			 * Gets or sets the key of the selected item in the
			 * {@link Eto.Forms.ListControl.DataStore}.
			 *
			 * This uses the {@link Eto.Forms.ListControl.ItemKeyBinding} to map the key for each
			 * item in the list.
			 */
			SelectedKey: string;

			/**
			 * Gets or sets the color of the text.
			 *
			 * By default, the text will get a color based on the user's theme. However, this is
			 * usually black.
			 */
			TextColor: Eto.Drawing.Color;

			/** Gets the binding to the {@link Eto.Forms.ListControl.SelectedIndex} property. */
			readonly SelectedIndexBinding: Eto.Forms.BindableBinding$2<Eto.Forms.ListControl, number>;

			/** Gets the binding to the {@link Eto.Forms.ListControl.SelectedKey} property. */
			readonly SelectedKeyBinding: Eto.Forms.BindableBinding$2<Eto.Forms.ListControl, string>;

			/** Gets the binding to the {@link Eto.Forms.ListControl.SelectedValue} property. */
			readonly SelectedValueBinding: Eto.Forms.BindableBinding$2<Eto.Forms.ListControl, unknown>;

			/** Gets or sets the font for the text of the control */
			Font: Eto.Drawing.Font;

			/**
			 * Gets a value indicating that the control is loaded onto a form, that is it has been
			 * created, added to a parent, and shown
			 *
			 * The {@link Eto.Forms.Control.OnLoad(System.EventArgs)} method sets this value to true
			 * after cascading to all children (for a {@link Eto.Forms.Container} ) and calling the
			 * platform handler's implementation.  It is called after adding to a loaded form, or
			 * when showing a new form.  The {@link Eto.Forms.Control.OnUnLoad(System.EventArgs)}
			 * method will set this value to false when the control is removed from its parent
			 */
			readonly Loaded: boolean;

			/**
			 * Gets an enumeration of controls that are in the visual tree.
			 *
			 * This is used to specify which controls are contained by this instance that are part of
			 * the visual tree. This should include all controls including non-logical Eto controls
			 * used for layout.
			 */
			readonly VisualControls: Iterable<Eto.Forms.Control>;

			/**
			 * Gets or sets a user-defined object that contains data about the control
			 *
			 * A common use of the tag property is to store data that is associated with the control
			 * that you can later retrieve.
			 */
			Tag: unknown;

			/**
			 * Gets the logical parent control.
			 *
			 * When the control is part of the visual tree (
				 * {@link Eto.Forms.Control.IsVisualControl} is true), this returns the logical parent
				 * that contains this control. Otherwise this is the same as
				 * {@link Eto.Forms.Control.Parent}.
				 */
				readonly LogicalParent: Eto.Forms.Container;

			/** Gets a value indicating this {@link Eto.Forms.Control} is part of the visual tree. */
			IsVisualControl: boolean;

			/**
			 * Gets or sets the size of the control. Use -1 to specify auto sizing for either the
			 * width and/or height.
			 *
			 * Setting the size of controls is entirely optional as most controls will size
			 * themselves appropriately. When specifying a size, it will be used as the desired size
			 * of the control.  The container will reposition and resize the control depending on the
			 * available size.  For a {@link Eto.Forms.Window}, it is preferred to set the
			 * {@link Eto.Forms.Container.ClientSize} instead, as various platforms have different
			 * sizes of window decorations, toolbars, etc.
			 */
			Size: Eto.Drawing.Size;

			/**
			 * Gets a value indicating this control currently has mouse capture
			 *
			 * Mouse capture can happen during a handled MouseDown event until MouseUp, or it can be
			 * captured explicitly via {@link Eto.Forms.Control.CaptureMouse}.
			 */
			readonly IsMouseCaptured: boolean;

			/** Gets or sets the width of the control size. */
			Width: number;

			/** Gets or sets the height of the control size. */
			Height: number;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Forms.Control} (or its
			 * children) are enabled and accept user input.
			 *
			 * Typically when a control is disabled, the user cannot do anything with the control or
			 * any of its children. Including for example, selecting text in a text control. Certain
			 * controls can have a 'Read Only' mode, such as {@link Eto.Forms.TextBox.ReadOnly} which
			 * allow the user to  select text, but not change its contents.
			 */
			Enabled: boolean;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Forms.Control} is visible to
			 * the user.
			 *
			 * When the visibility of a control is set to false, it will not occupy space in the
			 * layout.
			 */
			Visible: boolean;

			/** Gets the container which this control has been added to, if any */
			readonly Parent: Eto.Forms.Container;

			/**
			 * Gets the visual container of this control, if any.
			 *
			 * Some containers may use other Eto controls to layout its children, such as the
			 * {@link Eto.Forms.StackLayout}. This will return the parent control that visually
			 * contains this control as opposed to {@link Eto.Forms.Control.Parent} which will return
			 * the logical parent.
			 */
			VisualParent: Eto.Forms.Container;

			/** Gets a value indicating this control has been attached to a native container */
			readonly IsAttached: boolean;

			/**
			 * Gets or sets the color for the background of the control
			 *
			 * Note that on some platforms (e.g. Mac), setting the background color of a control can
			 * change the performance characteristics of the control and its children, since it must
			 * enable layers to do so.
			 */
			BackgroundColor: Eto.Drawing.Color;

			/** Gets a value indicating whether this instance has the keyboard input focus. */
			readonly HasFocus: boolean;

			/** Gets a value indicating whether the layout of child controls is suspended. */
			readonly IsSuspended: boolean;

			/** Gets the window this control is contained in */
			readonly ParentWindow: Eto.Forms.Window;

			/**
			 * Gets the supported platform commands that can be used to hook up system functions to
			 * user defined logic
			 *
			 * This lists all available commands that can be mapped using the
			 * {@link Eto.Forms.Control.MapPlatformCommand(System.String,Eto.Forms.Command)} method
			 * of the control.
			 */
			readonly SupportedPlatformCommands: Iterable<string>;

			/** Gets the bounding rectangle of this control relative to its container */
			readonly Bounds: Eto.Drawing.Rectangle;

			/**
			 * Gets the location of the control as positioned by the container
			 *
			 * A control's location is set by the container. This can be used to determine where the
			 * control is for overlaying floating windows, menus, etc.
			 */
			readonly Location: Eto.Drawing.Point;

			/** Gets or sets the type of cursor to use when the mouse is hovering over the control */
			Cursor: Eto.Forms.Cursor;

			/** Gets or sets the tool tip to show when the mouse is hovered over the control */
			ToolTip: string;

			/**
			 * Gets or sets the tab index order for this control within its container.
			 *
			 * This sets the order when using the tab key to cycle through controls  Note that some
			 * platforms (Gtk and WinForms) may not support setting the context of the tab order to
			 * StackLayout  or DynamicLayout containers and may not behave exactly as expected. Use
			 * the {@link Eto.PlatformFeatures.TabIndexWithCustomContainers} flag to determine if it
			 * is supported.
			 */
			TabIndex: number;

			/** Gets or sets a value indicating whether this control can serve as drop target. */
			AllowDrop: boolean;

			/**
			 * Gets or sets the parent widget which this widget has been added to, if any
			 *
			 * When implementing child widgets that can participate in the context based binding
			 * (MVVM), You can set this to the parent widget when it is added or removed to it
			 * (usually via a collection).  Note that you should typically provide a public new
			 * [ParentWidget] Parent { get; } property  so that consumers of your API cannot set the
			 * parent to an invalid value.
			 */
			Parent: Eto.Widget;

			/**
			 * Gets an enumeration of all parent widgets in the heirarchy by traversing the
			 * {@link Eto.Forms.BindableWidget.Parent} property.
			 */
			readonly Parents: Iterable<Eto.Widget>;

			/**
			 * Gets or sets the data context for this widget for binding
			 *
			 * Subclasses may override the standard behaviour so that hierarchy of widgets can be
			 * taken into account.  For example, a Control may return the data context of a parent,
			 * if it is not set explicitly.
			 */
			DataContext: unknown;

			/** Gets the collection of bindings that are attached to this widget */
			readonly Bindings: Eto.Forms.BindingCollection;

			/**
			 * Gets a value indicating that the {@link Eto.Forms.BindableWidget.DataContext} property
			 * is changing.
			 *
			 * This can be used to determine when to allow certain logic during the update of the
			 * data context.  It is used to disable binding setters on the model when the data
			 * context changes so that a binding does not cause the view model to be updated when the
			 * state hasn't been fully set yet.
			 */
			IsDataContextChanging: boolean;

			/**
			 * Gets the platform that was used to create the {@link Eto.Widget.Handler} for this
			 * widget
			 *
			 * This gets set to the current {@link Eto.Platform.Instance} during the construction of
			 * the object
			 */
			readonly Platform: Eto.Platform;

			/** Gets the platform-specific handler for this widget */
			Handler: unknown;

			/** Gets the native platform-specific handle for integration purposes */
			readonly NativeHandle: unknown;

			/** Gets the dictionary of properties for this widget */
			readonly Properties: Eto.PropertyStore;

			/** Gets or sets the ID of this widget */
			ID: string;

			/**
			 * Gets or sets the style of this widget
			 *
			 * Styles allow you to attach custom platform-specific logic to a widget. In your
			 * platform-specific assembly, use {@link Style.Add{H}(string, StyleHandler{H})} to add
			 * the style logic with the same id.
			 */
			Style: string;

			/**
			 * Gets the instance of the platform-specific object
			 *
			 * This can sometimes be useful to get the platform-specific object. Some handlers may
			 * not have any backing object for its functionality, so this may be null.  It is more
			 * preferred to use the {@link Eto.Widget.Handler} and cast that to the platform-specific
			 * handler class which can give you additional methods and helpers to do common tasks.
			 * For example, the {@link Eto.Forms.Application} object's handler for OS X has a
			 * AddFullScreenMenuItem property to specify if you want full screen support in your app.
			 */
			readonly ControlObject: unknown;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Widget} has been disposed.
			 *
			 * When the widget is disposed, it can no longer be used.
			 */
			IsDisposed: boolean;

			/**
			 * Queues a repaint of the entire control on the screen and any of its children.
			 *
			 * This is only useful when the control is visible.
			 */
			Invalidate(): void;

			/**
			 * Queues a repaint of the entire control on the screen
			 *
			 * This is only useful when the control is visible.
			 */
			Invalidate(invalidateChildren: boolean): void;

			/**
			 * Queues a repaint of the specified `rect` of the control and any children.
			 *
			 * This is only useful when the control is visible.
			 */
			Invalidate(rect: Eto.Drawing.Rectangle): void;

			/**
			 * Queues a repaint of the specified `rect` of the control
			 *
			 * This is only useful when the control is visible.
			 */
			Invalidate(
				rect: Eto.Drawing.Rectangle,
				invalidateChildren: boolean,
			): void;

			/**
			 * Updates the layout of this control if necessary.
			 *
			 * This will ensure the control has had all of its layout applied so you can use its
			 * position and size right after this call. Most platforms (except WinForms) use a
			 * deferred layout system so that after adding your control to the form dynamically it
			 * won't get laid out until the next idle loop. This is useful when you need to know the
			 * dimensions of the control immediately. Note that this can be an expensive operation,
			 * so it is recommended to only call this method when necessary and after all of the
			 * controls have been added/updated.
			 */
			UpdateLayout(): void;

			/** Gets the preferred size of this control given infinite space available. */
			GetPreferredSize(): Eto.Drawing.SizeF;

			/** Gets the preferred size of this control given the specified `availableSize`. */
			GetPreferredSize(availableSize: Eto.Drawing.SizeF): Eto.Drawing.SizeF;

			/**
			 * Captures all mouse events to this control.
			 *
			 * This captures all mouse events until {@link Eto.Forms.Control.ReleaseMouseCapture} is
			 * called.  Note that not all platforms will allow a mouse capture unless the mouse is
			 * currently down.
			 */
			CaptureMouse(): boolean;

			/** Releases the mouse capture after a call to {@link Eto.Forms.Control.CaptureMouse}. */
			ReleaseMouseCapture(): void;

			/**
			 * Finds a control in the parent hierarchy with the specified type and
			 * {@link Eto.Widget.ID} if specified
			 */
			FindParent(
				type: unknown,
				id?: string,
			): Eto.Forms.Container;

			/** Finds a control in the parent hierarchy with the specified `id` */
			FindParent(id: string): Eto.Forms.Container;

			/**
			 * Detaches the control by removing it from its parent
			 *
			 * This is essentially a shortcut to myControl.Parent.Remove(myControl);
			 */
			Detach(): void;

			/**
			 * Attaches the control for direct use in a native application
			 *
			 * Use this to use a control directly in a native application.  Note that the native
			 * application must be running the same framework as the current platform.  E.g. a
			 * WinForms application can use an Eto.Forms control when using the Eto.WinForms
			 * platform.  This prepares the control by firing the {@link Eto.Forms.Control.PreLoad},
			 * {@link Eto.Forms.Control.Load}, etc. events.
			 */
			AttachNative(): void;

			/**
			 * Detaches the control when it is used in a native application, when you want to reuse
			 * the control.
			 *
			 * This should only be called after {@link Eto.Forms.Control.AttachNative} has been
			 * called, which is usually done by calling to ToNative(true) .
			 */
			DetachNative(): void;

			/**
			 * Attempts to set the keyboard input focus to this control, or the first child that
			 * accepts focus. For Windows, this will bring it to front and activate it.
			 */
			Focus(): void;

			/**
			 * Suspends the layout of child controls
			 *
			 * This can be used to optimize some platforms while adding, removing, or changing many
			 * child controls at once. It disables the calculation of control positioning until
			 * {@link Eto.Forms.Control.ResumeLayout} is called. Each call to SuspendLayout() must be
			 * balanced with a call to {@link Eto.Forms.Control.ResumeLayout}.
			 */
			SuspendLayout(): void;

			/**
			 * Resumes the layout after it has been suspended, and performs a layout
			 *
			 * This can be used to optimize some platforms while adding, removing, or changing many
			 * child controls at once. Each call to ResumeLayout() must be balanced with a call to
			 * {@link Eto.Forms.Control.SuspendLayout} before it.
			 */
			ResumeLayout(): void;

			/**
			 * Specifies a command to execute for a platform-specific command
			 *
			 * Some platforms have specific system-defined commands that can be associated with a
			 * control. For example, the Mac platform's cut/copy/paste functionality is defined by
			 * the system, and if you want to hook into it, you can use this to map it to your own
			 * defined logic. The valid values of the `systemCommand` parameter are defined by each
			 * platform, and a list can be retrieved using
			 * {@link Eto.Forms.Control.SupportedPlatformCommands}
			 */
			MapPlatformCommand(
				systemCommand: string,
				command: Eto.Forms.Command,
			): void;

			/** Converts a point from screen space to control space. */
			PointFromScreen(point: Eto.Drawing.PointF): Eto.Drawing.PointF;

			/** Converts a point from control space to screen space */
			PointToScreen(point: Eto.Drawing.PointF): Eto.Drawing.PointF;

			/** Converts a rectangle from screen space to control space. */
			RectangleToScreen(rect: Eto.Drawing.RectangleF): Eto.Drawing.RectangleF;

			/** Converts a rectangle from control space to screen space */
			RectangleFromScreen(rect: Eto.Drawing.RectangleF): Eto.Drawing.RectangleF;

			/**
			 * Starts drag operation using this control as drag source.
			 *
			 * This method can be blocking on some platforms (Wpf, WinForms), and non-blocking on
			 * others (Mac, Gtk). Use the {@link Eto.Forms.Control.DragEnd} event to determine when
			 * the drag operation is completed and get its resulting DragEffects.
			 */
			DoDragDrop(
				data: Eto.Forms.DataObject,
				allowedEffects: Eto.Forms.DragEffects,
			): void;

			/**
			 * Starts drag operation using this control as drag source.
			 *
			 * This method can be blocking on some platforms (Wpf, WinForms), and non-blocking on
			 * others (Mac, Gtk). Use the {@link Eto.Forms.Control.DragEnd} event to determine when
			 * the drag operation is completed and get its resulting DragEffects.
			 */
			DoDragDrop(
				data: Eto.Forms.DataObject,
				allowedEffects: Eto.Forms.DragEffects,
				image: Eto.Drawing.Image,
				cursorOffset: Eto.Drawing.PointF,
			): void;

			/**
			 * Triggers the StyleChanged event and re-applies the styles to this control and its
			 * children.
			 */
			TriggerStyleChanged(): void;

			/** Shows a print dialog to print the specified control */
			Print(): void;

			/**
			 * Finds a control in the parent hierarchy with the specified type and
			 * {@link Eto.Widget.ID} if specified
			 */
			FindParent<T>(id?: string): T;

			/**
			 * Finds a control in the parent hierarchy with the specified type and
			 * {@link Eto.Widget.ID} if specified
			 */
			FindParent(
				type: unknown,
				id?: string,
			): Eto.Widget;

			/** Finds a control in the parent hierarchy with the specified `id` */
			FindParent(id: string): Eto.Widget;

			/**
			 * Unbinds any bindings in the {@link Eto.Forms.BindableWidget.Bindings} collection and
			 * removes the bindings
			 *
			 * When you implement {@link Eto.Forms.IBindableWidgetContainer}, this will also unbind
			 * any of its children.
			 */
			Unbind(): void;

			/**
			 * Updates all bindings in this widget
			 *
			 * When you implement {@link Eto.Forms.IBindableWidgetContainer}, this will also update
			 * bindings for all of its children.
			 */
			UpdateBindings(mode?: Eto.Forms.BindingUpdateMode): void;

			/** Disposes of this widget, supressing the finalizer */
			dispose(): void;

			/** Gets a string that represents the current object with its ID if specified. */
			ToString(): string;
		}
	}

	export namespace Eto.Forms {
		/** [Generic type factory] Radio button list based on an enumeration */
		export function EnumRadioButtonList$(T: IType): typeof EnumRadioButtonList$1<any>;

		/** Radio button list based on an enumeration */
		export class EnumRadioButtonList$1<T> implements
			Eto.IHandlerSource,
			Eto.Forms.IBindable,
			Eto.Forms.IMouseInputSource,
			Eto.Forms.IKeyboardInputSource {
			new(): EnumRadioButtonList$1<T>;

			/** Gets or sets the currently selected enumeration value */
			SelectedValue: T;

			/**
			 * Gets or sets a delegate used to get the text value for each item.
			 *
			 * You can use this delegate to provide translated or custom text for each enumeration.
			 * Otherwise, the name of the enum is used.
			 */
			GetText: (arg1: T) => string;

			/**
			 * Gets or sets a value indicating that the items in the list are sorted alphabetically,
			 * instead of by numerical value of the enumeration
			 */
			SortAlphabetically: boolean;

			/**
			 * Gets a binding to the {@link Eto.Forms.EnumRadioButtonList`1.SelectedValue} property.
			 */
			readonly SelectedValueBinding: Eto.Forms.BindableBinding$2<Eto.Forms.EnumRadioButtonList$1<T>, T>;

			/**
			 * Gets or sets the binding to get the text for each radio button.
			 *
			 * By default, this will bind to a "Text" property, or {@link Eto.Forms.IListItem.Text}
			 * when implemented.
			 */
			ItemTextBinding: Eto.Forms.IIndirectBinding$1<string>;

			/**
			 * Gets or sets the binding to get the key for each radio button.
			 *
			 * By default, this will bind to a "Key" property, or {@link Eto.Forms.IListItem.Key}
			 * when implemented.
			 */
			ItemKeyBinding: Eto.Forms.IIndirectBinding$1<string>;

			/** Gets or sets the binding to get the tooltip text for each radio button. */
			ItemToolTipBinding: Eto.Forms.IIndirectBinding$1<string>;

			/**
			 * Gets or sets the binding to get the text for each radio button.
			 *
			 * By default, this will bind to a "Text" property, or {@link Eto.Forms.IListItem.Text}
			 * when implemented.
			 */
			TextBinding: Eto.Forms.IIndirectBinding$1<string>;

			/**
			 * Gets or sets the binding to get the key for each radio button.
			 *
			 * By default, this will bind to a "Key" property, or {@link Eto.Forms.IListItem.Key}
			 * when implemented.
			 */
			KeyBinding: Eto.Forms.IIndirectBinding$1<string>;

			/**
			 * Gets or sets the selected key of the currently selected item using the
			 * {@link Eto.Forms.RadioButtonList.ItemKeyBinding}.
			 */
			SelectedKey: string;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Forms.RadioButtonList} is
			 * enabled.
			 *
			 * When the control is disabled, the user will not be able to change the selected radio
			 * button. However, you can still programatically change the selection.
			 */
			Enabled: boolean;

			/**
			 * Gets or sets the selected value, which is the {@link Eto.Forms.ListItem} or object in
			 * your custom data store.
			 */
			SelectedValue: unknown;

			/** Gets or sets the index of the selected item. */
			SelectedIndex: number;

			/** Gets or sets the color of the radio button text. */
			TextColor: Eto.Drawing.Color;

			/** Gets or sets the orientation of the radio buttons. */
			Orientation: Eto.Forms.Orientation;

			/** Gets or sets the spacing between each radio button. */
			Spacing: Eto.Drawing.Size;

			/**
			 * Gets the item collection, when adding items programatically.
			 *
			 * This is used when you want to add items manually.  Use the
			 * {@link Eto.Forms.RadioButtonList.DataStore} when you have an existing collection you
			 * want to bind to directly.
			 */
			readonly Items: Eto.Forms.ListItemCollection;

			/**
			 * Gets or sets the data store of the items shown in the list.
			 *
			 * When using a custom object collection, you can use the
			 * {@link Eto.Forms.RadioButtonList.ItemTextBinding} and
			 * {@link Eto.Forms.RadioButtonList.ItemKeyBinding} to specify how to get the text/key
			 * values for each item.
			 */
			DataStore: Iterable<unknown>;

			/** Gets a binding to the {@link Eto.Forms.RadioButtonList.SelectedValue} property. */
			readonly SelectedValueBinding: Eto.Forms.BindableBinding$2<Eto.Forms.RadioButtonList, unknown>;

			/** Gets a binding to the {@link Eto.Forms.RadioButtonList.SelectedIndex} property. */
			readonly SelectedIndexBinding: Eto.Forms.BindableBinding$2<Eto.Forms.RadioButtonList, number>;

			/** Gets a binding to the {@link Eto.Forms.RadioButtonList.SelectedKey} property. */
			readonly SelectedKeyBinding: Eto.Forms.BindableBinding$2<Eto.Forms.RadioButtonList, string>;

			/** Gets an enumeration of controls that are directly contained by this container */
			readonly Controls: Iterable<Eto.Forms.Control>;

			/** Gets or sets the padding around the {@link Eto.Forms.Panel.Content} of the panel. */
			Padding: Eto.Drawing.Padding;

			/** Gets or sets the minimum size of the panel. */
			MinimumSize: Eto.Drawing.Size;

			/**
			 * Gets or sets the context menu for the panel.
			 *
			 * The context menu is usually shown when the user right clicks the control, or in mobile
			 * platforms when the user taps and holds their finger down on the control.
			 */
			ContextMenu: Eto.Forms.ContextMenu;

			/**
			 * Gets or sets the main content of the panel.
			 *
			 * The main content will be offset by the {@link Eto.Forms.Panel.Padding} value
			 * specified, and will take up the entire content area of the control. Some controls may
			 * have decorations that will surround the content, such as a {@link Eto.Forms.GroupBox},
			 * {@link Eto.Forms.TabControl}, or {@link Eto.Forms.Window}
			 */
			Content: Eto.Forms.Control;

			/**
			 * Gets or sets the size for the client area of the control
			 *
			 * The client size differs from the {@link Eto.Forms.Control.Size} in that it excludes
			 * the decorations of the container, such as the title bar and border around a
			 * {@link Eto.Forms.Window}, or the title and line  around a {@link Eto.Forms.GroupBox}.
			 */
			ClientSize: Eto.Drawing.Size;

			/**
			 * Gets an enumeration of all contained child controls, including controls within child
			 * containers
			 */
			readonly Children: Iterable<Eto.Forms.Control>;

			/**
			 * Gets an enumeration of all contained child controls in the visual tree, including
			 * controls within child containers.
			 */
			readonly VisualChildren: Iterable<Eto.Forms.Control>;

			/**
			 * Gets or sets the style provider for this container.
			 *
			 * The style provider is used to style this container and its children.
			 */
			StyleProvider: Eto.IStyleProvider;

			/**
			 * Gets the default style provider for this container.
			 *
			 * Use this to apply styles to any child controls of this container. By default, styles
			 * will apply to all children, including children of children unless
			 * {@link Eto.DefaultStyleProvider.Inherit} is set to false .  Typically, you would set
			 * Inherit to false when creating composite controls that already have all their styles
			 * applied and you don't want any other styles to be inherited.
			 */
			readonly Styles: Eto.DefaultStyleProvider;

			/**
			 * Gets a value indicating that the control is loaded onto a form, that is it has been
			 * created, added to a parent, and shown
			 *
			 * The {@link Eto.Forms.Control.OnLoad(System.EventArgs)} method sets this value to true
			 * after cascading to all children (for a {@link Eto.Forms.Container} ) and calling the
			 * platform handler's implementation.  It is called after adding to a loaded form, or
			 * when showing a new form.  The {@link Eto.Forms.Control.OnUnLoad(System.EventArgs)}
			 * method will set this value to false when the control is removed from its parent
			 */
			readonly Loaded: boolean;

			/**
			 * Gets an enumeration of controls that are in the visual tree.
			 *
			 * This is used to specify which controls are contained by this instance that are part of
			 * the visual tree. This should include all controls including non-logical Eto controls
			 * used for layout.
			 */
			readonly VisualControls: Iterable<Eto.Forms.Control>;

			/**
			 * Gets or sets a user-defined object that contains data about the control
			 *
			 * A common use of the tag property is to store data that is associated with the control
			 * that you can later retrieve.
			 */
			Tag: unknown;

			/**
			 * Gets the logical parent control.
			 *
			 * When the control is part of the visual tree (
				 * {@link Eto.Forms.Control.IsVisualControl} is true), this returns the logical parent
				 * that contains this control. Otherwise this is the same as
				 * {@link Eto.Forms.Control.Parent}.
				 */
				readonly LogicalParent: Eto.Forms.Container;

			/** Gets a value indicating this {@link Eto.Forms.Control} is part of the visual tree. */
			IsVisualControl: boolean;

			/**
			 * Gets or sets the size of the control. Use -1 to specify auto sizing for either the
			 * width and/or height.
			 *
			 * Setting the size of controls is entirely optional as most controls will size
			 * themselves appropriately. When specifying a size, it will be used as the desired size
			 * of the control.  The container will reposition and resize the control depending on the
			 * available size.  For a {@link Eto.Forms.Window}, it is preferred to set the
			 * {@link Eto.Forms.Container.ClientSize} instead, as various platforms have different
			 * sizes of window decorations, toolbars, etc.
			 */
			Size: Eto.Drawing.Size;

			/**
			 * Gets a value indicating this control currently has mouse capture
			 *
			 * Mouse capture can happen during a handled MouseDown event until MouseUp, or it can be
			 * captured explicitly via {@link Eto.Forms.Control.CaptureMouse}.
			 */
			readonly IsMouseCaptured: boolean;

			/** Gets or sets the width of the control size. */
			Width: number;

			/** Gets or sets the height of the control size. */
			Height: number;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Forms.Control} is visible to
			 * the user.
			 *
			 * When the visibility of a control is set to false, it will not occupy space in the
			 * layout.
			 */
			Visible: boolean;

			/** Gets the container which this control has been added to, if any */
			readonly Parent: Eto.Forms.Container;

			/**
			 * Gets the visual container of this control, if any.
			 *
			 * Some containers may use other Eto controls to layout its children, such as the
			 * {@link Eto.Forms.StackLayout}. This will return the parent control that visually
			 * contains this control as opposed to {@link Eto.Forms.Control.Parent} which will return
			 * the logical parent.
			 */
			VisualParent: Eto.Forms.Container;

			/** Gets a value indicating this control has been attached to a native container */
			readonly IsAttached: boolean;

			/**
			 * Gets or sets the color for the background of the control
			 *
			 * Note that on some platforms (e.g. Mac), setting the background color of a control can
			 * change the performance characteristics of the control and its children, since it must
			 * enable layers to do so.
			 */
			BackgroundColor: Eto.Drawing.Color;

			/** Gets a value indicating whether this instance has the keyboard input focus. */
			readonly HasFocus: boolean;

			/** Gets a value indicating whether the layout of child controls is suspended. */
			readonly IsSuspended: boolean;

			/** Gets the window this control is contained in */
			readonly ParentWindow: Eto.Forms.Window;

			/**
			 * Gets the supported platform commands that can be used to hook up system functions to
			 * user defined logic
			 *
			 * This lists all available commands that can be mapped using the
			 * {@link Eto.Forms.Control.MapPlatformCommand(System.String,Eto.Forms.Command)} method
			 * of the control.
			 */
			readonly SupportedPlatformCommands: Iterable<string>;

			/** Gets the bounding rectangle of this control relative to its container */
			readonly Bounds: Eto.Drawing.Rectangle;

			/**
			 * Gets the location of the control as positioned by the container
			 *
			 * A control's location is set by the container. This can be used to determine where the
			 * control is for overlaying floating windows, menus, etc.
			 */
			readonly Location: Eto.Drawing.Point;

			/** Gets or sets the type of cursor to use when the mouse is hovering over the control */
			Cursor: Eto.Forms.Cursor;

			/** Gets or sets the tool tip to show when the mouse is hovered over the control */
			ToolTip: string;

			/**
			 * Gets or sets the tab index order for this control within its container.
			 *
			 * This sets the order when using the tab key to cycle through controls  Note that some
			 * platforms (Gtk and WinForms) may not support setting the context of the tab order to
			 * StackLayout  or DynamicLayout containers and may not behave exactly as expected. Use
			 * the {@link Eto.PlatformFeatures.TabIndexWithCustomContainers} flag to determine if it
			 * is supported.
			 */
			TabIndex: number;

			/** Gets or sets a value indicating whether this control can serve as drop target. */
			AllowDrop: boolean;

			/**
			 * Gets or sets the parent widget which this widget has been added to, if any
			 *
			 * When implementing child widgets that can participate in the context based binding
			 * (MVVM), You can set this to the parent widget when it is added or removed to it
			 * (usually via a collection).  Note that you should typically provide a public new
			 * [ParentWidget] Parent { get; } property  so that consumers of your API cannot set the
			 * parent to an invalid value.
			 */
			Parent: Eto.Widget;

			/**
			 * Gets an enumeration of all parent widgets in the heirarchy by traversing the
			 * {@link Eto.Forms.BindableWidget.Parent} property.
			 */
			readonly Parents: Iterable<Eto.Widget>;

			/**
			 * Gets or sets the data context for this widget for binding
			 *
			 * Subclasses may override the standard behaviour so that hierarchy of widgets can be
			 * taken into account.  For example, a Control may return the data context of a parent,
			 * if it is not set explicitly.
			 */
			DataContext: unknown;

			/** Gets the collection of bindings that are attached to this widget */
			readonly Bindings: Eto.Forms.BindingCollection;

			/**
			 * Gets a value indicating that the {@link Eto.Forms.BindableWidget.DataContext} property
			 * is changing.
			 *
			 * This can be used to determine when to allow certain logic during the update of the
			 * data context.  It is used to disable binding setters on the model when the data
			 * context changes so that a binding does not cause the view model to be updated when the
			 * state hasn't been fully set yet.
			 */
			IsDataContextChanging: boolean;

			/**
			 * Gets the platform that was used to create the {@link Eto.Widget.Handler} for this
			 * widget
			 *
			 * This gets set to the current {@link Eto.Platform.Instance} during the construction of
			 * the object
			 */
			readonly Platform: Eto.Platform;

			/** Gets the platform-specific handler for this widget */
			Handler: unknown;

			/** Gets the native platform-specific handle for integration purposes */
			readonly NativeHandle: unknown;

			/** Gets the dictionary of properties for this widget */
			readonly Properties: Eto.PropertyStore;

			/** Gets or sets the ID of this widget */
			ID: string;

			/**
			 * Gets or sets the style of this widget
			 *
			 * Styles allow you to attach custom platform-specific logic to a widget. In your
			 * platform-specific assembly, use {@link Style.Add{H}(string, StyleHandler{H})} to add
			 * the style logic with the same id.
			 */
			Style: string;

			/**
			 * Gets the instance of the platform-specific object
			 *
			 * This can sometimes be useful to get the platform-specific object. Some handlers may
			 * not have any backing object for its functionality, so this may be null.  It is more
			 * preferred to use the {@link Eto.Widget.Handler} and cast that to the platform-specific
			 * handler class which can give you additional methods and helpers to do common tasks.
			 * For example, the {@link Eto.Forms.Application} object's handler for OS X has a
			 * AddFullScreenMenuItem property to specify if you want full screen support in your app.
			 */
			readonly ControlObject: unknown;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Widget} has been disposed.
			 *
			 * When the widget is disposed, it can no longer be used.
			 */
			IsDisposed: boolean;

			/** Removes the specified child from the container */
			Remove(child: Eto.Forms.Control): void;

			/** Remove the specified `controls` from this container */
			Remove(controls: Iterable<Eto.Forms.Control>): void;

			/** Removes all controls from this container */
			RemoveAll(): void;

			/**
			 * Finds a child control in this container or any of its child containers with the
			 * specified `id`
			 */
			FindChild<T>(id?: string): T;

			/**
			 * Finds a child control in this container or any of its child containers with the
			 * specified `type`
			 */
			FindChild(
				type: unknown,
				id?: string,
			): Eto.Forms.Control;

			/**
			 * Finds a child control in this container or any of its child containers with the
			 * specified `id`.
			 */
			FindChild(id: string): Eto.Forms.Control;

			/**
			 * Queues a repaint of the entire control on the screen and any of its children.
			 *
			 * This is only useful when the control is visible.
			 */
			Invalidate(): void;

			/**
			 * Queues a repaint of the entire control on the screen
			 *
			 * This is only useful when the control is visible.
			 */
			Invalidate(invalidateChildren: boolean): void;

			/**
			 * Queues a repaint of the specified `rect` of the control and any children.
			 *
			 * This is only useful when the control is visible.
			 */
			Invalidate(rect: Eto.Drawing.Rectangle): void;

			/**
			 * Queues a repaint of the specified `rect` of the control
			 *
			 * This is only useful when the control is visible.
			 */
			Invalidate(
				rect: Eto.Drawing.Rectangle,
				invalidateChildren: boolean,
			): void;

			/**
			 * Updates the layout of this control if necessary.
			 *
			 * This will ensure the control has had all of its layout applied so you can use its
			 * position and size right after this call. Most platforms (except WinForms) use a
			 * deferred layout system so that after adding your control to the form dynamically it
			 * won't get laid out until the next idle loop. This is useful when you need to know the
			 * dimensions of the control immediately. Note that this can be an expensive operation,
			 * so it is recommended to only call this method when necessary and after all of the
			 * controls have been added/updated.
			 */
			UpdateLayout(): void;

			/** Gets the preferred size of this control given infinite space available. */
			GetPreferredSize(): Eto.Drawing.SizeF;

			/** Gets the preferred size of this control given the specified `availableSize`. */
			GetPreferredSize(availableSize: Eto.Drawing.SizeF): Eto.Drawing.SizeF;

			/**
			 * Captures all mouse events to this control.
			 *
			 * This captures all mouse events until {@link Eto.Forms.Control.ReleaseMouseCapture} is
			 * called.  Note that not all platforms will allow a mouse capture unless the mouse is
			 * currently down.
			 */
			CaptureMouse(): boolean;

			/** Releases the mouse capture after a call to {@link Eto.Forms.Control.CaptureMouse}. */
			ReleaseMouseCapture(): void;

			/**
			 * Finds a control in the parent hierarchy with the specified type and
			 * {@link Eto.Widget.ID} if specified
			 */
			FindParent(
				type: unknown,
				id?: string,
			): Eto.Forms.Container;

			/** Finds a control in the parent hierarchy with the specified `id` */
			FindParent(id: string): Eto.Forms.Container;

			/**
			 * Detaches the control by removing it from its parent
			 *
			 * This is essentially a shortcut to myControl.Parent.Remove(myControl);
			 */
			Detach(): void;

			/**
			 * Attaches the control for direct use in a native application
			 *
			 * Use this to use a control directly in a native application.  Note that the native
			 * application must be running the same framework as the current platform.  E.g. a
			 * WinForms application can use an Eto.Forms control when using the Eto.WinForms
			 * platform.  This prepares the control by firing the {@link Eto.Forms.Control.PreLoad},
			 * {@link Eto.Forms.Control.Load}, etc. events.
			 */
			AttachNative(): void;

			/**
			 * Detaches the control when it is used in a native application, when you want to reuse
			 * the control.
			 *
			 * This should only be called after {@link Eto.Forms.Control.AttachNative} has been
			 * called, which is usually done by calling to ToNative(true) .
			 */
			DetachNative(): void;

			/**
			 * Attempts to set the keyboard input focus to this control, or the first child that
			 * accepts focus. For Windows, this will bring it to front and activate it.
			 */
			Focus(): void;

			/**
			 * Suspends the layout of child controls
			 *
			 * This can be used to optimize some platforms while adding, removing, or changing many
			 * child controls at once. It disables the calculation of control positioning until
			 * {@link Eto.Forms.Control.ResumeLayout} is called. Each call to SuspendLayout() must be
			 * balanced with a call to {@link Eto.Forms.Control.ResumeLayout}.
			 */
			SuspendLayout(): void;

			/**
			 * Resumes the layout after it has been suspended, and performs a layout
			 *
			 * This can be used to optimize some platforms while adding, removing, or changing many
			 * child controls at once. Each call to ResumeLayout() must be balanced with a call to
			 * {@link Eto.Forms.Control.SuspendLayout} before it.
			 */
			ResumeLayout(): void;

			/**
			 * Specifies a command to execute for a platform-specific command
			 *
			 * Some platforms have specific system-defined commands that can be associated with a
			 * control. For example, the Mac platform's cut/copy/paste functionality is defined by
			 * the system, and if you want to hook into it, you can use this to map it to your own
			 * defined logic. The valid values of the `systemCommand` parameter are defined by each
			 * platform, and a list can be retrieved using
			 * {@link Eto.Forms.Control.SupportedPlatformCommands}
			 */
			MapPlatformCommand(
				systemCommand: string,
				command: Eto.Forms.Command,
			): void;

			/** Converts a point from screen space to control space. */
			PointFromScreen(point: Eto.Drawing.PointF): Eto.Drawing.PointF;

			/** Converts a point from control space to screen space */
			PointToScreen(point: Eto.Drawing.PointF): Eto.Drawing.PointF;

			/** Converts a rectangle from screen space to control space. */
			RectangleToScreen(rect: Eto.Drawing.RectangleF): Eto.Drawing.RectangleF;

			/** Converts a rectangle from control space to screen space */
			RectangleFromScreen(rect: Eto.Drawing.RectangleF): Eto.Drawing.RectangleF;

			/**
			 * Starts drag operation using this control as drag source.
			 *
			 * This method can be blocking on some platforms (Wpf, WinForms), and non-blocking on
			 * others (Mac, Gtk). Use the {@link Eto.Forms.Control.DragEnd} event to determine when
			 * the drag operation is completed and get its resulting DragEffects.
			 */
			DoDragDrop(
				data: Eto.Forms.DataObject,
				allowedEffects: Eto.Forms.DragEffects,
			): void;

			/**
			 * Starts drag operation using this control as drag source.
			 *
			 * This method can be blocking on some platforms (Wpf, WinForms), and non-blocking on
			 * others (Mac, Gtk). Use the {@link Eto.Forms.Control.DragEnd} event to determine when
			 * the drag operation is completed and get its resulting DragEffects.
			 */
			DoDragDrop(
				data: Eto.Forms.DataObject,
				allowedEffects: Eto.Forms.DragEffects,
				image: Eto.Drawing.Image,
				cursorOffset: Eto.Drawing.PointF,
			): void;

			/**
			 * Triggers the StyleChanged event and re-applies the styles to this control and its
			 * children.
			 */
			TriggerStyleChanged(): void;

			/** Shows a print dialog to print the specified control */
			Print(): void;

			/**
			 * Finds a control in the parent hierarchy with the specified type and
			 * {@link Eto.Widget.ID} if specified
			 */
			FindParent<T>(id?: string): T;

			/**
			 * Finds a control in the parent hierarchy with the specified type and
			 * {@link Eto.Widget.ID} if specified
			 */
			FindParent(
				type: unknown,
				id?: string,
			): Eto.Widget;

			/** Finds a control in the parent hierarchy with the specified `id` */
			FindParent(id: string): Eto.Widget;

			/**
			 * Unbinds any bindings in the {@link Eto.Forms.BindableWidget.Bindings} collection and
			 * removes the bindings
			 *
			 * When you implement {@link Eto.Forms.IBindableWidgetContainer}, this will also unbind
			 * any of its children.
			 */
			Unbind(): void;

			/**
			 * Updates all bindings in this widget
			 *
			 * When you implement {@link Eto.Forms.IBindableWidgetContainer}, this will also update
			 * bindings for all of its children.
			 */
			UpdateBindings(mode?: Eto.Forms.BindingUpdateMode): void;

			/** Disposes of this widget, supressing the finalizer */
			dispose(): void;

			/** Gets a string that represents the current object with its ID if specified. */
			ToString(): string;
		}
	}

	export namespace Eto.Forms {
		/**
		 * A control that provides a way to expand or collapse a panel. It includes a header and
		 * button.
		 */
		export class Expander implements
			Eto.IHandlerSource,
			Eto.Forms.IBindable,
			Eto.Forms.IMouseInputSource,
			Eto.Forms.IKeyboardInputSource {
			constructor();

			/** Gets an enumeration of controls that are directly contained by this container */
			readonly Controls: Iterable<Eto.Forms.Control>;

			/**
			 * Gets or sets a value indicating whether {@link Eto.Forms.Panel.Content} is currently
			 * expanded/visible.
			 */
			Expanded: boolean;

			/**
			 * Gets or sets the header control.
			 *
			 * Note, that there will always be a small button appearing in the header.
			 */
			Header: Eto.Forms.Control;

			/** Gets or sets the padding around the {@link Eto.Forms.Panel.Content} of the panel. */
			Padding: Eto.Drawing.Padding;

			/** Gets or sets the minimum size of the panel. */
			MinimumSize: Eto.Drawing.Size;

			/**
			 * Gets or sets the context menu for the panel.
			 *
			 * The context menu is usually shown when the user right clicks the control, or in mobile
			 * platforms when the user taps and holds their finger down on the control.
			 */
			ContextMenu: Eto.Forms.ContextMenu;

			/**
			 * Gets or sets the main content of the panel.
			 *
			 * The main content will be offset by the {@link Eto.Forms.Panel.Padding} value
			 * specified, and will take up the entire content area of the control. Some controls may
			 * have decorations that will surround the content, such as a {@link Eto.Forms.GroupBox},
			 * {@link Eto.Forms.TabControl}, or {@link Eto.Forms.Window}
			 */
			Content: Eto.Forms.Control;

			/**
			 * Gets or sets the size for the client area of the control
			 *
			 * The client size differs from the {@link Eto.Forms.Control.Size} in that it excludes
			 * the decorations of the container, such as the title bar and border around a
			 * {@link Eto.Forms.Window}, or the title and line  around a {@link Eto.Forms.GroupBox}.
			 */
			ClientSize: Eto.Drawing.Size;

			/**
			 * Gets an enumeration of all contained child controls, including controls within child
			 * containers
			 */
			readonly Children: Iterable<Eto.Forms.Control>;

			/**
			 * Gets an enumeration of all contained child controls in the visual tree, including
			 * controls within child containers.
			 */
			readonly VisualChildren: Iterable<Eto.Forms.Control>;

			/**
			 * Gets or sets the style provider for this container.
			 *
			 * The style provider is used to style this container and its children.
			 */
			StyleProvider: Eto.IStyleProvider;

			/**
			 * Gets the default style provider for this container.
			 *
			 * Use this to apply styles to any child controls of this container. By default, styles
			 * will apply to all children, including children of children unless
			 * {@link Eto.DefaultStyleProvider.Inherit} is set to false .  Typically, you would set
			 * Inherit to false when creating composite controls that already have all their styles
			 * applied and you don't want any other styles to be inherited.
			 */
			readonly Styles: Eto.DefaultStyleProvider;

			/**
			 * Gets a value indicating that the control is loaded onto a form, that is it has been
			 * created, added to a parent, and shown
			 *
			 * The {@link Eto.Forms.Control.OnLoad(System.EventArgs)} method sets this value to true
			 * after cascading to all children (for a {@link Eto.Forms.Container} ) and calling the
			 * platform handler's implementation.  It is called after adding to a loaded form, or
			 * when showing a new form.  The {@link Eto.Forms.Control.OnUnLoad(System.EventArgs)}
			 * method will set this value to false when the control is removed from its parent
			 */
			readonly Loaded: boolean;

			/**
			 * Gets an enumeration of controls that are in the visual tree.
			 *
			 * This is used to specify which controls are contained by this instance that are part of
			 * the visual tree. This should include all controls including non-logical Eto controls
			 * used for layout.
			 */
			readonly VisualControls: Iterable<Eto.Forms.Control>;

			/**
			 * Gets or sets a user-defined object that contains data about the control
			 *
			 * A common use of the tag property is to store data that is associated with the control
			 * that you can later retrieve.
			 */
			Tag: unknown;

			/**
			 * Gets the logical parent control.
			 *
			 * When the control is part of the visual tree (
				 * {@link Eto.Forms.Control.IsVisualControl} is true), this returns the logical parent
				 * that contains this control. Otherwise this is the same as
				 * {@link Eto.Forms.Control.Parent}.
				 */
				readonly LogicalParent: Eto.Forms.Container;

			/** Gets a value indicating this {@link Eto.Forms.Control} is part of the visual tree. */
			IsVisualControl: boolean;

			/**
			 * Gets or sets the size of the control. Use -1 to specify auto sizing for either the
			 * width and/or height.
			 *
			 * Setting the size of controls is entirely optional as most controls will size
			 * themselves appropriately. When specifying a size, it will be used as the desired size
			 * of the control.  The container will reposition and resize the control depending on the
			 * available size.  For a {@link Eto.Forms.Window}, it is preferred to set the
			 * {@link Eto.Forms.Container.ClientSize} instead, as various platforms have different
			 * sizes of window decorations, toolbars, etc.
			 */
			Size: Eto.Drawing.Size;

			/**
			 * Gets a value indicating this control currently has mouse capture
			 *
			 * Mouse capture can happen during a handled MouseDown event until MouseUp, or it can be
			 * captured explicitly via {@link Eto.Forms.Control.CaptureMouse}.
			 */
			readonly IsMouseCaptured: boolean;

			/** Gets or sets the width of the control size. */
			Width: number;

			/** Gets or sets the height of the control size. */
			Height: number;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Forms.Control} (or its
			 * children) are enabled and accept user input.
			 *
			 * Typically when a control is disabled, the user cannot do anything with the control or
			 * any of its children. Including for example, selecting text in a text control. Certain
			 * controls can have a 'Read Only' mode, such as {@link Eto.Forms.TextBox.ReadOnly} which
			 * allow the user to  select text, but not change its contents.
			 */
			Enabled: boolean;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Forms.Control} is visible to
			 * the user.
			 *
			 * When the visibility of a control is set to false, it will not occupy space in the
			 * layout.
			 */
			Visible: boolean;

			/** Gets the container which this control has been added to, if any */
			readonly Parent: Eto.Forms.Container;

			/**
			 * Gets the visual container of this control, if any.
			 *
			 * Some containers may use other Eto controls to layout its children, such as the
			 * {@link Eto.Forms.StackLayout}. This will return the parent control that visually
			 * contains this control as opposed to {@link Eto.Forms.Control.Parent} which will return
			 * the logical parent.
			 */
			VisualParent: Eto.Forms.Container;

			/** Gets a value indicating this control has been attached to a native container */
			readonly IsAttached: boolean;

			/**
			 * Gets or sets the color for the background of the control
			 *
			 * Note that on some platforms (e.g. Mac), setting the background color of a control can
			 * change the performance characteristics of the control and its children, since it must
			 * enable layers to do so.
			 */
			BackgroundColor: Eto.Drawing.Color;

			/** Gets a value indicating whether this instance has the keyboard input focus. */
			readonly HasFocus: boolean;

			/** Gets a value indicating whether the layout of child controls is suspended. */
			readonly IsSuspended: boolean;

			/** Gets the window this control is contained in */
			readonly ParentWindow: Eto.Forms.Window;

			/**
			 * Gets the supported platform commands that can be used to hook up system functions to
			 * user defined logic
			 *
			 * This lists all available commands that can be mapped using the
			 * {@link Eto.Forms.Control.MapPlatformCommand(System.String,Eto.Forms.Command)} method
			 * of the control.
			 */
			readonly SupportedPlatformCommands: Iterable<string>;

			/** Gets the bounding rectangle of this control relative to its container */
			readonly Bounds: Eto.Drawing.Rectangle;

			/**
			 * Gets the location of the control as positioned by the container
			 *
			 * A control's location is set by the container. This can be used to determine where the
			 * control is for overlaying floating windows, menus, etc.
			 */
			readonly Location: Eto.Drawing.Point;

			/** Gets or sets the type of cursor to use when the mouse is hovering over the control */
			Cursor: Eto.Forms.Cursor;

			/** Gets or sets the tool tip to show when the mouse is hovered over the control */
			ToolTip: string;

			/**
			 * Gets or sets the tab index order for this control within its container.
			 *
			 * This sets the order when using the tab key to cycle through controls  Note that some
			 * platforms (Gtk and WinForms) may not support setting the context of the tab order to
			 * StackLayout  or DynamicLayout containers and may not behave exactly as expected. Use
			 * the {@link Eto.PlatformFeatures.TabIndexWithCustomContainers} flag to determine if it
			 * is supported.
			 */
			TabIndex: number;

			/** Gets or sets a value indicating whether this control can serve as drop target. */
			AllowDrop: boolean;

			/**
			 * Gets or sets the parent widget which this widget has been added to, if any
			 *
			 * When implementing child widgets that can participate in the context based binding
			 * (MVVM), You can set this to the parent widget when it is added or removed to it
			 * (usually via a collection).  Note that you should typically provide a public new
			 * [ParentWidget] Parent { get; } property  so that consumers of your API cannot set the
			 * parent to an invalid value.
			 */
			Parent: Eto.Widget;

			/**
			 * Gets an enumeration of all parent widgets in the heirarchy by traversing the
			 * {@link Eto.Forms.BindableWidget.Parent} property.
			 */
			readonly Parents: Iterable<Eto.Widget>;

			/**
			 * Gets or sets the data context for this widget for binding
			 *
			 * Subclasses may override the standard behaviour so that hierarchy of widgets can be
			 * taken into account.  For example, a Control may return the data context of a parent,
			 * if it is not set explicitly.
			 */
			DataContext: unknown;

			/** Gets the collection of bindings that are attached to this widget */
			readonly Bindings: Eto.Forms.BindingCollection;

			/**
			 * Gets a value indicating that the {@link Eto.Forms.BindableWidget.DataContext} property
			 * is changing.
			 *
			 * This can be used to determine when to allow certain logic during the update of the
			 * data context.  It is used to disable binding setters on the model when the data
			 * context changes so that a binding does not cause the view model to be updated when the
			 * state hasn't been fully set yet.
			 */
			IsDataContextChanging: boolean;

			/**
			 * Gets the platform that was used to create the {@link Eto.Widget.Handler} for this
			 * widget
			 *
			 * This gets set to the current {@link Eto.Platform.Instance} during the construction of
			 * the object
			 */
			readonly Platform: Eto.Platform;

			/** Gets the platform-specific handler for this widget */
			Handler: unknown;

			/** Gets the native platform-specific handle for integration purposes */
			readonly NativeHandle: unknown;

			/** Gets the dictionary of properties for this widget */
			readonly Properties: Eto.PropertyStore;

			/** Gets or sets the ID of this widget */
			ID: string;

			/**
			 * Gets or sets the style of this widget
			 *
			 * Styles allow you to attach custom platform-specific logic to a widget. In your
			 * platform-specific assembly, use {@link Style.Add{H}(string, StyleHandler{H})} to add
			 * the style logic with the same id.
			 */
			Style: string;

			/**
			 * Gets the instance of the platform-specific object
			 *
			 * This can sometimes be useful to get the platform-specific object. Some handlers may
			 * not have any backing object for its functionality, so this may be null.  It is more
			 * preferred to use the {@link Eto.Widget.Handler} and cast that to the platform-specific
			 * handler class which can give you additional methods and helpers to do common tasks.
			 * For example, the {@link Eto.Forms.Application} object's handler for OS X has a
			 * AddFullScreenMenuItem property to specify if you want full screen support in your app.
			 */
			readonly ControlObject: unknown;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Widget} has been disposed.
			 *
			 * When the widget is disposed, it can no longer be used.
			 */
			IsDisposed: boolean;

			/** Removes the specified child from the container */
			Remove(child: Eto.Forms.Control): void;

			/** Remove the specified `controls` from this container */
			Remove(controls: Iterable<Eto.Forms.Control>): void;

			/** Removes all controls from this container */
			RemoveAll(): void;

			/**
			 * Finds a child control in this container or any of its child containers with the
			 * specified `id`
			 */
			FindChild<T>(id?: string): T;

			/**
			 * Finds a child control in this container or any of its child containers with the
			 * specified `type`
			 */
			FindChild(
				type: unknown,
				id?: string,
			): Eto.Forms.Control;

			/**
			 * Finds a child control in this container or any of its child containers with the
			 * specified `id`.
			 */
			FindChild(id: string): Eto.Forms.Control;

			/**
			 * Queues a repaint of the entire control on the screen and any of its children.
			 *
			 * This is only useful when the control is visible.
			 */
			Invalidate(): void;

			/**
			 * Queues a repaint of the entire control on the screen
			 *
			 * This is only useful when the control is visible.
			 */
			Invalidate(invalidateChildren: boolean): void;

			/**
			 * Queues a repaint of the specified `rect` of the control and any children.
			 *
			 * This is only useful when the control is visible.
			 */
			Invalidate(rect: Eto.Drawing.Rectangle): void;

			/**
			 * Queues a repaint of the specified `rect` of the control
			 *
			 * This is only useful when the control is visible.
			 */
			Invalidate(
				rect: Eto.Drawing.Rectangle,
				invalidateChildren: boolean,
			): void;

			/**
			 * Updates the layout of this control if necessary.
			 *
			 * This will ensure the control has had all of its layout applied so you can use its
			 * position and size right after this call. Most platforms (except WinForms) use a
			 * deferred layout system so that after adding your control to the form dynamically it
			 * won't get laid out until the next idle loop. This is useful when you need to know the
			 * dimensions of the control immediately. Note that this can be an expensive operation,
			 * so it is recommended to only call this method when necessary and after all of the
			 * controls have been added/updated.
			 */
			UpdateLayout(): void;

			/** Gets the preferred size of this control given infinite space available. */
			GetPreferredSize(): Eto.Drawing.SizeF;

			/** Gets the preferred size of this control given the specified `availableSize`. */
			GetPreferredSize(availableSize: Eto.Drawing.SizeF): Eto.Drawing.SizeF;

			/**
			 * Captures all mouse events to this control.
			 *
			 * This captures all mouse events until {@link Eto.Forms.Control.ReleaseMouseCapture} is
			 * called.  Note that not all platforms will allow a mouse capture unless the mouse is
			 * currently down.
			 */
			CaptureMouse(): boolean;

			/** Releases the mouse capture after a call to {@link Eto.Forms.Control.CaptureMouse}. */
			ReleaseMouseCapture(): void;

			/**
			 * Finds a control in the parent hierarchy with the specified type and
			 * {@link Eto.Widget.ID} if specified
			 */
			FindParent(
				type: unknown,
				id?: string,
			): Eto.Forms.Container;

			/** Finds a control in the parent hierarchy with the specified `id` */
			FindParent(id: string): Eto.Forms.Container;

			/**
			 * Detaches the control by removing it from its parent
			 *
			 * This is essentially a shortcut to myControl.Parent.Remove(myControl);
			 */
			Detach(): void;

			/**
			 * Attaches the control for direct use in a native application
			 *
			 * Use this to use a control directly in a native application.  Note that the native
			 * application must be running the same framework as the current platform.  E.g. a
			 * WinForms application can use an Eto.Forms control when using the Eto.WinForms
			 * platform.  This prepares the control by firing the {@link Eto.Forms.Control.PreLoad},
			 * {@link Eto.Forms.Control.Load}, etc. events.
			 */
			AttachNative(): void;

			/**
			 * Detaches the control when it is used in a native application, when you want to reuse
			 * the control.
			 *
			 * This should only be called after {@link Eto.Forms.Control.AttachNative} has been
			 * called, which is usually done by calling to ToNative(true) .
			 */
			DetachNative(): void;

			/**
			 * Attempts to set the keyboard input focus to this control, or the first child that
			 * accepts focus. For Windows, this will bring it to front and activate it.
			 */
			Focus(): void;

			/**
			 * Suspends the layout of child controls
			 *
			 * This can be used to optimize some platforms while adding, removing, or changing many
			 * child controls at once. It disables the calculation of control positioning until
			 * {@link Eto.Forms.Control.ResumeLayout} is called. Each call to SuspendLayout() must be
			 * balanced with a call to {@link Eto.Forms.Control.ResumeLayout}.
			 */
			SuspendLayout(): void;

			/**
			 * Resumes the layout after it has been suspended, and performs a layout
			 *
			 * This can be used to optimize some platforms while adding, removing, or changing many
			 * child controls at once. Each call to ResumeLayout() must be balanced with a call to
			 * {@link Eto.Forms.Control.SuspendLayout} before it.
			 */
			ResumeLayout(): void;

			/**
			 * Specifies a command to execute for a platform-specific command
			 *
			 * Some platforms have specific system-defined commands that can be associated with a
			 * control. For example, the Mac platform's cut/copy/paste functionality is defined by
			 * the system, and if you want to hook into it, you can use this to map it to your own
			 * defined logic. The valid values of the `systemCommand` parameter are defined by each
			 * platform, and a list can be retrieved using
			 * {@link Eto.Forms.Control.SupportedPlatformCommands}
			 */
			MapPlatformCommand(
				systemCommand: string,
				command: Eto.Forms.Command,
			): void;

			/** Converts a point from screen space to control space. */
			PointFromScreen(point: Eto.Drawing.PointF): Eto.Drawing.PointF;

			/** Converts a point from control space to screen space */
			PointToScreen(point: Eto.Drawing.PointF): Eto.Drawing.PointF;

			/** Converts a rectangle from screen space to control space. */
			RectangleToScreen(rect: Eto.Drawing.RectangleF): Eto.Drawing.RectangleF;

			/** Converts a rectangle from control space to screen space */
			RectangleFromScreen(rect: Eto.Drawing.RectangleF): Eto.Drawing.RectangleF;

			/**
			 * Starts drag operation using this control as drag source.
			 *
			 * This method can be blocking on some platforms (Wpf, WinForms), and non-blocking on
			 * others (Mac, Gtk). Use the {@link Eto.Forms.Control.DragEnd} event to determine when
			 * the drag operation is completed and get its resulting DragEffects.
			 */
			DoDragDrop(
				data: Eto.Forms.DataObject,
				allowedEffects: Eto.Forms.DragEffects,
			): void;

			/**
			 * Starts drag operation using this control as drag source.
			 *
			 * This method can be blocking on some platforms (Wpf, WinForms), and non-blocking on
			 * others (Mac, Gtk). Use the {@link Eto.Forms.Control.DragEnd} event to determine when
			 * the drag operation is completed and get its resulting DragEffects.
			 */
			DoDragDrop(
				data: Eto.Forms.DataObject,
				allowedEffects: Eto.Forms.DragEffects,
				image: Eto.Drawing.Image,
				cursorOffset: Eto.Drawing.PointF,
			): void;

			/**
			 * Triggers the StyleChanged event and re-applies the styles to this control and its
			 * children.
			 */
			TriggerStyleChanged(): void;

			/** Shows a print dialog to print the specified control */
			Print(): void;

			/**
			 * Finds a control in the parent hierarchy with the specified type and
			 * {@link Eto.Widget.ID} if specified
			 */
			FindParent<T>(id?: string): T;

			/**
			 * Finds a control in the parent hierarchy with the specified type and
			 * {@link Eto.Widget.ID} if specified
			 */
			FindParent(
				type: unknown,
				id?: string,
			): Eto.Widget;

			/** Finds a control in the parent hierarchy with the specified `id` */
			FindParent(id: string): Eto.Widget;

			/**
			 * Unbinds any bindings in the {@link Eto.Forms.BindableWidget.Bindings} collection and
			 * removes the bindings
			 *
			 * When you implement {@link Eto.Forms.IBindableWidgetContainer}, this will also unbind
			 * any of its children.
			 */
			Unbind(): void;

			/**
			 * Updates all bindings in this widget
			 *
			 * When you implement {@link Eto.Forms.IBindableWidgetContainer}, this will also update
			 * bindings for all of its children.
			 */
			UpdateBindings(mode?: Eto.Forms.BindingUpdateMode): void;

			/** Disposes of this widget, supressing the finalizer */
			dispose(): void;

			/** Gets a string that represents the current object with its ID if specified. */
			ToString(): string;
		}
	}

	export namespace Eto.Forms.Expander {
		export interface ICallback extends
			Eto.Forms.Control.ICallback,
			Eto.Widget.ICallback {
			OnExpandedChanged(
				widget: Eto.Forms.Expander,
				e: unknown,
			): void;
		}
	}

	export namespace Eto.Forms.Expander {
		export interface IHandler extends
			Eto.Forms.Panel.IHandler,
			Eto.Forms.Container.IHandler,
			Eto.Forms.Control.IHandler,
			Eto.Widget.IHandler,
			Eto.Forms.IContextMenuHost {
			Expanded: boolean;

			Header: Eto.Forms.Control;
		}
	}

	export namespace Eto.Forms {
		/**
		 * A control that allows the user to interact with files and folders. It can be used to
		 * save files, select files or select directories.
		 */
		export class FilePicker implements
			Eto.IHandlerSource,
			Eto.Forms.IBindable,
			Eto.Forms.IMouseInputSource,
			Eto.Forms.IKeyboardInputSource {
			constructor();

			/**
			 * Gets or sets the index of the current filter in the
			 * {@link Eto.Forms.FilePicker.Filters} collection.
			 */
			CurrentFilterIndex: number;

			/**
			 * Gets or sets the currently selected filter from the
			 * {@link Eto.Forms.FilePicker.Filters} collection. Also updates
			 * {@link Eto.Forms.FilePicker.CurrentFilterIndex} accordingly.
			 *
			 * This can return `null` if either the {@link Eto.Forms.FilePicker.Filters} collection
			 * is `null`, or if the current filter is not in the {@link Eto.Forms.FilePicker.Filters}
			 * collection.
			 */
			CurrentFilter: Eto.Forms.FileFilter;

			/**
			 * Gets the collection of available file filters the user can select from.
			 *
			 * Add entries to this collection to set the filters the user can select when the file
			 * dialog is shown.  Some platforms may either disable (OS X) or hide (GTK/WinForms/WPF)
			 * files that do not match the currently selected filter.
			 */
			readonly Filters: unknown;

			/**
			 * Gets or sets the {@link Eto.Forms.FilePicker.FileAction}, which indicates how the file
			 * picker should behave.
			 */
			FileAction: Eto.FileAction;

			/**
			 * Gets or sets the full path of the file that was selected, or should be selected by
			 * default when opening the picker.
			 */
			FilePath: string;

			/** Gets or sets the title of the dialog that the file picker will show. */
			Title: string;

			/**
			 * Gets a value indicating that the control is loaded onto a form, that is it has been
			 * created, added to a parent, and shown
			 *
			 * The {@link Eto.Forms.Control.OnLoad(System.EventArgs)} method sets this value to true
			 * after cascading to all children (for a {@link Eto.Forms.Container} ) and calling the
			 * platform handler's implementation.  It is called after adding to a loaded form, or
			 * when showing a new form.  The {@link Eto.Forms.Control.OnUnLoad(System.EventArgs)}
			 * method will set this value to false when the control is removed from its parent
			 */
			readonly Loaded: boolean;

			/**
			 * Gets an enumeration of controls that are in the visual tree.
			 *
			 * This is used to specify which controls are contained by this instance that are part of
			 * the visual tree. This should include all controls including non-logical Eto controls
			 * used for layout.
			 */
			readonly VisualControls: Iterable<Eto.Forms.Control>;

			/**
			 * Gets or sets a user-defined object that contains data about the control
			 *
			 * A common use of the tag property is to store data that is associated with the control
			 * that you can later retrieve.
			 */
			Tag: unknown;

			/**
			 * Gets the logical parent control.
			 *
			 * When the control is part of the visual tree (
				 * {@link Eto.Forms.Control.IsVisualControl} is true), this returns the logical parent
				 * that contains this control. Otherwise this is the same as
				 * {@link Eto.Forms.Control.Parent}.
				 */
				readonly LogicalParent: Eto.Forms.Container;

			/** Gets a value indicating this {@link Eto.Forms.Control} is part of the visual tree. */
			IsVisualControl: boolean;

			/**
			 * Gets or sets the size of the control. Use -1 to specify auto sizing for either the
			 * width and/or height.
			 *
			 * Setting the size of controls is entirely optional as most controls will size
			 * themselves appropriately. When specifying a size, it will be used as the desired size
			 * of the control.  The container will reposition and resize the control depending on the
			 * available size.  For a {@link Eto.Forms.Window}, it is preferred to set the
			 * {@link Eto.Forms.Container.ClientSize} instead, as various platforms have different
			 * sizes of window decorations, toolbars, etc.
			 */
			Size: Eto.Drawing.Size;

			/**
			 * Gets a value indicating this control currently has mouse capture
			 *
			 * Mouse capture can happen during a handled MouseDown event until MouseUp, or it can be
			 * captured explicitly via {@link Eto.Forms.Control.CaptureMouse}.
			 */
			readonly IsMouseCaptured: boolean;

			/** Gets or sets the width of the control size. */
			Width: number;

			/** Gets or sets the height of the control size. */
			Height: number;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Forms.Control} (or its
			 * children) are enabled and accept user input.
			 *
			 * Typically when a control is disabled, the user cannot do anything with the control or
			 * any of its children. Including for example, selecting text in a text control. Certain
			 * controls can have a 'Read Only' mode, such as {@link Eto.Forms.TextBox.ReadOnly} which
			 * allow the user to  select text, but not change its contents.
			 */
			Enabled: boolean;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Forms.Control} is visible to
			 * the user.
			 *
			 * When the visibility of a control is set to false, it will not occupy space in the
			 * layout.
			 */
			Visible: boolean;

			/** Gets the container which this control has been added to, if any */
			readonly Parent: Eto.Forms.Container;

			/**
			 * Gets the visual container of this control, if any.
			 *
			 * Some containers may use other Eto controls to layout its children, such as the
			 * {@link Eto.Forms.StackLayout}. This will return the parent control that visually
			 * contains this control as opposed to {@link Eto.Forms.Control.Parent} which will return
			 * the logical parent.
			 */
			VisualParent: Eto.Forms.Container;

			/** Gets a value indicating this control has been attached to a native container */
			readonly IsAttached: boolean;

			/**
			 * Gets or sets the color for the background of the control
			 *
			 * Note that on some platforms (e.g. Mac), setting the background color of a control can
			 * change the performance characteristics of the control and its children, since it must
			 * enable layers to do so.
			 */
			BackgroundColor: Eto.Drawing.Color;

			/** Gets a value indicating whether this instance has the keyboard input focus. */
			readonly HasFocus: boolean;

			/** Gets a value indicating whether the layout of child controls is suspended. */
			readonly IsSuspended: boolean;

			/** Gets the window this control is contained in */
			readonly ParentWindow: Eto.Forms.Window;

			/**
			 * Gets the supported platform commands that can be used to hook up system functions to
			 * user defined logic
			 *
			 * This lists all available commands that can be mapped using the
			 * {@link Eto.Forms.Control.MapPlatformCommand(System.String,Eto.Forms.Command)} method
			 * of the control.
			 */
			readonly SupportedPlatformCommands: Iterable<string>;

			/** Gets the bounding rectangle of this control relative to its container */
			readonly Bounds: Eto.Drawing.Rectangle;

			/**
			 * Gets the location of the control as positioned by the container
			 *
			 * A control's location is set by the container. This can be used to determine where the
			 * control is for overlaying floating windows, menus, etc.
			 */
			readonly Location: Eto.Drawing.Point;

			/** Gets or sets the type of cursor to use when the mouse is hovering over the control */
			Cursor: Eto.Forms.Cursor;

			/** Gets or sets the tool tip to show when the mouse is hovered over the control */
			ToolTip: string;

			/**
			 * Gets or sets the tab index order for this control within its container.
			 *
			 * This sets the order when using the tab key to cycle through controls  Note that some
			 * platforms (Gtk and WinForms) may not support setting the context of the tab order to
			 * StackLayout  or DynamicLayout containers and may not behave exactly as expected. Use
			 * the {@link Eto.PlatformFeatures.TabIndexWithCustomContainers} flag to determine if it
			 * is supported.
			 */
			TabIndex: number;

			/** Gets or sets a value indicating whether this control can serve as drop target. */
			AllowDrop: boolean;

			/**
			 * Gets or sets the parent widget which this widget has been added to, if any
			 *
			 * When implementing child widgets that can participate in the context based binding
			 * (MVVM), You can set this to the parent widget when it is added or removed to it
			 * (usually via a collection).  Note that you should typically provide a public new
			 * [ParentWidget] Parent { get; } property  so that consumers of your API cannot set the
			 * parent to an invalid value.
			 */
			Parent: Eto.Widget;

			/**
			 * Gets an enumeration of all parent widgets in the heirarchy by traversing the
			 * {@link Eto.Forms.BindableWidget.Parent} property.
			 */
			readonly Parents: Iterable<Eto.Widget>;

			/**
			 * Gets or sets the data context for this widget for binding
			 *
			 * Subclasses may override the standard behaviour so that hierarchy of widgets can be
			 * taken into account.  For example, a Control may return the data context of a parent,
			 * if it is not set explicitly.
			 */
			DataContext: unknown;

			/** Gets the collection of bindings that are attached to this widget */
			readonly Bindings: Eto.Forms.BindingCollection;

			/**
			 * Gets a value indicating that the {@link Eto.Forms.BindableWidget.DataContext} property
			 * is changing.
			 *
			 * This can be used to determine when to allow certain logic during the update of the
			 * data context.  It is used to disable binding setters on the model when the data
			 * context changes so that a binding does not cause the view model to be updated when the
			 * state hasn't been fully set yet.
			 */
			IsDataContextChanging: boolean;

			/**
			 * Gets the platform that was used to create the {@link Eto.Widget.Handler} for this
			 * widget
			 *
			 * This gets set to the current {@link Eto.Platform.Instance} during the construction of
			 * the object
			 */
			readonly Platform: Eto.Platform;

			/** Gets the platform-specific handler for this widget */
			Handler: unknown;

			/** Gets the native platform-specific handle for integration purposes */
			readonly NativeHandle: unknown;

			/** Gets the dictionary of properties for this widget */
			readonly Properties: Eto.PropertyStore;

			/** Gets or sets the ID of this widget */
			ID: string;

			/**
			 * Gets or sets the style of this widget
			 *
			 * Styles allow you to attach custom platform-specific logic to a widget. In your
			 * platform-specific assembly, use {@link Style.Add{H}(string, StyleHandler{H})} to add
			 * the style logic with the same id.
			 */
			Style: string;

			/**
			 * Gets the instance of the platform-specific object
			 *
			 * This can sometimes be useful to get the platform-specific object. Some handlers may
			 * not have any backing object for its functionality, so this may be null.  It is more
			 * preferred to use the {@link Eto.Widget.Handler} and cast that to the platform-specific
			 * handler class which can give you additional methods and helpers to do common tasks.
			 * For example, the {@link Eto.Forms.Application} object's handler for OS X has a
			 * AddFullScreenMenuItem property to specify if you want full screen support in your app.
			 */
			readonly ControlObject: unknown;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Widget} has been disposed.
			 *
			 * When the widget is disposed, it can no longer be used.
			 */
			IsDisposed: boolean;

			/**
			 * Queues a repaint of the entire control on the screen and any of its children.
			 *
			 * This is only useful when the control is visible.
			 */
			Invalidate(): void;

			/**
			 * Queues a repaint of the entire control on the screen
			 *
			 * This is only useful when the control is visible.
			 */
			Invalidate(invalidateChildren: boolean): void;

			/**
			 * Queues a repaint of the specified `rect` of the control and any children.
			 *
			 * This is only useful when the control is visible.
			 */
			Invalidate(rect: Eto.Drawing.Rectangle): void;

			/**
			 * Queues a repaint of the specified `rect` of the control
			 *
			 * This is only useful when the control is visible.
			 */
			Invalidate(
				rect: Eto.Drawing.Rectangle,
				invalidateChildren: boolean,
			): void;

			/**
			 * Updates the layout of this control if necessary.
			 *
			 * This will ensure the control has had all of its layout applied so you can use its
			 * position and size right after this call. Most platforms (except WinForms) use a
			 * deferred layout system so that after adding your control to the form dynamically it
			 * won't get laid out until the next idle loop. This is useful when you need to know the
			 * dimensions of the control immediately. Note that this can be an expensive operation,
			 * so it is recommended to only call this method when necessary and after all of the
			 * controls have been added/updated.
			 */
			UpdateLayout(): void;

			/** Gets the preferred size of this control given infinite space available. */
			GetPreferredSize(): Eto.Drawing.SizeF;

			/** Gets the preferred size of this control given the specified `availableSize`. */
			GetPreferredSize(availableSize: Eto.Drawing.SizeF): Eto.Drawing.SizeF;

			/**
			 * Captures all mouse events to this control.
			 *
			 * This captures all mouse events until {@link Eto.Forms.Control.ReleaseMouseCapture} is
			 * called.  Note that not all platforms will allow a mouse capture unless the mouse is
			 * currently down.
			 */
			CaptureMouse(): boolean;

			/** Releases the mouse capture after a call to {@link Eto.Forms.Control.CaptureMouse}. */
			ReleaseMouseCapture(): void;

			/**
			 * Finds a control in the parent hierarchy with the specified type and
			 * {@link Eto.Widget.ID} if specified
			 */
			FindParent(
				type: unknown,
				id?: string,
			): Eto.Forms.Container;

			/** Finds a control in the parent hierarchy with the specified `id` */
			FindParent(id: string): Eto.Forms.Container;

			/**
			 * Detaches the control by removing it from its parent
			 *
			 * This is essentially a shortcut to myControl.Parent.Remove(myControl);
			 */
			Detach(): void;

			/**
			 * Attaches the control for direct use in a native application
			 *
			 * Use this to use a control directly in a native application.  Note that the native
			 * application must be running the same framework as the current platform.  E.g. a
			 * WinForms application can use an Eto.Forms control when using the Eto.WinForms
			 * platform.  This prepares the control by firing the {@link Eto.Forms.Control.PreLoad},
			 * {@link Eto.Forms.Control.Load}, etc. events.
			 */
			AttachNative(): void;

			/**
			 * Detaches the control when it is used in a native application, when you want to reuse
			 * the control.
			 *
			 * This should only be called after {@link Eto.Forms.Control.AttachNative} has been
			 * called, which is usually done by calling to ToNative(true) .
			 */
			DetachNative(): void;

			/**
			 * Attempts to set the keyboard input focus to this control, or the first child that
			 * accepts focus. For Windows, this will bring it to front and activate it.
			 */
			Focus(): void;

			/**
			 * Suspends the layout of child controls
			 *
			 * This can be used to optimize some platforms while adding, removing, or changing many
			 * child controls at once. It disables the calculation of control positioning until
			 * {@link Eto.Forms.Control.ResumeLayout} is called. Each call to SuspendLayout() must be
			 * balanced with a call to {@link Eto.Forms.Control.ResumeLayout}.
			 */
			SuspendLayout(): void;

			/**
			 * Resumes the layout after it has been suspended, and performs a layout
			 *
			 * This can be used to optimize some platforms while adding, removing, or changing many
			 * child controls at once. Each call to ResumeLayout() must be balanced with a call to
			 * {@link Eto.Forms.Control.SuspendLayout} before it.
			 */
			ResumeLayout(): void;

			/**
			 * Specifies a command to execute for a platform-specific command
			 *
			 * Some platforms have specific system-defined commands that can be associated with a
			 * control. For example, the Mac platform's cut/copy/paste functionality is defined by
			 * the system, and if you want to hook into it, you can use this to map it to your own
			 * defined logic. The valid values of the `systemCommand` parameter are defined by each
			 * platform, and a list can be retrieved using
			 * {@link Eto.Forms.Control.SupportedPlatformCommands}
			 */
			MapPlatformCommand(
				systemCommand: string,
				command: Eto.Forms.Command,
			): void;

			/** Converts a point from screen space to control space. */
			PointFromScreen(point: Eto.Drawing.PointF): Eto.Drawing.PointF;

			/** Converts a point from control space to screen space */
			PointToScreen(point: Eto.Drawing.PointF): Eto.Drawing.PointF;

			/** Converts a rectangle from screen space to control space. */
			RectangleToScreen(rect: Eto.Drawing.RectangleF): Eto.Drawing.RectangleF;

			/** Converts a rectangle from control space to screen space */
			RectangleFromScreen(rect: Eto.Drawing.RectangleF): Eto.Drawing.RectangleF;

			/**
			 * Starts drag operation using this control as drag source.
			 *
			 * This method can be blocking on some platforms (Wpf, WinForms), and non-blocking on
			 * others (Mac, Gtk). Use the {@link Eto.Forms.Control.DragEnd} event to determine when
			 * the drag operation is completed and get its resulting DragEffects.
			 */
			DoDragDrop(
				data: Eto.Forms.DataObject,
				allowedEffects: Eto.Forms.DragEffects,
			): void;

			/**
			 * Starts drag operation using this control as drag source.
			 *
			 * This method can be blocking on some platforms (Wpf, WinForms), and non-blocking on
			 * others (Mac, Gtk). Use the {@link Eto.Forms.Control.DragEnd} event to determine when
			 * the drag operation is completed and get its resulting DragEffects.
			 */
			DoDragDrop(
				data: Eto.Forms.DataObject,
				allowedEffects: Eto.Forms.DragEffects,
				image: Eto.Drawing.Image,
				cursorOffset: Eto.Drawing.PointF,
			): void;

			/**
			 * Triggers the StyleChanged event and re-applies the styles to this control and its
			 * children.
			 */
			TriggerStyleChanged(): void;

			/** Shows a print dialog to print the specified control */
			Print(): void;

			/**
			 * Finds a control in the parent hierarchy with the specified type and
			 * {@link Eto.Widget.ID} if specified
			 */
			FindParent<T>(id?: string): T;

			/**
			 * Finds a control in the parent hierarchy with the specified type and
			 * {@link Eto.Widget.ID} if specified
			 */
			FindParent(
				type: unknown,
				id?: string,
			): Eto.Widget;

			/** Finds a control in the parent hierarchy with the specified `id` */
			FindParent(id: string): Eto.Widget;

			/**
			 * Unbinds any bindings in the {@link Eto.Forms.BindableWidget.Bindings} collection and
			 * removes the bindings
			 *
			 * When you implement {@link Eto.Forms.IBindableWidgetContainer}, this will also unbind
			 * any of its children.
			 */
			Unbind(): void;

			/**
			 * Updates all bindings in this widget
			 *
			 * When you implement {@link Eto.Forms.IBindableWidgetContainer}, this will also update
			 * bindings for all of its children.
			 */
			UpdateBindings(mode?: Eto.Forms.BindingUpdateMode): void;

			/** Disposes of this widget, supressing the finalizer */
			dispose(): void;

			/** Gets a string that represents the current object with its ID if specified. */
			ToString(): string;
		}
	}

	export namespace Eto.Forms.FilePicker {
		export interface IHandler extends
			Eto.Forms.Control.IHandler,
			Eto.Widget.IHandler {
			FileAction: Eto.FileAction;

			FilePath: string;

			CurrentFilterIndex: number;

			Title: string;

			ClearFilters(): void;

			InsertFilter(
				index: number,
				filter: Eto.Forms.FileFilter,
			): void;

			RemoveFilter(index: number): void;
		}
	}

	export namespace Eto.Forms.FilePicker {
		export interface ICallback extends
			Eto.Forms.Control.ICallback,
			Eto.Widget.ICallback {
			OnFilePathChanged(
				widget: Eto.Forms.FilePicker,
				e: unknown,
			): void;
		}
	}

	export namespace Eto.Forms {
		/** Control to show and pick a font. */
		export class FontPicker implements
			Eto.IHandlerSource,
			Eto.Forms.IBindable,
			Eto.Forms.IMouseInputSource,
			Eto.Forms.IKeyboardInputSource {
			/** Initializes a new instance of the {@link Eto.Forms.FontPicker} class. */
			constructor();

			/** Initializes a new instance of the {@link Eto.Forms.FontPicker} class. */
			constructor(font: Eto.Drawing.Font);

			/** Gets or sets the currently selected font. */
			Value: Eto.Drawing.Font;

			/** Gets a new binding for the {@link Eto.Forms.FontPicker.Value} property. */
			readonly ValueBinding: Eto.Forms.BindableBinding$2<Eto.Forms.FontPicker, Eto.Drawing.Font>;

			/**
			 * Gets a value indicating that the control is loaded onto a form, that is it has been
			 * created, added to a parent, and shown
			 *
			 * The {@link Eto.Forms.Control.OnLoad(System.EventArgs)} method sets this value to true
			 * after cascading to all children (for a {@link Eto.Forms.Container} ) and calling the
			 * platform handler's implementation.  It is called after adding to a loaded form, or
			 * when showing a new form.  The {@link Eto.Forms.Control.OnUnLoad(System.EventArgs)}
			 * method will set this value to false when the control is removed from its parent
			 */
			readonly Loaded: boolean;

			/**
			 * Gets an enumeration of controls that are in the visual tree.
			 *
			 * This is used to specify which controls are contained by this instance that are part of
			 * the visual tree. This should include all controls including non-logical Eto controls
			 * used for layout.
			 */
			readonly VisualControls: Iterable<Eto.Forms.Control>;

			/**
			 * Gets or sets a user-defined object that contains data about the control
			 *
			 * A common use of the tag property is to store data that is associated with the control
			 * that you can later retrieve.
			 */
			Tag: unknown;

			/**
			 * Gets the logical parent control.
			 *
			 * When the control is part of the visual tree (
				 * {@link Eto.Forms.Control.IsVisualControl} is true), this returns the logical parent
				 * that contains this control. Otherwise this is the same as
				 * {@link Eto.Forms.Control.Parent}.
				 */
				readonly LogicalParent: Eto.Forms.Container;

			/** Gets a value indicating this {@link Eto.Forms.Control} is part of the visual tree. */
			IsVisualControl: boolean;

			/**
			 * Gets or sets the size of the control. Use -1 to specify auto sizing for either the
			 * width and/or height.
			 *
			 * Setting the size of controls is entirely optional as most controls will size
			 * themselves appropriately. When specifying a size, it will be used as the desired size
			 * of the control.  The container will reposition and resize the control depending on the
			 * available size.  For a {@link Eto.Forms.Window}, it is preferred to set the
			 * {@link Eto.Forms.Container.ClientSize} instead, as various platforms have different
			 * sizes of window decorations, toolbars, etc.
			 */
			Size: Eto.Drawing.Size;

			/**
			 * Gets a value indicating this control currently has mouse capture
			 *
			 * Mouse capture can happen during a handled MouseDown event until MouseUp, or it can be
			 * captured explicitly via {@link Eto.Forms.Control.CaptureMouse}.
			 */
			readonly IsMouseCaptured: boolean;

			/** Gets or sets the width of the control size. */
			Width: number;

			/** Gets or sets the height of the control size. */
			Height: number;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Forms.Control} (or its
			 * children) are enabled and accept user input.
			 *
			 * Typically when a control is disabled, the user cannot do anything with the control or
			 * any of its children. Including for example, selecting text in a text control. Certain
			 * controls can have a 'Read Only' mode, such as {@link Eto.Forms.TextBox.ReadOnly} which
			 * allow the user to  select text, but not change its contents.
			 */
			Enabled: boolean;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Forms.Control} is visible to
			 * the user.
			 *
			 * When the visibility of a control is set to false, it will not occupy space in the
			 * layout.
			 */
			Visible: boolean;

			/** Gets the container which this control has been added to, if any */
			readonly Parent: Eto.Forms.Container;

			/**
			 * Gets the visual container of this control, if any.
			 *
			 * Some containers may use other Eto controls to layout its children, such as the
			 * {@link Eto.Forms.StackLayout}. This will return the parent control that visually
			 * contains this control as opposed to {@link Eto.Forms.Control.Parent} which will return
			 * the logical parent.
			 */
			VisualParent: Eto.Forms.Container;

			/** Gets a value indicating this control has been attached to a native container */
			readonly IsAttached: boolean;

			/**
			 * Gets or sets the color for the background of the control
			 *
			 * Note that on some platforms (e.g. Mac), setting the background color of a control can
			 * change the performance characteristics of the control and its children, since it must
			 * enable layers to do so.
			 */
			BackgroundColor: Eto.Drawing.Color;

			/** Gets a value indicating whether this instance has the keyboard input focus. */
			readonly HasFocus: boolean;

			/** Gets a value indicating whether the layout of child controls is suspended. */
			readonly IsSuspended: boolean;

			/** Gets the window this control is contained in */
			readonly ParentWindow: Eto.Forms.Window;

			/**
			 * Gets the supported platform commands that can be used to hook up system functions to
			 * user defined logic
			 *
			 * This lists all available commands that can be mapped using the
			 * {@link Eto.Forms.Control.MapPlatformCommand(System.String,Eto.Forms.Command)} method
			 * of the control.
			 */
			readonly SupportedPlatformCommands: Iterable<string>;

			/** Gets the bounding rectangle of this control relative to its container */
			readonly Bounds: Eto.Drawing.Rectangle;

			/**
			 * Gets the location of the control as positioned by the container
			 *
			 * A control's location is set by the container. This can be used to determine where the
			 * control is for overlaying floating windows, menus, etc.
			 */
			readonly Location: Eto.Drawing.Point;

			/** Gets or sets the type of cursor to use when the mouse is hovering over the control */
			Cursor: Eto.Forms.Cursor;

			/** Gets or sets the tool tip to show when the mouse is hovered over the control */
			ToolTip: string;

			/**
			 * Gets or sets the tab index order for this control within its container.
			 *
			 * This sets the order when using the tab key to cycle through controls  Note that some
			 * platforms (Gtk and WinForms) may not support setting the context of the tab order to
			 * StackLayout  or DynamicLayout containers and may not behave exactly as expected. Use
			 * the {@link Eto.PlatformFeatures.TabIndexWithCustomContainers} flag to determine if it
			 * is supported.
			 */
			TabIndex: number;

			/** Gets or sets a value indicating whether this control can serve as drop target. */
			AllowDrop: boolean;

			/**
			 * Gets or sets the parent widget which this widget has been added to, if any
			 *
			 * When implementing child widgets that can participate in the context based binding
			 * (MVVM), You can set this to the parent widget when it is added or removed to it
			 * (usually via a collection).  Note that you should typically provide a public new
			 * [ParentWidget] Parent { get; } property  so that consumers of your API cannot set the
			 * parent to an invalid value.
			 */
			Parent: Eto.Widget;

			/**
			 * Gets an enumeration of all parent widgets in the heirarchy by traversing the
			 * {@link Eto.Forms.BindableWidget.Parent} property.
			 */
			readonly Parents: Iterable<Eto.Widget>;

			/**
			 * Gets or sets the data context for this widget for binding
			 *
			 * Subclasses may override the standard behaviour so that hierarchy of widgets can be
			 * taken into account.  For example, a Control may return the data context of a parent,
			 * if it is not set explicitly.
			 */
			DataContext: unknown;

			/** Gets the collection of bindings that are attached to this widget */
			readonly Bindings: Eto.Forms.BindingCollection;

			/**
			 * Gets a value indicating that the {@link Eto.Forms.BindableWidget.DataContext} property
			 * is changing.
			 *
			 * This can be used to determine when to allow certain logic during the update of the
			 * data context.  It is used to disable binding setters on the model when the data
			 * context changes so that a binding does not cause the view model to be updated when the
			 * state hasn't been fully set yet.
			 */
			IsDataContextChanging: boolean;

			/**
			 * Gets the platform that was used to create the {@link Eto.Widget.Handler} for this
			 * widget
			 *
			 * This gets set to the current {@link Eto.Platform.Instance} during the construction of
			 * the object
			 */
			readonly Platform: Eto.Platform;

			/** Gets the platform-specific handler for this widget */
			Handler: unknown;

			/** Gets the native platform-specific handle for integration purposes */
			readonly NativeHandle: unknown;

			/** Gets the dictionary of properties for this widget */
			readonly Properties: Eto.PropertyStore;

			/** Gets or sets the ID of this widget */
			ID: string;

			/**
			 * Gets or sets the style of this widget
			 *
			 * Styles allow you to attach custom platform-specific logic to a widget. In your
			 * platform-specific assembly, use {@link Style.Add{H}(string, StyleHandler{H})} to add
			 * the style logic with the same id.
			 */
			Style: string;

			/**
			 * Gets the instance of the platform-specific object
			 *
			 * This can sometimes be useful to get the platform-specific object. Some handlers may
			 * not have any backing object for its functionality, so this may be null.  It is more
			 * preferred to use the {@link Eto.Widget.Handler} and cast that to the platform-specific
			 * handler class which can give you additional methods and helpers to do common tasks.
			 * For example, the {@link Eto.Forms.Application} object's handler for OS X has a
			 * AddFullScreenMenuItem property to specify if you want full screen support in your app.
			 */
			readonly ControlObject: unknown;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Widget} has been disposed.
			 *
			 * When the widget is disposed, it can no longer be used.
			 */
			IsDisposed: boolean;

			/**
			 * Queues a repaint of the entire control on the screen and any of its children.
			 *
			 * This is only useful when the control is visible.
			 */
			Invalidate(): void;

			/**
			 * Queues a repaint of the entire control on the screen
			 *
			 * This is only useful when the control is visible.
			 */
			Invalidate(invalidateChildren: boolean): void;

			/**
			 * Queues a repaint of the specified `rect` of the control and any children.
			 *
			 * This is only useful when the control is visible.
			 */
			Invalidate(rect: Eto.Drawing.Rectangle): void;

			/**
			 * Queues a repaint of the specified `rect` of the control
			 *
			 * This is only useful when the control is visible.
			 */
			Invalidate(
				rect: Eto.Drawing.Rectangle,
				invalidateChildren: boolean,
			): void;

			/**
			 * Updates the layout of this control if necessary.
			 *
			 * This will ensure the control has had all of its layout applied so you can use its
			 * position and size right after this call. Most platforms (except WinForms) use a
			 * deferred layout system so that after adding your control to the form dynamically it
			 * won't get laid out until the next idle loop. This is useful when you need to know the
			 * dimensions of the control immediately. Note that this can be an expensive operation,
			 * so it is recommended to only call this method when necessary and after all of the
			 * controls have been added/updated.
			 */
			UpdateLayout(): void;

			/** Gets the preferred size of this control given infinite space available. */
			GetPreferredSize(): Eto.Drawing.SizeF;

			/** Gets the preferred size of this control given the specified `availableSize`. */
			GetPreferredSize(availableSize: Eto.Drawing.SizeF): Eto.Drawing.SizeF;

			/**
			 * Captures all mouse events to this control.
			 *
			 * This captures all mouse events until {@link Eto.Forms.Control.ReleaseMouseCapture} is
			 * called.  Note that not all platforms will allow a mouse capture unless the mouse is
			 * currently down.
			 */
			CaptureMouse(): boolean;

			/** Releases the mouse capture after a call to {@link Eto.Forms.Control.CaptureMouse}. */
			ReleaseMouseCapture(): void;

			/**
			 * Finds a control in the parent hierarchy with the specified type and
			 * {@link Eto.Widget.ID} if specified
			 */
			FindParent(
				type: unknown,
				id?: string,
			): Eto.Forms.Container;

			/** Finds a control in the parent hierarchy with the specified `id` */
			FindParent(id: string): Eto.Forms.Container;

			/**
			 * Detaches the control by removing it from its parent
			 *
			 * This is essentially a shortcut to myControl.Parent.Remove(myControl);
			 */
			Detach(): void;

			/**
			 * Attaches the control for direct use in a native application
			 *
			 * Use this to use a control directly in a native application.  Note that the native
			 * application must be running the same framework as the current platform.  E.g. a
			 * WinForms application can use an Eto.Forms control when using the Eto.WinForms
			 * platform.  This prepares the control by firing the {@link Eto.Forms.Control.PreLoad},
			 * {@link Eto.Forms.Control.Load}, etc. events.
			 */
			AttachNative(): void;

			/**
			 * Detaches the control when it is used in a native application, when you want to reuse
			 * the control.
			 *
			 * This should only be called after {@link Eto.Forms.Control.AttachNative} has been
			 * called, which is usually done by calling to ToNative(true) .
			 */
			DetachNative(): void;

			/**
			 * Attempts to set the keyboard input focus to this control, or the first child that
			 * accepts focus. For Windows, this will bring it to front and activate it.
			 */
			Focus(): void;

			/**
			 * Suspends the layout of child controls
			 *
			 * This can be used to optimize some platforms while adding, removing, or changing many
			 * child controls at once. It disables the calculation of control positioning until
			 * {@link Eto.Forms.Control.ResumeLayout} is called. Each call to SuspendLayout() must be
			 * balanced with a call to {@link Eto.Forms.Control.ResumeLayout}.
			 */
			SuspendLayout(): void;

			/**
			 * Resumes the layout after it has been suspended, and performs a layout
			 *
			 * This can be used to optimize some platforms while adding, removing, or changing many
			 * child controls at once. Each call to ResumeLayout() must be balanced with a call to
			 * {@link Eto.Forms.Control.SuspendLayout} before it.
			 */
			ResumeLayout(): void;

			/**
			 * Specifies a command to execute for a platform-specific command
			 *
			 * Some platforms have specific system-defined commands that can be associated with a
			 * control. For example, the Mac platform's cut/copy/paste functionality is defined by
			 * the system, and if you want to hook into it, you can use this to map it to your own
			 * defined logic. The valid values of the `systemCommand` parameter are defined by each
			 * platform, and a list can be retrieved using
			 * {@link Eto.Forms.Control.SupportedPlatformCommands}
			 */
			MapPlatformCommand(
				systemCommand: string,
				command: Eto.Forms.Command,
			): void;

			/** Converts a point from screen space to control space. */
			PointFromScreen(point: Eto.Drawing.PointF): Eto.Drawing.PointF;

			/** Converts a point from control space to screen space */
			PointToScreen(point: Eto.Drawing.PointF): Eto.Drawing.PointF;

			/** Converts a rectangle from screen space to control space. */
			RectangleToScreen(rect: Eto.Drawing.RectangleF): Eto.Drawing.RectangleF;

			/** Converts a rectangle from control space to screen space */
			RectangleFromScreen(rect: Eto.Drawing.RectangleF): Eto.Drawing.RectangleF;

			/**
			 * Starts drag operation using this control as drag source.
			 *
			 * This method can be blocking on some platforms (Wpf, WinForms), and non-blocking on
			 * others (Mac, Gtk). Use the {@link Eto.Forms.Control.DragEnd} event to determine when
			 * the drag operation is completed and get its resulting DragEffects.
			 */
			DoDragDrop(
				data: Eto.Forms.DataObject,
				allowedEffects: Eto.Forms.DragEffects,
			): void;

			/**
			 * Starts drag operation using this control as drag source.
			 *
			 * This method can be blocking on some platforms (Wpf, WinForms), and non-blocking on
			 * others (Mac, Gtk). Use the {@link Eto.Forms.Control.DragEnd} event to determine when
			 * the drag operation is completed and get its resulting DragEffects.
			 */
			DoDragDrop(
				data: Eto.Forms.DataObject,
				allowedEffects: Eto.Forms.DragEffects,
				image: Eto.Drawing.Image,
				cursorOffset: Eto.Drawing.PointF,
			): void;

			/**
			 * Triggers the StyleChanged event and re-applies the styles to this control and its
			 * children.
			 */
			TriggerStyleChanged(): void;

			/** Shows a print dialog to print the specified control */
			Print(): void;

			/**
			 * Finds a control in the parent hierarchy with the specified type and
			 * {@link Eto.Widget.ID} if specified
			 */
			FindParent<T>(id?: string): T;

			/**
			 * Finds a control in the parent hierarchy with the specified type and
			 * {@link Eto.Widget.ID} if specified
			 */
			FindParent(
				type: unknown,
				id?: string,
			): Eto.Widget;

			/** Finds a control in the parent hierarchy with the specified `id` */
			FindParent(id: string): Eto.Widget;

			/**
			 * Unbinds any bindings in the {@link Eto.Forms.BindableWidget.Bindings} collection and
			 * removes the bindings
			 *
			 * When you implement {@link Eto.Forms.IBindableWidgetContainer}, this will also unbind
			 * any of its children.
			 */
			Unbind(): void;

			/**
			 * Updates all bindings in this widget
			 *
			 * When you implement {@link Eto.Forms.IBindableWidgetContainer}, this will also update
			 * bindings for all of its children.
			 */
			UpdateBindings(mode?: Eto.Forms.BindingUpdateMode): void;

			/** Disposes of this widget, supressing the finalizer */
			dispose(): void;

			/** Gets a string that represents the current object with its ID if specified. */
			ToString(): string;
		}
	}

	export namespace Eto.Forms.FontPicker {
		export interface IHandler extends
			Eto.Forms.Control.IHandler,
			Eto.Widget.IHandler {
			Value: Eto.Drawing.Font;
		}
	}

	export namespace Eto.Forms.FontPicker {
		export interface ICallback extends
			Eto.Forms.Control.ICallback,
			Eto.Widget.ICallback {
			OnValueChanged(
				widget: Eto.Forms.FontPicker,
				e: unknown,
			): void;
		}
	}

	export namespace Eto.Forms {
		/** Event arguments for {@link Eto.Forms.Grid} events relating to a specific column */
		export class GridColumnEventArgs {
			/** Initializes a new instance of the {@link Eto.Forms.GridColumnEventArgs} class. */
			constructor(column: Eto.Forms.GridColumn);

			/** Gets the column that originated the event */
			Column: Eto.Forms.GridColumn;
		}
	}

	export namespace Eto.Forms {
		/**
		 * Event arguments for cell-based events of a {@link Eto.Forms.Grid} triggered by the
		 * mouse.
		 */
		export class GridCellMouseEventArgs {
			/** Initializes a new instance of the GridCellMouseEventArgs class. */
			constructor(
				gridColumn: Eto.Forms.GridColumn,
				row: number,
				column: number,
				item: unknown,
				buttons: Eto.Forms.MouseButtons,
				modifiers: Eto.Forms.Keys,
				location: Eto.Drawing.PointF,
				delta?: Eto.Drawing.SizeF,
				pressure?: number,
			);

			/** Gets the grid column that triggered the event. */
			GridColumn: Eto.Forms.GridColumn;

			/** Gets the row that triggered the event, or -1 if no row. */
			Row: number;

			/** Gets the index of the column that triggered the event, or -1 if no column. */
			Column: number;

			/** Gets the item of the row that triggered the event, or null if there was no item. */
			Item: unknown;

			/**
			 * Gets the key modifiers such as {@link Eto.Forms.Keys.Control},
			 * {@link Eto.Forms.Keys.Alt}, or {@link Eto.Forms.Keys.Shift}.
			 */
			readonly Modifiers: Eto.Forms.Keys;

			/** Gets the mouse buttons involved in the event. */
			readonly Buttons: Eto.Forms.MouseButtons;

			/** Gets the location of the mouse relative to the control that raised the event. */
			readonly Location: Eto.Drawing.PointF;

			/**
			 * Gets or sets a value indicating whether the event is handled.
			 *
			 * Set this to true if you perform logic with the event and wish the default event to be
			 * cancelled. Some platforms may cause audio feedback if the user's action does not
			 * perform anything.
			 */
			Handled: boolean;

			/**
			 * Gets or sets the pressure of the mouse/stylus press, if applicable. 1.0 if full
			 * pressure or not supported.
			 */
			readonly Pressure: number;

			/** Gets or sets the delta change of the scroll wheel for the event. */
			readonly Delta: Eto.Drawing.SizeF;
		}
	}

	export namespace Eto.Forms {
		/**
		 * Enumeration for the type of grid lines to show around each column/row in a
		 * {@link Eto.Forms.Grid}
		 */
		export enum GridLines {
			/** No grid lines shown */
			None = 0,

			/** A horizontal line is shown between each row */
			Horizontal = 1,

			/** A vertical line is shown between each column */
			Vertical = 2,

			/** Shows both vertical and horizontal lines between each column/row */
			Both = 3,
		}
	}

	export namespace Eto.Forms {
		/** Event arguments to format a cell in a {@link Eto.Forms.Grid} */
		export class GridCellFormatEventArgs {
			/** Gets the column to format */
			Column: Eto.Forms.GridColumn;

			/** Gets the item that is associated with the row being formatted */
			Item: unknown;

			/** Gets the row number in the data source */
			readonly Row: number;

			/** Gets or sets the font to use for the cell, or null to use the default font */
			Font: Eto.Drawing.Font;

			/** Gets or sets the background color for the cell */
			BackgroundColor: Eto.Drawing.Color;

			/** Gets or sets the foreground color for the cell contents */
			ForegroundColor: Eto.Drawing.Color;
		}
	}

	export namespace Eto.Forms {
		/**
		 * Event arguments for formatting a row in a {@link Eto.Forms.Grid} using the
		 * {@link Eto.Forms.Grid.RowFormatting} event.
		 */
		export class GridRowFormatEventArgs {
			/** Initializes a new instance of the GridRowFormatEventArgs class. */
			constructor(
				item: unknown,
				row: number,
			);

			/** Gets or sets the background color for the cell */
			BackgroundColor: Eto.Drawing.Color;

			/** Gets the item that is associated with the row being formatted */
			readonly Item: unknown;

			/** Gets the row number in the data source */
			readonly Row: number;
		}
	}

	export namespace Eto.Forms {
		/** Base grid control to display items in columns and rows */
		export class Grid implements
			Eto.IHandlerSource,
			Eto.Forms.IBindable,
			Eto.Forms.IMouseInputSource,
			Eto.Forms.IKeyboardInputSource,
			Eto.Forms.ISelectable$1<unknown> {
			/** Gets the collection of columns to display in the grid */
			readonly Columns: Eto.Forms.GridColumnCollection;

			/** Gets or sets a value indicating that the header should be shown */
			ShowHeader: boolean;

			/** Gets or sets a value indicating whether the user can re-order columns */
			AllowColumnReordering: boolean;

			/** Gets or sets a value indicating whether the user can select multiple rows */
			AllowMultipleSelection: boolean;

			/** Gets an enumeration of the currently selected items */
			readonly SelectedItems: Iterable<unknown>;

			/**
			 * If there is exactly one selected item, returns it, otherwise returns null.
			 *
			 * Typically, you would use {@link Eto.Forms.Grid.SelectedItems} when
			 * {@link Eto.Forms.Grid.AllowMultipleSelection} is true .
			 */
			readonly SelectedItem: unknown;

			/** Gets a binding object to bind to the {@link Eto.Forms.Grid.SelectedItem} property. */
			readonly SelectedItemBinding: Eto.Forms.BindableBinding$2<Eto.Forms.Grid, unknown>;

			/** Gets or sets the selected rows indexes */
			SelectedRows: Iterable<number>;

			/**
			 * Gets or sets the selected row, or -1 for none.
			 *
			 * When {@link Eto.Forms.Grid.AllowMultipleSelection} is true and you want all selected
			 * rows, use {@link Eto.Forms.Grid.SelectedRow}.
			 */
			SelectedRow: number;

			/** Gets or sets the height for each row in the grid */
			RowHeight: number;

			/** Gets or sets the style of grid lines to show between columns and rows */
			GridLines: Eto.Forms.GridLines;

			/** Gets or sets the border type */
			Border: Eto.Forms.BorderType;

			/**
			 * Gets or sets a value indicating that the user can clear the selection.
			 *
			 * When true, the user can deselect the item by cmd/ctrl+click the last selected row, or
			 * by clicking on the empty space in the Grid. Some platforms may have empty space to the
			 * right, and some only have space at the bottom. When false, this setting will make it
			 * so the user cannot deselect the last selected item, and the control will initially
			 * select the first item when setting the DataStore property. This does not affect the
			 * ability to clear the selection programmatically.
			 */
			AllowEmptySelection: boolean;

			/** Gets a value indicating that the current cell is in edit mode. */
			readonly IsEditing: boolean;

			/**
			 * Gets a value indicating that the control is loaded onto a form, that is it has been
			 * created, added to a parent, and shown
			 *
			 * The {@link Eto.Forms.Control.OnLoad(System.EventArgs)} method sets this value to true
			 * after cascading to all children (for a {@link Eto.Forms.Container} ) and calling the
			 * platform handler's implementation.  It is called after adding to a loaded form, or
			 * when showing a new form.  The {@link Eto.Forms.Control.OnUnLoad(System.EventArgs)}
			 * method will set this value to false when the control is removed from its parent
			 */
			readonly Loaded: boolean;

			/**
			 * Gets an enumeration of controls that are in the visual tree.
			 *
			 * This is used to specify which controls are contained by this instance that are part of
			 * the visual tree. This should include all controls including non-logical Eto controls
			 * used for layout.
			 */
			readonly VisualControls: Iterable<Eto.Forms.Control>;

			/**
			 * Gets or sets a user-defined object that contains data about the control
			 *
			 * A common use of the tag property is to store data that is associated with the control
			 * that you can later retrieve.
			 */
			Tag: unknown;

			/**
			 * Gets the logical parent control.
			 *
			 * When the control is part of the visual tree (
				 * {@link Eto.Forms.Control.IsVisualControl} is true), this returns the logical parent
				 * that contains this control. Otherwise this is the same as
				 * {@link Eto.Forms.Control.Parent}.
				 */
				readonly LogicalParent: Eto.Forms.Container;

			/** Gets a value indicating this {@link Eto.Forms.Control} is part of the visual tree. */
			IsVisualControl: boolean;

			/**
			 * Gets or sets the size of the control. Use -1 to specify auto sizing for either the
			 * width and/or height.
			 *
			 * Setting the size of controls is entirely optional as most controls will size
			 * themselves appropriately. When specifying a size, it will be used as the desired size
			 * of the control.  The container will reposition and resize the control depending on the
			 * available size.  For a {@link Eto.Forms.Window}, it is preferred to set the
			 * {@link Eto.Forms.Container.ClientSize} instead, as various platforms have different
			 * sizes of window decorations, toolbars, etc.
			 */
			Size: Eto.Drawing.Size;

			/**
			 * Gets a value indicating this control currently has mouse capture
			 *
			 * Mouse capture can happen during a handled MouseDown event until MouseUp, or it can be
			 * captured explicitly via {@link Eto.Forms.Control.CaptureMouse}.
			 */
			readonly IsMouseCaptured: boolean;

			/** Gets or sets the width of the control size. */
			Width: number;

			/** Gets or sets the height of the control size. */
			Height: number;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Forms.Control} (or its
			 * children) are enabled and accept user input.
			 *
			 * Typically when a control is disabled, the user cannot do anything with the control or
			 * any of its children. Including for example, selecting text in a text control. Certain
			 * controls can have a 'Read Only' mode, such as {@link Eto.Forms.TextBox.ReadOnly} which
			 * allow the user to  select text, but not change its contents.
			 */
			Enabled: boolean;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Forms.Control} is visible to
			 * the user.
			 *
			 * When the visibility of a control is set to false, it will not occupy space in the
			 * layout.
			 */
			Visible: boolean;

			/** Gets the container which this control has been added to, if any */
			readonly Parent: Eto.Forms.Container;

			/**
			 * Gets the visual container of this control, if any.
			 *
			 * Some containers may use other Eto controls to layout its children, such as the
			 * {@link Eto.Forms.StackLayout}. This will return the parent control that visually
			 * contains this control as opposed to {@link Eto.Forms.Control.Parent} which will return
			 * the logical parent.
			 */
			VisualParent: Eto.Forms.Container;

			/** Gets a value indicating this control has been attached to a native container */
			readonly IsAttached: boolean;

			/**
			 * Gets or sets the color for the background of the control
			 *
			 * Note that on some platforms (e.g. Mac), setting the background color of a control can
			 * change the performance characteristics of the control and its children, since it must
			 * enable layers to do so.
			 */
			BackgroundColor: Eto.Drawing.Color;

			/** Gets a value indicating whether this instance has the keyboard input focus. */
			readonly HasFocus: boolean;

			/** Gets a value indicating whether the layout of child controls is suspended. */
			readonly IsSuspended: boolean;

			/** Gets the window this control is contained in */
			readonly ParentWindow: Eto.Forms.Window;

			/**
			 * Gets the supported platform commands that can be used to hook up system functions to
			 * user defined logic
			 *
			 * This lists all available commands that can be mapped using the
			 * {@link Eto.Forms.Control.MapPlatformCommand(System.String,Eto.Forms.Command)} method
			 * of the control.
			 */
			readonly SupportedPlatformCommands: Iterable<string>;

			/** Gets the bounding rectangle of this control relative to its container */
			readonly Bounds: Eto.Drawing.Rectangle;

			/**
			 * Gets the location of the control as positioned by the container
			 *
			 * A control's location is set by the container. This can be used to determine where the
			 * control is for overlaying floating windows, menus, etc.
			 */
			readonly Location: Eto.Drawing.Point;

			/** Gets or sets the type of cursor to use when the mouse is hovering over the control */
			Cursor: Eto.Forms.Cursor;

			/** Gets or sets the tool tip to show when the mouse is hovered over the control */
			ToolTip: string;

			/**
			 * Gets or sets the tab index order for this control within its container.
			 *
			 * This sets the order when using the tab key to cycle through controls  Note that some
			 * platforms (Gtk and WinForms) may not support setting the context of the tab order to
			 * StackLayout  or DynamicLayout containers and may not behave exactly as expected. Use
			 * the {@link Eto.PlatformFeatures.TabIndexWithCustomContainers} flag to determine if it
			 * is supported.
			 */
			TabIndex: number;

			/** Gets or sets a value indicating whether this control can serve as drop target. */
			AllowDrop: boolean;

			/**
			 * Gets or sets the parent widget which this widget has been added to, if any
			 *
			 * When implementing child widgets that can participate in the context based binding
			 * (MVVM), You can set this to the parent widget when it is added or removed to it
			 * (usually via a collection).  Note that you should typically provide a public new
			 * [ParentWidget] Parent { get; } property  so that consumers of your API cannot set the
			 * parent to an invalid value.
			 */
			Parent: Eto.Widget;

			/**
			 * Gets an enumeration of all parent widgets in the heirarchy by traversing the
			 * {@link Eto.Forms.BindableWidget.Parent} property.
			 */
			readonly Parents: Iterable<Eto.Widget>;

			/**
			 * Gets or sets the data context for this widget for binding
			 *
			 * Subclasses may override the standard behaviour so that hierarchy of widgets can be
			 * taken into account.  For example, a Control may return the data context of a parent,
			 * if it is not set explicitly.
			 */
			DataContext: unknown;

			/** Gets the collection of bindings that are attached to this widget */
			readonly Bindings: Eto.Forms.BindingCollection;

			/**
			 * Gets a value indicating that the {@link Eto.Forms.BindableWidget.DataContext} property
			 * is changing.
			 *
			 * This can be used to determine when to allow certain logic during the update of the
			 * data context.  It is used to disable binding setters on the model when the data
			 * context changes so that a binding does not cause the view model to be updated when the
			 * state hasn't been fully set yet.
			 */
			IsDataContextChanging: boolean;

			/**
			 * Gets the platform that was used to create the {@link Eto.Widget.Handler} for this
			 * widget
			 *
			 * This gets set to the current {@link Eto.Platform.Instance} during the construction of
			 * the object
			 */
			readonly Platform: Eto.Platform;

			/** Gets the platform-specific handler for this widget */
			Handler: unknown;

			/** Gets the native platform-specific handle for integration purposes */
			readonly NativeHandle: unknown;

			/** Gets the dictionary of properties for this widget */
			readonly Properties: Eto.PropertyStore;

			/** Gets or sets the ID of this widget */
			ID: string;

			/**
			 * Gets or sets the style of this widget
			 *
			 * Styles allow you to attach custom platform-specific logic to a widget. In your
			 * platform-specific assembly, use {@link Style.Add{H}(string, StyleHandler{H})} to add
			 * the style logic with the same id.
			 */
			Style: string;

			/**
			 * Gets the instance of the platform-specific object
			 *
			 * This can sometimes be useful to get the platform-specific object. Some handlers may
			 * not have any backing object for its functionality, so this may be null.  It is more
			 * preferred to use the {@link Eto.Widget.Handler} and cast that to the platform-specific
			 * handler class which can give you additional methods and helpers to do common tasks.
			 * For example, the {@link Eto.Forms.Application} object's handler for OS X has a
			 * AddFullScreenMenuItem property to specify if you want full screen support in your app.
			 */
			readonly ControlObject: unknown;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Widget} has been disposed.
			 *
			 * When the widget is disposed, it can no longer be used.
			 */
			IsDisposed: boolean;

			/** Selects the row to the specified `row`, clearing other selections */
			SelectRow(row: number): void;

			/** Selects all rows */
			SelectAll(): void;

			/** Unselects the specified `row` */
			UnselectRow(row: number): void;

			/** Clears the selection */
			UnselectAll(): void;

			/** Begin to edit one cell */
			BeginEdit(
				row: number,
				column: number,
			): void;

			/** Commits a current edit operation and sets the current value to the model. */
			CommitEdit(): boolean;

			/**
			 * Cancels the current edit operation and reverts the cell value to the value in the
			 * model.
			 */
			CancelEdit(): boolean;

			/** Scrolls to show the specified row in the view */
			ScrollToRow(row: number): void;

			/**
			 * Queues a repaint of the entire control on the screen and any of its children.
			 *
			 * This is only useful when the control is visible.
			 */
			Invalidate(): void;

			/**
			 * Queues a repaint of the entire control on the screen
			 *
			 * This is only useful when the control is visible.
			 */
			Invalidate(invalidateChildren: boolean): void;

			/**
			 * Queues a repaint of the specified `rect` of the control and any children.
			 *
			 * This is only useful when the control is visible.
			 */
			Invalidate(rect: Eto.Drawing.Rectangle): void;

			/**
			 * Queues a repaint of the specified `rect` of the control
			 *
			 * This is only useful when the control is visible.
			 */
			Invalidate(
				rect: Eto.Drawing.Rectangle,
				invalidateChildren: boolean,
			): void;

			/**
			 * Updates the layout of this control if necessary.
			 *
			 * This will ensure the control has had all of its layout applied so you can use its
			 * position and size right after this call. Most platforms (except WinForms) use a
			 * deferred layout system so that after adding your control to the form dynamically it
			 * won't get laid out until the next idle loop. This is useful when you need to know the
			 * dimensions of the control immediately. Note that this can be an expensive operation,
			 * so it is recommended to only call this method when necessary and after all of the
			 * controls have been added/updated.
			 */
			UpdateLayout(): void;

			/** Gets the preferred size of this control given infinite space available. */
			GetPreferredSize(): Eto.Drawing.SizeF;

			/** Gets the preferred size of this control given the specified `availableSize`. */
			GetPreferredSize(availableSize: Eto.Drawing.SizeF): Eto.Drawing.SizeF;

			/**
			 * Captures all mouse events to this control.
			 *
			 * This captures all mouse events until {@link Eto.Forms.Control.ReleaseMouseCapture} is
			 * called.  Note that not all platforms will allow a mouse capture unless the mouse is
			 * currently down.
			 */
			CaptureMouse(): boolean;

			/** Releases the mouse capture after a call to {@link Eto.Forms.Control.CaptureMouse}. */
			ReleaseMouseCapture(): void;

			/**
			 * Finds a control in the parent hierarchy with the specified type and
			 * {@link Eto.Widget.ID} if specified
			 */
			FindParent(
				type: unknown,
				id?: string,
			): Eto.Forms.Container;

			/** Finds a control in the parent hierarchy with the specified `id` */
			FindParent(id: string): Eto.Forms.Container;

			/**
			 * Detaches the control by removing it from its parent
			 *
			 * This is essentially a shortcut to myControl.Parent.Remove(myControl);
			 */
			Detach(): void;

			/**
			 * Attaches the control for direct use in a native application
			 *
			 * Use this to use a control directly in a native application.  Note that the native
			 * application must be running the same framework as the current platform.  E.g. a
			 * WinForms application can use an Eto.Forms control when using the Eto.WinForms
			 * platform.  This prepares the control by firing the {@link Eto.Forms.Control.PreLoad},
			 * {@link Eto.Forms.Control.Load}, etc. events.
			 */
			AttachNative(): void;

			/**
			 * Detaches the control when it is used in a native application, when you want to reuse
			 * the control.
			 *
			 * This should only be called after {@link Eto.Forms.Control.AttachNative} has been
			 * called, which is usually done by calling to ToNative(true) .
			 */
			DetachNative(): void;

			/**
			 * Attempts to set the keyboard input focus to this control, or the first child that
			 * accepts focus. For Windows, this will bring it to front and activate it.
			 */
			Focus(): void;

			/**
			 * Suspends the layout of child controls
			 *
			 * This can be used to optimize some platforms while adding, removing, or changing many
			 * child controls at once. It disables the calculation of control positioning until
			 * {@link Eto.Forms.Control.ResumeLayout} is called. Each call to SuspendLayout() must be
			 * balanced with a call to {@link Eto.Forms.Control.ResumeLayout}.
			 */
			SuspendLayout(): void;

			/**
			 * Resumes the layout after it has been suspended, and performs a layout
			 *
			 * This can be used to optimize some platforms while adding, removing, or changing many
			 * child controls at once. Each call to ResumeLayout() must be balanced with a call to
			 * {@link Eto.Forms.Control.SuspendLayout} before it.
			 */
			ResumeLayout(): void;

			/**
			 * Specifies a command to execute for a platform-specific command
			 *
			 * Some platforms have specific system-defined commands that can be associated with a
			 * control. For example, the Mac platform's cut/copy/paste functionality is defined by
			 * the system, and if you want to hook into it, you can use this to map it to your own
			 * defined logic. The valid values of the `systemCommand` parameter are defined by each
			 * platform, and a list can be retrieved using
			 * {@link Eto.Forms.Control.SupportedPlatformCommands}
			 */
			MapPlatformCommand(
				systemCommand: string,
				command: Eto.Forms.Command,
			): void;

			/** Converts a point from screen space to control space. */
			PointFromScreen(point: Eto.Drawing.PointF): Eto.Drawing.PointF;

			/** Converts a point from control space to screen space */
			PointToScreen(point: Eto.Drawing.PointF): Eto.Drawing.PointF;

			/** Converts a rectangle from screen space to control space. */
			RectangleToScreen(rect: Eto.Drawing.RectangleF): Eto.Drawing.RectangleF;

			/** Converts a rectangle from control space to screen space */
			RectangleFromScreen(rect: Eto.Drawing.RectangleF): Eto.Drawing.RectangleF;

			/**
			 * Starts drag operation using this control as drag source.
			 *
			 * This method can be blocking on some platforms (Wpf, WinForms), and non-blocking on
			 * others (Mac, Gtk). Use the {@link Eto.Forms.Control.DragEnd} event to determine when
			 * the drag operation is completed and get its resulting DragEffects.
			 */
			DoDragDrop(
				data: Eto.Forms.DataObject,
				allowedEffects: Eto.Forms.DragEffects,
			): void;

			/**
			 * Starts drag operation using this control as drag source.
			 *
			 * This method can be blocking on some platforms (Wpf, WinForms), and non-blocking on
			 * others (Mac, Gtk). Use the {@link Eto.Forms.Control.DragEnd} event to determine when
			 * the drag operation is completed and get its resulting DragEffects.
			 */
			DoDragDrop(
				data: Eto.Forms.DataObject,
				allowedEffects: Eto.Forms.DragEffects,
				image: Eto.Drawing.Image,
				cursorOffset: Eto.Drawing.PointF,
			): void;

			/**
			 * Triggers the StyleChanged event and re-applies the styles to this control and its
			 * children.
			 */
			TriggerStyleChanged(): void;

			/** Shows a print dialog to print the specified control */
			Print(): void;

			/**
			 * Finds a control in the parent hierarchy with the specified type and
			 * {@link Eto.Widget.ID} if specified
			 */
			FindParent<T>(id?: string): T;

			/**
			 * Finds a control in the parent hierarchy with the specified type and
			 * {@link Eto.Widget.ID} if specified
			 */
			FindParent(
				type: unknown,
				id?: string,
			): Eto.Widget;

			/** Finds a control in the parent hierarchy with the specified `id` */
			FindParent(id: string): Eto.Widget;

			/**
			 * Unbinds any bindings in the {@link Eto.Forms.BindableWidget.Bindings} collection and
			 * removes the bindings
			 *
			 * When you implement {@link Eto.Forms.IBindableWidgetContainer}, this will also unbind
			 * any of its children.
			 */
			Unbind(): void;

			/**
			 * Updates all bindings in this widget
			 *
			 * When you implement {@link Eto.Forms.IBindableWidgetContainer}, this will also update
			 * bindings for all of its children.
			 */
			UpdateBindings(mode?: Eto.Forms.BindingUpdateMode): void;

			/** Disposes of this widget, supressing the finalizer */
			dispose(): void;

			/** Gets a string that represents the current object with its ID if specified. */
			ToString(): string;
		}
	}

	export namespace Eto.Forms.Grid {
		export interface ICallback extends
			Eto.Forms.Control.ICallback,
			Eto.Widget.ICallback {
			OnCellEditing(
				widget: Eto.Forms.Grid,
				e: Eto.Forms.GridViewCellEventArgs,
			): void;

			OnCellEdited(
				widget: Eto.Forms.Grid,
				e: Eto.Forms.GridViewCellEventArgs,
			): void;

			OnCellClick(
				widget: Eto.Forms.Grid,
				e: Eto.Forms.GridCellMouseEventArgs,
			): void;

			OnCellDoubleClick(
				widget: Eto.Forms.Grid,
				e: Eto.Forms.GridCellMouseEventArgs,
			): void;

			OnSelectionChanged(
				widget: Eto.Forms.Grid,
				e: unknown,
			): void;

			OnColumnHeaderClick(
				widget: Eto.Forms.Grid,
				e: Eto.Forms.GridColumnEventArgs,
			): void;

			OnCellFormatting(
				widget: Eto.Forms.Grid,
				e: Eto.Forms.GridCellFormatEventArgs,
			): void;

			OnRowFormatting(
				widget: Eto.Forms.Grid,
				e: Eto.Forms.GridRowFormatEventArgs,
			): void;

			OnColumnOrderChanged(
				widget: Eto.Forms.Grid,
				e: Eto.Forms.GridColumnEventArgs,
			): void;

			OnColumnWidthChanged(
				widget: Eto.Forms.Grid,
				e: Eto.Forms.GridColumnEventArgs,
			): void;
		}
	}

	export namespace Eto.Forms.Grid {
		export interface IHandler extends
			Eto.Forms.Control.IHandler,
			Eto.Widget.IHandler {
			ShowHeader: boolean;

			RowHeight: number;

			AllowColumnReordering: boolean;

			AllowMultipleSelection: boolean;

			SelectedRows: Iterable<number>;

			GridLines: Eto.Forms.GridLines;

			Border: Eto.Forms.BorderType;

			readonly IsEditing: boolean;

			AllowEmptySelection: boolean;

			SelectRow(row: number): void;

			UnselectRow(row: number): void;

			SelectAll(): void;

			UnselectAll(): void;

			BeginEdit(
				row: number,
				column: number,
			): void;

			CommitEdit(): boolean;

			CancelEdit(): boolean;

			ScrollToRow(row: number): void;
		}
	}

	export namespace Eto.Forms {
		/** Column collection for the {@link Eto.Forms.Grid} */
		export class GridColumnCollection {
			constructor();
		}
	}

	export namespace Eto.Forms {
		/** Grid column definition for a {@link Eto.Forms.Grid} */
		export class GridColumn implements
			Eto.IHandlerSource {
			constructor();

			/** Gets or sets the text to display in the header of the column. */
			HeaderText: string;

			/**
			 * Gets or sets the tooltip to display when the user moves the cursor over the header of
			 * this column.
			 */
			HeaderToolTip: string;

			/** Gets or sets the binding to use to get the tooltip for each cell in this column. */
			CellToolTipBinding: Eto.Forms.IIndirectBinding$1<string>;

			/** Gets or sets a value indicating whether the column is resizable by the user. */
			Resizable: boolean;

			/**
			 * Gets or sets a value indicating whether this column will auto size to the content of
			 * the grid.
			 *
			 * This usually will only auto size based on the visible content to be as performant as
			 * possible.
			 */
			AutoSize: boolean;

			/** Gets or sets a value indicating whether the user can click on the header. */
			Sortable: boolean;

			/** Gets or sets the initial width of the column. */
			Width: number;

			/** Gets or sets the cell for the content of the column. */
			DataCell: Eto.Forms.Cell;

			/**
			 * Gets or sets a value indicating whether the user can edit the contents of the cells,
			 * if the {@link Eto.Forms.GridColumn.DataCell} allows it.
			 */
			Editable: boolean;

			/** Gets or sets a value indicating whether this column is visible. */
			Visible: boolean;

			/**
			 * Gets or sets a value indicating whether this column should expand to fill the
			 * available space in the Grid
			 *
			 * If more than one column has this set, they will share the space evenly.
			 */
			Expand: boolean;

			/** Gets or sets a value to specify the header text alignment for this column */
			HeaderTextAlignment: Eto.Forms.TextAlignment;

			/** Gets or sets the minimum width for the column */
			MinWidth: number;

			/** Gets or sets the maximum width for the column */
			MaxWidth: number;

			/**
			 * Gets or sets the index of the column in display order, or -1 to use the order they are
			 * added.
			 *
			 * This value must be within the range of the total number of columns that are added.
			 */
			DisplayIndex: number;

			/**
			 * Gets the platform that was used to create the {@link Eto.Widget.Handler} for this
			 * widget
			 *
			 * This gets set to the current {@link Eto.Platform.Instance} during the construction of
			 * the object
			 */
			readonly Platform: Eto.Platform;

			/** Gets the platform-specific handler for this widget */
			Handler: unknown;

			/** Gets the native platform-specific handle for integration purposes */
			readonly NativeHandle: unknown;

			/** Gets the dictionary of properties for this widget */
			readonly Properties: Eto.PropertyStore;

			/** Gets or sets the ID of this widget */
			ID: string;

			/**
			 * Gets or sets the style of this widget
			 *
			 * Styles allow you to attach custom platform-specific logic to a widget. In your
			 * platform-specific assembly, use {@link Style.Add{H}(string, StyleHandler{H})} to add
			 * the style logic with the same id.
			 */
			Style: string;

			/**
			 * Gets the instance of the platform-specific object
			 *
			 * This can sometimes be useful to get the platform-specific object. Some handlers may
			 * not have any backing object for its functionality, so this may be null.  It is more
			 * preferred to use the {@link Eto.Widget.Handler} and cast that to the platform-specific
			 * handler class which can give you additional methods and helpers to do common tasks.
			 * For example, the {@link Eto.Forms.Application} object's handler for OS X has a
			 * AddFullScreenMenuItem property to specify if you want full screen support in your app.
			 */
			readonly ControlObject: unknown;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Widget} has been disposed.
			 *
			 * When the widget is disposed, it can no longer be used.
			 */
			IsDisposed: boolean;

			/** Disposes of this widget, supressing the finalizer */
			dispose(): void;

			/** Gets a string that represents the current object with its ID if specified. */
			ToString(): string;
		}
	}

	export namespace Eto.Forms.GridColumn {
		export interface IHandler extends Eto.Widget.IHandler {
			HeaderText: string;

			Resizable: boolean;

			Sortable: boolean;

			AutoSize: boolean;

			Width: number;

			DataCell: Eto.Forms.Cell;

			Editable: boolean;

			Visible: boolean;

			Expand: boolean;

			HeaderTextAlignment: Eto.Forms.TextAlignment;

			MinWidth: number;

			MaxWidth: number;

			DisplayIndex: number;

			HeaderToolTip: string;

			CellToolTipBinding: Eto.Forms.IIndirectBinding$1<string>;
		}
	}

	export namespace Eto.Forms {
		/**
		 * Helper for an item in a {@link Eto.Forms.GridView} to store values in an array.
		 *
		 * This should only be used when you don't have your own class to represent each row. You
		 * can use the {@link Eto.Forms.ColumnBinding<>} to bind to an indexed value in this
		 * item.
		 */
		export class GridItem implements Eto.Forms.IColumnItem {
			/** Initializes a new instance of the {@link Eto.Forms.GridItem} class. */
			constructor();

			/** Initializes a new instance of the {@link Eto.Forms.GridItem} class. */
			constructor(values: unknown[]);

			/** Gets or sets a custom value to associate with this item. */
			Tag: unknown;

			/** Gets or sets the values of the row. */
			Values: unknown[];

			/** Gets the value from this item for the specified column/index */
			GetValue(column: number): unknown;

			/** Sets the value of this object for the specified column/index */
			SetValue(
				column: number,
				value: unknown,
			): void;
		}
	}

	export namespace Eto.Forms {
		/** Event arguments for cell-based events of a {@link Eto.Forms.GridView} */
		export class GridViewCellEventArgs {
			/** Initializes a new instance of the {@link Eto.Forms.GridViewCellEventArgs} class. */
			constructor(
				gridColumn: Eto.Forms.GridColumn,
				row: number,
				column: number,
				item: unknown,
			);

			/** Gets the grid column that triggered the event. */
			GridColumn: Eto.Forms.GridColumn;

			/** Gets the row that triggered the event, or -1 if no row. */
			Row: number;

			/** Gets the index of the column that triggered the event, or -1 if no column. */
			Column: number;

			/** Gets the item of the row that triggered the event, or null if there was no item. */
			Item: unknown;
		}
	}

	export namespace Eto.Forms {
		/** Information of a cell in the {@link Eto.Forms.TreeGridView} */
		export class GridCell {
			/** Initializes a new instance of the GridCell class */
			constructor(
				column: Eto.Forms.GridColumn,
				columnIndex: number,
				rowIndex: number,
				type: Eto.Forms.GridCellType,
				item: unknown,
			);

			/** Gets the item associated with the row of the cell, or null if there is no row. */
			readonly Item: unknown;

			/** Gets the index of the row, or -1 if there is no row at this location. */
			readonly RowIndex: number;

			/**
			 * Gets the column of the cell, or null if there is no column at the specified location.
			 */
			readonly Column: Eto.Forms.GridColumn;

			/**
			 * Gets the index of the column, or -1 if there is no column at the specified location.
			 */
			readonly ColumnIndex: number;

			/** Gets the type of the cell */
			readonly Type: Eto.Forms.GridCellType;
		}
	}

	export namespace Eto.Forms {
		/**
		 * Extra drag information when dragging to a {@link Eto.Forms.TreeGridView}.
		 *
		 * Use this information to determine where the user is dragging to, and also to change
		 * where the drag indicator will be shown by modifying the Item and ChildIndex
		 * properties.
		 */
		export class GridViewDragInfo {
			/** Initializes a new instance of the {@link Eto.Forms.GridDragInfo} class. */
			constructor(
				control: Eto.Forms.GridView,
				item: unknown,
				index: number,
				position: Eto.Forms.GridDragPosition,
			);

			/** Gets or sets the item the user is dragging to. */
			readonly Item: unknown;

			/**
			 * Gets or sets the insertion index where the user is dragging to as a child of Item, or
			 * -1 if dragging ontop of the Item.
			 *
			 * This is useful if the user is dragging inbetween existing items, or the beginning or
			 * end of a child list.  Only some platforms may support this property, otherwise it will
			 * always return -1.
			 */
			Index: number;

			/**
			 * Gets the position of the ChildIndex relative to the item under the mouse cursor.
			 *
			 * When dragging between items, this will tell you if the ChildIndex specified is after
			 * or before the item under the mouse cursor. This allows you to adjust the Item and
			 * ChildIndex.
			 */
			Position: Eto.Forms.GridDragPosition;

			/** Gets the parent tree control this info is for. */
			readonly Control: Eto.Forms.GridView;

			/**
			 * Gets a value indicating whether this {@link Eto.Forms.GridDragInfo} is changed.
			 *
			 * This will return true if the {@link Eto.Forms.GridViewDragInfo.Index} or
			 * {@link Eto.Forms.GridViewDragInfo.Item} have been set. This is useful for platform
			 * implementations to determine if the drop target has been modified.
			 */
			IsChanged: boolean;

			/** Gets the insertion index of drop operation, or -1 if not an insert (dragging over) */
			readonly InsertIndex: number;

			/** Helper to restrict to drop on top an existing item without allowing any insertion. */
			RestrictToOver(): void;

			/**
			 * Helper to restrict the drop to insert items only without allowing draging over
			 * existing items.
			 */
			RestrictToInsert(): void;
		}
	}

	export namespace Eto.Forms {
		/** [Generic type factory] Grid view with a data store of a specific type */
		export function GridView$(T: IType): typeof GridView$1<any>;

		/** Grid view with a data store of a specific type */
		export class GridView$1<T> implements
			Eto.IHandlerSource,
			Eto.Forms.IBindable,
			Eto.Forms.IMouseInputSource,
			Eto.Forms.IKeyboardInputSource,
			Eto.Forms.ISelectable$1<unknown>,
			Eto.Forms.ISelectableControl$1<unknown>,
			Eto.Forms.ISelectableControl$1<T>,
			Eto.Forms.ISelectable$1<T> {
			new(): GridView$1<T>;

			/**
			 * The data store for the grid.
			 *
			 * This defines what data to show in the grid. If the source implements
			 * {@link System.Collections.Specialized.INotifyCollectionChanged}, such as an
			 * {@link System.Collections.ObjectModel.ObservableCollection<>}, then changes to the
			 * collection will be reflected in the grid.
			 */
			DataStore: Iterable<T>;

			/** Gets an enumeration of the currently selected items */
			readonly SelectedItems: Iterable<T>;

			/**
			 * If there is exactly one selected item, returns it, otherwise returns null.
			 *
			 * Typically, you would use {@link Eto.Forms.Grid.SelectedItems} when
			 * {@link Eto.Forms.Grid.AllowMultipleSelection} is true .
			 */
			readonly SelectedItem: T;

			/**
			 * Gets a binding object to bind to the {@link Eto.Forms.GridView`1.SelectedItem}
			 * property.
			 */
			readonly SelectedItemBinding: Eto.Forms.BindableBinding$2<Eto.Forms.GridView$1<T>, T>;

			/**
			 * A delegate method to delete an item in response to a user's request. The method should
			 * return true after deleting the item, or false to indicate the item could not be
			 * deleted.  Currently supported on iOS only.
			 */
			DeleteItemHandler: (arg1: unknown) => boolean;

			/**
			 * A delegate that returns true if an item can be deleted  Currently supported on iOS
			 * only.
			 */
			CanDeleteItem: (arg1: unknown) => boolean;

			/** The text to display in a Delete item button.  Currently supported on iOS only. */
			DeleteConfirmationTitle: (arg1: unknown) => string;

			/**
			 * The data store for the grid.
			 *
			 * This defines what data to show in the grid. If the source implements
			 * {@link System.Collections.Specialized.INotifyCollectionChanged}, such as an
			 * {@link System.Collections.ObjectModel.ObservableCollection<>}, then changes to the
			 * collection will be reflected in the grid.
			 */
			DataStore: Iterable<unknown>;

			/** Gets or sets a value indicating whether to show a border around each cell. */
			ShowCellBorders: boolean;

			/**
			 * Gets a new selection preserver instance for the grid.
			 *
			 * This is used to keep the selected items consistent for a grid when changing the
			 * {@link Eto.Forms.GridView.DataStore} collection dramatically, such as filtering or
			 * sorting the collection.  Events such as removing or adding rows will always keep the
			 * selection of existing rows.
			 */
			readonly SelectionPreserver: Eto.Forms.ISelectionPreserver;

			/** Gets an enumeration of the currently selected items */
			readonly SelectedItems: Iterable<unknown>;

			/**
			 * Gets or sets the context menu when right clicking or pressing the menu button on the
			 * control.
			 */
			ContextMenu: Eto.Forms.ContextMenu;

			/** Gets the collection of columns to display in the grid */
			readonly Columns: Eto.Forms.GridColumnCollection;

			/** Gets or sets a value indicating that the header should be shown */
			ShowHeader: boolean;

			/** Gets or sets a value indicating whether the user can re-order columns */
			AllowColumnReordering: boolean;

			/** Gets or sets a value indicating whether the user can select multiple rows */
			AllowMultipleSelection: boolean;

			/**
			 * If there is exactly one selected item, returns it, otherwise returns null.
			 *
			 * Typically, you would use {@link Eto.Forms.Grid.SelectedItems} when
			 * {@link Eto.Forms.Grid.AllowMultipleSelection} is true .
			 */
			readonly SelectedItem: unknown;

			/** Gets a binding object to bind to the {@link Eto.Forms.Grid.SelectedItem} property. */
			readonly SelectedItemBinding: Eto.Forms.BindableBinding$2<Eto.Forms.Grid, unknown>;

			/** Gets or sets the selected rows indexes */
			SelectedRows: Iterable<number>;

			/**
			 * Gets or sets the selected row, or -1 for none.
			 *
			 * When {@link Eto.Forms.Grid.AllowMultipleSelection} is true and you want all selected
			 * rows, use {@link Eto.Forms.Grid.SelectedRow}.
			 */
			SelectedRow: number;

			/** Gets or sets the height for each row in the grid */
			RowHeight: number;

			/** Gets or sets the style of grid lines to show between columns and rows */
			GridLines: Eto.Forms.GridLines;

			/** Gets or sets the border type */
			Border: Eto.Forms.BorderType;

			/**
			 * Gets or sets a value indicating that the user can clear the selection.
			 *
			 * When true, the user can deselect the item by cmd/ctrl+click the last selected row, or
			 * by clicking on the empty space in the Grid. Some platforms may have empty space to the
			 * right, and some only have space at the bottom. When false, this setting will make it
			 * so the user cannot deselect the last selected item, and the control will initially
			 * select the first item when setting the DataStore property. This does not affect the
			 * ability to clear the selection programmatically.
			 */
			AllowEmptySelection: boolean;

			/** Gets a value indicating that the current cell is in edit mode. */
			readonly IsEditing: boolean;

			/**
			 * Gets a value indicating that the control is loaded onto a form, that is it has been
			 * created, added to a parent, and shown
			 *
			 * The {@link Eto.Forms.Control.OnLoad(System.EventArgs)} method sets this value to true
			 * after cascading to all children (for a {@link Eto.Forms.Container} ) and calling the
			 * platform handler's implementation.  It is called after adding to a loaded form, or
			 * when showing a new form.  The {@link Eto.Forms.Control.OnUnLoad(System.EventArgs)}
			 * method will set this value to false when the control is removed from its parent
			 */
			readonly Loaded: boolean;

			/**
			 * Gets an enumeration of controls that are in the visual tree.
			 *
			 * This is used to specify which controls are contained by this instance that are part of
			 * the visual tree. This should include all controls including non-logical Eto controls
			 * used for layout.
			 */
			readonly VisualControls: Iterable<Eto.Forms.Control>;

			/**
			 * Gets or sets a user-defined object that contains data about the control
			 *
			 * A common use of the tag property is to store data that is associated with the control
			 * that you can later retrieve.
			 */
			Tag: unknown;

			/**
			 * Gets the logical parent control.
			 *
			 * When the control is part of the visual tree (
				 * {@link Eto.Forms.Control.IsVisualControl} is true), this returns the logical parent
				 * that contains this control. Otherwise this is the same as
				 * {@link Eto.Forms.Control.Parent}.
				 */
				readonly LogicalParent: Eto.Forms.Container;

			/** Gets a value indicating this {@link Eto.Forms.Control} is part of the visual tree. */
			IsVisualControl: boolean;

			/**
			 * Gets or sets the size of the control. Use -1 to specify auto sizing for either the
			 * width and/or height.
			 *
			 * Setting the size of controls is entirely optional as most controls will size
			 * themselves appropriately. When specifying a size, it will be used as the desired size
			 * of the control.  The container will reposition and resize the control depending on the
			 * available size.  For a {@link Eto.Forms.Window}, it is preferred to set the
			 * {@link Eto.Forms.Container.ClientSize} instead, as various platforms have different
			 * sizes of window decorations, toolbars, etc.
			 */
			Size: Eto.Drawing.Size;

			/**
			 * Gets a value indicating this control currently has mouse capture
			 *
			 * Mouse capture can happen during a handled MouseDown event until MouseUp, or it can be
			 * captured explicitly via {@link Eto.Forms.Control.CaptureMouse}.
			 */
			readonly IsMouseCaptured: boolean;

			/** Gets or sets the width of the control size. */
			Width: number;

			/** Gets or sets the height of the control size. */
			Height: number;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Forms.Control} (or its
			 * children) are enabled and accept user input.
			 *
			 * Typically when a control is disabled, the user cannot do anything with the control or
			 * any of its children. Including for example, selecting text in a text control. Certain
			 * controls can have a 'Read Only' mode, such as {@link Eto.Forms.TextBox.ReadOnly} which
			 * allow the user to  select text, but not change its contents.
			 */
			Enabled: boolean;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Forms.Control} is visible to
			 * the user.
			 *
			 * When the visibility of a control is set to false, it will not occupy space in the
			 * layout.
			 */
			Visible: boolean;

			/** Gets the container which this control has been added to, if any */
			readonly Parent: Eto.Forms.Container;

			/**
			 * Gets the visual container of this control, if any.
			 *
			 * Some containers may use other Eto controls to layout its children, such as the
			 * {@link Eto.Forms.StackLayout}. This will return the parent control that visually
			 * contains this control as opposed to {@link Eto.Forms.Control.Parent} which will return
			 * the logical parent.
			 */
			VisualParent: Eto.Forms.Container;

			/** Gets a value indicating this control has been attached to a native container */
			readonly IsAttached: boolean;

			/**
			 * Gets or sets the color for the background of the control
			 *
			 * Note that on some platforms (e.g. Mac), setting the background color of a control can
			 * change the performance characteristics of the control and its children, since it must
			 * enable layers to do so.
			 */
			BackgroundColor: Eto.Drawing.Color;

			/** Gets a value indicating whether this instance has the keyboard input focus. */
			readonly HasFocus: boolean;

			/** Gets a value indicating whether the layout of child controls is suspended. */
			readonly IsSuspended: boolean;

			/** Gets the window this control is contained in */
			readonly ParentWindow: Eto.Forms.Window;

			/**
			 * Gets the supported platform commands that can be used to hook up system functions to
			 * user defined logic
			 *
			 * This lists all available commands that can be mapped using the
			 * {@link Eto.Forms.Control.MapPlatformCommand(System.String,Eto.Forms.Command)} method
			 * of the control.
			 */
			readonly SupportedPlatformCommands: Iterable<string>;

			/** Gets the bounding rectangle of this control relative to its container */
			readonly Bounds: Eto.Drawing.Rectangle;

			/**
			 * Gets the location of the control as positioned by the container
			 *
			 * A control's location is set by the container. This can be used to determine where the
			 * control is for overlaying floating windows, menus, etc.
			 */
			readonly Location: Eto.Drawing.Point;

			/** Gets or sets the type of cursor to use when the mouse is hovering over the control */
			Cursor: Eto.Forms.Cursor;

			/** Gets or sets the tool tip to show when the mouse is hovered over the control */
			ToolTip: string;

			/**
			 * Gets or sets the tab index order for this control within its container.
			 *
			 * This sets the order when using the tab key to cycle through controls  Note that some
			 * platforms (Gtk and WinForms) may not support setting the context of the tab order to
			 * StackLayout  or DynamicLayout containers and may not behave exactly as expected. Use
			 * the {@link Eto.PlatformFeatures.TabIndexWithCustomContainers} flag to determine if it
			 * is supported.
			 */
			TabIndex: number;

			/** Gets or sets a value indicating whether this control can serve as drop target. */
			AllowDrop: boolean;

			/**
			 * Gets or sets the parent widget which this widget has been added to, if any
			 *
			 * When implementing child widgets that can participate in the context based binding
			 * (MVVM), You can set this to the parent widget when it is added or removed to it
			 * (usually via a collection).  Note that you should typically provide a public new
			 * [ParentWidget] Parent { get; } property  so that consumers of your API cannot set the
			 * parent to an invalid value.
			 */
			Parent: Eto.Widget;

			/**
			 * Gets an enumeration of all parent widgets in the heirarchy by traversing the
			 * {@link Eto.Forms.BindableWidget.Parent} property.
			 */
			readonly Parents: Iterable<Eto.Widget>;

			/**
			 * Gets or sets the data context for this widget for binding
			 *
			 * Subclasses may override the standard behaviour so that hierarchy of widgets can be
			 * taken into account.  For example, a Control may return the data context of a parent,
			 * if it is not set explicitly.
			 */
			DataContext: unknown;

			/** Gets the collection of bindings that are attached to this widget */
			readonly Bindings: Eto.Forms.BindingCollection;

			/**
			 * Gets a value indicating that the {@link Eto.Forms.BindableWidget.DataContext} property
			 * is changing.
			 *
			 * This can be used to determine when to allow certain logic during the update of the
			 * data context.  It is used to disable binding setters on the model when the data
			 * context changes so that a binding does not cause the view model to be updated when the
			 * state hasn't been fully set yet.
			 */
			IsDataContextChanging: boolean;

			/**
			 * Gets the platform that was used to create the {@link Eto.Widget.Handler} for this
			 * widget
			 *
			 * This gets set to the current {@link Eto.Platform.Instance} during the construction of
			 * the object
			 */
			readonly Platform: Eto.Platform;

			/** Gets the platform-specific handler for this widget */
			Handler: unknown;

			/** Gets the native platform-specific handle for integration purposes */
			readonly NativeHandle: unknown;

			/** Gets the dictionary of properties for this widget */
			readonly Properties: Eto.PropertyStore;

			/** Gets or sets the ID of this widget */
			ID: string;

			/**
			 * Gets or sets the style of this widget
			 *
			 * Styles allow you to attach custom platform-specific logic to a widget. In your
			 * platform-specific assembly, use {@link Style.Add{H}(string, StyleHandler{H})} to add
			 * the style logic with the same id.
			 */
			Style: string;

			/**
			 * Gets the instance of the platform-specific object
			 *
			 * This can sometimes be useful to get the platform-specific object. Some handlers may
			 * not have any backing object for its functionality, so this may be null.  It is more
			 * preferred to use the {@link Eto.Widget.Handler} and cast that to the platform-specific
			 * handler class which can give you additional methods and helpers to do common tasks.
			 * For example, the {@link Eto.Forms.Application} object's handler for OS X has a
			 * AddFullScreenMenuItem property to specify if you want full screen support in your app.
			 */
			readonly ControlObject: unknown;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Widget} has been disposed.
			 *
			 * When the widget is disposed, it can no longer be used.
			 */
			IsDisposed: boolean;

			/**
			 * Gets the grid drag info for the specified DragEventArgs.
			 *
			 * Use this to get or set information about where the drop will occur.
			 */
			GetDragInfo(args: Eto.Forms.DragEventArgs): Eto.Forms.GridViewDragInfo;

			/**
			 * Gets the cell information at a specified location from the origin of the control
			 *
			 * Useful for determining which cell is under the mouse cursor.
			 */
			GetCellAt(location: Eto.Drawing.PointF): Eto.Forms.GridCell;

			/**
			 * Reloads the data at the specified row.
			 *
			 * This will refresh the cells of the specified row with the current data in the model
			 * for that row.
			 */
			ReloadData(row: number): void;

			/**
			 * Reloads the data at the specified rows.
			 *
			 * This will refresh the cells of the specified rows with the current data in the model
			 * for each row.
			 */
			ReloadData(rows: Iterable<number>): void;

			/**
			 * Reloads the data at the specified range of rows.
			 *
			 * This will refresh the cells of the specified range of rows with the current data in
			 * the model for each row.
			 */
			ReloadData(range: Eto.Forms.Range$1<number>): void;

			/** Selects the row to the specified `row`, clearing other selections */
			SelectRow(row: number): void;

			/** Selects all rows */
			SelectAll(): void;

			/** Unselects the specified `row` */
			UnselectRow(row: number): void;

			/** Clears the selection */
			UnselectAll(): void;

			/** Begin to edit one cell */
			BeginEdit(
				row: number,
				column: number,
			): void;

			/** Commits a current edit operation and sets the current value to the model. */
			CommitEdit(): boolean;

			/**
			 * Cancels the current edit operation and reverts the cell value to the value in the
			 * model.
			 */
			CancelEdit(): boolean;

			/** Scrolls to show the specified row in the view */
			ScrollToRow(row: number): void;

			/**
			 * Queues a repaint of the entire control on the screen and any of its children.
			 *
			 * This is only useful when the control is visible.
			 */
			Invalidate(): void;

			/**
			 * Queues a repaint of the entire control on the screen
			 *
			 * This is only useful when the control is visible.
			 */
			Invalidate(invalidateChildren: boolean): void;

			/**
			 * Queues a repaint of the specified `rect` of the control and any children.
			 *
			 * This is only useful when the control is visible.
			 */
			Invalidate(rect: Eto.Drawing.Rectangle): void;

			/**
			 * Queues a repaint of the specified `rect` of the control
			 *
			 * This is only useful when the control is visible.
			 */
			Invalidate(
				rect: Eto.Drawing.Rectangle,
				invalidateChildren: boolean,
			): void;

			/**
			 * Updates the layout of this control if necessary.
			 *
			 * This will ensure the control has had all of its layout applied so you can use its
			 * position and size right after this call. Most platforms (except WinForms) use a
			 * deferred layout system so that after adding your control to the form dynamically it
			 * won't get laid out until the next idle loop. This is useful when you need to know the
			 * dimensions of the control immediately. Note that this can be an expensive operation,
			 * so it is recommended to only call this method when necessary and after all of the
			 * controls have been added/updated.
			 */
			UpdateLayout(): void;

			/** Gets the preferred size of this control given infinite space available. */
			GetPreferredSize(): Eto.Drawing.SizeF;

			/** Gets the preferred size of this control given the specified `availableSize`. */
			GetPreferredSize(availableSize: Eto.Drawing.SizeF): Eto.Drawing.SizeF;

			/**
			 * Captures all mouse events to this control.
			 *
			 * This captures all mouse events until {@link Eto.Forms.Control.ReleaseMouseCapture} is
			 * called.  Note that not all platforms will allow a mouse capture unless the mouse is
			 * currently down.
			 */
			CaptureMouse(): boolean;

			/** Releases the mouse capture after a call to {@link Eto.Forms.Control.CaptureMouse}. */
			ReleaseMouseCapture(): void;

			/**
			 * Finds a control in the parent hierarchy with the specified type and
			 * {@link Eto.Widget.ID} if specified
			 */
			FindParent(
				type: unknown,
				id?: string,
			): Eto.Forms.Container;

			/** Finds a control in the parent hierarchy with the specified `id` */
			FindParent(id: string): Eto.Forms.Container;

			/**
			 * Detaches the control by removing it from its parent
			 *
			 * This is essentially a shortcut to myControl.Parent.Remove(myControl);
			 */
			Detach(): void;

			/**
			 * Attaches the control for direct use in a native application
			 *
			 * Use this to use a control directly in a native application.  Note that the native
			 * application must be running the same framework as the current platform.  E.g. a
			 * WinForms application can use an Eto.Forms control when using the Eto.WinForms
			 * platform.  This prepares the control by firing the {@link Eto.Forms.Control.PreLoad},
			 * {@link Eto.Forms.Control.Load}, etc. events.
			 */
			AttachNative(): void;

			/**
			 * Detaches the control when it is used in a native application, when you want to reuse
			 * the control.
			 *
			 * This should only be called after {@link Eto.Forms.Control.AttachNative} has been
			 * called, which is usually done by calling to ToNative(true) .
			 */
			DetachNative(): void;

			/**
			 * Attempts to set the keyboard input focus to this control, or the first child that
			 * accepts focus. For Windows, this will bring it to front and activate it.
			 */
			Focus(): void;

			/**
			 * Suspends the layout of child controls
			 *
			 * This can be used to optimize some platforms while adding, removing, or changing many
			 * child controls at once. It disables the calculation of control positioning until
			 * {@link Eto.Forms.Control.ResumeLayout} is called. Each call to SuspendLayout() must be
			 * balanced with a call to {@link Eto.Forms.Control.ResumeLayout}.
			 */
			SuspendLayout(): void;

			/**
			 * Resumes the layout after it has been suspended, and performs a layout
			 *
			 * This can be used to optimize some platforms while adding, removing, or changing many
			 * child controls at once. Each call to ResumeLayout() must be balanced with a call to
			 * {@link Eto.Forms.Control.SuspendLayout} before it.
			 */
			ResumeLayout(): void;

			/**
			 * Specifies a command to execute for a platform-specific command
			 *
			 * Some platforms have specific system-defined commands that can be associated with a
			 * control. For example, the Mac platform's cut/copy/paste functionality is defined by
			 * the system, and if you want to hook into it, you can use this to map it to your own
			 * defined logic. The valid values of the `systemCommand` parameter are defined by each
			 * platform, and a list can be retrieved using
			 * {@link Eto.Forms.Control.SupportedPlatformCommands}
			 */
			MapPlatformCommand(
				systemCommand: string,
				command: Eto.Forms.Command,
			): void;

			/** Converts a point from screen space to control space. */
			PointFromScreen(point: Eto.Drawing.PointF): Eto.Drawing.PointF;

			/** Converts a point from control space to screen space */
			PointToScreen(point: Eto.Drawing.PointF): Eto.Drawing.PointF;

			/** Converts a rectangle from screen space to control space. */
			RectangleToScreen(rect: Eto.Drawing.RectangleF): Eto.Drawing.RectangleF;

			/** Converts a rectangle from control space to screen space */
			RectangleFromScreen(rect: Eto.Drawing.RectangleF): Eto.Drawing.RectangleF;

			/**
			 * Starts drag operation using this control as drag source.
			 *
			 * This method can be blocking on some platforms (Wpf, WinForms), and non-blocking on
			 * others (Mac, Gtk). Use the {@link Eto.Forms.Control.DragEnd} event to determine when
			 * the drag operation is completed and get its resulting DragEffects.
			 */
			DoDragDrop(
				data: Eto.Forms.DataObject,
				allowedEffects: Eto.Forms.DragEffects,
			): void;

			/**
			 * Starts drag operation using this control as drag source.
			 *
			 * This method can be blocking on some platforms (Wpf, WinForms), and non-blocking on
			 * others (Mac, Gtk). Use the {@link Eto.Forms.Control.DragEnd} event to determine when
			 * the drag operation is completed and get its resulting DragEffects.
			 */
			DoDragDrop(
				data: Eto.Forms.DataObject,
				allowedEffects: Eto.Forms.DragEffects,
				image: Eto.Drawing.Image,
				cursorOffset: Eto.Drawing.PointF,
			): void;

			/**
			 * Triggers the StyleChanged event and re-applies the styles to this control and its
			 * children.
			 */
			TriggerStyleChanged(): void;

			/** Shows a print dialog to print the specified control */
			Print(): void;

			/**
			 * Finds a control in the parent hierarchy with the specified type and
			 * {@link Eto.Widget.ID} if specified
			 */
			FindParent<T>(id?: string): T;

			/**
			 * Finds a control in the parent hierarchy with the specified type and
			 * {@link Eto.Widget.ID} if specified
			 */
			FindParent(
				type: unknown,
				id?: string,
			): Eto.Widget;

			/** Finds a control in the parent hierarchy with the specified `id` */
			FindParent(id: string): Eto.Widget;

			/**
			 * Unbinds any bindings in the {@link Eto.Forms.BindableWidget.Bindings} collection and
			 * removes the bindings
			 *
			 * When you implement {@link Eto.Forms.IBindableWidgetContainer}, this will also unbind
			 * any of its children.
			 */
			Unbind(): void;

			/**
			 * Updates all bindings in this widget
			 *
			 * When you implement {@link Eto.Forms.IBindableWidgetContainer}, this will also update
			 * bindings for all of its children.
			 */
			UpdateBindings(mode?: Eto.Forms.BindingUpdateMode): void;

			/** Disposes of this widget, supressing the finalizer */
			dispose(): void;

			/** Gets a string that represents the current object with its ID if specified. */
			ToString(): string;
		}
	}

	export namespace Eto.Forms {
		/** Control to present data in a grid in columns and rows. */
		export class GridView implements
			Eto.IHandlerSource,
			Eto.Forms.IBindable,
			Eto.Forms.IMouseInputSource,
			Eto.Forms.IKeyboardInputSource,
			Eto.Forms.ISelectable$1<unknown>,
			Eto.Forms.ISelectableControl$1<unknown> {
			/** Initializes a new instance of the {@link Eto.Forms.GridView} class. */
			constructor();

			/**
			 * A delegate method to delete an item in response to a user's request. The method should
			 * return true after deleting the item, or false to indicate the item could not be
			 * deleted.  Currently supported on iOS only.
			 */
			DeleteItemHandler: (arg1: unknown) => boolean;

			/**
			 * A delegate that returns true if an item can be deleted  Currently supported on iOS
			 * only.
			 */
			CanDeleteItem: (arg1: unknown) => boolean;

			/** The text to display in a Delete item button.  Currently supported on iOS only. */
			DeleteConfirmationTitle: (arg1: unknown) => string;

			/**
			 * The data store for the grid.
			 *
			 * This defines what data to show in the grid. If the source implements
			 * {@link System.Collections.Specialized.INotifyCollectionChanged}, such as an
			 * {@link System.Collections.ObjectModel.ObservableCollection<>}, then changes to the
			 * collection will be reflected in the grid.
			 */
			DataStore: Iterable<unknown>;

			/** Gets or sets a value indicating whether to show a border around each cell. */
			ShowCellBorders: boolean;

			/**
			 * Gets a new selection preserver instance for the grid.
			 *
			 * This is used to keep the selected items consistent for a grid when changing the
			 * {@link Eto.Forms.GridView.DataStore} collection dramatically, such as filtering or
			 * sorting the collection.  Events such as removing or adding rows will always keep the
			 * selection of existing rows.
			 */
			readonly SelectionPreserver: Eto.Forms.ISelectionPreserver;

			/** Gets an enumeration of the currently selected items */
			readonly SelectedItems: Iterable<unknown>;

			/**
			 * Gets or sets the context menu when right clicking or pressing the menu button on the
			 * control.
			 */
			ContextMenu: Eto.Forms.ContextMenu;

			/** Gets the collection of columns to display in the grid */
			readonly Columns: Eto.Forms.GridColumnCollection;

			/** Gets or sets a value indicating that the header should be shown */
			ShowHeader: boolean;

			/** Gets or sets a value indicating whether the user can re-order columns */
			AllowColumnReordering: boolean;

			/** Gets or sets a value indicating whether the user can select multiple rows */
			AllowMultipleSelection: boolean;

			/**
			 * If there is exactly one selected item, returns it, otherwise returns null.
			 *
			 * Typically, you would use {@link Eto.Forms.Grid.SelectedItems} when
			 * {@link Eto.Forms.Grid.AllowMultipleSelection} is true .
			 */
			readonly SelectedItem: unknown;

			/** Gets a binding object to bind to the {@link Eto.Forms.Grid.SelectedItem} property. */
			readonly SelectedItemBinding: Eto.Forms.BindableBinding$2<Eto.Forms.Grid, unknown>;

			/** Gets or sets the selected rows indexes */
			SelectedRows: Iterable<number>;

			/**
			 * Gets or sets the selected row, or -1 for none.
			 *
			 * When {@link Eto.Forms.Grid.AllowMultipleSelection} is true and you want all selected
			 * rows, use {@link Eto.Forms.Grid.SelectedRow}.
			 */
			SelectedRow: number;

			/** Gets or sets the height for each row in the grid */
			RowHeight: number;

			/** Gets or sets the style of grid lines to show between columns and rows */
			GridLines: Eto.Forms.GridLines;

			/** Gets or sets the border type */
			Border: Eto.Forms.BorderType;

			/**
			 * Gets or sets a value indicating that the user can clear the selection.
			 *
			 * When true, the user can deselect the item by cmd/ctrl+click the last selected row, or
			 * by clicking on the empty space in the Grid. Some platforms may have empty space to the
			 * right, and some only have space at the bottom. When false, this setting will make it
			 * so the user cannot deselect the last selected item, and the control will initially
			 * select the first item when setting the DataStore property. This does not affect the
			 * ability to clear the selection programmatically.
			 */
			AllowEmptySelection: boolean;

			/** Gets a value indicating that the current cell is in edit mode. */
			readonly IsEditing: boolean;

			/**
			 * Gets a value indicating that the control is loaded onto a form, that is it has been
			 * created, added to a parent, and shown
			 *
			 * The {@link Eto.Forms.Control.OnLoad(System.EventArgs)} method sets this value to true
			 * after cascading to all children (for a {@link Eto.Forms.Container} ) and calling the
			 * platform handler's implementation.  It is called after adding to a loaded form, or
			 * when showing a new form.  The {@link Eto.Forms.Control.OnUnLoad(System.EventArgs)}
			 * method will set this value to false when the control is removed from its parent
			 */
			readonly Loaded: boolean;

			/**
			 * Gets an enumeration of controls that are in the visual tree.
			 *
			 * This is used to specify which controls are contained by this instance that are part of
			 * the visual tree. This should include all controls including non-logical Eto controls
			 * used for layout.
			 */
			readonly VisualControls: Iterable<Eto.Forms.Control>;

			/**
			 * Gets or sets a user-defined object that contains data about the control
			 *
			 * A common use of the tag property is to store data that is associated with the control
			 * that you can later retrieve.
			 */
			Tag: unknown;

			/**
			 * Gets the logical parent control.
			 *
			 * When the control is part of the visual tree (
				 * {@link Eto.Forms.Control.IsVisualControl} is true), this returns the logical parent
				 * that contains this control. Otherwise this is the same as
				 * {@link Eto.Forms.Control.Parent}.
				 */
				readonly LogicalParent: Eto.Forms.Container;

			/** Gets a value indicating this {@link Eto.Forms.Control} is part of the visual tree. */
			IsVisualControl: boolean;

			/**
			 * Gets or sets the size of the control. Use -1 to specify auto sizing for either the
			 * width and/or height.
			 *
			 * Setting the size of controls is entirely optional as most controls will size
			 * themselves appropriately. When specifying a size, it will be used as the desired size
			 * of the control.  The container will reposition and resize the control depending on the
			 * available size.  For a {@link Eto.Forms.Window}, it is preferred to set the
			 * {@link Eto.Forms.Container.ClientSize} instead, as various platforms have different
			 * sizes of window decorations, toolbars, etc.
			 */
			Size: Eto.Drawing.Size;

			/**
			 * Gets a value indicating this control currently has mouse capture
			 *
			 * Mouse capture can happen during a handled MouseDown event until MouseUp, or it can be
			 * captured explicitly via {@link Eto.Forms.Control.CaptureMouse}.
			 */
			readonly IsMouseCaptured: boolean;

			/** Gets or sets the width of the control size. */
			Width: number;

			/** Gets or sets the height of the control size. */
			Height: number;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Forms.Control} (or its
			 * children) are enabled and accept user input.
			 *
			 * Typically when a control is disabled, the user cannot do anything with the control or
			 * any of its children. Including for example, selecting text in a text control. Certain
			 * controls can have a 'Read Only' mode, such as {@link Eto.Forms.TextBox.ReadOnly} which
			 * allow the user to  select text, but not change its contents.
			 */
			Enabled: boolean;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Forms.Control} is visible to
			 * the user.
			 *
			 * When the visibility of a control is set to false, it will not occupy space in the
			 * layout.
			 */
			Visible: boolean;

			/** Gets the container which this control has been added to, if any */
			readonly Parent: Eto.Forms.Container;

			/**
			 * Gets the visual container of this control, if any.
			 *
			 * Some containers may use other Eto controls to layout its children, such as the
			 * {@link Eto.Forms.StackLayout}. This will return the parent control that visually
			 * contains this control as opposed to {@link Eto.Forms.Control.Parent} which will return
			 * the logical parent.
			 */
			VisualParent: Eto.Forms.Container;

			/** Gets a value indicating this control has been attached to a native container */
			readonly IsAttached: boolean;

			/**
			 * Gets or sets the color for the background of the control
			 *
			 * Note that on some platforms (e.g. Mac), setting the background color of a control can
			 * change the performance characteristics of the control and its children, since it must
			 * enable layers to do so.
			 */
			BackgroundColor: Eto.Drawing.Color;

			/** Gets a value indicating whether this instance has the keyboard input focus. */
			readonly HasFocus: boolean;

			/** Gets a value indicating whether the layout of child controls is suspended. */
			readonly IsSuspended: boolean;

			/** Gets the window this control is contained in */
			readonly ParentWindow: Eto.Forms.Window;

			/**
			 * Gets the supported platform commands that can be used to hook up system functions to
			 * user defined logic
			 *
			 * This lists all available commands that can be mapped using the
			 * {@link Eto.Forms.Control.MapPlatformCommand(System.String,Eto.Forms.Command)} method
			 * of the control.
			 */
			readonly SupportedPlatformCommands: Iterable<string>;

			/** Gets the bounding rectangle of this control relative to its container */
			readonly Bounds: Eto.Drawing.Rectangle;

			/**
			 * Gets the location of the control as positioned by the container
			 *
			 * A control's location is set by the container. This can be used to determine where the
			 * control is for overlaying floating windows, menus, etc.
			 */
			readonly Location: Eto.Drawing.Point;

			/** Gets or sets the type of cursor to use when the mouse is hovering over the control */
			Cursor: Eto.Forms.Cursor;

			/** Gets or sets the tool tip to show when the mouse is hovered over the control */
			ToolTip: string;

			/**
			 * Gets or sets the tab index order for this control within its container.
			 *
			 * This sets the order when using the tab key to cycle through controls  Note that some
			 * platforms (Gtk and WinForms) may not support setting the context of the tab order to
			 * StackLayout  or DynamicLayout containers and may not behave exactly as expected. Use
			 * the {@link Eto.PlatformFeatures.TabIndexWithCustomContainers} flag to determine if it
			 * is supported.
			 */
			TabIndex: number;

			/** Gets or sets a value indicating whether this control can serve as drop target. */
			AllowDrop: boolean;

			/**
			 * Gets or sets the parent widget which this widget has been added to, if any
			 *
			 * When implementing child widgets that can participate in the context based binding
			 * (MVVM), You can set this to the parent widget when it is added or removed to it
			 * (usually via a collection).  Note that you should typically provide a public new
			 * [ParentWidget] Parent { get; } property  so that consumers of your API cannot set the
			 * parent to an invalid value.
			 */
			Parent: Eto.Widget;

			/**
			 * Gets an enumeration of all parent widgets in the heirarchy by traversing the
			 * {@link Eto.Forms.BindableWidget.Parent} property.
			 */
			readonly Parents: Iterable<Eto.Widget>;

			/**
			 * Gets or sets the data context for this widget for binding
			 *
			 * Subclasses may override the standard behaviour so that hierarchy of widgets can be
			 * taken into account.  For example, a Control may return the data context of a parent,
			 * if it is not set explicitly.
			 */
			DataContext: unknown;

			/** Gets the collection of bindings that are attached to this widget */
			readonly Bindings: Eto.Forms.BindingCollection;

			/**
			 * Gets a value indicating that the {@link Eto.Forms.BindableWidget.DataContext} property
			 * is changing.
			 *
			 * This can be used to determine when to allow certain logic during the update of the
			 * data context.  It is used to disable binding setters on the model when the data
			 * context changes so that a binding does not cause the view model to be updated when the
			 * state hasn't been fully set yet.
			 */
			IsDataContextChanging: boolean;

			/**
			 * Gets the platform that was used to create the {@link Eto.Widget.Handler} for this
			 * widget
			 *
			 * This gets set to the current {@link Eto.Platform.Instance} during the construction of
			 * the object
			 */
			readonly Platform: Eto.Platform;

			/** Gets the platform-specific handler for this widget */
			Handler: unknown;

			/** Gets the native platform-specific handle for integration purposes */
			readonly NativeHandle: unknown;

			/** Gets the dictionary of properties for this widget */
			readonly Properties: Eto.PropertyStore;

			/** Gets or sets the ID of this widget */
			ID: string;

			/**
			 * Gets or sets the style of this widget
			 *
			 * Styles allow you to attach custom platform-specific logic to a widget. In your
			 * platform-specific assembly, use {@link Style.Add{H}(string, StyleHandler{H})} to add
			 * the style logic with the same id.
			 */
			Style: string;

			/**
			 * Gets the instance of the platform-specific object
			 *
			 * This can sometimes be useful to get the platform-specific object. Some handlers may
			 * not have any backing object for its functionality, so this may be null.  It is more
			 * preferred to use the {@link Eto.Widget.Handler} and cast that to the platform-specific
			 * handler class which can give you additional methods and helpers to do common tasks.
			 * For example, the {@link Eto.Forms.Application} object's handler for OS X has a
			 * AddFullScreenMenuItem property to specify if you want full screen support in your app.
			 */
			readonly ControlObject: unknown;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Widget} has been disposed.
			 *
			 * When the widget is disposed, it can no longer be used.
			 */
			IsDisposed: boolean;

			/**
			 * Gets the grid drag info for the specified DragEventArgs.
			 *
			 * Use this to get or set information about where the drop will occur.
			 */
			GetDragInfo(args: Eto.Forms.DragEventArgs): Eto.Forms.GridViewDragInfo;

			/**
			 * Gets the cell information at a specified location from the origin of the control
			 *
			 * Useful for determining which cell is under the mouse cursor.
			 */
			GetCellAt(location: Eto.Drawing.PointF): Eto.Forms.GridCell;

			/**
			 * Reloads the data at the specified row.
			 *
			 * This will refresh the cells of the specified row with the current data in the model
			 * for that row.
			 */
			ReloadData(row: number): void;

			/**
			 * Reloads the data at the specified rows.
			 *
			 * This will refresh the cells of the specified rows with the current data in the model
			 * for each row.
			 */
			ReloadData(rows: Iterable<number>): void;

			/**
			 * Reloads the data at the specified range of rows.
			 *
			 * This will refresh the cells of the specified range of rows with the current data in
			 * the model for each row.
			 */
			ReloadData(range: Eto.Forms.Range$1<number>): void;

			/** Selects the row to the specified `row`, clearing other selections */
			SelectRow(row: number): void;

			/** Selects all rows */
			SelectAll(): void;

			/** Unselects the specified `row` */
			UnselectRow(row: number): void;

			/** Clears the selection */
			UnselectAll(): void;

			/** Begin to edit one cell */
			BeginEdit(
				row: number,
				column: number,
			): void;

			/** Commits a current edit operation and sets the current value to the model. */
			CommitEdit(): boolean;

			/**
			 * Cancels the current edit operation and reverts the cell value to the value in the
			 * model.
			 */
			CancelEdit(): boolean;

			/** Scrolls to show the specified row in the view */
			ScrollToRow(row: number): void;

			/**
			 * Queues a repaint of the entire control on the screen and any of its children.
			 *
			 * This is only useful when the control is visible.
			 */
			Invalidate(): void;

			/**
			 * Queues a repaint of the entire control on the screen
			 *
			 * This is only useful when the control is visible.
			 */
			Invalidate(invalidateChildren: boolean): void;

			/**
			 * Queues a repaint of the specified `rect` of the control and any children.
			 *
			 * This is only useful when the control is visible.
			 */
			Invalidate(rect: Eto.Drawing.Rectangle): void;

			/**
			 * Queues a repaint of the specified `rect` of the control
			 *
			 * This is only useful when the control is visible.
			 */
			Invalidate(
				rect: Eto.Drawing.Rectangle,
				invalidateChildren: boolean,
			): void;

			/**
			 * Updates the layout of this control if necessary.
			 *
			 * This will ensure the control has had all of its layout applied so you can use its
			 * position and size right after this call. Most platforms (except WinForms) use a
			 * deferred layout system so that after adding your control to the form dynamically it
			 * won't get laid out until the next idle loop. This is useful when you need to know the
			 * dimensions of the control immediately. Note that this can be an expensive operation,
			 * so it is recommended to only call this method when necessary and after all of the
			 * controls have been added/updated.
			 */
			UpdateLayout(): void;

			/** Gets the preferred size of this control given infinite space available. */
			GetPreferredSize(): Eto.Drawing.SizeF;

			/** Gets the preferred size of this control given the specified `availableSize`. */
			GetPreferredSize(availableSize: Eto.Drawing.SizeF): Eto.Drawing.SizeF;

			/**
			 * Captures all mouse events to this control.
			 *
			 * This captures all mouse events until {@link Eto.Forms.Control.ReleaseMouseCapture} is
			 * called.  Note that not all platforms will allow a mouse capture unless the mouse is
			 * currently down.
			 */
			CaptureMouse(): boolean;

			/** Releases the mouse capture after a call to {@link Eto.Forms.Control.CaptureMouse}. */
			ReleaseMouseCapture(): void;

			/**
			 * Finds a control in the parent hierarchy with the specified type and
			 * {@link Eto.Widget.ID} if specified
			 */
			FindParent(
				type: unknown,
				id?: string,
			): Eto.Forms.Container;

			/** Finds a control in the parent hierarchy with the specified `id` */
			FindParent(id: string): Eto.Forms.Container;

			/**
			 * Detaches the control by removing it from its parent
			 *
			 * This is essentially a shortcut to myControl.Parent.Remove(myControl);
			 */
			Detach(): void;

			/**
			 * Attaches the control for direct use in a native application
			 *
			 * Use this to use a control directly in a native application.  Note that the native
			 * application must be running the same framework as the current platform.  E.g. a
			 * WinForms application can use an Eto.Forms control when using the Eto.WinForms
			 * platform.  This prepares the control by firing the {@link Eto.Forms.Control.PreLoad},
			 * {@link Eto.Forms.Control.Load}, etc. events.
			 */
			AttachNative(): void;

			/**
			 * Detaches the control when it is used in a native application, when you want to reuse
			 * the control.
			 *
			 * This should only be called after {@link Eto.Forms.Control.AttachNative} has been
			 * called, which is usually done by calling to ToNative(true) .
			 */
			DetachNative(): void;

			/**
			 * Attempts to set the keyboard input focus to this control, or the first child that
			 * accepts focus. For Windows, this will bring it to front and activate it.
			 */
			Focus(): void;

			/**
			 * Suspends the layout of child controls
			 *
			 * This can be used to optimize some platforms while adding, removing, or changing many
			 * child controls at once. It disables the calculation of control positioning until
			 * {@link Eto.Forms.Control.ResumeLayout} is called. Each call to SuspendLayout() must be
			 * balanced with a call to {@link Eto.Forms.Control.ResumeLayout}.
			 */
			SuspendLayout(): void;

			/**
			 * Resumes the layout after it has been suspended, and performs a layout
			 *
			 * This can be used to optimize some platforms while adding, removing, or changing many
			 * child controls at once. Each call to ResumeLayout() must be balanced with a call to
			 * {@link Eto.Forms.Control.SuspendLayout} before it.
			 */
			ResumeLayout(): void;

			/**
			 * Specifies a command to execute for a platform-specific command
			 *
			 * Some platforms have specific system-defined commands that can be associated with a
			 * control. For example, the Mac platform's cut/copy/paste functionality is defined by
			 * the system, and if you want to hook into it, you can use this to map it to your own
			 * defined logic. The valid values of the `systemCommand` parameter are defined by each
			 * platform, and a list can be retrieved using
			 * {@link Eto.Forms.Control.SupportedPlatformCommands}
			 */
			MapPlatformCommand(
				systemCommand: string,
				command: Eto.Forms.Command,
			): void;

			/** Converts a point from screen space to control space. */
			PointFromScreen(point: Eto.Drawing.PointF): Eto.Drawing.PointF;

			/** Converts a point from control space to screen space */
			PointToScreen(point: Eto.Drawing.PointF): Eto.Drawing.PointF;

			/** Converts a rectangle from screen space to control space. */
			RectangleToScreen(rect: Eto.Drawing.RectangleF): Eto.Drawing.RectangleF;

			/** Converts a rectangle from control space to screen space */
			RectangleFromScreen(rect: Eto.Drawing.RectangleF): Eto.Drawing.RectangleF;

			/**
			 * Starts drag operation using this control as drag source.
			 *
			 * This method can be blocking on some platforms (Wpf, WinForms), and non-blocking on
			 * others (Mac, Gtk). Use the {@link Eto.Forms.Control.DragEnd} event to determine when
			 * the drag operation is completed and get its resulting DragEffects.
			 */
			DoDragDrop(
				data: Eto.Forms.DataObject,
				allowedEffects: Eto.Forms.DragEffects,
			): void;

			/**
			 * Starts drag operation using this control as drag source.
			 *
			 * This method can be blocking on some platforms (Wpf, WinForms), and non-blocking on
			 * others (Mac, Gtk). Use the {@link Eto.Forms.Control.DragEnd} event to determine when
			 * the drag operation is completed and get its resulting DragEffects.
			 */
			DoDragDrop(
				data: Eto.Forms.DataObject,
				allowedEffects: Eto.Forms.DragEffects,
				image: Eto.Drawing.Image,
				cursorOffset: Eto.Drawing.PointF,
			): void;

			/**
			 * Triggers the StyleChanged event and re-applies the styles to this control and its
			 * children.
			 */
			TriggerStyleChanged(): void;

			/** Shows a print dialog to print the specified control */
			Print(): void;

			/**
			 * Finds a control in the parent hierarchy with the specified type and
			 * {@link Eto.Widget.ID} if specified
			 */
			FindParent<T>(id?: string): T;

			/**
			 * Finds a control in the parent hierarchy with the specified type and
			 * {@link Eto.Widget.ID} if specified
			 */
			FindParent(
				type: unknown,
				id?: string,
			): Eto.Widget;

			/** Finds a control in the parent hierarchy with the specified `id` */
			FindParent(id: string): Eto.Widget;

			/**
			 * Unbinds any bindings in the {@link Eto.Forms.BindableWidget.Bindings} collection and
			 * removes the bindings
			 *
			 * When you implement {@link Eto.Forms.IBindableWidgetContainer}, this will also unbind
			 * any of its children.
			 */
			Unbind(): void;

			/**
			 * Updates all bindings in this widget
			 *
			 * When you implement {@link Eto.Forms.IBindableWidgetContainer}, this will also update
			 * bindings for all of its children.
			 */
			UpdateBindings(mode?: Eto.Forms.BindingUpdateMode): void;

			/** Disposes of this widget, supressing the finalizer */
			dispose(): void;

			/** Gets a string that represents the current object with its ID if specified. */
			ToString(): string;
		}
	}

	export namespace Eto.Forms.GridView {
		export interface IHandler extends
			Eto.Forms.Grid.IHandler,
			Eto.Forms.Control.IHandler,
			Eto.Widget.IHandler,
			Eto.Forms.IContextMenuHost {
			DataStore: Iterable<unknown>;

			readonly SelectedItems: Iterable<unknown>;

			ReloadData(rows: Iterable<number>): void;

			GetCellAt(location: Eto.Drawing.PointF): Eto.Forms.GridCell;

			GetDragInfo(args: Eto.Forms.DragEventArgs): Eto.Forms.GridViewDragInfo;
		}
	}

	export namespace Eto.Forms {
		/** Interface elment to group controls inside a box with an optional title */
		export class GroupBox implements
			Eto.IHandlerSource,
			Eto.Forms.IBindable,
			Eto.Forms.IMouseInputSource,
			Eto.Forms.IKeyboardInputSource {
			constructor();

			/** Gets or sets the font used for the title */
			Font: Eto.Drawing.Font;

			/** Gets or sets the title text. */
			Text: string;

			/**
			 * Gets or sets the color of the text.
			 *
			 * By default, the text will get a color based on the user's theme. However, this is
			 * usually black.
			 */
			TextColor: Eto.Drawing.Color;

			/** Gets an enumeration of controls that are directly contained by this container */
			readonly Controls: Iterable<Eto.Forms.Control>;

			/** Gets or sets the padding around the {@link Eto.Forms.Panel.Content} of the panel. */
			Padding: Eto.Drawing.Padding;

			/** Gets or sets the minimum size of the panel. */
			MinimumSize: Eto.Drawing.Size;

			/**
			 * Gets or sets the context menu for the panel.
			 *
			 * The context menu is usually shown when the user right clicks the control, or in mobile
			 * platforms when the user taps and holds their finger down on the control.
			 */
			ContextMenu: Eto.Forms.ContextMenu;

			/**
			 * Gets or sets the main content of the panel.
			 *
			 * The main content will be offset by the {@link Eto.Forms.Panel.Padding} value
			 * specified, and will take up the entire content area of the control. Some controls may
			 * have decorations that will surround the content, such as a {@link Eto.Forms.GroupBox},
			 * {@link Eto.Forms.TabControl}, or {@link Eto.Forms.Window}
			 */
			Content: Eto.Forms.Control;

			/**
			 * Gets or sets the size for the client area of the control
			 *
			 * The client size differs from the {@link Eto.Forms.Control.Size} in that it excludes
			 * the decorations of the container, such as the title bar and border around a
			 * {@link Eto.Forms.Window}, or the title and line  around a {@link Eto.Forms.GroupBox}.
			 */
			ClientSize: Eto.Drawing.Size;

			/**
			 * Gets an enumeration of all contained child controls, including controls within child
			 * containers
			 */
			readonly Children: Iterable<Eto.Forms.Control>;

			/**
			 * Gets an enumeration of all contained child controls in the visual tree, including
			 * controls within child containers.
			 */
			readonly VisualChildren: Iterable<Eto.Forms.Control>;

			/**
			 * Gets or sets the style provider for this container.
			 *
			 * The style provider is used to style this container and its children.
			 */
			StyleProvider: Eto.IStyleProvider;

			/**
			 * Gets the default style provider for this container.
			 *
			 * Use this to apply styles to any child controls of this container. By default, styles
			 * will apply to all children, including children of children unless
			 * {@link Eto.DefaultStyleProvider.Inherit} is set to false .  Typically, you would set
			 * Inherit to false when creating composite controls that already have all their styles
			 * applied and you don't want any other styles to be inherited.
			 */
			readonly Styles: Eto.DefaultStyleProvider;

			/**
			 * Gets a value indicating that the control is loaded onto a form, that is it has been
			 * created, added to a parent, and shown
			 *
			 * The {@link Eto.Forms.Control.OnLoad(System.EventArgs)} method sets this value to true
			 * after cascading to all children (for a {@link Eto.Forms.Container} ) and calling the
			 * platform handler's implementation.  It is called after adding to a loaded form, or
			 * when showing a new form.  The {@link Eto.Forms.Control.OnUnLoad(System.EventArgs)}
			 * method will set this value to false when the control is removed from its parent
			 */
			readonly Loaded: boolean;

			/**
			 * Gets an enumeration of controls that are in the visual tree.
			 *
			 * This is used to specify which controls are contained by this instance that are part of
			 * the visual tree. This should include all controls including non-logical Eto controls
			 * used for layout.
			 */
			readonly VisualControls: Iterable<Eto.Forms.Control>;

			/**
			 * Gets or sets a user-defined object that contains data about the control
			 *
			 * A common use of the tag property is to store data that is associated with the control
			 * that you can later retrieve.
			 */
			Tag: unknown;

			/**
			 * Gets the logical parent control.
			 *
			 * When the control is part of the visual tree (
				 * {@link Eto.Forms.Control.IsVisualControl} is true), this returns the logical parent
				 * that contains this control. Otherwise this is the same as
				 * {@link Eto.Forms.Control.Parent}.
				 */
				readonly LogicalParent: Eto.Forms.Container;

			/** Gets a value indicating this {@link Eto.Forms.Control} is part of the visual tree. */
			IsVisualControl: boolean;

			/**
			 * Gets or sets the size of the control. Use -1 to specify auto sizing for either the
			 * width and/or height.
			 *
			 * Setting the size of controls is entirely optional as most controls will size
			 * themselves appropriately. When specifying a size, it will be used as the desired size
			 * of the control.  The container will reposition and resize the control depending on the
			 * available size.  For a {@link Eto.Forms.Window}, it is preferred to set the
			 * {@link Eto.Forms.Container.ClientSize} instead, as various platforms have different
			 * sizes of window decorations, toolbars, etc.
			 */
			Size: Eto.Drawing.Size;

			/**
			 * Gets a value indicating this control currently has mouse capture
			 *
			 * Mouse capture can happen during a handled MouseDown event until MouseUp, or it can be
			 * captured explicitly via {@link Eto.Forms.Control.CaptureMouse}.
			 */
			readonly IsMouseCaptured: boolean;

			/** Gets or sets the width of the control size. */
			Width: number;

			/** Gets or sets the height of the control size. */
			Height: number;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Forms.Control} (or its
			 * children) are enabled and accept user input.
			 *
			 * Typically when a control is disabled, the user cannot do anything with the control or
			 * any of its children. Including for example, selecting text in a text control. Certain
			 * controls can have a 'Read Only' mode, such as {@link Eto.Forms.TextBox.ReadOnly} which
			 * allow the user to  select text, but not change its contents.
			 */
			Enabled: boolean;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Forms.Control} is visible to
			 * the user.
			 *
			 * When the visibility of a control is set to false, it will not occupy space in the
			 * layout.
			 */
			Visible: boolean;

			/** Gets the container which this control has been added to, if any */
			readonly Parent: Eto.Forms.Container;

			/**
			 * Gets the visual container of this control, if any.
			 *
			 * Some containers may use other Eto controls to layout its children, such as the
			 * {@link Eto.Forms.StackLayout}. This will return the parent control that visually
			 * contains this control as opposed to {@link Eto.Forms.Control.Parent} which will return
			 * the logical parent.
			 */
			VisualParent: Eto.Forms.Container;

			/** Gets a value indicating this control has been attached to a native container */
			readonly IsAttached: boolean;

			/**
			 * Gets or sets the color for the background of the control
			 *
			 * Note that on some platforms (e.g. Mac), setting the background color of a control can
			 * change the performance characteristics of the control and its children, since it must
			 * enable layers to do so.
			 */
			BackgroundColor: Eto.Drawing.Color;

			/** Gets a value indicating whether this instance has the keyboard input focus. */
			readonly HasFocus: boolean;

			/** Gets a value indicating whether the layout of child controls is suspended. */
			readonly IsSuspended: boolean;

			/** Gets the window this control is contained in */
			readonly ParentWindow: Eto.Forms.Window;

			/**
			 * Gets the supported platform commands that can be used to hook up system functions to
			 * user defined logic
			 *
			 * This lists all available commands that can be mapped using the
			 * {@link Eto.Forms.Control.MapPlatformCommand(System.String,Eto.Forms.Command)} method
			 * of the control.
			 */
			readonly SupportedPlatformCommands: Iterable<string>;

			/** Gets the bounding rectangle of this control relative to its container */
			readonly Bounds: Eto.Drawing.Rectangle;

			/**
			 * Gets the location of the control as positioned by the container
			 *
			 * A control's location is set by the container. This can be used to determine where the
			 * control is for overlaying floating windows, menus, etc.
			 */
			readonly Location: Eto.Drawing.Point;

			/** Gets or sets the type of cursor to use when the mouse is hovering over the control */
			Cursor: Eto.Forms.Cursor;

			/** Gets or sets the tool tip to show when the mouse is hovered over the control */
			ToolTip: string;

			/**
			 * Gets or sets the tab index order for this control within its container.
			 *
			 * This sets the order when using the tab key to cycle through controls  Note that some
			 * platforms (Gtk and WinForms) may not support setting the context of the tab order to
			 * StackLayout  or DynamicLayout containers and may not behave exactly as expected. Use
			 * the {@link Eto.PlatformFeatures.TabIndexWithCustomContainers} flag to determine if it
			 * is supported.
			 */
			TabIndex: number;

			/** Gets or sets a value indicating whether this control can serve as drop target. */
			AllowDrop: boolean;

			/**
			 * Gets or sets the parent widget which this widget has been added to, if any
			 *
			 * When implementing child widgets that can participate in the context based binding
			 * (MVVM), You can set this to the parent widget when it is added or removed to it
			 * (usually via a collection).  Note that you should typically provide a public new
			 * [ParentWidget] Parent { get; } property  so that consumers of your API cannot set the
			 * parent to an invalid value.
			 */
			Parent: Eto.Widget;

			/**
			 * Gets an enumeration of all parent widgets in the heirarchy by traversing the
			 * {@link Eto.Forms.BindableWidget.Parent} property.
			 */
			readonly Parents: Iterable<Eto.Widget>;

			/**
			 * Gets or sets the data context for this widget for binding
			 *
			 * Subclasses may override the standard behaviour so that hierarchy of widgets can be
			 * taken into account.  For example, a Control may return the data context of a parent,
			 * if it is not set explicitly.
			 */
			DataContext: unknown;

			/** Gets the collection of bindings that are attached to this widget */
			readonly Bindings: Eto.Forms.BindingCollection;

			/**
			 * Gets a value indicating that the {@link Eto.Forms.BindableWidget.DataContext} property
			 * is changing.
			 *
			 * This can be used to determine when to allow certain logic during the update of the
			 * data context.  It is used to disable binding setters on the model when the data
			 * context changes so that a binding does not cause the view model to be updated when the
			 * state hasn't been fully set yet.
			 */
			IsDataContextChanging: boolean;

			/**
			 * Gets the platform that was used to create the {@link Eto.Widget.Handler} for this
			 * widget
			 *
			 * This gets set to the current {@link Eto.Platform.Instance} during the construction of
			 * the object
			 */
			readonly Platform: Eto.Platform;

			/** Gets the platform-specific handler for this widget */
			Handler: unknown;

			/** Gets the native platform-specific handle for integration purposes */
			readonly NativeHandle: unknown;

			/** Gets the dictionary of properties for this widget */
			readonly Properties: Eto.PropertyStore;

			/** Gets or sets the ID of this widget */
			ID: string;

			/**
			 * Gets or sets the style of this widget
			 *
			 * Styles allow you to attach custom platform-specific logic to a widget. In your
			 * platform-specific assembly, use {@link Style.Add{H}(string, StyleHandler{H})} to add
			 * the style logic with the same id.
			 */
			Style: string;

			/**
			 * Gets the instance of the platform-specific object
			 *
			 * This can sometimes be useful to get the platform-specific object. Some handlers may
			 * not have any backing object for its functionality, so this may be null.  It is more
			 * preferred to use the {@link Eto.Widget.Handler} and cast that to the platform-specific
			 * handler class which can give you additional methods and helpers to do common tasks.
			 * For example, the {@link Eto.Forms.Application} object's handler for OS X has a
			 * AddFullScreenMenuItem property to specify if you want full screen support in your app.
			 */
			readonly ControlObject: unknown;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Widget} has been disposed.
			 *
			 * When the widget is disposed, it can no longer be used.
			 */
			IsDisposed: boolean;

			/** Removes the specified child from the container */
			Remove(child: Eto.Forms.Control): void;

			/** Remove the specified `controls` from this container */
			Remove(controls: Iterable<Eto.Forms.Control>): void;

			/** Removes all controls from this container */
			RemoveAll(): void;

			/**
			 * Finds a child control in this container or any of its child containers with the
			 * specified `id`
			 */
			FindChild<T>(id?: string): T;

			/**
			 * Finds a child control in this container or any of its child containers with the
			 * specified `type`
			 */
			FindChild(
				type: unknown,
				id?: string,
			): Eto.Forms.Control;

			/**
			 * Finds a child control in this container or any of its child containers with the
			 * specified `id`.
			 */
			FindChild(id: string): Eto.Forms.Control;

			/**
			 * Queues a repaint of the entire control on the screen and any of its children.
			 *
			 * This is only useful when the control is visible.
			 */
			Invalidate(): void;

			/**
			 * Queues a repaint of the entire control on the screen
			 *
			 * This is only useful when the control is visible.
			 */
			Invalidate(invalidateChildren: boolean): void;

			/**
			 * Queues a repaint of the specified `rect` of the control and any children.
			 *
			 * This is only useful when the control is visible.
			 */
			Invalidate(rect: Eto.Drawing.Rectangle): void;

			/**
			 * Queues a repaint of the specified `rect` of the control
			 *
			 * This is only useful when the control is visible.
			 */
			Invalidate(
				rect: Eto.Drawing.Rectangle,
				invalidateChildren: boolean,
			): void;

			/**
			 * Updates the layout of this control if necessary.
			 *
			 * This will ensure the control has had all of its layout applied so you can use its
			 * position and size right after this call. Most platforms (except WinForms) use a
			 * deferred layout system so that after adding your control to the form dynamically it
			 * won't get laid out until the next idle loop. This is useful when you need to know the
			 * dimensions of the control immediately. Note that this can be an expensive operation,
			 * so it is recommended to only call this method when necessary and after all of the
			 * controls have been added/updated.
			 */
			UpdateLayout(): void;

			/** Gets the preferred size of this control given infinite space available. */
			GetPreferredSize(): Eto.Drawing.SizeF;

			/** Gets the preferred size of this control given the specified `availableSize`. */
			GetPreferredSize(availableSize: Eto.Drawing.SizeF): Eto.Drawing.SizeF;

			/**
			 * Captures all mouse events to this control.
			 *
			 * This captures all mouse events until {@link Eto.Forms.Control.ReleaseMouseCapture} is
			 * called.  Note that not all platforms will allow a mouse capture unless the mouse is
			 * currently down.
			 */
			CaptureMouse(): boolean;

			/** Releases the mouse capture after a call to {@link Eto.Forms.Control.CaptureMouse}. */
			ReleaseMouseCapture(): void;

			/**
			 * Finds a control in the parent hierarchy with the specified type and
			 * {@link Eto.Widget.ID} if specified
			 */
			FindParent(
				type: unknown,
				id?: string,
			): Eto.Forms.Container;

			/** Finds a control in the parent hierarchy with the specified `id` */
			FindParent(id: string): Eto.Forms.Container;

			/**
			 * Detaches the control by removing it from its parent
			 *
			 * This is essentially a shortcut to myControl.Parent.Remove(myControl);
			 */
			Detach(): void;

			/**
			 * Attaches the control for direct use in a native application
			 *
			 * Use this to use a control directly in a native application.  Note that the native
			 * application must be running the same framework as the current platform.  E.g. a
			 * WinForms application can use an Eto.Forms control when using the Eto.WinForms
			 * platform.  This prepares the control by firing the {@link Eto.Forms.Control.PreLoad},
			 * {@link Eto.Forms.Control.Load}, etc. events.
			 */
			AttachNative(): void;

			/**
			 * Detaches the control when it is used in a native application, when you want to reuse
			 * the control.
			 *
			 * This should only be called after {@link Eto.Forms.Control.AttachNative} has been
			 * called, which is usually done by calling to ToNative(true) .
			 */
			DetachNative(): void;

			/**
			 * Attempts to set the keyboard input focus to this control, or the first child that
			 * accepts focus. For Windows, this will bring it to front and activate it.
			 */
			Focus(): void;

			/**
			 * Suspends the layout of child controls
			 *
			 * This can be used to optimize some platforms while adding, removing, or changing many
			 * child controls at once. It disables the calculation of control positioning until
			 * {@link Eto.Forms.Control.ResumeLayout} is called. Each call to SuspendLayout() must be
			 * balanced with a call to {@link Eto.Forms.Control.ResumeLayout}.
			 */
			SuspendLayout(): void;

			/**
			 * Resumes the layout after it has been suspended, and performs a layout
			 *
			 * This can be used to optimize some platforms while adding, removing, or changing many
			 * child controls at once. Each call to ResumeLayout() must be balanced with a call to
			 * {@link Eto.Forms.Control.SuspendLayout} before it.
			 */
			ResumeLayout(): void;

			/**
			 * Specifies a command to execute for a platform-specific command
			 *
			 * Some platforms have specific system-defined commands that can be associated with a
			 * control. For example, the Mac platform's cut/copy/paste functionality is defined by
			 * the system, and if you want to hook into it, you can use this to map it to your own
			 * defined logic. The valid values of the `systemCommand` parameter are defined by each
			 * platform, and a list can be retrieved using
			 * {@link Eto.Forms.Control.SupportedPlatformCommands}
			 */
			MapPlatformCommand(
				systemCommand: string,
				command: Eto.Forms.Command,
			): void;

			/** Converts a point from screen space to control space. */
			PointFromScreen(point: Eto.Drawing.PointF): Eto.Drawing.PointF;

			/** Converts a point from control space to screen space */
			PointToScreen(point: Eto.Drawing.PointF): Eto.Drawing.PointF;

			/** Converts a rectangle from screen space to control space. */
			RectangleToScreen(rect: Eto.Drawing.RectangleF): Eto.Drawing.RectangleF;

			/** Converts a rectangle from control space to screen space */
			RectangleFromScreen(rect: Eto.Drawing.RectangleF): Eto.Drawing.RectangleF;

			/**
			 * Starts drag operation using this control as drag source.
			 *
			 * This method can be blocking on some platforms (Wpf, WinForms), and non-blocking on
			 * others (Mac, Gtk). Use the {@link Eto.Forms.Control.DragEnd} event to determine when
			 * the drag operation is completed and get its resulting DragEffects.
			 */
			DoDragDrop(
				data: Eto.Forms.DataObject,
				allowedEffects: Eto.Forms.DragEffects,
			): void;

			/**
			 * Starts drag operation using this control as drag source.
			 *
			 * This method can be blocking on some platforms (Wpf, WinForms), and non-blocking on
			 * others (Mac, Gtk). Use the {@link Eto.Forms.Control.DragEnd} event to determine when
			 * the drag operation is completed and get its resulting DragEffects.
			 */
			DoDragDrop(
				data: Eto.Forms.DataObject,
				allowedEffects: Eto.Forms.DragEffects,
				image: Eto.Drawing.Image,
				cursorOffset: Eto.Drawing.PointF,
			): void;

			/**
			 * Triggers the StyleChanged event and re-applies the styles to this control and its
			 * children.
			 */
			TriggerStyleChanged(): void;

			/** Shows a print dialog to print the specified control */
			Print(): void;

			/**
			 * Finds a control in the parent hierarchy with the specified type and
			 * {@link Eto.Widget.ID} if specified
			 */
			FindParent<T>(id?: string): T;

			/**
			 * Finds a control in the parent hierarchy with the specified type and
			 * {@link Eto.Widget.ID} if specified
			 */
			FindParent(
				type: unknown,
				id?: string,
			): Eto.Widget;

			/** Finds a control in the parent hierarchy with the specified `id` */
			FindParent(id: string): Eto.Widget;

			/**
			 * Unbinds any bindings in the {@link Eto.Forms.BindableWidget.Bindings} collection and
			 * removes the bindings
			 *
			 * When you implement {@link Eto.Forms.IBindableWidgetContainer}, this will also unbind
			 * any of its children.
			 */
			Unbind(): void;

			/**
			 * Updates all bindings in this widget
			 *
			 * When you implement {@link Eto.Forms.IBindableWidgetContainer}, this will also update
			 * bindings for all of its children.
			 */
			UpdateBindings(mode?: Eto.Forms.BindingUpdateMode): void;

			/** Disposes of this widget, supressing the finalizer */
			dispose(): void;

			/** Gets a string that represents the current object with its ID if specified. */
			ToString(): string;
		}
	}

	export namespace Eto.Forms.GroupBox {
		export interface IHandler extends
			Eto.Forms.Panel.IHandler,
			Eto.Forms.Container.IHandler,
			Eto.Forms.Control.IHandler,
			Eto.Widget.IHandler,
			Eto.Forms.IContextMenuHost {
			Font: Eto.Drawing.Font;

			Text: string;

			TextColor: Eto.Drawing.Color;
		}
	}

	export namespace Eto.Forms {
		/**
		 * Control to display an image
		 *
		 * By default, the ImageView will automatically size to the size of the specified
		 * {@link Eto.Forms.ImageView.Image}, otherwise the image will be scaled to fit inside
		 * the available area for the control.
		 */
		export class ImageView implements
			Eto.IHandlerSource,
			Eto.Forms.IBindable,
			Eto.Forms.IMouseInputSource,
			Eto.Forms.IKeyboardInputSource {
			constructor();

			/** Gets or sets the image to display. */
			Image: Eto.Drawing.Image;

			/**
			 * Gets a value indicating that the control is loaded onto a form, that is it has been
			 * created, added to a parent, and shown
			 *
			 * The {@link Eto.Forms.Control.OnLoad(System.EventArgs)} method sets this value to true
			 * after cascading to all children (for a {@link Eto.Forms.Container} ) and calling the
			 * platform handler's implementation.  It is called after adding to a loaded form, or
			 * when showing a new form.  The {@link Eto.Forms.Control.OnUnLoad(System.EventArgs)}
			 * method will set this value to false when the control is removed from its parent
			 */
			readonly Loaded: boolean;

			/**
			 * Gets an enumeration of controls that are in the visual tree.
			 *
			 * This is used to specify which controls are contained by this instance that are part of
			 * the visual tree. This should include all controls including non-logical Eto controls
			 * used for layout.
			 */
			readonly VisualControls: Iterable<Eto.Forms.Control>;

			/**
			 * Gets or sets a user-defined object that contains data about the control
			 *
			 * A common use of the tag property is to store data that is associated with the control
			 * that you can later retrieve.
			 */
			Tag: unknown;

			/**
			 * Gets the logical parent control.
			 *
			 * When the control is part of the visual tree (
				 * {@link Eto.Forms.Control.IsVisualControl} is true), this returns the logical parent
				 * that contains this control. Otherwise this is the same as
				 * {@link Eto.Forms.Control.Parent}.
				 */
				readonly LogicalParent: Eto.Forms.Container;

			/** Gets a value indicating this {@link Eto.Forms.Control} is part of the visual tree. */
			IsVisualControl: boolean;

			/**
			 * Gets or sets the size of the control. Use -1 to specify auto sizing for either the
			 * width and/or height.
			 *
			 * Setting the size of controls is entirely optional as most controls will size
			 * themselves appropriately. When specifying a size, it will be used as the desired size
			 * of the control.  The container will reposition and resize the control depending on the
			 * available size.  For a {@link Eto.Forms.Window}, it is preferred to set the
			 * {@link Eto.Forms.Container.ClientSize} instead, as various platforms have different
			 * sizes of window decorations, toolbars, etc.
			 */
			Size: Eto.Drawing.Size;

			/**
			 * Gets a value indicating this control currently has mouse capture
			 *
			 * Mouse capture can happen during a handled MouseDown event until MouseUp, or it can be
			 * captured explicitly via {@link Eto.Forms.Control.CaptureMouse}.
			 */
			readonly IsMouseCaptured: boolean;

			/** Gets or sets the width of the control size. */
			Width: number;

			/** Gets or sets the height of the control size. */
			Height: number;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Forms.Control} (or its
			 * children) are enabled and accept user input.
			 *
			 * Typically when a control is disabled, the user cannot do anything with the control or
			 * any of its children. Including for example, selecting text in a text control. Certain
			 * controls can have a 'Read Only' mode, such as {@link Eto.Forms.TextBox.ReadOnly} which
			 * allow the user to  select text, but not change its contents.
			 */
			Enabled: boolean;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Forms.Control} is visible to
			 * the user.
			 *
			 * When the visibility of a control is set to false, it will not occupy space in the
			 * layout.
			 */
			Visible: boolean;

			/** Gets the container which this control has been added to, if any */
			readonly Parent: Eto.Forms.Container;

			/**
			 * Gets the visual container of this control, if any.
			 *
			 * Some containers may use other Eto controls to layout its children, such as the
			 * {@link Eto.Forms.StackLayout}. This will return the parent control that visually
			 * contains this control as opposed to {@link Eto.Forms.Control.Parent} which will return
			 * the logical parent.
			 */
			VisualParent: Eto.Forms.Container;

			/** Gets a value indicating this control has been attached to a native container */
			readonly IsAttached: boolean;

			/**
			 * Gets or sets the color for the background of the control
			 *
			 * Note that on some platforms (e.g. Mac), setting the background color of a control can
			 * change the performance characteristics of the control and its children, since it must
			 * enable layers to do so.
			 */
			BackgroundColor: Eto.Drawing.Color;

			/** Gets a value indicating whether this instance has the keyboard input focus. */
			readonly HasFocus: boolean;

			/** Gets a value indicating whether the layout of child controls is suspended. */
			readonly IsSuspended: boolean;

			/** Gets the window this control is contained in */
			readonly ParentWindow: Eto.Forms.Window;

			/**
			 * Gets the supported platform commands that can be used to hook up system functions to
			 * user defined logic
			 *
			 * This lists all available commands that can be mapped using the
			 * {@link Eto.Forms.Control.MapPlatformCommand(System.String,Eto.Forms.Command)} method
			 * of the control.
			 */
			readonly SupportedPlatformCommands: Iterable<string>;

			/** Gets the bounding rectangle of this control relative to its container */
			readonly Bounds: Eto.Drawing.Rectangle;

			/**
			 * Gets the location of the control as positioned by the container
			 *
			 * A control's location is set by the container. This can be used to determine where the
			 * control is for overlaying floating windows, menus, etc.
			 */
			readonly Location: Eto.Drawing.Point;

			/** Gets or sets the type of cursor to use when the mouse is hovering over the control */
			Cursor: Eto.Forms.Cursor;

			/** Gets or sets the tool tip to show when the mouse is hovered over the control */
			ToolTip: string;

			/**
			 * Gets or sets the tab index order for this control within its container.
			 *
			 * This sets the order when using the tab key to cycle through controls  Note that some
			 * platforms (Gtk and WinForms) may not support setting the context of the tab order to
			 * StackLayout  or DynamicLayout containers and may not behave exactly as expected. Use
			 * the {@link Eto.PlatformFeatures.TabIndexWithCustomContainers} flag to determine if it
			 * is supported.
			 */
			TabIndex: number;

			/** Gets or sets a value indicating whether this control can serve as drop target. */
			AllowDrop: boolean;

			/**
			 * Gets or sets the parent widget which this widget has been added to, if any
			 *
			 * When implementing child widgets that can participate in the context based binding
			 * (MVVM), You can set this to the parent widget when it is added or removed to it
			 * (usually via a collection).  Note that you should typically provide a public new
			 * [ParentWidget] Parent { get; } property  so that consumers of your API cannot set the
			 * parent to an invalid value.
			 */
			Parent: Eto.Widget;

			/**
			 * Gets an enumeration of all parent widgets in the heirarchy by traversing the
			 * {@link Eto.Forms.BindableWidget.Parent} property.
			 */
			readonly Parents: Iterable<Eto.Widget>;

			/**
			 * Gets or sets the data context for this widget for binding
			 *
			 * Subclasses may override the standard behaviour so that hierarchy of widgets can be
			 * taken into account.  For example, a Control may return the data context of a parent,
			 * if it is not set explicitly.
			 */
			DataContext: unknown;

			/** Gets the collection of bindings that are attached to this widget */
			readonly Bindings: Eto.Forms.BindingCollection;

			/**
			 * Gets a value indicating that the {@link Eto.Forms.BindableWidget.DataContext} property
			 * is changing.
			 *
			 * This can be used to determine when to allow certain logic during the update of the
			 * data context.  It is used to disable binding setters on the model when the data
			 * context changes so that a binding does not cause the view model to be updated when the
			 * state hasn't been fully set yet.
			 */
			IsDataContextChanging: boolean;

			/**
			 * Gets the platform that was used to create the {@link Eto.Widget.Handler} for this
			 * widget
			 *
			 * This gets set to the current {@link Eto.Platform.Instance} during the construction of
			 * the object
			 */
			readonly Platform: Eto.Platform;

			/** Gets the platform-specific handler for this widget */
			Handler: unknown;

			/** Gets the native platform-specific handle for integration purposes */
			readonly NativeHandle: unknown;

			/** Gets the dictionary of properties for this widget */
			readonly Properties: Eto.PropertyStore;

			/** Gets or sets the ID of this widget */
			ID: string;

			/**
			 * Gets or sets the style of this widget
			 *
			 * Styles allow you to attach custom platform-specific logic to a widget. In your
			 * platform-specific assembly, use {@link Style.Add{H}(string, StyleHandler{H})} to add
			 * the style logic with the same id.
			 */
			Style: string;

			/**
			 * Gets the instance of the platform-specific object
			 *
			 * This can sometimes be useful to get the platform-specific object. Some handlers may
			 * not have any backing object for its functionality, so this may be null.  It is more
			 * preferred to use the {@link Eto.Widget.Handler} and cast that to the platform-specific
			 * handler class which can give you additional methods and helpers to do common tasks.
			 * For example, the {@link Eto.Forms.Application} object's handler for OS X has a
			 * AddFullScreenMenuItem property to specify if you want full screen support in your app.
			 */
			readonly ControlObject: unknown;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Widget} has been disposed.
			 *
			 * When the widget is disposed, it can no longer be used.
			 */
			IsDisposed: boolean;

			/**
			 * Queues a repaint of the entire control on the screen and any of its children.
			 *
			 * This is only useful when the control is visible.
			 */
			Invalidate(): void;

			/**
			 * Queues a repaint of the entire control on the screen
			 *
			 * This is only useful when the control is visible.
			 */
			Invalidate(invalidateChildren: boolean): void;

			/**
			 * Queues a repaint of the specified `rect` of the control and any children.
			 *
			 * This is only useful when the control is visible.
			 */
			Invalidate(rect: Eto.Drawing.Rectangle): void;

			/**
			 * Queues a repaint of the specified `rect` of the control
			 *
			 * This is only useful when the control is visible.
			 */
			Invalidate(
				rect: Eto.Drawing.Rectangle,
				invalidateChildren: boolean,
			): void;

			/**
			 * Updates the layout of this control if necessary.
			 *
			 * This will ensure the control has had all of its layout applied so you can use its
			 * position and size right after this call. Most platforms (except WinForms) use a
			 * deferred layout system so that after adding your control to the form dynamically it
			 * won't get laid out until the next idle loop. This is useful when you need to know the
			 * dimensions of the control immediately. Note that this can be an expensive operation,
			 * so it is recommended to only call this method when necessary and after all of the
			 * controls have been added/updated.
			 */
			UpdateLayout(): void;

			/** Gets the preferred size of this control given infinite space available. */
			GetPreferredSize(): Eto.Drawing.SizeF;

			/** Gets the preferred size of this control given the specified `availableSize`. */
			GetPreferredSize(availableSize: Eto.Drawing.SizeF): Eto.Drawing.SizeF;

			/**
			 * Captures all mouse events to this control.
			 *
			 * This captures all mouse events until {@link Eto.Forms.Control.ReleaseMouseCapture} is
			 * called.  Note that not all platforms will allow a mouse capture unless the mouse is
			 * currently down.
			 */
			CaptureMouse(): boolean;

			/** Releases the mouse capture after a call to {@link Eto.Forms.Control.CaptureMouse}. */
			ReleaseMouseCapture(): void;

			/**
			 * Finds a control in the parent hierarchy with the specified type and
			 * {@link Eto.Widget.ID} if specified
			 */
			FindParent(
				type: unknown,
				id?: string,
			): Eto.Forms.Container;

			/** Finds a control in the parent hierarchy with the specified `id` */
			FindParent(id: string): Eto.Forms.Container;

			/**
			 * Detaches the control by removing it from its parent
			 *
			 * This is essentially a shortcut to myControl.Parent.Remove(myControl);
			 */
			Detach(): void;

			/**
			 * Attaches the control for direct use in a native application
			 *
			 * Use this to use a control directly in a native application.  Note that the native
			 * application must be running the same framework as the current platform.  E.g. a
			 * WinForms application can use an Eto.Forms control when using the Eto.WinForms
			 * platform.  This prepares the control by firing the {@link Eto.Forms.Control.PreLoad},
			 * {@link Eto.Forms.Control.Load}, etc. events.
			 */
			AttachNative(): void;

			/**
			 * Detaches the control when it is used in a native application, when you want to reuse
			 * the control.
			 *
			 * This should only be called after {@link Eto.Forms.Control.AttachNative} has been
			 * called, which is usually done by calling to ToNative(true) .
			 */
			DetachNative(): void;

			/**
			 * Attempts to set the keyboard input focus to this control, or the first child that
			 * accepts focus. For Windows, this will bring it to front and activate it.
			 */
			Focus(): void;

			/**
			 * Suspends the layout of child controls
			 *
			 * This can be used to optimize some platforms while adding, removing, or changing many
			 * child controls at once. It disables the calculation of control positioning until
			 * {@link Eto.Forms.Control.ResumeLayout} is called. Each call to SuspendLayout() must be
			 * balanced with a call to {@link Eto.Forms.Control.ResumeLayout}.
			 */
			SuspendLayout(): void;

			/**
			 * Resumes the layout after it has been suspended, and performs a layout
			 *
			 * This can be used to optimize some platforms while adding, removing, or changing many
			 * child controls at once. Each call to ResumeLayout() must be balanced with a call to
			 * {@link Eto.Forms.Control.SuspendLayout} before it.
			 */
			ResumeLayout(): void;

			/**
			 * Specifies a command to execute for a platform-specific command
			 *
			 * Some platforms have specific system-defined commands that can be associated with a
			 * control. For example, the Mac platform's cut/copy/paste functionality is defined by
			 * the system, and if you want to hook into it, you can use this to map it to your own
			 * defined logic. The valid values of the `systemCommand` parameter are defined by each
			 * platform, and a list can be retrieved using
			 * {@link Eto.Forms.Control.SupportedPlatformCommands}
			 */
			MapPlatformCommand(
				systemCommand: string,
				command: Eto.Forms.Command,
			): void;

			/** Converts a point from screen space to control space. */
			PointFromScreen(point: Eto.Drawing.PointF): Eto.Drawing.PointF;

			/** Converts a point from control space to screen space */
			PointToScreen(point: Eto.Drawing.PointF): Eto.Drawing.PointF;

			/** Converts a rectangle from screen space to control space. */
			RectangleToScreen(rect: Eto.Drawing.RectangleF): Eto.Drawing.RectangleF;

			/** Converts a rectangle from control space to screen space */
			RectangleFromScreen(rect: Eto.Drawing.RectangleF): Eto.Drawing.RectangleF;

			/**
			 * Starts drag operation using this control as drag source.
			 *
			 * This method can be blocking on some platforms (Wpf, WinForms), and non-blocking on
			 * others (Mac, Gtk). Use the {@link Eto.Forms.Control.DragEnd} event to determine when
			 * the drag operation is completed and get its resulting DragEffects.
			 */
			DoDragDrop(
				data: Eto.Forms.DataObject,
				allowedEffects: Eto.Forms.DragEffects,
			): void;

			/**
			 * Starts drag operation using this control as drag source.
			 *
			 * This method can be blocking on some platforms (Wpf, WinForms), and non-blocking on
			 * others (Mac, Gtk). Use the {@link Eto.Forms.Control.DragEnd} event to determine when
			 * the drag operation is completed and get its resulting DragEffects.
			 */
			DoDragDrop(
				data: Eto.Forms.DataObject,
				allowedEffects: Eto.Forms.DragEffects,
				image: Eto.Drawing.Image,
				cursorOffset: Eto.Drawing.PointF,
			): void;

			/**
			 * Triggers the StyleChanged event and re-applies the styles to this control and its
			 * children.
			 */
			TriggerStyleChanged(): void;

			/** Shows a print dialog to print the specified control */
			Print(): void;

			/**
			 * Finds a control in the parent hierarchy with the specified type and
			 * {@link Eto.Widget.ID} if specified
			 */
			FindParent<T>(id?: string): T;

			/**
			 * Finds a control in the parent hierarchy with the specified type and
			 * {@link Eto.Widget.ID} if specified
			 */
			FindParent(
				type: unknown,
				id?: string,
			): Eto.Widget;

			/** Finds a control in the parent hierarchy with the specified `id` */
			FindParent(id: string): Eto.Widget;

			/**
			 * Unbinds any bindings in the {@link Eto.Forms.BindableWidget.Bindings} collection and
			 * removes the bindings
			 *
			 * When you implement {@link Eto.Forms.IBindableWidgetContainer}, this will also unbind
			 * any of its children.
			 */
			Unbind(): void;

			/**
			 * Updates all bindings in this widget
			 *
			 * When you implement {@link Eto.Forms.IBindableWidgetContainer}, this will also update
			 * bindings for all of its children.
			 */
			UpdateBindings(mode?: Eto.Forms.BindingUpdateMode): void;

			/** Disposes of this widget, supressing the finalizer */
			dispose(): void;

			/** Gets a string that represents the current object with its ID if specified. */
			ToString(): string;
		}
	}

	export namespace Eto.Forms.ImageView {
		export interface IHandler extends
			Eto.Forms.Control.IHandler,
			Eto.Widget.IHandler {
			Image: Eto.Drawing.Image;
		}
	}

	export namespace Eto.Forms {
		/** Type of key event */
		export enum KeyEventType {
			/** The key was pressed */
			KeyDown = 0,

			/** The key was released */
			KeyUp = 1,
		}
	}

	export namespace Eto.Forms {
		/** Arguments for key press events */
		export class KeyEventArgs {
			/**
			 * Initializes a new instance of the KeyPressEventArgs class for a character key press
			 */
			constructor(
				keyData: Eto.Forms.Keys,
				keyEventType: Eto.Forms.KeyEventType,
				keyChar?: unknown,
			);

			/** Gets the type of the key event. */
			KeyEventType: Eto.Forms.KeyEventType;

			/**
			 * Gets the raw key data (the combination of the {@link Eto.Forms.KeyEventArgs.Key} and
			 * {@link Eto.Forms.KeyEventArgs.Modifiers} )
			 */
			KeyData: Eto.Forms.Keys;

			/** Gets the key value (without modifiers) */
			readonly Key: Eto.Forms.Keys;

			/** Gets the modifier keys that were pressed for this event */
			readonly Modifiers: Eto.Forms.Keys;

			/** Gets a value indicating that the key press corresponds to a character input value */
			readonly IsChar: boolean;

			/**
			 * Gets or sets a value indicating that this event was handled by user code
			 *
			 * If you pass true for this, typically the key press will not be passed to the control
			 * for event processing. This also allows controls to handle key combinations that would
			 * otherwise be handled as a shortcut in the menu or toolbar items.
			 */
			Handled: boolean;

			/**
			 * Gets the key character corresponding to the key press (if
			 * {@link Eto.Forms.KeyEventArgs.IsChar} is true)
			 */
			readonly KeyChar: unknown;

			/** Gets whether the shift key was pressed/released for the event */
			readonly Shift: boolean;

			/** Gets whether the control key was pressed/released for the event */
			readonly Control: boolean;

			/** Gets whether the alt key was pressed/released for the event */
			readonly Alt: boolean;

			/** Gets whether the application key was pressed/released for the event */
			readonly Application: boolean;

			/** Determines whether the specified key and modifier was released */
			IsKeyUp(
				key: Eto.Forms.Keys,
				modifier?: Eto.Forms.Keys,
			): boolean;

			/** Determines whether the specified key and modifier was pressed */
			IsKeyDown(
				key: Eto.Forms.Keys,
				modifier?: Eto.Forms.Keys,
			): boolean;
		}
	}

	export namespace Eto.Forms {
		/** Specifies the text alignment for a {@link Eto.Forms.Label} */
		export enum TextAlignment {
			/** Text will be aligned to the left */
			Left = 0,

			/** Text will be aligned in the center of the label */
			Center = 1,

			/** Text will be aligned to the right */
			Right = 2,
		}
	}

	export namespace Eto.Forms {
		/**
		 * Specifies the wrapping mode for the text of a {@link Eto.Forms.Label}
		 *
		 * Regardless of the mode, you can always add hard wraps by inserting newline characters.
		 */
		export enum WrapMode {
			/** No wrapping, the text will clip when smaller than the required space for the text. */
			None = 0,

			/** Text will wrap by word to fit the horizontal space available */
			Word = 1,

			/** Text will wrap by character to fit the horizontal space available */
			Character = 2,
		}
	}

	export namespace Eto.Forms {
		/** Displays a string of text on the form */
		export class Label implements
			Eto.IHandlerSource,
			Eto.Forms.IBindable,
			Eto.Forms.IMouseInputSource,
			Eto.Forms.IKeyboardInputSource {
			constructor();

			/**
			 * Gets or sets the wrap mode for the text
			 *
			 * This defines the soft wrapping for the label's text.  Hard wraps can be placed in the
			 * text with newline characters.  Wrapping will only occur if the label's width is
			 * smaller than the space needed for the text. If you are autosizing your control, it may
			 * get autosized to the width so you will have to add constraints to the container or
			 * explicitly set the size.
			 */
			Wrap: Eto.Forms.WrapMode;

			/**
			 * Gets or sets the horizontal alignment of the text.
			 *
			 * When auto sizing the label, this won't have an affect unless the label's container is
			 * larger than the text.
			 */
			TextAlignment: Eto.Forms.TextAlignment;

			/**
			 * Gets or sets the horizontal alignment of the text.
			 *
			 * When auto sizing the label, this won't have an affect unless the label's container is
			 * larger than the text.
			 */
			HorizontalAlign: Eto.Forms.HorizontalAlign;

			/**
			 * Gets or sets the vertical alignment of the text.
			 *
			 * When auto sizing the label, this won't have an affect unless the label's container is
			 * larger than the text.
			 */
			VerticalAlignment: Eto.Forms.VerticalAlignment;

			/**
			 * Gets or sets the vertical alignment of the text.
			 *
			 * When auto sizing the label, this won't have an affect unless the label's container is
			 * larger than the text.
			 */
			VerticalAlign: Eto.Forms.VerticalAlign;

			/**
			 * Gets or sets the text of the control.
			 *
			 * Usually, the caret and selection will be set to the end of the string after its set.
			 */
			Text: string;

			/**
			 * Gets or sets the color of the text.
			 *
			 * By default, the text will get a color based on the user's theme. However, this is
			 * usually black.
			 */
			TextColor: Eto.Drawing.Color;

			/** Gets the binding for the {@link Eto.Forms.TextControl.Text} property. */
			readonly TextBinding: Eto.Forms.BindableBinding$2<Eto.Forms.TextControl, string>;

			/** Gets or sets the font for the text of the control */
			Font: Eto.Drawing.Font;

			/**
			 * Gets a value indicating that the control is loaded onto a form, that is it has been
			 * created, added to a parent, and shown
			 *
			 * The {@link Eto.Forms.Control.OnLoad(System.EventArgs)} method sets this value to true
			 * after cascading to all children (for a {@link Eto.Forms.Container} ) and calling the
			 * platform handler's implementation.  It is called after adding to a loaded form, or
			 * when showing a new form.  The {@link Eto.Forms.Control.OnUnLoad(System.EventArgs)}
			 * method will set this value to false when the control is removed from its parent
			 */
			readonly Loaded: boolean;

			/**
			 * Gets an enumeration of controls that are in the visual tree.
			 *
			 * This is used to specify which controls are contained by this instance that are part of
			 * the visual tree. This should include all controls including non-logical Eto controls
			 * used for layout.
			 */
			readonly VisualControls: Iterable<Eto.Forms.Control>;

			/**
			 * Gets or sets a user-defined object that contains data about the control
			 *
			 * A common use of the tag property is to store data that is associated with the control
			 * that you can later retrieve.
			 */
			Tag: unknown;

			/**
			 * Gets the logical parent control.
			 *
			 * When the control is part of the visual tree (
				 * {@link Eto.Forms.Control.IsVisualControl} is true), this returns the logical parent
				 * that contains this control. Otherwise this is the same as
				 * {@link Eto.Forms.Control.Parent}.
				 */
				readonly LogicalParent: Eto.Forms.Container;

			/** Gets a value indicating this {@link Eto.Forms.Control} is part of the visual tree. */
			IsVisualControl: boolean;

			/**
			 * Gets or sets the size of the control. Use -1 to specify auto sizing for either the
			 * width and/or height.
			 *
			 * Setting the size of controls is entirely optional as most controls will size
			 * themselves appropriately. When specifying a size, it will be used as the desired size
			 * of the control.  The container will reposition and resize the control depending on the
			 * available size.  For a {@link Eto.Forms.Window}, it is preferred to set the
			 * {@link Eto.Forms.Container.ClientSize} instead, as various platforms have different
			 * sizes of window decorations, toolbars, etc.
			 */
			Size: Eto.Drawing.Size;

			/**
			 * Gets a value indicating this control currently has mouse capture
			 *
			 * Mouse capture can happen during a handled MouseDown event until MouseUp, or it can be
			 * captured explicitly via {@link Eto.Forms.Control.CaptureMouse}.
			 */
			readonly IsMouseCaptured: boolean;

			/** Gets or sets the width of the control size. */
			Width: number;

			/** Gets or sets the height of the control size. */
			Height: number;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Forms.Control} (or its
			 * children) are enabled and accept user input.
			 *
			 * Typically when a control is disabled, the user cannot do anything with the control or
			 * any of its children. Including for example, selecting text in a text control. Certain
			 * controls can have a 'Read Only' mode, such as {@link Eto.Forms.TextBox.ReadOnly} which
			 * allow the user to  select text, but not change its contents.
			 */
			Enabled: boolean;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Forms.Control} is visible to
			 * the user.
			 *
			 * When the visibility of a control is set to false, it will not occupy space in the
			 * layout.
			 */
			Visible: boolean;

			/** Gets the container which this control has been added to, if any */
			readonly Parent: Eto.Forms.Container;

			/**
			 * Gets the visual container of this control, if any.
			 *
			 * Some containers may use other Eto controls to layout its children, such as the
			 * {@link Eto.Forms.StackLayout}. This will return the parent control that visually
			 * contains this control as opposed to {@link Eto.Forms.Control.Parent} which will return
			 * the logical parent.
			 */
			VisualParent: Eto.Forms.Container;

			/** Gets a value indicating this control has been attached to a native container */
			readonly IsAttached: boolean;

			/**
			 * Gets or sets the color for the background of the control
			 *
			 * Note that on some platforms (e.g. Mac), setting the background color of a control can
			 * change the performance characteristics of the control and its children, since it must
			 * enable layers to do so.
			 */
			BackgroundColor: Eto.Drawing.Color;

			/** Gets a value indicating whether this instance has the keyboard input focus. */
			readonly HasFocus: boolean;

			/** Gets a value indicating whether the layout of child controls is suspended. */
			readonly IsSuspended: boolean;

			/** Gets the window this control is contained in */
			readonly ParentWindow: Eto.Forms.Window;

			/**
			 * Gets the supported platform commands that can be used to hook up system functions to
			 * user defined logic
			 *
			 * This lists all available commands that can be mapped using the
			 * {@link Eto.Forms.Control.MapPlatformCommand(System.String,Eto.Forms.Command)} method
			 * of the control.
			 */
			readonly SupportedPlatformCommands: Iterable<string>;

			/** Gets the bounding rectangle of this control relative to its container */
			readonly Bounds: Eto.Drawing.Rectangle;

			/**
			 * Gets the location of the control as positioned by the container
			 *
			 * A control's location is set by the container. This can be used to determine where the
			 * control is for overlaying floating windows, menus, etc.
			 */
			readonly Location: Eto.Drawing.Point;

			/** Gets or sets the type of cursor to use when the mouse is hovering over the control */
			Cursor: Eto.Forms.Cursor;

			/** Gets or sets the tool tip to show when the mouse is hovered over the control */
			ToolTip: string;

			/**
			 * Gets or sets the tab index order for this control within its container.
			 *
			 * This sets the order when using the tab key to cycle through controls  Note that some
			 * platforms (Gtk and WinForms) may not support setting the context of the tab order to
			 * StackLayout  or DynamicLayout containers and may not behave exactly as expected. Use
			 * the {@link Eto.PlatformFeatures.TabIndexWithCustomContainers} flag to determine if it
			 * is supported.
			 */
			TabIndex: number;

			/** Gets or sets a value indicating whether this control can serve as drop target. */
			AllowDrop: boolean;

			/**
			 * Gets or sets the parent widget which this widget has been added to, if any
			 *
			 * When implementing child widgets that can participate in the context based binding
			 * (MVVM), You can set this to the parent widget when it is added or removed to it
			 * (usually via a collection).  Note that you should typically provide a public new
			 * [ParentWidget] Parent { get; } property  so that consumers of your API cannot set the
			 * parent to an invalid value.
			 */
			Parent: Eto.Widget;

			/**
			 * Gets an enumeration of all parent widgets in the heirarchy by traversing the
			 * {@link Eto.Forms.BindableWidget.Parent} property.
			 */
			readonly Parents: Iterable<Eto.Widget>;

			/**
			 * Gets or sets the data context for this widget for binding
			 *
			 * Subclasses may override the standard behaviour so that hierarchy of widgets can be
			 * taken into account.  For example, a Control may return the data context of a parent,
			 * if it is not set explicitly.
			 */
			DataContext: unknown;

			/** Gets the collection of bindings that are attached to this widget */
			readonly Bindings: Eto.Forms.BindingCollection;

			/**
			 * Gets a value indicating that the {@link Eto.Forms.BindableWidget.DataContext} property
			 * is changing.
			 *
			 * This can be used to determine when to allow certain logic during the update of the
			 * data context.  It is used to disable binding setters on the model when the data
			 * context changes so that a binding does not cause the view model to be updated when the
			 * state hasn't been fully set yet.
			 */
			IsDataContextChanging: boolean;

			/**
			 * Gets the platform that was used to create the {@link Eto.Widget.Handler} for this
			 * widget
			 *
			 * This gets set to the current {@link Eto.Platform.Instance} during the construction of
			 * the object
			 */
			readonly Platform: Eto.Platform;

			/** Gets the platform-specific handler for this widget */
			Handler: unknown;

			/** Gets the native platform-specific handle for integration purposes */
			readonly NativeHandle: unknown;

			/** Gets the dictionary of properties for this widget */
			readonly Properties: Eto.PropertyStore;

			/** Gets or sets the ID of this widget */
			ID: string;

			/**
			 * Gets or sets the style of this widget
			 *
			 * Styles allow you to attach custom platform-specific logic to a widget. In your
			 * platform-specific assembly, use {@link Style.Add{H}(string, StyleHandler{H})} to add
			 * the style logic with the same id.
			 */
			Style: string;

			/**
			 * Gets the instance of the platform-specific object
			 *
			 * This can sometimes be useful to get the platform-specific object. Some handlers may
			 * not have any backing object for its functionality, so this may be null.  It is more
			 * preferred to use the {@link Eto.Widget.Handler} and cast that to the platform-specific
			 * handler class which can give you additional methods and helpers to do common tasks.
			 * For example, the {@link Eto.Forms.Application} object's handler for OS X has a
			 * AddFullScreenMenuItem property to specify if you want full screen support in your app.
			 */
			readonly ControlObject: unknown;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Widget} has been disposed.
			 *
			 * When the widget is disposed, it can no longer be used.
			 */
			IsDisposed: boolean;

			/**
			 * Queues a repaint of the entire control on the screen and any of its children.
			 *
			 * This is only useful when the control is visible.
			 */
			Invalidate(): void;

			/**
			 * Queues a repaint of the entire control on the screen
			 *
			 * This is only useful when the control is visible.
			 */
			Invalidate(invalidateChildren: boolean): void;

			/**
			 * Queues a repaint of the specified `rect` of the control and any children.
			 *
			 * This is only useful when the control is visible.
			 */
			Invalidate(rect: Eto.Drawing.Rectangle): void;

			/**
			 * Queues a repaint of the specified `rect` of the control
			 *
			 * This is only useful when the control is visible.
			 */
			Invalidate(
				rect: Eto.Drawing.Rectangle,
				invalidateChildren: boolean,
			): void;

			/**
			 * Updates the layout of this control if necessary.
			 *
			 * This will ensure the control has had all of its layout applied so you can use its
			 * position and size right after this call. Most platforms (except WinForms) use a
			 * deferred layout system so that after adding your control to the form dynamically it
			 * won't get laid out until the next idle loop. This is useful when you need to know the
			 * dimensions of the control immediately. Note that this can be an expensive operation,
			 * so it is recommended to only call this method when necessary and after all of the
			 * controls have been added/updated.
			 */
			UpdateLayout(): void;

			/** Gets the preferred size of this control given infinite space available. */
			GetPreferredSize(): Eto.Drawing.SizeF;

			/** Gets the preferred size of this control given the specified `availableSize`. */
			GetPreferredSize(availableSize: Eto.Drawing.SizeF): Eto.Drawing.SizeF;

			/**
			 * Captures all mouse events to this control.
			 *
			 * This captures all mouse events until {@link Eto.Forms.Control.ReleaseMouseCapture} is
			 * called.  Note that not all platforms will allow a mouse capture unless the mouse is
			 * currently down.
			 */
			CaptureMouse(): boolean;

			/** Releases the mouse capture after a call to {@link Eto.Forms.Control.CaptureMouse}. */
			ReleaseMouseCapture(): void;

			/**
			 * Finds a control in the parent hierarchy with the specified type and
			 * {@link Eto.Widget.ID} if specified
			 */
			FindParent(
				type: unknown,
				id?: string,
			): Eto.Forms.Container;

			/** Finds a control in the parent hierarchy with the specified `id` */
			FindParent(id: string): Eto.Forms.Container;

			/**
			 * Detaches the control by removing it from its parent
			 *
			 * This is essentially a shortcut to myControl.Parent.Remove(myControl);
			 */
			Detach(): void;

			/**
			 * Attaches the control for direct use in a native application
			 *
			 * Use this to use a control directly in a native application.  Note that the native
			 * application must be running the same framework as the current platform.  E.g. a
			 * WinForms application can use an Eto.Forms control when using the Eto.WinForms
			 * platform.  This prepares the control by firing the {@link Eto.Forms.Control.PreLoad},
			 * {@link Eto.Forms.Control.Load}, etc. events.
			 */
			AttachNative(): void;

			/**
			 * Detaches the control when it is used in a native application, when you want to reuse
			 * the control.
			 *
			 * This should only be called after {@link Eto.Forms.Control.AttachNative} has been
			 * called, which is usually done by calling to ToNative(true) .
			 */
			DetachNative(): void;

			/**
			 * Attempts to set the keyboard input focus to this control, or the first child that
			 * accepts focus. For Windows, this will bring it to front and activate it.
			 */
			Focus(): void;

			/**
			 * Suspends the layout of child controls
			 *
			 * This can be used to optimize some platforms while adding, removing, or changing many
			 * child controls at once. It disables the calculation of control positioning until
			 * {@link Eto.Forms.Control.ResumeLayout} is called. Each call to SuspendLayout() must be
			 * balanced with a call to {@link Eto.Forms.Control.ResumeLayout}.
			 */
			SuspendLayout(): void;

			/**
			 * Resumes the layout after it has been suspended, and performs a layout
			 *
			 * This can be used to optimize some platforms while adding, removing, or changing many
			 * child controls at once. Each call to ResumeLayout() must be balanced with a call to
			 * {@link Eto.Forms.Control.SuspendLayout} before it.
			 */
			ResumeLayout(): void;

			/**
			 * Specifies a command to execute for a platform-specific command
			 *
			 * Some platforms have specific system-defined commands that can be associated with a
			 * control. For example, the Mac platform's cut/copy/paste functionality is defined by
			 * the system, and if you want to hook into it, you can use this to map it to your own
			 * defined logic. The valid values of the `systemCommand` parameter are defined by each
			 * platform, and a list can be retrieved using
			 * {@link Eto.Forms.Control.SupportedPlatformCommands}
			 */
			MapPlatformCommand(
				systemCommand: string,
				command: Eto.Forms.Command,
			): void;

			/** Converts a point from screen space to control space. */
			PointFromScreen(point: Eto.Drawing.PointF): Eto.Drawing.PointF;

			/** Converts a point from control space to screen space */
			PointToScreen(point: Eto.Drawing.PointF): Eto.Drawing.PointF;

			/** Converts a rectangle from screen space to control space. */
			RectangleToScreen(rect: Eto.Drawing.RectangleF): Eto.Drawing.RectangleF;

			/** Converts a rectangle from control space to screen space */
			RectangleFromScreen(rect: Eto.Drawing.RectangleF): Eto.Drawing.RectangleF;

			/**
			 * Starts drag operation using this control as drag source.
			 *
			 * This method can be blocking on some platforms (Wpf, WinForms), and non-blocking on
			 * others (Mac, Gtk). Use the {@link Eto.Forms.Control.DragEnd} event to determine when
			 * the drag operation is completed and get its resulting DragEffects.
			 */
			DoDragDrop(
				data: Eto.Forms.DataObject,
				allowedEffects: Eto.Forms.DragEffects,
			): void;

			/**
			 * Starts drag operation using this control as drag source.
			 *
			 * This method can be blocking on some platforms (Wpf, WinForms), and non-blocking on
			 * others (Mac, Gtk). Use the {@link Eto.Forms.Control.DragEnd} event to determine when
			 * the drag operation is completed and get its resulting DragEffects.
			 */
			DoDragDrop(
				data: Eto.Forms.DataObject,
				allowedEffects: Eto.Forms.DragEffects,
				image: Eto.Drawing.Image,
				cursorOffset: Eto.Drawing.PointF,
			): void;

			/**
			 * Triggers the StyleChanged event and re-applies the styles to this control and its
			 * children.
			 */
			TriggerStyleChanged(): void;

			/** Shows a print dialog to print the specified control */
			Print(): void;

			/**
			 * Finds a control in the parent hierarchy with the specified type and
			 * {@link Eto.Widget.ID} if specified
			 */
			FindParent<T>(id?: string): T;

			/**
			 * Finds a control in the parent hierarchy with the specified type and
			 * {@link Eto.Widget.ID} if specified
			 */
			FindParent(
				type: unknown,
				id?: string,
			): Eto.Widget;

			/** Finds a control in the parent hierarchy with the specified `id` */
			FindParent(id: string): Eto.Widget;

			/**
			 * Unbinds any bindings in the {@link Eto.Forms.BindableWidget.Bindings} collection and
			 * removes the bindings
			 *
			 * When you implement {@link Eto.Forms.IBindableWidgetContainer}, this will also unbind
			 * any of its children.
			 */
			Unbind(): void;

			/**
			 * Updates all bindings in this widget
			 *
			 * When you implement {@link Eto.Forms.IBindableWidgetContainer}, this will also update
			 * bindings for all of its children.
			 */
			UpdateBindings(mode?: Eto.Forms.BindingUpdateMode): void;

			/** Disposes of this widget, supressing the finalizer */
			dispose(): void;

			/** Gets a string that represents the current object with its ID if specified. */
			ToString(): string;
		}
	}

	export namespace Eto.Forms.Label {
		export interface IHandler extends
			Eto.Forms.TextControl.IHandler,
			Eto.Forms.CommonControl.IHandler,
			Eto.Forms.Control.IHandler,
			Eto.Widget.IHandler {
			TextAlignment: Eto.Forms.TextAlignment;

			VerticalAlignment: Eto.Forms.VerticalAlignment;

			Wrap: Eto.Forms.WrapMode;
		}
	}

	export namespace Eto.Forms {
		/** Specifies the horizontal alignment for a {@link Eto.Forms.Label} */
		export class HorizontalAlign {
			/** Text will be aligned in the center of the label */
			static readonly Center: Eto.Forms.HorizontalAlign;

			/** Text will be aligned to the left */
			static readonly Left: Eto.Forms.HorizontalAlign;

			/** Text will be aligned to the right */
			static readonly Right: Eto.Forms.HorizontalAlign;

			/**
			 * Determines whether the specified {@link System.Object} is equal to the current
			 * {@link Eto.Forms.HorizontalAlign}.
			 */
			Equals(obj: unknown): boolean;

			/** Serves as a hash function for a {@link Eto.Forms.HorizontalAlign} object. */
			GetHashCode(): number;
		}
	}

	export namespace Eto.Forms {
		/** Specifies the horizontal alignment for a {@link Eto.Forms.Label} */
		export class VerticalAlign {
			/** Text will be aligned to the middle of the label */
			static readonly Middle: Eto.Forms.VerticalAlign;

			/** Text will be aligned to the top of the label */
			static readonly Top: Eto.Forms.VerticalAlign;

			/** Text will be aligned to the bottom of the label */
			static readonly Bottom: Eto.Forms.VerticalAlign;

			/**
			 * Determines whether the specified {@link System.Object} is equal to the current
			 * {@link Eto.Forms.VerticalAlign}.
			 */
			Equals(obj: unknown): boolean;

			/** Serves as a hash function for a {@link Eto.Forms.VerticalAlign} object. */
			GetHashCode(): number;
		}
	}

	export namespace Eto.Forms {
		/** Button that is visually represented like a hyperlink on a web page. */
		export class LinkButton implements
			Eto.IHandlerSource,
			Eto.Forms.IBindable,
			Eto.Forms.IMouseInputSource,
			Eto.Forms.IKeyboardInputSource {
			constructor();

			/**
			 * Gets or sets the command to invoke when the link button is pressed.
			 *
			 * This will invoke the specified command when the link button is pressed. The
			 * {@link System.Windows.Input.ICommand.CanExecute(System.Object)} will also used to set
			 * the enabled/disabled state of the link button.
			 */
			Command: unknown;

			/**
			 * Gets or sets the parameter to pass to the {@link Eto.Forms.LinkButton.Command} when
			 * executing or determining its CanExecute state.
			 */
			CommandParameter: unknown;

			/** Gets or sets the color of the text when the control is disabled. */
			DisabledTextColor: Eto.Drawing.Color;

			/**
			 * Gets or sets the text of the control.
			 *
			 * Usually, the caret and selection will be set to the end of the string after its set.
			 */
			Text: string;

			/**
			 * Gets or sets the color of the text.
			 *
			 * By default, the text will get a color based on the user's theme. However, this is
			 * usually black.
			 */
			TextColor: Eto.Drawing.Color;

			/** Gets the binding for the {@link Eto.Forms.TextControl.Text} property. */
			readonly TextBinding: Eto.Forms.BindableBinding$2<Eto.Forms.TextControl, string>;

			/** Gets or sets the font for the text of the control */
			Font: Eto.Drawing.Font;

			/**
			 * Gets a value indicating that the control is loaded onto a form, that is it has been
			 * created, added to a parent, and shown
			 *
			 * The {@link Eto.Forms.Control.OnLoad(System.EventArgs)} method sets this value to true
			 * after cascading to all children (for a {@link Eto.Forms.Container} ) and calling the
			 * platform handler's implementation.  It is called after adding to a loaded form, or
			 * when showing a new form.  The {@link Eto.Forms.Control.OnUnLoad(System.EventArgs)}
			 * method will set this value to false when the control is removed from its parent
			 */
			readonly Loaded: boolean;

			/**
			 * Gets an enumeration of controls that are in the visual tree.
			 *
			 * This is used to specify which controls are contained by this instance that are part of
			 * the visual tree. This should include all controls including non-logical Eto controls
			 * used for layout.
			 */
			readonly VisualControls: Iterable<Eto.Forms.Control>;

			/**
			 * Gets or sets a user-defined object that contains data about the control
			 *
			 * A common use of the tag property is to store data that is associated with the control
			 * that you can later retrieve.
			 */
			Tag: unknown;

			/**
			 * Gets the logical parent control.
			 *
			 * When the control is part of the visual tree (
				 * {@link Eto.Forms.Control.IsVisualControl} is true), this returns the logical parent
				 * that contains this control. Otherwise this is the same as
				 * {@link Eto.Forms.Control.Parent}.
				 */
				readonly LogicalParent: Eto.Forms.Container;

			/** Gets a value indicating this {@link Eto.Forms.Control} is part of the visual tree. */
			IsVisualControl: boolean;

			/**
			 * Gets or sets the size of the control. Use -1 to specify auto sizing for either the
			 * width and/or height.
			 *
			 * Setting the size of controls is entirely optional as most controls will size
			 * themselves appropriately. When specifying a size, it will be used as the desired size
			 * of the control.  The container will reposition and resize the control depending on the
			 * available size.  For a {@link Eto.Forms.Window}, it is preferred to set the
			 * {@link Eto.Forms.Container.ClientSize} instead, as various platforms have different
			 * sizes of window decorations, toolbars, etc.
			 */
			Size: Eto.Drawing.Size;

			/**
			 * Gets a value indicating this control currently has mouse capture
			 *
			 * Mouse capture can happen during a handled MouseDown event until MouseUp, or it can be
			 * captured explicitly via {@link Eto.Forms.Control.CaptureMouse}.
			 */
			readonly IsMouseCaptured: boolean;

			/** Gets or sets the width of the control size. */
			Width: number;

			/** Gets or sets the height of the control size. */
			Height: number;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Forms.Control} (or its
			 * children) are enabled and accept user input.
			 *
			 * Typically when a control is disabled, the user cannot do anything with the control or
			 * any of its children. Including for example, selecting text in a text control. Certain
			 * controls can have a 'Read Only' mode, such as {@link Eto.Forms.TextBox.ReadOnly} which
			 * allow the user to  select text, but not change its contents.
			 */
			Enabled: boolean;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Forms.Control} is visible to
			 * the user.
			 *
			 * When the visibility of a control is set to false, it will not occupy space in the
			 * layout.
			 */
			Visible: boolean;

			/** Gets the container which this control has been added to, if any */
			readonly Parent: Eto.Forms.Container;

			/**
			 * Gets the visual container of this control, if any.
			 *
			 * Some containers may use other Eto controls to layout its children, such as the
			 * {@link Eto.Forms.StackLayout}. This will return the parent control that visually
			 * contains this control as opposed to {@link Eto.Forms.Control.Parent} which will return
			 * the logical parent.
			 */
			VisualParent: Eto.Forms.Container;

			/** Gets a value indicating this control has been attached to a native container */
			readonly IsAttached: boolean;

			/**
			 * Gets or sets the color for the background of the control
			 *
			 * Note that on some platforms (e.g. Mac), setting the background color of a control can
			 * change the performance characteristics of the control and its children, since it must
			 * enable layers to do so.
			 */
			BackgroundColor: Eto.Drawing.Color;

			/** Gets a value indicating whether this instance has the keyboard input focus. */
			readonly HasFocus: boolean;

			/** Gets a value indicating whether the layout of child controls is suspended. */
			readonly IsSuspended: boolean;

			/** Gets the window this control is contained in */
			readonly ParentWindow: Eto.Forms.Window;

			/**
			 * Gets the supported platform commands that can be used to hook up system functions to
			 * user defined logic
			 *
			 * This lists all available commands that can be mapped using the
			 * {@link Eto.Forms.Control.MapPlatformCommand(System.String,Eto.Forms.Command)} method
			 * of the control.
			 */
			readonly SupportedPlatformCommands: Iterable<string>;

			/** Gets the bounding rectangle of this control relative to its container */
			readonly Bounds: Eto.Drawing.Rectangle;

			/**
			 * Gets the location of the control as positioned by the container
			 *
			 * A control's location is set by the container. This can be used to determine where the
			 * control is for overlaying floating windows, menus, etc.
			 */
			readonly Location: Eto.Drawing.Point;

			/** Gets or sets the type of cursor to use when the mouse is hovering over the control */
			Cursor: Eto.Forms.Cursor;

			/** Gets or sets the tool tip to show when the mouse is hovered over the control */
			ToolTip: string;

			/**
			 * Gets or sets the tab index order for this control within its container.
			 *
			 * This sets the order when using the tab key to cycle through controls  Note that some
			 * platforms (Gtk and WinForms) may not support setting the context of the tab order to
			 * StackLayout  or DynamicLayout containers and may not behave exactly as expected. Use
			 * the {@link Eto.PlatformFeatures.TabIndexWithCustomContainers} flag to determine if it
			 * is supported.
			 */
			TabIndex: number;

			/** Gets or sets a value indicating whether this control can serve as drop target. */
			AllowDrop: boolean;

			/**
			 * Gets or sets the parent widget which this widget has been added to, if any
			 *
			 * When implementing child widgets that can participate in the context based binding
			 * (MVVM), You can set this to the parent widget when it is added or removed to it
			 * (usually via a collection).  Note that you should typically provide a public new
			 * [ParentWidget] Parent { get; } property  so that consumers of your API cannot set the
			 * parent to an invalid value.
			 */
			Parent: Eto.Widget;

			/**
			 * Gets an enumeration of all parent widgets in the heirarchy by traversing the
			 * {@link Eto.Forms.BindableWidget.Parent} property.
			 */
			readonly Parents: Iterable<Eto.Widget>;

			/**
			 * Gets or sets the data context for this widget for binding
			 *
			 * Subclasses may override the standard behaviour so that hierarchy of widgets can be
			 * taken into account.  For example, a Control may return the data context of a parent,
			 * if it is not set explicitly.
			 */
			DataContext: unknown;

			/** Gets the collection of bindings that are attached to this widget */
			readonly Bindings: Eto.Forms.BindingCollection;

			/**
			 * Gets a value indicating that the {@link Eto.Forms.BindableWidget.DataContext} property
			 * is changing.
			 *
			 * This can be used to determine when to allow certain logic during the update of the
			 * data context.  It is used to disable binding setters on the model when the data
			 * context changes so that a binding does not cause the view model to be updated when the
			 * state hasn't been fully set yet.
			 */
			IsDataContextChanging: boolean;

			/**
			 * Gets the platform that was used to create the {@link Eto.Widget.Handler} for this
			 * widget
			 *
			 * This gets set to the current {@link Eto.Platform.Instance} during the construction of
			 * the object
			 */
			readonly Platform: Eto.Platform;

			/** Gets the platform-specific handler for this widget */
			Handler: unknown;

			/** Gets the native platform-specific handle for integration purposes */
			readonly NativeHandle: unknown;

			/** Gets the dictionary of properties for this widget */
			readonly Properties: Eto.PropertyStore;

			/** Gets or sets the ID of this widget */
			ID: string;

			/**
			 * Gets or sets the style of this widget
			 *
			 * Styles allow you to attach custom platform-specific logic to a widget. In your
			 * platform-specific assembly, use {@link Style.Add{H}(string, StyleHandler{H})} to add
			 * the style logic with the same id.
			 */
			Style: string;

			/**
			 * Gets the instance of the platform-specific object
			 *
			 * This can sometimes be useful to get the platform-specific object. Some handlers may
			 * not have any backing object for its functionality, so this may be null.  It is more
			 * preferred to use the {@link Eto.Widget.Handler} and cast that to the platform-specific
			 * handler class which can give you additional methods and helpers to do common tasks.
			 * For example, the {@link Eto.Forms.Application} object's handler for OS X has a
			 * AddFullScreenMenuItem property to specify if you want full screen support in your app.
			 */
			readonly ControlObject: unknown;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Widget} has been disposed.
			 *
			 * When the widget is disposed, it can no longer be used.
			 */
			IsDisposed: boolean;

			/**
			 * Queues a repaint of the entire control on the screen and any of its children.
			 *
			 * This is only useful when the control is visible.
			 */
			Invalidate(): void;

			/**
			 * Queues a repaint of the entire control on the screen
			 *
			 * This is only useful when the control is visible.
			 */
			Invalidate(invalidateChildren: boolean): void;

			/**
			 * Queues a repaint of the specified `rect` of the control and any children.
			 *
			 * This is only useful when the control is visible.
			 */
			Invalidate(rect: Eto.Drawing.Rectangle): void;

			/**
			 * Queues a repaint of the specified `rect` of the control
			 *
			 * This is only useful when the control is visible.
			 */
			Invalidate(
				rect: Eto.Drawing.Rectangle,
				invalidateChildren: boolean,
			): void;

			/**
			 * Updates the layout of this control if necessary.
			 *
			 * This will ensure the control has had all of its layout applied so you can use its
			 * position and size right after this call. Most platforms (except WinForms) use a
			 * deferred layout system so that after adding your control to the form dynamically it
			 * won't get laid out until the next idle loop. This is useful when you need to know the
			 * dimensions of the control immediately. Note that this can be an expensive operation,
			 * so it is recommended to only call this method when necessary and after all of the
			 * controls have been added/updated.
			 */
			UpdateLayout(): void;

			/** Gets the preferred size of this control given infinite space available. */
			GetPreferredSize(): Eto.Drawing.SizeF;

			/** Gets the preferred size of this control given the specified `availableSize`. */
			GetPreferredSize(availableSize: Eto.Drawing.SizeF): Eto.Drawing.SizeF;

			/**
			 * Captures all mouse events to this control.
			 *
			 * This captures all mouse events until {@link Eto.Forms.Control.ReleaseMouseCapture} is
			 * called.  Note that not all platforms will allow a mouse capture unless the mouse is
			 * currently down.
			 */
			CaptureMouse(): boolean;

			/** Releases the mouse capture after a call to {@link Eto.Forms.Control.CaptureMouse}. */
			ReleaseMouseCapture(): void;

			/**
			 * Finds a control in the parent hierarchy with the specified type and
			 * {@link Eto.Widget.ID} if specified
			 */
			FindParent(
				type: unknown,
				id?: string,
			): Eto.Forms.Container;

			/** Finds a control in the parent hierarchy with the specified `id` */
			FindParent(id: string): Eto.Forms.Container;

			/**
			 * Detaches the control by removing it from its parent
			 *
			 * This is essentially a shortcut to myControl.Parent.Remove(myControl);
			 */
			Detach(): void;

			/**
			 * Attaches the control for direct use in a native application
			 *
			 * Use this to use a control directly in a native application.  Note that the native
			 * application must be running the same framework as the current platform.  E.g. a
			 * WinForms application can use an Eto.Forms control when using the Eto.WinForms
			 * platform.  This prepares the control by firing the {@link Eto.Forms.Control.PreLoad},
			 * {@link Eto.Forms.Control.Load}, etc. events.
			 */
			AttachNative(): void;

			/**
			 * Detaches the control when it is used in a native application, when you want to reuse
			 * the control.
			 *
			 * This should only be called after {@link Eto.Forms.Control.AttachNative} has been
			 * called, which is usually done by calling to ToNative(true) .
			 */
			DetachNative(): void;

			/**
			 * Attempts to set the keyboard input focus to this control, or the first child that
			 * accepts focus. For Windows, this will bring it to front and activate it.
			 */
			Focus(): void;

			/**
			 * Suspends the layout of child controls
			 *
			 * This can be used to optimize some platforms while adding, removing, or changing many
			 * child controls at once. It disables the calculation of control positioning until
			 * {@link Eto.Forms.Control.ResumeLayout} is called. Each call to SuspendLayout() must be
			 * balanced with a call to {@link Eto.Forms.Control.ResumeLayout}.
			 */
			SuspendLayout(): void;

			/**
			 * Resumes the layout after it has been suspended, and performs a layout
			 *
			 * This can be used to optimize some platforms while adding, removing, or changing many
			 * child controls at once. Each call to ResumeLayout() must be balanced with a call to
			 * {@link Eto.Forms.Control.SuspendLayout} before it.
			 */
			ResumeLayout(): void;

			/**
			 * Specifies a command to execute for a platform-specific command
			 *
			 * Some platforms have specific system-defined commands that can be associated with a
			 * control. For example, the Mac platform's cut/copy/paste functionality is defined by
			 * the system, and if you want to hook into it, you can use this to map it to your own
			 * defined logic. The valid values of the `systemCommand` parameter are defined by each
			 * platform, and a list can be retrieved using
			 * {@link Eto.Forms.Control.SupportedPlatformCommands}
			 */
			MapPlatformCommand(
				systemCommand: string,
				command: Eto.Forms.Command,
			): void;

			/** Converts a point from screen space to control space. */
			PointFromScreen(point: Eto.Drawing.PointF): Eto.Drawing.PointF;

			/** Converts a point from control space to screen space */
			PointToScreen(point: Eto.Drawing.PointF): Eto.Drawing.PointF;

			/** Converts a rectangle from screen space to control space. */
			RectangleToScreen(rect: Eto.Drawing.RectangleF): Eto.Drawing.RectangleF;

			/** Converts a rectangle from control space to screen space */
			RectangleFromScreen(rect: Eto.Drawing.RectangleF): Eto.Drawing.RectangleF;

			/**
			 * Starts drag operation using this control as drag source.
			 *
			 * This method can be blocking on some platforms (Wpf, WinForms), and non-blocking on
			 * others (Mac, Gtk). Use the {@link Eto.Forms.Control.DragEnd} event to determine when
			 * the drag operation is completed and get its resulting DragEffects.
			 */
			DoDragDrop(
				data: Eto.Forms.DataObject,
				allowedEffects: Eto.Forms.DragEffects,
			): void;

			/**
			 * Starts drag operation using this control as drag source.
			 *
			 * This method can be blocking on some platforms (Wpf, WinForms), and non-blocking on
			 * others (Mac, Gtk). Use the {@link Eto.Forms.Control.DragEnd} event to determine when
			 * the drag operation is completed and get its resulting DragEffects.
			 */
			DoDragDrop(
				data: Eto.Forms.DataObject,
				allowedEffects: Eto.Forms.DragEffects,
				image: Eto.Drawing.Image,
				cursorOffset: Eto.Drawing.PointF,
			): void;

			/**
			 * Triggers the StyleChanged event and re-applies the styles to this control and its
			 * children.
			 */
			TriggerStyleChanged(): void;

			/** Shows a print dialog to print the specified control */
			Print(): void;

			/**
			 * Finds a control in the parent hierarchy with the specified type and
			 * {@link Eto.Widget.ID} if specified
			 */
			FindParent<T>(id?: string): T;

			/**
			 * Finds a control in the parent hierarchy with the specified type and
			 * {@link Eto.Widget.ID} if specified
			 */
			FindParent(
				type: unknown,
				id?: string,
			): Eto.Widget;

			/** Finds a control in the parent hierarchy with the specified `id` */
			FindParent(id: string): Eto.Widget;

			/**
			 * Unbinds any bindings in the {@link Eto.Forms.BindableWidget.Bindings} collection and
			 * removes the bindings
			 *
			 * When you implement {@link Eto.Forms.IBindableWidgetContainer}, this will also unbind
			 * any of its children.
			 */
			Unbind(): void;

			/**
			 * Updates all bindings in this widget
			 *
			 * When you implement {@link Eto.Forms.IBindableWidgetContainer}, this will also update
			 * bindings for all of its children.
			 */
			UpdateBindings(mode?: Eto.Forms.BindingUpdateMode): void;

			/** Disposes of this widget, supressing the finalizer */
			dispose(): void;

			/** Gets a string that represents the current object with its ID if specified. */
			ToString(): string;
		}
	}

	export namespace Eto.Forms.LinkButton {
		export interface ICallback extends
			Eto.Forms.TextControl.ICallback,
			Eto.Forms.Control.ICallback,
			Eto.Widget.ICallback {
			OnClick(
				widget: Eto.Forms.LinkButton,
				e: unknown,
			): void;
		}
	}

	export namespace Eto.Forms.LinkButton {
		export interface IHandler extends
			Eto.Forms.TextControl.IHandler,
			Eto.Forms.CommonControl.IHandler,
			Eto.Forms.Control.IHandler,
			Eto.Widget.IHandler {
			DisabledTextColor: Eto.Drawing.Color;
		}
	}

	export namespace Eto.Forms {
		/**
		 * Represents a list item that can have an image associated with each item.
		 *
		 * Not all controls that use the {@link Eto.Forms.IListItem} can support images, for
		 * example the {@link Eto.Forms.DropDown}.
		 */
		export interface IImageListItem extends Eto.Forms.IListItem {
			/** Gets the image for this item. */
			readonly Image: Eto.Drawing.Image;
		}
	}

	export namespace Eto.Forms {
		/** Control to show a list of items that the user can select */
		export class ListBox implements
			Eto.IHandlerSource,
			Eto.Forms.IBindable,
			Eto.Forms.IMouseInputSource,
			Eto.Forms.IKeyboardInputSource {
			/** Initializes a new instance of the {@link Eto.Forms.ListBox} class. */
			constructor();

			/**
			 * Gets or sets the binding for the Image of each item
			 *
			 * By default will be an public Image property on your object
			 */
			ItemImageBinding: Eto.Forms.IIndirectBinding$1<Eto.Drawing.Image>;

			/**
			 * Gets or sets the binding for the Image of each item
			 *
			 * By default will be an public Image property on your object
			 */
			ImageBinding: Eto.Forms.IIndirectBinding$1<Eto.Drawing.Image>;

			/** Gets or sets the context menu for the control. */
			ContextMenu: Eto.Forms.ContextMenu;

			/** Gets or sets the binding for the text value of each item. */
			ItemTextBinding: Eto.Forms.IIndirectBinding$1<string>;

			/** Gets or sets the binding for the key value of each item. */
			ItemKeyBinding: Eto.Forms.IIndirectBinding$1<string>;

			/** Gets or sets the binding for the text value of each item. */
			TextBinding: Eto.Forms.IIndirectBinding$1<string>;

			/** Gets or sets the binding for the key value of each item. */
			KeyBinding: Eto.Forms.IIndirectBinding$1<string>;

			/**
			 * Gets the list of items in the control.
			 *
			 * This is an alternate to using {@link Eto.Forms.ListControl.DataStore} to easily add
			 * items to the list, when you do not want to use custom objects as the source for the
			 * list. This will set the {@link Eto.Forms.ListControl.DataStore} to a new instance of a
			 * {@link Eto.Forms.ListItemCollection}.
			 */
			readonly Items: Eto.Forms.ListItemCollection;

			/** Gets or sets the data store for the items of the list control. */
			DataStore: Iterable<unknown>;

			/**
			 * Gets or sets the index of the currently selected item in the
			 * {@link Eto.Forms.ListControl.DataStore}
			 */
			SelectedIndex: number;

			/**
			 * Gets or sets the selected object value of the item in
			 * {@link Eto.Forms.ListControl.DataStore}
			 */
			SelectedValue: unknown;

			/**
			 * Gets or sets the key of the selected item in the
			 * {@link Eto.Forms.ListControl.DataStore}.
			 *
			 * This uses the {@link Eto.Forms.ListControl.ItemKeyBinding} to map the key for each
			 * item in the list.
			 */
			SelectedKey: string;

			/**
			 * Gets or sets the color of the text.
			 *
			 * By default, the text will get a color based on the user's theme. However, this is
			 * usually black.
			 */
			TextColor: Eto.Drawing.Color;

			/** Gets the binding to the {@link Eto.Forms.ListControl.SelectedIndex} property. */
			readonly SelectedIndexBinding: Eto.Forms.BindableBinding$2<Eto.Forms.ListControl, number>;

			/** Gets the binding to the {@link Eto.Forms.ListControl.SelectedKey} property. */
			readonly SelectedKeyBinding: Eto.Forms.BindableBinding$2<Eto.Forms.ListControl, string>;

			/** Gets the binding to the {@link Eto.Forms.ListControl.SelectedValue} property. */
			readonly SelectedValueBinding: Eto.Forms.BindableBinding$2<Eto.Forms.ListControl, unknown>;

			/** Gets or sets the font for the text of the control */
			Font: Eto.Drawing.Font;

			/**
			 * Gets a value indicating that the control is loaded onto a form, that is it has been
			 * created, added to a parent, and shown
			 *
			 * The {@link Eto.Forms.Control.OnLoad(System.EventArgs)} method sets this value to true
			 * after cascading to all children (for a {@link Eto.Forms.Container} ) and calling the
			 * platform handler's implementation.  It is called after adding to a loaded form, or
			 * when showing a new form.  The {@link Eto.Forms.Control.OnUnLoad(System.EventArgs)}
			 * method will set this value to false when the control is removed from its parent
			 */
			readonly Loaded: boolean;

			/**
			 * Gets an enumeration of controls that are in the visual tree.
			 *
			 * This is used to specify which controls are contained by this instance that are part of
			 * the visual tree. This should include all controls including non-logical Eto controls
			 * used for layout.
			 */
			readonly VisualControls: Iterable<Eto.Forms.Control>;

			/**
			 * Gets or sets a user-defined object that contains data about the control
			 *
			 * A common use of the tag property is to store data that is associated with the control
			 * that you can later retrieve.
			 */
			Tag: unknown;

			/**
			 * Gets the logical parent control.
			 *
			 * When the control is part of the visual tree (
				 * {@link Eto.Forms.Control.IsVisualControl} is true), this returns the logical parent
				 * that contains this control. Otherwise this is the same as
				 * {@link Eto.Forms.Control.Parent}.
				 */
				readonly LogicalParent: Eto.Forms.Container;

			/** Gets a value indicating this {@link Eto.Forms.Control} is part of the visual tree. */
			IsVisualControl: boolean;

			/**
			 * Gets or sets the size of the control. Use -1 to specify auto sizing for either the
			 * width and/or height.
			 *
			 * Setting the size of controls is entirely optional as most controls will size
			 * themselves appropriately. When specifying a size, it will be used as the desired size
			 * of the control.  The container will reposition and resize the control depending on the
			 * available size.  For a {@link Eto.Forms.Window}, it is preferred to set the
			 * {@link Eto.Forms.Container.ClientSize} instead, as various platforms have different
			 * sizes of window decorations, toolbars, etc.
			 */
			Size: Eto.Drawing.Size;

			/**
			 * Gets a value indicating this control currently has mouse capture
			 *
			 * Mouse capture can happen during a handled MouseDown event until MouseUp, or it can be
			 * captured explicitly via {@link Eto.Forms.Control.CaptureMouse}.
			 */
			readonly IsMouseCaptured: boolean;

			/** Gets or sets the width of the control size. */
			Width: number;

			/** Gets or sets the height of the control size. */
			Height: number;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Forms.Control} (or its
			 * children) are enabled and accept user input.
			 *
			 * Typically when a control is disabled, the user cannot do anything with the control or
			 * any of its children. Including for example, selecting text in a text control. Certain
			 * controls can have a 'Read Only' mode, such as {@link Eto.Forms.TextBox.ReadOnly} which
			 * allow the user to  select text, but not change its contents.
			 */
			Enabled: boolean;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Forms.Control} is visible to
			 * the user.
			 *
			 * When the visibility of a control is set to false, it will not occupy space in the
			 * layout.
			 */
			Visible: boolean;

			/** Gets the container which this control has been added to, if any */
			readonly Parent: Eto.Forms.Container;

			/**
			 * Gets the visual container of this control, if any.
			 *
			 * Some containers may use other Eto controls to layout its children, such as the
			 * {@link Eto.Forms.StackLayout}. This will return the parent control that visually
			 * contains this control as opposed to {@link Eto.Forms.Control.Parent} which will return
			 * the logical parent.
			 */
			VisualParent: Eto.Forms.Container;

			/** Gets a value indicating this control has been attached to a native container */
			readonly IsAttached: boolean;

			/**
			 * Gets or sets the color for the background of the control
			 *
			 * Note that on some platforms (e.g. Mac), setting the background color of a control can
			 * change the performance characteristics of the control and its children, since it must
			 * enable layers to do so.
			 */
			BackgroundColor: Eto.Drawing.Color;

			/** Gets a value indicating whether this instance has the keyboard input focus. */
			readonly HasFocus: boolean;

			/** Gets a value indicating whether the layout of child controls is suspended. */
			readonly IsSuspended: boolean;

			/** Gets the window this control is contained in */
			readonly ParentWindow: Eto.Forms.Window;

			/**
			 * Gets the supported platform commands that can be used to hook up system functions to
			 * user defined logic
			 *
			 * This lists all available commands that can be mapped using the
			 * {@link Eto.Forms.Control.MapPlatformCommand(System.String,Eto.Forms.Command)} method
			 * of the control.
			 */
			readonly SupportedPlatformCommands: Iterable<string>;

			/** Gets the bounding rectangle of this control relative to its container */
			readonly Bounds: Eto.Drawing.Rectangle;

			/**
			 * Gets the location of the control as positioned by the container
			 *
			 * A control's location is set by the container. This can be used to determine where the
			 * control is for overlaying floating windows, menus, etc.
			 */
			readonly Location: Eto.Drawing.Point;

			/** Gets or sets the type of cursor to use when the mouse is hovering over the control */
			Cursor: Eto.Forms.Cursor;

			/** Gets or sets the tool tip to show when the mouse is hovered over the control */
			ToolTip: string;

			/**
			 * Gets or sets the tab index order for this control within its container.
			 *
			 * This sets the order when using the tab key to cycle through controls  Note that some
			 * platforms (Gtk and WinForms) may not support setting the context of the tab order to
			 * StackLayout  or DynamicLayout containers and may not behave exactly as expected. Use
			 * the {@link Eto.PlatformFeatures.TabIndexWithCustomContainers} flag to determine if it
			 * is supported.
			 */
			TabIndex: number;

			/** Gets or sets a value indicating whether this control can serve as drop target. */
			AllowDrop: boolean;

			/**
			 * Gets or sets the parent widget which this widget has been added to, if any
			 *
			 * When implementing child widgets that can participate in the context based binding
			 * (MVVM), You can set this to the parent widget when it is added or removed to it
			 * (usually via a collection).  Note that you should typically provide a public new
			 * [ParentWidget] Parent { get; } property  so that consumers of your API cannot set the
			 * parent to an invalid value.
			 */
			Parent: Eto.Widget;

			/**
			 * Gets an enumeration of all parent widgets in the heirarchy by traversing the
			 * {@link Eto.Forms.BindableWidget.Parent} property.
			 */
			readonly Parents: Iterable<Eto.Widget>;

			/**
			 * Gets or sets the data context for this widget for binding
			 *
			 * Subclasses may override the standard behaviour so that hierarchy of widgets can be
			 * taken into account.  For example, a Control may return the data context of a parent,
			 * if it is not set explicitly.
			 */
			DataContext: unknown;

			/** Gets the collection of bindings that are attached to this widget */
			readonly Bindings: Eto.Forms.BindingCollection;

			/**
			 * Gets a value indicating that the {@link Eto.Forms.BindableWidget.DataContext} property
			 * is changing.
			 *
			 * This can be used to determine when to allow certain logic during the update of the
			 * data context.  It is used to disable binding setters on the model when the data
			 * context changes so that a binding does not cause the view model to be updated when the
			 * state hasn't been fully set yet.
			 */
			IsDataContextChanging: boolean;

			/**
			 * Gets the platform that was used to create the {@link Eto.Widget.Handler} for this
			 * widget
			 *
			 * This gets set to the current {@link Eto.Platform.Instance} during the construction of
			 * the object
			 */
			readonly Platform: Eto.Platform;

			/** Gets the platform-specific handler for this widget */
			Handler: unknown;

			/** Gets the native platform-specific handle for integration purposes */
			readonly NativeHandle: unknown;

			/** Gets the dictionary of properties for this widget */
			readonly Properties: Eto.PropertyStore;

			/** Gets or sets the ID of this widget */
			ID: string;

			/**
			 * Gets or sets the style of this widget
			 *
			 * Styles allow you to attach custom platform-specific logic to a widget. In your
			 * platform-specific assembly, use {@link Style.Add{H}(string, StyleHandler{H})} to add
			 * the style logic with the same id.
			 */
			Style: string;

			/**
			 * Gets the instance of the platform-specific object
			 *
			 * This can sometimes be useful to get the platform-specific object. Some handlers may
			 * not have any backing object for its functionality, so this may be null.  It is more
			 * preferred to use the {@link Eto.Widget.Handler} and cast that to the platform-specific
			 * handler class which can give you additional methods and helpers to do common tasks.
			 * For example, the {@link Eto.Forms.Application} object's handler for OS X has a
			 * AddFullScreenMenuItem property to specify if you want full screen support in your app.
			 */
			readonly ControlObject: unknown;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Widget} has been disposed.
			 *
			 * When the widget is disposed, it can no longer be used.
			 */
			IsDisposed: boolean;

			/**
			 * Queues a repaint of the entire control on the screen and any of its children.
			 *
			 * This is only useful when the control is visible.
			 */
			Invalidate(): void;

			/**
			 * Queues a repaint of the entire control on the screen
			 *
			 * This is only useful when the control is visible.
			 */
			Invalidate(invalidateChildren: boolean): void;

			/**
			 * Queues a repaint of the specified `rect` of the control and any children.
			 *
			 * This is only useful when the control is visible.
			 */
			Invalidate(rect: Eto.Drawing.Rectangle): void;

			/**
			 * Queues a repaint of the specified `rect` of the control
			 *
			 * This is only useful when the control is visible.
			 */
			Invalidate(
				rect: Eto.Drawing.Rectangle,
				invalidateChildren: boolean,
			): void;

			/**
			 * Updates the layout of this control if necessary.
			 *
			 * This will ensure the control has had all of its layout applied so you can use its
			 * position and size right after this call. Most platforms (except WinForms) use a
			 * deferred layout system so that after adding your control to the form dynamically it
			 * won't get laid out until the next idle loop. This is useful when you need to know the
			 * dimensions of the control immediately. Note that this can be an expensive operation,
			 * so it is recommended to only call this method when necessary and after all of the
			 * controls have been added/updated.
			 */
			UpdateLayout(): void;

			/** Gets the preferred size of this control given infinite space available. */
			GetPreferredSize(): Eto.Drawing.SizeF;

			/** Gets the preferred size of this control given the specified `availableSize`. */
			GetPreferredSize(availableSize: Eto.Drawing.SizeF): Eto.Drawing.SizeF;

			/**
			 * Captures all mouse events to this control.
			 *
			 * This captures all mouse events until {@link Eto.Forms.Control.ReleaseMouseCapture} is
			 * called.  Note that not all platforms will allow a mouse capture unless the mouse is
			 * currently down.
			 */
			CaptureMouse(): boolean;

			/** Releases the mouse capture after a call to {@link Eto.Forms.Control.CaptureMouse}. */
			ReleaseMouseCapture(): void;

			/**
			 * Finds a control in the parent hierarchy with the specified type and
			 * {@link Eto.Widget.ID} if specified
			 */
			FindParent(
				type: unknown,
				id?: string,
			): Eto.Forms.Container;

			/** Finds a control in the parent hierarchy with the specified `id` */
			FindParent(id: string): Eto.Forms.Container;

			/**
			 * Detaches the control by removing it from its parent
			 *
			 * This is essentially a shortcut to myControl.Parent.Remove(myControl);
			 */
			Detach(): void;

			/**
			 * Attaches the control for direct use in a native application
			 *
			 * Use this to use a control directly in a native application.  Note that the native
			 * application must be running the same framework as the current platform.  E.g. a
			 * WinForms application can use an Eto.Forms control when using the Eto.WinForms
			 * platform.  This prepares the control by firing the {@link Eto.Forms.Control.PreLoad},
			 * {@link Eto.Forms.Control.Load}, etc. events.
			 */
			AttachNative(): void;

			/**
			 * Detaches the control when it is used in a native application, when you want to reuse
			 * the control.
			 *
			 * This should only be called after {@link Eto.Forms.Control.AttachNative} has been
			 * called, which is usually done by calling to ToNative(true) .
			 */
			DetachNative(): void;

			/**
			 * Attempts to set the keyboard input focus to this control, or the first child that
			 * accepts focus. For Windows, this will bring it to front and activate it.
			 */
			Focus(): void;

			/**
			 * Suspends the layout of child controls
			 *
			 * This can be used to optimize some platforms while adding, removing, or changing many
			 * child controls at once. It disables the calculation of control positioning until
			 * {@link Eto.Forms.Control.ResumeLayout} is called. Each call to SuspendLayout() must be
			 * balanced with a call to {@link Eto.Forms.Control.ResumeLayout}.
			 */
			SuspendLayout(): void;

			/**
			 * Resumes the layout after it has been suspended, and performs a layout
			 *
			 * This can be used to optimize some platforms while adding, removing, or changing many
			 * child controls at once. Each call to ResumeLayout() must be balanced with a call to
			 * {@link Eto.Forms.Control.SuspendLayout} before it.
			 */
			ResumeLayout(): void;

			/**
			 * Specifies a command to execute for a platform-specific command
			 *
			 * Some platforms have specific system-defined commands that can be associated with a
			 * control. For example, the Mac platform's cut/copy/paste functionality is defined by
			 * the system, and if you want to hook into it, you can use this to map it to your own
			 * defined logic. The valid values of the `systemCommand` parameter are defined by each
			 * platform, and a list can be retrieved using
			 * {@link Eto.Forms.Control.SupportedPlatformCommands}
			 */
			MapPlatformCommand(
				systemCommand: string,
				command: Eto.Forms.Command,
			): void;

			/** Converts a point from screen space to control space. */
			PointFromScreen(point: Eto.Drawing.PointF): Eto.Drawing.PointF;

			/** Converts a point from control space to screen space */
			PointToScreen(point: Eto.Drawing.PointF): Eto.Drawing.PointF;

			/** Converts a rectangle from screen space to control space. */
			RectangleToScreen(rect: Eto.Drawing.RectangleF): Eto.Drawing.RectangleF;

			/** Converts a rectangle from control space to screen space */
			RectangleFromScreen(rect: Eto.Drawing.RectangleF): Eto.Drawing.RectangleF;

			/**
			 * Starts drag operation using this control as drag source.
			 *
			 * This method can be blocking on some platforms (Wpf, WinForms), and non-blocking on
			 * others (Mac, Gtk). Use the {@link Eto.Forms.Control.DragEnd} event to determine when
			 * the drag operation is completed and get its resulting DragEffects.
			 */
			DoDragDrop(
				data: Eto.Forms.DataObject,
				allowedEffects: Eto.Forms.DragEffects,
			): void;

			/**
			 * Starts drag operation using this control as drag source.
			 *
			 * This method can be blocking on some platforms (Wpf, WinForms), and non-blocking on
			 * others (Mac, Gtk). Use the {@link Eto.Forms.Control.DragEnd} event to determine when
			 * the drag operation is completed and get its resulting DragEffects.
			 */
			DoDragDrop(
				data: Eto.Forms.DataObject,
				allowedEffects: Eto.Forms.DragEffects,
				image: Eto.Drawing.Image,
				cursorOffset: Eto.Drawing.PointF,
			): void;

			/**
			 * Triggers the StyleChanged event and re-applies the styles to this control and its
			 * children.
			 */
			TriggerStyleChanged(): void;

			/** Shows a print dialog to print the specified control */
			Print(): void;

			/**
			 * Finds a control in the parent hierarchy with the specified type and
			 * {@link Eto.Widget.ID} if specified
			 */
			FindParent<T>(id?: string): T;

			/**
			 * Finds a control in the parent hierarchy with the specified type and
			 * {@link Eto.Widget.ID} if specified
			 */
			FindParent(
				type: unknown,
				id?: string,
			): Eto.Widget;

			/** Finds a control in the parent hierarchy with the specified `id` */
			FindParent(id: string): Eto.Widget;

			/**
			 * Unbinds any bindings in the {@link Eto.Forms.BindableWidget.Bindings} collection and
			 * removes the bindings
			 *
			 * When you implement {@link Eto.Forms.IBindableWidgetContainer}, this will also unbind
			 * any of its children.
			 */
			Unbind(): void;

			/**
			 * Updates all bindings in this widget
			 *
			 * When you implement {@link Eto.Forms.IBindableWidgetContainer}, this will also update
			 * bindings for all of its children.
			 */
			UpdateBindings(mode?: Eto.Forms.BindingUpdateMode): void;

			/** Disposes of this widget, supressing the finalizer */
			dispose(): void;

			/** Gets a string that represents the current object with its ID if specified. */
			ToString(): string;
		}
	}

	export namespace Eto.Forms.ListBox {
		export interface ICallback extends
			Eto.Forms.ListControl.ICallback,
			Eto.Forms.Control.ICallback,
			Eto.Widget.ICallback {
			OnActivated(
				widget: Eto.Forms.ListBox,
				e: unknown,
			): void;
		}
	}

	export namespace Eto.Forms.ListBox {
		export interface IHandler extends
			Eto.Forms.ListControl.IHandler,
			Eto.Forms.CommonControl.IHandler,
			Eto.Forms.Control.IHandler,
			Eto.Widget.IHandler,
			Eto.Forms.IContextMenuHost {
		}
	}

	export namespace Eto.Forms {
		/**
		 * A collection of {@link Eto.Forms.ListItem} objects for use with
		 * {@link Eto.Forms.ListControl} objects
		 *
		 * This is used to provide an easy way to add items to a {@link Eto.Forms.ListControl}.
		 * It is not mandatory to use this collection, however, since each control can specify
		 * bindings to your own model objects using {@link Eto.Forms.ListControl.ItemKeyBinding},
		 * {@link Eto.Forms.ListControl.ItemTextBinding}, or other subclass bindings.
		 */
		export class ListItemCollection {
			/** Initializes a new instance of the ListItemCollection class. */
			constructor();

			/**
			 * Initializes a new instance of the ListItemCollection class with the specified
			 * collection.
			 */
			constructor(collection: Iterable<Eto.Forms.IListItem>);

			/** Adds a new item to the list with the specified text */
			Add(text: string): void;

			/** Add a new item to the list with the specified text and key */
			Add(
				text: string,
				key: string,
			): void;

			Sort(comparer: unknown): void;

			Sort(comparison: unknown): void;

			AddRange(items: Iterable<Eto.Forms.IListItem>): void;
		}
	}

	export namespace Eto.Forms {
		/** Base control binding to a list of items */
		export class ListControl implements
			Eto.IHandlerSource,
			Eto.Forms.IBindable,
			Eto.Forms.IMouseInputSource,
			Eto.Forms.IKeyboardInputSource {
			/** Gets or sets the binding for the text value of each item. */
			ItemTextBinding: Eto.Forms.IIndirectBinding$1<string>;

			/** Gets or sets the binding for the key value of each item. */
			ItemKeyBinding: Eto.Forms.IIndirectBinding$1<string>;

			/** Gets or sets the binding for the text value of each item. */
			TextBinding: Eto.Forms.IIndirectBinding$1<string>;

			/** Gets or sets the binding for the key value of each item. */
			KeyBinding: Eto.Forms.IIndirectBinding$1<string>;

			/**
			 * Gets the list of items in the control.
			 *
			 * This is an alternate to using {@link Eto.Forms.ListControl.DataStore} to easily add
			 * items to the list, when you do not want to use custom objects as the source for the
			 * list. This will set the {@link Eto.Forms.ListControl.DataStore} to a new instance of a
			 * {@link Eto.Forms.ListItemCollection}.
			 */
			readonly Items: Eto.Forms.ListItemCollection;

			/** Gets or sets the data store for the items of the list control. */
			DataStore: Iterable<unknown>;

			/**
			 * Gets or sets the index of the currently selected item in the
			 * {@link Eto.Forms.ListControl.DataStore}
			 */
			SelectedIndex: number;

			/**
			 * Gets or sets the selected object value of the item in
			 * {@link Eto.Forms.ListControl.DataStore}
			 */
			SelectedValue: unknown;

			/**
			 * Gets or sets the key of the selected item in the
			 * {@link Eto.Forms.ListControl.DataStore}.
			 *
			 * This uses the {@link Eto.Forms.ListControl.ItemKeyBinding} to map the key for each
			 * item in the list.
			 */
			SelectedKey: string;

			/**
			 * Gets or sets the color of the text.
			 *
			 * By default, the text will get a color based on the user's theme. However, this is
			 * usually black.
			 */
			TextColor: Eto.Drawing.Color;

			/** Gets the binding to the {@link Eto.Forms.ListControl.SelectedIndex} property. */
			readonly SelectedIndexBinding: Eto.Forms.BindableBinding$2<Eto.Forms.ListControl, number>;

			/** Gets the binding to the {@link Eto.Forms.ListControl.SelectedKey} property. */
			readonly SelectedKeyBinding: Eto.Forms.BindableBinding$2<Eto.Forms.ListControl, string>;

			/** Gets the binding to the {@link Eto.Forms.ListControl.SelectedValue} property. */
			readonly SelectedValueBinding: Eto.Forms.BindableBinding$2<Eto.Forms.ListControl, unknown>;

			/** Gets or sets the font for the text of the control */
			Font: Eto.Drawing.Font;

			/**
			 * Gets a value indicating that the control is loaded onto a form, that is it has been
			 * created, added to a parent, and shown
			 *
			 * The {@link Eto.Forms.Control.OnLoad(System.EventArgs)} method sets this value to true
			 * after cascading to all children (for a {@link Eto.Forms.Container} ) and calling the
			 * platform handler's implementation.  It is called after adding to a loaded form, or
			 * when showing a new form.  The {@link Eto.Forms.Control.OnUnLoad(System.EventArgs)}
			 * method will set this value to false when the control is removed from its parent
			 */
			readonly Loaded: boolean;

			/**
			 * Gets an enumeration of controls that are in the visual tree.
			 *
			 * This is used to specify which controls are contained by this instance that are part of
			 * the visual tree. This should include all controls including non-logical Eto controls
			 * used for layout.
			 */
			readonly VisualControls: Iterable<Eto.Forms.Control>;

			/**
			 * Gets or sets a user-defined object that contains data about the control
			 *
			 * A common use of the tag property is to store data that is associated with the control
			 * that you can later retrieve.
			 */
			Tag: unknown;

			/**
			 * Gets the logical parent control.
			 *
			 * When the control is part of the visual tree (
				 * {@link Eto.Forms.Control.IsVisualControl} is true), this returns the logical parent
				 * that contains this control. Otherwise this is the same as
				 * {@link Eto.Forms.Control.Parent}.
				 */
				readonly LogicalParent: Eto.Forms.Container;

			/** Gets a value indicating this {@link Eto.Forms.Control} is part of the visual tree. */
			IsVisualControl: boolean;

			/**
			 * Gets or sets the size of the control. Use -1 to specify auto sizing for either the
			 * width and/or height.
			 *
			 * Setting the size of controls is entirely optional as most controls will size
			 * themselves appropriately. When specifying a size, it will be used as the desired size
			 * of the control.  The container will reposition and resize the control depending on the
			 * available size.  For a {@link Eto.Forms.Window}, it is preferred to set the
			 * {@link Eto.Forms.Container.ClientSize} instead, as various platforms have different
			 * sizes of window decorations, toolbars, etc.
			 */
			Size: Eto.Drawing.Size;

			/**
			 * Gets a value indicating this control currently has mouse capture
			 *
			 * Mouse capture can happen during a handled MouseDown event until MouseUp, or it can be
			 * captured explicitly via {@link Eto.Forms.Control.CaptureMouse}.
			 */
			readonly IsMouseCaptured: boolean;

			/** Gets or sets the width of the control size. */
			Width: number;

			/** Gets or sets the height of the control size. */
			Height: number;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Forms.Control} (or its
			 * children) are enabled and accept user input.
			 *
			 * Typically when a control is disabled, the user cannot do anything with the control or
			 * any of its children. Including for example, selecting text in a text control. Certain
			 * controls can have a 'Read Only' mode, such as {@link Eto.Forms.TextBox.ReadOnly} which
			 * allow the user to  select text, but not change its contents.
			 */
			Enabled: boolean;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Forms.Control} is visible to
			 * the user.
			 *
			 * When the visibility of a control is set to false, it will not occupy space in the
			 * layout.
			 */
			Visible: boolean;

			/** Gets the container which this control has been added to, if any */
			readonly Parent: Eto.Forms.Container;

			/**
			 * Gets the visual container of this control, if any.
			 *
			 * Some containers may use other Eto controls to layout its children, such as the
			 * {@link Eto.Forms.StackLayout}. This will return the parent control that visually
			 * contains this control as opposed to {@link Eto.Forms.Control.Parent} which will return
			 * the logical parent.
			 */
			VisualParent: Eto.Forms.Container;

			/** Gets a value indicating this control has been attached to a native container */
			readonly IsAttached: boolean;

			/**
			 * Gets or sets the color for the background of the control
			 *
			 * Note that on some platforms (e.g. Mac), setting the background color of a control can
			 * change the performance characteristics of the control and its children, since it must
			 * enable layers to do so.
			 */
			BackgroundColor: Eto.Drawing.Color;

			/** Gets a value indicating whether this instance has the keyboard input focus. */
			readonly HasFocus: boolean;

			/** Gets a value indicating whether the layout of child controls is suspended. */
			readonly IsSuspended: boolean;

			/** Gets the window this control is contained in */
			readonly ParentWindow: Eto.Forms.Window;

			/**
			 * Gets the supported platform commands that can be used to hook up system functions to
			 * user defined logic
			 *
			 * This lists all available commands that can be mapped using the
			 * {@link Eto.Forms.Control.MapPlatformCommand(System.String,Eto.Forms.Command)} method
			 * of the control.
			 */
			readonly SupportedPlatformCommands: Iterable<string>;

			/** Gets the bounding rectangle of this control relative to its container */
			readonly Bounds: Eto.Drawing.Rectangle;

			/**
			 * Gets the location of the control as positioned by the container
			 *
			 * A control's location is set by the container. This can be used to determine where the
			 * control is for overlaying floating windows, menus, etc.
			 */
			readonly Location: Eto.Drawing.Point;

			/** Gets or sets the type of cursor to use when the mouse is hovering over the control */
			Cursor: Eto.Forms.Cursor;

			/** Gets or sets the tool tip to show when the mouse is hovered over the control */
			ToolTip: string;

			/**
			 * Gets or sets the tab index order for this control within its container.
			 *
			 * This sets the order when using the tab key to cycle through controls  Note that some
			 * platforms (Gtk and WinForms) may not support setting the context of the tab order to
			 * StackLayout  or DynamicLayout containers and may not behave exactly as expected. Use
			 * the {@link Eto.PlatformFeatures.TabIndexWithCustomContainers} flag to determine if it
			 * is supported.
			 */
			TabIndex: number;

			/** Gets or sets a value indicating whether this control can serve as drop target. */
			AllowDrop: boolean;

			/**
			 * Gets or sets the parent widget which this widget has been added to, if any
			 *
			 * When implementing child widgets that can participate in the context based binding
			 * (MVVM), You can set this to the parent widget when it is added or removed to it
			 * (usually via a collection).  Note that you should typically provide a public new
			 * [ParentWidget] Parent { get; } property  so that consumers of your API cannot set the
			 * parent to an invalid value.
			 */
			Parent: Eto.Widget;

			/**
			 * Gets an enumeration of all parent widgets in the heirarchy by traversing the
			 * {@link Eto.Forms.BindableWidget.Parent} property.
			 */
			readonly Parents: Iterable<Eto.Widget>;

			/**
			 * Gets or sets the data context for this widget for binding
			 *
			 * Subclasses may override the standard behaviour so that hierarchy of widgets can be
			 * taken into account.  For example, a Control may return the data context of a parent,
			 * if it is not set explicitly.
			 */
			DataContext: unknown;

			/** Gets the collection of bindings that are attached to this widget */
			readonly Bindings: Eto.Forms.BindingCollection;

			/**
			 * Gets a value indicating that the {@link Eto.Forms.BindableWidget.DataContext} property
			 * is changing.
			 *
			 * This can be used to determine when to allow certain logic during the update of the
			 * data context.  It is used to disable binding setters on the model when the data
			 * context changes so that a binding does not cause the view model to be updated when the
			 * state hasn't been fully set yet.
			 */
			IsDataContextChanging: boolean;

			/**
			 * Gets the platform that was used to create the {@link Eto.Widget.Handler} for this
			 * widget
			 *
			 * This gets set to the current {@link Eto.Platform.Instance} during the construction of
			 * the object
			 */
			readonly Platform: Eto.Platform;

			/** Gets the platform-specific handler for this widget */
			Handler: unknown;

			/** Gets the native platform-specific handle for integration purposes */
			readonly NativeHandle: unknown;

			/** Gets the dictionary of properties for this widget */
			readonly Properties: Eto.PropertyStore;

			/** Gets or sets the ID of this widget */
			ID: string;

			/**
			 * Gets or sets the style of this widget
			 *
			 * Styles allow you to attach custom platform-specific logic to a widget. In your
			 * platform-specific assembly, use {@link Style.Add{H}(string, StyleHandler{H})} to add
			 * the style logic with the same id.
			 */
			Style: string;

			/**
			 * Gets the instance of the platform-specific object
			 *
			 * This can sometimes be useful to get the platform-specific object. Some handlers may
			 * not have any backing object for its functionality, so this may be null.  It is more
			 * preferred to use the {@link Eto.Widget.Handler} and cast that to the platform-specific
			 * handler class which can give you additional methods and helpers to do common tasks.
			 * For example, the {@link Eto.Forms.Application} object's handler for OS X has a
			 * AddFullScreenMenuItem property to specify if you want full screen support in your app.
			 */
			readonly ControlObject: unknown;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Widget} has been disposed.
			 *
			 * When the widget is disposed, it can no longer be used.
			 */
			IsDisposed: boolean;

			/**
			 * Queues a repaint of the entire control on the screen and any of its children.
			 *
			 * This is only useful when the control is visible.
			 */
			Invalidate(): void;

			/**
			 * Queues a repaint of the entire control on the screen
			 *
			 * This is only useful when the control is visible.
			 */
			Invalidate(invalidateChildren: boolean): void;

			/**
			 * Queues a repaint of the specified `rect` of the control and any children.
			 *
			 * This is only useful when the control is visible.
			 */
			Invalidate(rect: Eto.Drawing.Rectangle): void;

			/**
			 * Queues a repaint of the specified `rect` of the control
			 *
			 * This is only useful when the control is visible.
			 */
			Invalidate(
				rect: Eto.Drawing.Rectangle,
				invalidateChildren: boolean,
			): void;

			/**
			 * Updates the layout of this control if necessary.
			 *
			 * This will ensure the control has had all of its layout applied so you can use its
			 * position and size right after this call. Most platforms (except WinForms) use a
			 * deferred layout system so that after adding your control to the form dynamically it
			 * won't get laid out until the next idle loop. This is useful when you need to know the
			 * dimensions of the control immediately. Note that this can be an expensive operation,
			 * so it is recommended to only call this method when necessary and after all of the
			 * controls have been added/updated.
			 */
			UpdateLayout(): void;

			/** Gets the preferred size of this control given infinite space available. */
			GetPreferredSize(): Eto.Drawing.SizeF;

			/** Gets the preferred size of this control given the specified `availableSize`. */
			GetPreferredSize(availableSize: Eto.Drawing.SizeF): Eto.Drawing.SizeF;

			/**
			 * Captures all mouse events to this control.
			 *
			 * This captures all mouse events until {@link Eto.Forms.Control.ReleaseMouseCapture} is
			 * called.  Note that not all platforms will allow a mouse capture unless the mouse is
			 * currently down.
			 */
			CaptureMouse(): boolean;

			/** Releases the mouse capture after a call to {@link Eto.Forms.Control.CaptureMouse}. */
			ReleaseMouseCapture(): void;

			/**
			 * Finds a control in the parent hierarchy with the specified type and
			 * {@link Eto.Widget.ID} if specified
			 */
			FindParent(
				type: unknown,
				id?: string,
			): Eto.Forms.Container;

			/** Finds a control in the parent hierarchy with the specified `id` */
			FindParent(id: string): Eto.Forms.Container;

			/**
			 * Detaches the control by removing it from its parent
			 *
			 * This is essentially a shortcut to myControl.Parent.Remove(myControl);
			 */
			Detach(): void;

			/**
			 * Attaches the control for direct use in a native application
			 *
			 * Use this to use a control directly in a native application.  Note that the native
			 * application must be running the same framework as the current platform.  E.g. a
			 * WinForms application can use an Eto.Forms control when using the Eto.WinForms
			 * platform.  This prepares the control by firing the {@link Eto.Forms.Control.PreLoad},
			 * {@link Eto.Forms.Control.Load}, etc. events.
			 */
			AttachNative(): void;

			/**
			 * Detaches the control when it is used in a native application, when you want to reuse
			 * the control.
			 *
			 * This should only be called after {@link Eto.Forms.Control.AttachNative} has been
			 * called, which is usually done by calling to ToNative(true) .
			 */
			DetachNative(): void;

			/**
			 * Attempts to set the keyboard input focus to this control, or the first child that
			 * accepts focus. For Windows, this will bring it to front and activate it.
			 */
			Focus(): void;

			/**
			 * Suspends the layout of child controls
			 *
			 * This can be used to optimize some platforms while adding, removing, or changing many
			 * child controls at once. It disables the calculation of control positioning until
			 * {@link Eto.Forms.Control.ResumeLayout} is called. Each call to SuspendLayout() must be
			 * balanced with a call to {@link Eto.Forms.Control.ResumeLayout}.
			 */
			SuspendLayout(): void;

			/**
			 * Resumes the layout after it has been suspended, and performs a layout
			 *
			 * This can be used to optimize some platforms while adding, removing, or changing many
			 * child controls at once. Each call to ResumeLayout() must be balanced with a call to
			 * {@link Eto.Forms.Control.SuspendLayout} before it.
			 */
			ResumeLayout(): void;

			/**
			 * Specifies a command to execute for a platform-specific command
			 *
			 * Some platforms have specific system-defined commands that can be associated with a
			 * control. For example, the Mac platform's cut/copy/paste functionality is defined by
			 * the system, and if you want to hook into it, you can use this to map it to your own
			 * defined logic. The valid values of the `systemCommand` parameter are defined by each
			 * platform, and a list can be retrieved using
			 * {@link Eto.Forms.Control.SupportedPlatformCommands}
			 */
			MapPlatformCommand(
				systemCommand: string,
				command: Eto.Forms.Command,
			): void;

			/** Converts a point from screen space to control space. */
			PointFromScreen(point: Eto.Drawing.PointF): Eto.Drawing.PointF;

			/** Converts a point from control space to screen space */
			PointToScreen(point: Eto.Drawing.PointF): Eto.Drawing.PointF;

			/** Converts a rectangle from screen space to control space. */
			RectangleToScreen(rect: Eto.Drawing.RectangleF): Eto.Drawing.RectangleF;

			/** Converts a rectangle from control space to screen space */
			RectangleFromScreen(rect: Eto.Drawing.RectangleF): Eto.Drawing.RectangleF;

			/**
			 * Starts drag operation using this control as drag source.
			 *
			 * This method can be blocking on some platforms (Wpf, WinForms), and non-blocking on
			 * others (Mac, Gtk). Use the {@link Eto.Forms.Control.DragEnd} event to determine when
			 * the drag operation is completed and get its resulting DragEffects.
			 */
			DoDragDrop(
				data: Eto.Forms.DataObject,
				allowedEffects: Eto.Forms.DragEffects,
			): void;

			/**
			 * Starts drag operation using this control as drag source.
			 *
			 * This method can be blocking on some platforms (Wpf, WinForms), and non-blocking on
			 * others (Mac, Gtk). Use the {@link Eto.Forms.Control.DragEnd} event to determine when
			 * the drag operation is completed and get its resulting DragEffects.
			 */
			DoDragDrop(
				data: Eto.Forms.DataObject,
				allowedEffects: Eto.Forms.DragEffects,
				image: Eto.Drawing.Image,
				cursorOffset: Eto.Drawing.PointF,
			): void;

			/**
			 * Triggers the StyleChanged event and re-applies the styles to this control and its
			 * children.
			 */
			TriggerStyleChanged(): void;

			/** Shows a print dialog to print the specified control */
			Print(): void;

			/**
			 * Finds a control in the parent hierarchy with the specified type and
			 * {@link Eto.Widget.ID} if specified
			 */
			FindParent<T>(id?: string): T;

			/**
			 * Finds a control in the parent hierarchy with the specified type and
			 * {@link Eto.Widget.ID} if specified
			 */
			FindParent(
				type: unknown,
				id?: string,
			): Eto.Widget;

			/** Finds a control in the parent hierarchy with the specified `id` */
			FindParent(id: string): Eto.Widget;

			/**
			 * Unbinds any bindings in the {@link Eto.Forms.BindableWidget.Bindings} collection and
			 * removes the bindings
			 *
			 * When you implement {@link Eto.Forms.IBindableWidgetContainer}, this will also unbind
			 * any of its children.
			 */
			Unbind(): void;

			/**
			 * Updates all bindings in this widget
			 *
			 * When you implement {@link Eto.Forms.IBindableWidgetContainer}, this will also update
			 * bindings for all of its children.
			 */
			UpdateBindings(mode?: Eto.Forms.BindingUpdateMode): void;

			/** Disposes of this widget, supressing the finalizer */
			dispose(): void;

			/** Gets a string that represents the current object with its ID if specified. */
			ToString(): string;
		}
	}

	export namespace Eto.Forms.ListControl {
		export interface ICallback extends
			Eto.Forms.Control.ICallback,
			Eto.Widget.ICallback {
			OnSelectedIndexChanged(
				widget: Eto.Forms.ListControl,
				e: unknown,
			): void;
		}
	}

	export namespace Eto.Forms.ListControl {
		export interface IHandler extends
			Eto.Forms.CommonControl.IHandler,
			Eto.Forms.Control.IHandler,
			Eto.Widget.IHandler {
			DataStore: Iterable<unknown>;

			SelectedIndex: number;

			TextColor: Eto.Drawing.Color;

			ItemTextBinding: Eto.Forms.IIndirectBinding$1<string>;

			ItemKeyBinding: Eto.Forms.IIndirectBinding$1<string>;
		}
	}

	export namespace Eto.Forms {
		/** Mode for insertion of text when the user types into a control. */
		export enum InsertKeyMode {
			/**
			 * Always insert, shifting any characters to the right of the caret position when
			 * inserting or deleting text.
			 */
			Insert = 0,

			/** Always overwrite and do not shift characters when inserting or deleting text. */
			Overwrite = 1,

			/**
			 * Allow the user to toggle the insert mode (fn+Return on OS X or insert key on other
			 * keyboards)
			 */
			Toggle = 2,
		}
	}

	export namespace Eto.Forms {
		/** Mode for when prompt characters are shown in a control. */
		export enum ShowPromptMode {
			/** Always show the prompt characters. */
			Always = 0,

			/** Only show the prompt characters when the control has focus. */
			OnFocus = 1,

			/** Never show the prompt characters */
			Never = 2,
		}
	}

	export namespace Eto.Forms {
		/**
		 * [Generic type factory] Masked text box with a variable length numeric mask.
		 *
		 * This provides a text box that limits the user input to only allow numeric values.
		 */
		export function NumericMaskedTextBox$(T: IType): typeof NumericMaskedTextBox$1<any>;

		/**
		 * Masked text box with a variable length numeric mask.
		 *
		 * This provides a text box that limits the user input to only allow numeric values.
		 */
		export class NumericMaskedTextBox$1<T> implements
			Eto.IHandlerSource,
			Eto.Forms.IBindable,
			Eto.Forms.IMouseInputSource,
			Eto.Forms.IKeyboardInputSource {
			/** Initializes a new instance of the {@link Eto.Forms.NumericMaskedTextBox<>} class. */
			new(): NumericMaskedTextBox$1<T>;

			/** Gets the numeric provider. */
			readonly Provider: Eto.Forms.NumericMaskedTextProvider$1<T>;

			/**
			 * Gets or sets a value indicating whether the mask can accept a sign.
			 *
			 * This defaults to whether the type specified by  allows negative values.
			 */
			AllowSign: boolean;

			/**
			 * Gets or sets a value indicating whether the mask can input a decimal.
			 *
			 * This defaults to whether the type specified by  allows decimals, such as when it is a
			 * decimal, double, or float.
			 */
			AllowDecimal: boolean;

			/**
			 * Gets or sets the culture for the
			 * {@link Eto.Forms.NumericMaskedTextProvider.DecimalCharacter} and
			 * {@link Eto.Forms.NumericMaskedTextProvider.SignCharacters} formatting characters.
			 */
			Culture: unknown;

			Provider: Eto.Forms.IMaskedTextProvider$1<T>;

			Value: T;

			readonly ValueBinding: Eto.Forms.BindableBinding$2<Eto.Forms.MaskedTextBox$1<T>, T>;

			/** Gets or sets the masked text provider to specify the mask format. */
			Provider: Eto.Forms.IMaskedTextProvider;

			/**
			 * Gets or sets the mode for insertion. Use {@link Eto.Forms.MaskedTextBox.IsOverwrite}
			 * to determine the current mode.
			 */
			InsertMode: Eto.Forms.InsertKeyMode;

			/** Gets a value indicating whether typing will overwrite text. */
			readonly IsOverwrite: boolean;

			/**
			 * Gets or sets a value indicating that the prompt characters should only be shown when
			 * the control has focus.
			 */
			ShowPromptOnFocus: boolean;

			/** Gets or sets the mode for when the input prompts should be shown */
			ShowPromptMode: Eto.Forms.ShowPromptMode;

			/**
			 * Gets or sets a value indicating that the placeholder should be shown when the mask is
			 * empty and the control does not have focus.
			 */
			ShowPlaceholderWhenEmpty: boolean;

			/** Gets or sets the text of the control including any mask characters. */
			Text: string;

			/** Gets a value indicating whether the mask is completed. */
			readonly MaskCompleted: boolean;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Forms.TextBox} is read only.
			 *
			 * A user can selected and copied text when the read only, however the user will not be
			 * able to change any of the text. This differs from the
			 * {@link Eto.Forms.Control.Enabled} property, which disables all user interaction.
			 */
			ReadOnly: boolean;

			/**
			 * Gets or sets the maximum length of the text that can be entered in the control, 0 for
			 * no limit.
			 *
			 * This typically does not affect the value set using {@link Eto.Forms.TextControl.Text},
			 * only the limit of what the user can  enter into the control.
			 */
			MaxLength: number;

			/**
			 * Gets or sets the placeholder text to show as a hint of what the user should enter.
			 *
			 * Typically this will be shown when the control is blank, and will dissappear when the
			 * user enters text or if it has an existing value.
			 */
			PlaceholderText: string;

			/**
			 * Gets or sets a value indicating whether to show the control's border.
			 *
			 * This is a hint to omit the border of the control and show it as plainly as possible.
			 * Typically used when you want to show the control within a cell of the
			 * {@link Eto.Forms.GridView}.
			 */
			ShowBorder: boolean;

			/** Gets or sets the alignment of the text in the entry box. */
			TextAlignment: Eto.Forms.TextAlignment;

			/**
			 * Gets or sets the index of the current insertion point.
			 *
			 * When there is selected text, this is usually the start of the selection.
			 */
			CaretIndex: number;

			/** Gets or sets the current text selection. */
			Selection: Eto.Forms.Range$1<number>;

			/** Gets or sets the selected text. */
			SelectedText: string;

			/** Gets or sets the auto selection mode. */
			AutoSelectMode: Eto.Forms.AutoSelectMode;

			/**
			 * Gets or sets the color of the text.
			 *
			 * By default, the text will get a color based on the user's theme. However, this is
			 * usually black.
			 */
			TextColor: Eto.Drawing.Color;

			/** Gets the binding for the {@link Eto.Forms.TextControl.Text} property. */
			readonly TextBinding: Eto.Forms.BindableBinding$2<Eto.Forms.TextControl, string>;

			/** Gets or sets the font for the text of the control */
			Font: Eto.Drawing.Font;

			/**
			 * Gets a value indicating that the control is loaded onto a form, that is it has been
			 * created, added to a parent, and shown
			 *
			 * The {@link Eto.Forms.Control.OnLoad(System.EventArgs)} method sets this value to true
			 * after cascading to all children (for a {@link Eto.Forms.Container} ) and calling the
			 * platform handler's implementation.  It is called after adding to a loaded form, or
			 * when showing a new form.  The {@link Eto.Forms.Control.OnUnLoad(System.EventArgs)}
			 * method will set this value to false when the control is removed from its parent
			 */
			readonly Loaded: boolean;

			/**
			 * Gets an enumeration of controls that are in the visual tree.
			 *
			 * This is used to specify which controls are contained by this instance that are part of
			 * the visual tree. This should include all controls including non-logical Eto controls
			 * used for layout.
			 */
			readonly VisualControls: Iterable<Eto.Forms.Control>;

			/**
			 * Gets or sets a user-defined object that contains data about the control
			 *
			 * A common use of the tag property is to store data that is associated with the control
			 * that you can later retrieve.
			 */
			Tag: unknown;

			/**
			 * Gets the logical parent control.
			 *
			 * When the control is part of the visual tree (
				 * {@link Eto.Forms.Control.IsVisualControl} is true), this returns the logical parent
				 * that contains this control. Otherwise this is the same as
				 * {@link Eto.Forms.Control.Parent}.
				 */
				readonly LogicalParent: Eto.Forms.Container;

			/** Gets a value indicating this {@link Eto.Forms.Control} is part of the visual tree. */
			IsVisualControl: boolean;

			/**
			 * Gets or sets the size of the control. Use -1 to specify auto sizing for either the
			 * width and/or height.
			 *
			 * Setting the size of controls is entirely optional as most controls will size
			 * themselves appropriately. When specifying a size, it will be used as the desired size
			 * of the control.  The container will reposition and resize the control depending on the
			 * available size.  For a {@link Eto.Forms.Window}, it is preferred to set the
			 * {@link Eto.Forms.Container.ClientSize} instead, as various platforms have different
			 * sizes of window decorations, toolbars, etc.
			 */
			Size: Eto.Drawing.Size;

			/**
			 * Gets a value indicating this control currently has mouse capture
			 *
			 * Mouse capture can happen during a handled MouseDown event until MouseUp, or it can be
			 * captured explicitly via {@link Eto.Forms.Control.CaptureMouse}.
			 */
			readonly IsMouseCaptured: boolean;

			/** Gets or sets the width of the control size. */
			Width: number;

			/** Gets or sets the height of the control size. */
			Height: number;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Forms.Control} (or its
			 * children) are enabled and accept user input.
			 *
			 * Typically when a control is disabled, the user cannot do anything with the control or
			 * any of its children. Including for example, selecting text in a text control. Certain
			 * controls can have a 'Read Only' mode, such as {@link Eto.Forms.TextBox.ReadOnly} which
			 * allow the user to  select text, but not change its contents.
			 */
			Enabled: boolean;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Forms.Control} is visible to
			 * the user.
			 *
			 * When the visibility of a control is set to false, it will not occupy space in the
			 * layout.
			 */
			Visible: boolean;

			/** Gets the container which this control has been added to, if any */
			readonly Parent: Eto.Forms.Container;

			/**
			 * Gets the visual container of this control, if any.
			 *
			 * Some containers may use other Eto controls to layout its children, such as the
			 * {@link Eto.Forms.StackLayout}. This will return the parent control that visually
			 * contains this control as opposed to {@link Eto.Forms.Control.Parent} which will return
			 * the logical parent.
			 */
			VisualParent: Eto.Forms.Container;

			/** Gets a value indicating this control has been attached to a native container */
			readonly IsAttached: boolean;

			/**
			 * Gets or sets the color for the background of the control
			 *
			 * Note that on some platforms (e.g. Mac), setting the background color of a control can
			 * change the performance characteristics of the control and its children, since it must
			 * enable layers to do so.
			 */
			BackgroundColor: Eto.Drawing.Color;

			/** Gets a value indicating whether this instance has the keyboard input focus. */
			readonly HasFocus: boolean;

			/** Gets a value indicating whether the layout of child controls is suspended. */
			readonly IsSuspended: boolean;

			/** Gets the window this control is contained in */
			readonly ParentWindow: Eto.Forms.Window;

			/**
			 * Gets the supported platform commands that can be used to hook up system functions to
			 * user defined logic
			 *
			 * This lists all available commands that can be mapped using the
			 * {@link Eto.Forms.Control.MapPlatformCommand(System.String,Eto.Forms.Command)} method
			 * of the control.
			 */
			readonly SupportedPlatformCommands: Iterable<string>;

			/** Gets the bounding rectangle of this control relative to its container */
			readonly Bounds: Eto.Drawing.Rectangle;

			/**
			 * Gets the location of the control as positioned by the container
			 *
			 * A control's location is set by the container. This can be used to determine where the
			 * control is for overlaying floating windows, menus, etc.
			 */
			readonly Location: Eto.Drawing.Point;

			/** Gets or sets the type of cursor to use when the mouse is hovering over the control */
			Cursor: Eto.Forms.Cursor;

			/** Gets or sets the tool tip to show when the mouse is hovered over the control */
			ToolTip: string;

			/**
			 * Gets or sets the tab index order for this control within its container.
			 *
			 * This sets the order when using the tab key to cycle through controls  Note that some
			 * platforms (Gtk and WinForms) may not support setting the context of the tab order to
			 * StackLayout  or DynamicLayout containers and may not behave exactly as expected. Use
			 * the {@link Eto.PlatformFeatures.TabIndexWithCustomContainers} flag to determine if it
			 * is supported.
			 */
			TabIndex: number;

			/** Gets or sets a value indicating whether this control can serve as drop target. */
			AllowDrop: boolean;

			/**
			 * Gets or sets the parent widget which this widget has been added to, if any
			 *
			 * When implementing child widgets that can participate in the context based binding
			 * (MVVM), You can set this to the parent widget when it is added or removed to it
			 * (usually via a collection).  Note that you should typically provide a public new
			 * [ParentWidget] Parent { get; } property  so that consumers of your API cannot set the
			 * parent to an invalid value.
			 */
			Parent: Eto.Widget;

			/**
			 * Gets an enumeration of all parent widgets in the heirarchy by traversing the
			 * {@link Eto.Forms.BindableWidget.Parent} property.
			 */
			readonly Parents: Iterable<Eto.Widget>;

			/**
			 * Gets or sets the data context for this widget for binding
			 *
			 * Subclasses may override the standard behaviour so that hierarchy of widgets can be
			 * taken into account.  For example, a Control may return the data context of a parent,
			 * if it is not set explicitly.
			 */
			DataContext: unknown;

			/** Gets the collection of bindings that are attached to this widget */
			readonly Bindings: Eto.Forms.BindingCollection;

			/**
			 * Gets a value indicating that the {@link Eto.Forms.BindableWidget.DataContext} property
			 * is changing.
			 *
			 * This can be used to determine when to allow certain logic during the update of the
			 * data context.  It is used to disable binding setters on the model when the data
			 * context changes so that a binding does not cause the view model to be updated when the
			 * state hasn't been fully set yet.
			 */
			IsDataContextChanging: boolean;

			/**
			 * Gets the platform that was used to create the {@link Eto.Widget.Handler} for this
			 * widget
			 *
			 * This gets set to the current {@link Eto.Platform.Instance} during the construction of
			 * the object
			 */
			readonly Platform: Eto.Platform;

			/** Gets the platform-specific handler for this widget */
			Handler: unknown;

			/** Gets the native platform-specific handle for integration purposes */
			readonly NativeHandle: unknown;

			/** Gets the dictionary of properties for this widget */
			readonly Properties: Eto.PropertyStore;

			/** Gets or sets the ID of this widget */
			ID: string;

			/**
			 * Gets or sets the style of this widget
			 *
			 * Styles allow you to attach custom platform-specific logic to a widget. In your
			 * platform-specific assembly, use {@link Style.Add{H}(string, StyleHandler{H})} to add
			 * the style logic with the same id.
			 */
			Style: string;

			/**
			 * Gets the instance of the platform-specific object
			 *
			 * This can sometimes be useful to get the platform-specific object. Some handlers may
			 * not have any backing object for its functionality, so this may be null.  It is more
			 * preferred to use the {@link Eto.Widget.Handler} and cast that to the platform-specific
			 * handler class which can give you additional methods and helpers to do common tasks.
			 * For example, the {@link Eto.Forms.Application} object's handler for OS X has a
			 * AddFullScreenMenuItem property to specify if you want full screen support in your app.
			 */
			readonly ControlObject: unknown;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Widget} has been disposed.
			 *
			 * When the widget is disposed, it can no longer be used.
			 */
			IsDisposed: boolean;

			/**
			 * Selects all of the text in the control.
			 *
			 * When setting the selection, the control will be focussed and the associated keyboard
			 * may appear on mobile platforms.
			 */
			SelectAll(): void;

			/**
			 * Queues a repaint of the entire control on the screen and any of its children.
			 *
			 * This is only useful when the control is visible.
			 */
			Invalidate(): void;

			/**
			 * Queues a repaint of the entire control on the screen
			 *
			 * This is only useful when the control is visible.
			 */
			Invalidate(invalidateChildren: boolean): void;

			/**
			 * Queues a repaint of the specified `rect` of the control and any children.
			 *
			 * This is only useful when the control is visible.
			 */
			Invalidate(rect: Eto.Drawing.Rectangle): void;

			/**
			 * Queues a repaint of the specified `rect` of the control
			 *
			 * This is only useful when the control is visible.
			 */
			Invalidate(
				rect: Eto.Drawing.Rectangle,
				invalidateChildren: boolean,
			): void;

			/**
			 * Updates the layout of this control if necessary.
			 *
			 * This will ensure the control has had all of its layout applied so you can use its
			 * position and size right after this call. Most platforms (except WinForms) use a
			 * deferred layout system so that after adding your control to the form dynamically it
			 * won't get laid out until the next idle loop. This is useful when you need to know the
			 * dimensions of the control immediately. Note that this can be an expensive operation,
			 * so it is recommended to only call this method when necessary and after all of the
			 * controls have been added/updated.
			 */
			UpdateLayout(): void;

			/** Gets the preferred size of this control given infinite space available. */
			GetPreferredSize(): Eto.Drawing.SizeF;

			/** Gets the preferred size of this control given the specified `availableSize`. */
			GetPreferredSize(availableSize: Eto.Drawing.SizeF): Eto.Drawing.SizeF;

			/**
			 * Captures all mouse events to this control.
			 *
			 * This captures all mouse events until {@link Eto.Forms.Control.ReleaseMouseCapture} is
			 * called.  Note that not all platforms will allow a mouse capture unless the mouse is
			 * currently down.
			 */
			CaptureMouse(): boolean;

			/** Releases the mouse capture after a call to {@link Eto.Forms.Control.CaptureMouse}. */
			ReleaseMouseCapture(): void;

			/**
			 * Finds a control in the parent hierarchy with the specified type and
			 * {@link Eto.Widget.ID} if specified
			 */
			FindParent(
				type: unknown,
				id?: string,
			): Eto.Forms.Container;

			/** Finds a control in the parent hierarchy with the specified `id` */
			FindParent(id: string): Eto.Forms.Container;

			/**
			 * Detaches the control by removing it from its parent
			 *
			 * This is essentially a shortcut to myControl.Parent.Remove(myControl);
			 */
			Detach(): void;

			/**
			 * Attaches the control for direct use in a native application
			 *
			 * Use this to use a control directly in a native application.  Note that the native
			 * application must be running the same framework as the current platform.  E.g. a
			 * WinForms application can use an Eto.Forms control when using the Eto.WinForms
			 * platform.  This prepares the control by firing the {@link Eto.Forms.Control.PreLoad},
			 * {@link Eto.Forms.Control.Load}, etc. events.
			 */
			AttachNative(): void;

			/**
			 * Detaches the control when it is used in a native application, when you want to reuse
			 * the control.
			 *
			 * This should only be called after {@link Eto.Forms.Control.AttachNative} has been
			 * called, which is usually done by calling to ToNative(true) .
			 */
			DetachNative(): void;

			/**
			 * Attempts to set the keyboard input focus to this control, or the first child that
			 * accepts focus. For Windows, this will bring it to front and activate it.
			 */
			Focus(): void;

			/**
			 * Suspends the layout of child controls
			 *
			 * This can be used to optimize some platforms while adding, removing, or changing many
			 * child controls at once. It disables the calculation of control positioning until
			 * {@link Eto.Forms.Control.ResumeLayout} is called. Each call to SuspendLayout() must be
			 * balanced with a call to {@link Eto.Forms.Control.ResumeLayout}.
			 */
			SuspendLayout(): void;

			/**
			 * Resumes the layout after it has been suspended, and performs a layout
			 *
			 * This can be used to optimize some platforms while adding, removing, or changing many
			 * child controls at once. Each call to ResumeLayout() must be balanced with a call to
			 * {@link Eto.Forms.Control.SuspendLayout} before it.
			 */
			ResumeLayout(): void;

			/**
			 * Specifies a command to execute for a platform-specific command
			 *
			 * Some platforms have specific system-defined commands that can be associated with a
			 * control. For example, the Mac platform's cut/copy/paste functionality is defined by
			 * the system, and if you want to hook into it, you can use this to map it to your own
			 * defined logic. The valid values of the `systemCommand` parameter are defined by each
			 * platform, and a list can be retrieved using
			 * {@link Eto.Forms.Control.SupportedPlatformCommands}
			 */
			MapPlatformCommand(
				systemCommand: string,
				command: Eto.Forms.Command,
			): void;

			/** Converts a point from screen space to control space. */
			PointFromScreen(point: Eto.Drawing.PointF): Eto.Drawing.PointF;

			/** Converts a point from control space to screen space */
			PointToScreen(point: Eto.Drawing.PointF): Eto.Drawing.PointF;

			/** Converts a rectangle from screen space to control space. */
			RectangleToScreen(rect: Eto.Drawing.RectangleF): Eto.Drawing.RectangleF;

			/** Converts a rectangle from control space to screen space */
			RectangleFromScreen(rect: Eto.Drawing.RectangleF): Eto.Drawing.RectangleF;

			/**
			 * Starts drag operation using this control as drag source.
			 *
			 * This method can be blocking on some platforms (Wpf, WinForms), and non-blocking on
			 * others (Mac, Gtk). Use the {@link Eto.Forms.Control.DragEnd} event to determine when
			 * the drag operation is completed and get its resulting DragEffects.
			 */
			DoDragDrop(
				data: Eto.Forms.DataObject,
				allowedEffects: Eto.Forms.DragEffects,
			): void;

			/**
			 * Starts drag operation using this control as drag source.
			 *
			 * This method can be blocking on some platforms (Wpf, WinForms), and non-blocking on
			 * others (Mac, Gtk). Use the {@link Eto.Forms.Control.DragEnd} event to determine when
			 * the drag operation is completed and get its resulting DragEffects.
			 */
			DoDragDrop(
				data: Eto.Forms.DataObject,
				allowedEffects: Eto.Forms.DragEffects,
				image: Eto.Drawing.Image,
				cursorOffset: Eto.Drawing.PointF,
			): void;

			/**
			 * Triggers the StyleChanged event and re-applies the styles to this control and its
			 * children.
			 */
			TriggerStyleChanged(): void;

			/** Shows a print dialog to print the specified control */
			Print(): void;

			/**
			 * Finds a control in the parent hierarchy with the specified type and
			 * {@link Eto.Widget.ID} if specified
			 */
			FindParent<T>(id?: string): T;

			/**
			 * Finds a control in the parent hierarchy with the specified type and
			 * {@link Eto.Widget.ID} if specified
			 */
			FindParent(
				type: unknown,
				id?: string,
			): Eto.Widget;

			/** Finds a control in the parent hierarchy with the specified `id` */
			FindParent(id: string): Eto.Widget;

			/**
			 * Unbinds any bindings in the {@link Eto.Forms.BindableWidget.Bindings} collection and
			 * removes the bindings
			 *
			 * When you implement {@link Eto.Forms.IBindableWidgetContainer}, this will also unbind
			 * any of its children.
			 */
			Unbind(): void;

			/**
			 * Updates all bindings in this widget
			 *
			 * When you implement {@link Eto.Forms.IBindableWidgetContainer}, this will also update
			 * bindings for all of its children.
			 */
			UpdateBindings(mode?: Eto.Forms.BindingUpdateMode): void;

			/** Disposes of this widget, supressing the finalizer */
			dispose(): void;

			/** Gets a string that represents the current object with its ID if specified. */
			ToString(): string;
		}
	}

	export namespace Eto.Forms {
		/**
		 * [Generic type factory] Masked text box that provides a value converted to/from text
		 *
		 * This is useful when the text can be converted to another type (e.g. DateTime, numeric,
		 * etc).  The {@link Eto.Forms.MaskedTextBox`1.Provider} specified for the control is
		 * responsible for converting the value.
		 */
		export function MaskedTextBox$(T: IType): typeof MaskedTextBox$1<any>;

		/**
		 * Masked text box that provides a value converted to/from text
		 *
		 * This is useful when the text can be converted to another type (e.g. DateTime, numeric,
		 * etc).  The {@link Eto.Forms.MaskedTextBox`1.Provider} specified for the control is
		 * responsible for converting the value.
		 */
		export class MaskedTextBox$1<T> implements
			Eto.IHandlerSource,
			Eto.Forms.IBindable,
			Eto.Forms.IMouseInputSource,
			Eto.Forms.IKeyboardInputSource {
			/** Initializes a new instance of the {@link Eto.Forms.MaskedTextBox<>} class. */
			new(): MaskedTextBox$1<T>;

			/**
			 * Initializes a new instance of the {@link Eto.Forms.MaskedTextBox<>} class with the
			 * specified masked text provider.
			 */
			new(provider: Eto.Forms.IMaskedTextProvider$1<T>): MaskedTextBox$1<T>;

			/** Gets or sets the provider for the text box */
			Provider: Eto.Forms.IMaskedTextProvider$1<T>;

			/** Gets or sets the translated value of the masked text. */
			Value: T;

			/** Gets a binding for the {@link Eto.Forms.MaskedTextBox`1.Value} property. */
			readonly ValueBinding: Eto.Forms.BindableBinding$2<Eto.Forms.MaskedTextBox$1<T>, T>;

			/** Gets or sets the masked text provider to specify the mask format. */
			Provider: Eto.Forms.IMaskedTextProvider;

			/**
			 * Gets or sets the mode for insertion. Use {@link Eto.Forms.MaskedTextBox.IsOverwrite}
			 * to determine the current mode.
			 */
			InsertMode: Eto.Forms.InsertKeyMode;

			/** Gets a value indicating whether typing will overwrite text. */
			readonly IsOverwrite: boolean;

			/**
			 * Gets or sets a value indicating that the prompt characters should only be shown when
			 * the control has focus.
			 */
			ShowPromptOnFocus: boolean;

			/** Gets or sets the mode for when the input prompts should be shown */
			ShowPromptMode: Eto.Forms.ShowPromptMode;

			/**
			 * Gets or sets a value indicating that the placeholder should be shown when the mask is
			 * empty and the control does not have focus.
			 */
			ShowPlaceholderWhenEmpty: boolean;

			/** Gets or sets the text of the control including any mask characters. */
			Text: string;

			/** Gets a value indicating whether the mask is completed. */
			readonly MaskCompleted: boolean;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Forms.TextBox} is read only.
			 *
			 * A user can selected and copied text when the read only, however the user will not be
			 * able to change any of the text. This differs from the
			 * {@link Eto.Forms.Control.Enabled} property, which disables all user interaction.
			 */
			ReadOnly: boolean;

			/**
			 * Gets or sets the maximum length of the text that can be entered in the control, 0 for
			 * no limit.
			 *
			 * This typically does not affect the value set using {@link Eto.Forms.TextControl.Text},
			 * only the limit of what the user can  enter into the control.
			 */
			MaxLength: number;

			/**
			 * Gets or sets the placeholder text to show as a hint of what the user should enter.
			 *
			 * Typically this will be shown when the control is blank, and will dissappear when the
			 * user enters text or if it has an existing value.
			 */
			PlaceholderText: string;

			/**
			 * Gets or sets a value indicating whether to show the control's border.
			 *
			 * This is a hint to omit the border of the control and show it as plainly as possible.
			 * Typically used when you want to show the control within a cell of the
			 * {@link Eto.Forms.GridView}.
			 */
			ShowBorder: boolean;

			/** Gets or sets the alignment of the text in the entry box. */
			TextAlignment: Eto.Forms.TextAlignment;

			/**
			 * Gets or sets the index of the current insertion point.
			 *
			 * When there is selected text, this is usually the start of the selection.
			 */
			CaretIndex: number;

			/** Gets or sets the current text selection. */
			Selection: Eto.Forms.Range$1<number>;

			/** Gets or sets the selected text. */
			SelectedText: string;

			/** Gets or sets the auto selection mode. */
			AutoSelectMode: Eto.Forms.AutoSelectMode;

			/**
			 * Gets or sets the color of the text.
			 *
			 * By default, the text will get a color based on the user's theme. However, this is
			 * usually black.
			 */
			TextColor: Eto.Drawing.Color;

			/** Gets the binding for the {@link Eto.Forms.TextControl.Text} property. */
			readonly TextBinding: Eto.Forms.BindableBinding$2<Eto.Forms.TextControl, string>;

			/** Gets or sets the font for the text of the control */
			Font: Eto.Drawing.Font;

			/**
			 * Gets a value indicating that the control is loaded onto a form, that is it has been
			 * created, added to a parent, and shown
			 *
			 * The {@link Eto.Forms.Control.OnLoad(System.EventArgs)} method sets this value to true
			 * after cascading to all children (for a {@link Eto.Forms.Container} ) and calling the
			 * platform handler's implementation.  It is called after adding to a loaded form, or
			 * when showing a new form.  The {@link Eto.Forms.Control.OnUnLoad(System.EventArgs)}
			 * method will set this value to false when the control is removed from its parent
			 */
			readonly Loaded: boolean;

			/**
			 * Gets an enumeration of controls that are in the visual tree.
			 *
			 * This is used to specify which controls are contained by this instance that are part of
			 * the visual tree. This should include all controls including non-logical Eto controls
			 * used for layout.
			 */
			readonly VisualControls: Iterable<Eto.Forms.Control>;

			/**
			 * Gets or sets a user-defined object that contains data about the control
			 *
			 * A common use of the tag property is to store data that is associated with the control
			 * that you can later retrieve.
			 */
			Tag: unknown;

			/**
			 * Gets the logical parent control.
			 *
			 * When the control is part of the visual tree (
				 * {@link Eto.Forms.Control.IsVisualControl} is true), this returns the logical parent
				 * that contains this control. Otherwise this is the same as
				 * {@link Eto.Forms.Control.Parent}.
				 */
				readonly LogicalParent: Eto.Forms.Container;

			/** Gets a value indicating this {@link Eto.Forms.Control} is part of the visual tree. */
			IsVisualControl: boolean;

			/**
			 * Gets or sets the size of the control. Use -1 to specify auto sizing for either the
			 * width and/or height.
			 *
			 * Setting the size of controls is entirely optional as most controls will size
			 * themselves appropriately. When specifying a size, it will be used as the desired size
			 * of the control.  The container will reposition and resize the control depending on the
			 * available size.  For a {@link Eto.Forms.Window}, it is preferred to set the
			 * {@link Eto.Forms.Container.ClientSize} instead, as various platforms have different
			 * sizes of window decorations, toolbars, etc.
			 */
			Size: Eto.Drawing.Size;

			/**
			 * Gets a value indicating this control currently has mouse capture
			 *
			 * Mouse capture can happen during a handled MouseDown event until MouseUp, or it can be
			 * captured explicitly via {@link Eto.Forms.Control.CaptureMouse}.
			 */
			readonly IsMouseCaptured: boolean;

			/** Gets or sets the width of the control size. */
			Width: number;

			/** Gets or sets the height of the control size. */
			Height: number;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Forms.Control} (or its
			 * children) are enabled and accept user input.
			 *
			 * Typically when a control is disabled, the user cannot do anything with the control or
			 * any of its children. Including for example, selecting text in a text control. Certain
			 * controls can have a 'Read Only' mode, such as {@link Eto.Forms.TextBox.ReadOnly} which
			 * allow the user to  select text, but not change its contents.
			 */
			Enabled: boolean;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Forms.Control} is visible to
			 * the user.
			 *
			 * When the visibility of a control is set to false, it will not occupy space in the
			 * layout.
			 */
			Visible: boolean;

			/** Gets the container which this control has been added to, if any */
			readonly Parent: Eto.Forms.Container;

			/**
			 * Gets the visual container of this control, if any.
			 *
			 * Some containers may use other Eto controls to layout its children, such as the
			 * {@link Eto.Forms.StackLayout}. This will return the parent control that visually
			 * contains this control as opposed to {@link Eto.Forms.Control.Parent} which will return
			 * the logical parent.
			 */
			VisualParent: Eto.Forms.Container;

			/** Gets a value indicating this control has been attached to a native container */
			readonly IsAttached: boolean;

			/**
			 * Gets or sets the color for the background of the control
			 *
			 * Note that on some platforms (e.g. Mac), setting the background color of a control can
			 * change the performance characteristics of the control and its children, since it must
			 * enable layers to do so.
			 */
			BackgroundColor: Eto.Drawing.Color;

			/** Gets a value indicating whether this instance has the keyboard input focus. */
			readonly HasFocus: boolean;

			/** Gets a value indicating whether the layout of child controls is suspended. */
			readonly IsSuspended: boolean;

			/** Gets the window this control is contained in */
			readonly ParentWindow: Eto.Forms.Window;

			/**
			 * Gets the supported platform commands that can be used to hook up system functions to
			 * user defined logic
			 *
			 * This lists all available commands that can be mapped using the
			 * {@link Eto.Forms.Control.MapPlatformCommand(System.String,Eto.Forms.Command)} method
			 * of the control.
			 */
			readonly SupportedPlatformCommands: Iterable<string>;

			/** Gets the bounding rectangle of this control relative to its container */
			readonly Bounds: Eto.Drawing.Rectangle;

			/**
			 * Gets the location of the control as positioned by the container
			 *
			 * A control's location is set by the container. This can be used to determine where the
			 * control is for overlaying floating windows, menus, etc.
			 */
			readonly Location: Eto.Drawing.Point;

			/** Gets or sets the type of cursor to use when the mouse is hovering over the control */
			Cursor: Eto.Forms.Cursor;

			/** Gets or sets the tool tip to show when the mouse is hovered over the control */
			ToolTip: string;

			/**
			 * Gets or sets the tab index order for this control within its container.
			 *
			 * This sets the order when using the tab key to cycle through controls  Note that some
			 * platforms (Gtk and WinForms) may not support setting the context of the tab order to
			 * StackLayout  or DynamicLayout containers and may not behave exactly as expected. Use
			 * the {@link Eto.PlatformFeatures.TabIndexWithCustomContainers} flag to determine if it
			 * is supported.
			 */
			TabIndex: number;

			/** Gets or sets a value indicating whether this control can serve as drop target. */
			AllowDrop: boolean;

			/**
			 * Gets or sets the parent widget which this widget has been added to, if any
			 *
			 * When implementing child widgets that can participate in the context based binding
			 * (MVVM), You can set this to the parent widget when it is added or removed to it
			 * (usually via a collection).  Note that you should typically provide a public new
			 * [ParentWidget] Parent { get; } property  so that consumers of your API cannot set the
			 * parent to an invalid value.
			 */
			Parent: Eto.Widget;

			/**
			 * Gets an enumeration of all parent widgets in the heirarchy by traversing the
			 * {@link Eto.Forms.BindableWidget.Parent} property.
			 */
			readonly Parents: Iterable<Eto.Widget>;

			/**
			 * Gets or sets the data context for this widget for binding
			 *
			 * Subclasses may override the standard behaviour so that hierarchy of widgets can be
			 * taken into account.  For example, a Control may return the data context of a parent,
			 * if it is not set explicitly.
			 */
			DataContext: unknown;

			/** Gets the collection of bindings that are attached to this widget */
			readonly Bindings: Eto.Forms.BindingCollection;

			/**
			 * Gets a value indicating that the {@link Eto.Forms.BindableWidget.DataContext} property
			 * is changing.
			 *
			 * This can be used to determine when to allow certain logic during the update of the
			 * data context.  It is used to disable binding setters on the model when the data
			 * context changes so that a binding does not cause the view model to be updated when the
			 * state hasn't been fully set yet.
			 */
			IsDataContextChanging: boolean;

			/**
			 * Gets the platform that was used to create the {@link Eto.Widget.Handler} for this
			 * widget
			 *
			 * This gets set to the current {@link Eto.Platform.Instance} during the construction of
			 * the object
			 */
			readonly Platform: Eto.Platform;

			/** Gets the platform-specific handler for this widget */
			Handler: unknown;

			/** Gets the native platform-specific handle for integration purposes */
			readonly NativeHandle: unknown;

			/** Gets the dictionary of properties for this widget */
			readonly Properties: Eto.PropertyStore;

			/** Gets or sets the ID of this widget */
			ID: string;

			/**
			 * Gets or sets the style of this widget
			 *
			 * Styles allow you to attach custom platform-specific logic to a widget. In your
			 * platform-specific assembly, use {@link Style.Add{H}(string, StyleHandler{H})} to add
			 * the style logic with the same id.
			 */
			Style: string;

			/**
			 * Gets the instance of the platform-specific object
			 *
			 * This can sometimes be useful to get the platform-specific object. Some handlers may
			 * not have any backing object for its functionality, so this may be null.  It is more
			 * preferred to use the {@link Eto.Widget.Handler} and cast that to the platform-specific
			 * handler class which can give you additional methods and helpers to do common tasks.
			 * For example, the {@link Eto.Forms.Application} object's handler for OS X has a
			 * AddFullScreenMenuItem property to specify if you want full screen support in your app.
			 */
			readonly ControlObject: unknown;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Widget} has been disposed.
			 *
			 * When the widget is disposed, it can no longer be used.
			 */
			IsDisposed: boolean;

			/**
			 * Selects all of the text in the control.
			 *
			 * When setting the selection, the control will be focussed and the associated keyboard
			 * may appear on mobile platforms.
			 */
			SelectAll(): void;

			/**
			 * Queues a repaint of the entire control on the screen and any of its children.
			 *
			 * This is only useful when the control is visible.
			 */
			Invalidate(): void;

			/**
			 * Queues a repaint of the entire control on the screen
			 *
			 * This is only useful when the control is visible.
			 */
			Invalidate(invalidateChildren: boolean): void;

			/**
			 * Queues a repaint of the specified `rect` of the control and any children.
			 *
			 * This is only useful when the control is visible.
			 */
			Invalidate(rect: Eto.Drawing.Rectangle): void;

			/**
			 * Queues a repaint of the specified `rect` of the control
			 *
			 * This is only useful when the control is visible.
			 */
			Invalidate(
				rect: Eto.Drawing.Rectangle,
				invalidateChildren: boolean,
			): void;

			/**
			 * Updates the layout of this control if necessary.
			 *
			 * This will ensure the control has had all of its layout applied so you can use its
			 * position and size right after this call. Most platforms (except WinForms) use a
			 * deferred layout system so that after adding your control to the form dynamically it
			 * won't get laid out until the next idle loop. This is useful when you need to know the
			 * dimensions of the control immediately. Note that this can be an expensive operation,
			 * so it is recommended to only call this method when necessary and after all of the
			 * controls have been added/updated.
			 */
			UpdateLayout(): void;

			/** Gets the preferred size of this control given infinite space available. */
			GetPreferredSize(): Eto.Drawing.SizeF;

			/** Gets the preferred size of this control given the specified `availableSize`. */
			GetPreferredSize(availableSize: Eto.Drawing.SizeF): Eto.Drawing.SizeF;

			/**
			 * Captures all mouse events to this control.
			 *
			 * This captures all mouse events until {@link Eto.Forms.Control.ReleaseMouseCapture} is
			 * called.  Note that not all platforms will allow a mouse capture unless the mouse is
			 * currently down.
			 */
			CaptureMouse(): boolean;

			/** Releases the mouse capture after a call to {@link Eto.Forms.Control.CaptureMouse}. */
			ReleaseMouseCapture(): void;

			/**
			 * Finds a control in the parent hierarchy with the specified type and
			 * {@link Eto.Widget.ID} if specified
			 */
			FindParent(
				type: unknown,
				id?: string,
			): Eto.Forms.Container;

			/** Finds a control in the parent hierarchy with the specified `id` */
			FindParent(id: string): Eto.Forms.Container;

			/**
			 * Detaches the control by removing it from its parent
			 *
			 * This is essentially a shortcut to myControl.Parent.Remove(myControl);
			 */
			Detach(): void;

			/**
			 * Attaches the control for direct use in a native application
			 *
			 * Use this to use a control directly in a native application.  Note that the native
			 * application must be running the same framework as the current platform.  E.g. a
			 * WinForms application can use an Eto.Forms control when using the Eto.WinForms
			 * platform.  This prepares the control by firing the {@link Eto.Forms.Control.PreLoad},
			 * {@link Eto.Forms.Control.Load}, etc. events.
			 */
			AttachNative(): void;

			/**
			 * Detaches the control when it is used in a native application, when you want to reuse
			 * the control.
			 *
			 * This should only be called after {@link Eto.Forms.Control.AttachNative} has been
			 * called, which is usually done by calling to ToNative(true) .
			 */
			DetachNative(): void;

			/**
			 * Attempts to set the keyboard input focus to this control, or the first child that
			 * accepts focus. For Windows, this will bring it to front and activate it.
			 */
			Focus(): void;

			/**
			 * Suspends the layout of child controls
			 *
			 * This can be used to optimize some platforms while adding, removing, or changing many
			 * child controls at once. It disables the calculation of control positioning until
			 * {@link Eto.Forms.Control.ResumeLayout} is called. Each call to SuspendLayout() must be
			 * balanced with a call to {@link Eto.Forms.Control.ResumeLayout}.
			 */
			SuspendLayout(): void;

			/**
			 * Resumes the layout after it has been suspended, and performs a layout
			 *
			 * This can be used to optimize some platforms while adding, removing, or changing many
			 * child controls at once. Each call to ResumeLayout() must be balanced with a call to
			 * {@link Eto.Forms.Control.SuspendLayout} before it.
			 */
			ResumeLayout(): void;

			/**
			 * Specifies a command to execute for a platform-specific command
			 *
			 * Some platforms have specific system-defined commands that can be associated with a
			 * control. For example, the Mac platform's cut/copy/paste functionality is defined by
			 * the system, and if you want to hook into it, you can use this to map it to your own
			 * defined logic. The valid values of the `systemCommand` parameter are defined by each
			 * platform, and a list can be retrieved using
			 * {@link Eto.Forms.Control.SupportedPlatformCommands}
			 */
			MapPlatformCommand(
				systemCommand: string,
				command: Eto.Forms.Command,
			): void;

			/** Converts a point from screen space to control space. */
			PointFromScreen(point: Eto.Drawing.PointF): Eto.Drawing.PointF;

			/** Converts a point from control space to screen space */
			PointToScreen(point: Eto.Drawing.PointF): Eto.Drawing.PointF;

			/** Converts a rectangle from screen space to control space. */
			RectangleToScreen(rect: Eto.Drawing.RectangleF): Eto.Drawing.RectangleF;

			/** Converts a rectangle from control space to screen space */
			RectangleFromScreen(rect: Eto.Drawing.RectangleF): Eto.Drawing.RectangleF;

			/**
			 * Starts drag operation using this control as drag source.
			 *
			 * This method can be blocking on some platforms (Wpf, WinForms), and non-blocking on
			 * others (Mac, Gtk). Use the {@link Eto.Forms.Control.DragEnd} event to determine when
			 * the drag operation is completed and get its resulting DragEffects.
			 */
			DoDragDrop(
				data: Eto.Forms.DataObject,
				allowedEffects: Eto.Forms.DragEffects,
			): void;

			/**
			 * Starts drag operation using this control as drag source.
			 *
			 * This method can be blocking on some platforms (Wpf, WinForms), and non-blocking on
			 * others (Mac, Gtk). Use the {@link Eto.Forms.Control.DragEnd} event to determine when
			 * the drag operation is completed and get its resulting DragEffects.
			 */
			DoDragDrop(
				data: Eto.Forms.DataObject,
				allowedEffects: Eto.Forms.DragEffects,
				image: Eto.Drawing.Image,
				cursorOffset: Eto.Drawing.PointF,
			): void;

			/**
			 * Triggers the StyleChanged event and re-applies the styles to this control and its
			 * children.
			 */
			TriggerStyleChanged(): void;

			/** Shows a print dialog to print the specified control */
			Print(): void;

			/**
			 * Finds a control in the parent hierarchy with the specified type and
			 * {@link Eto.Widget.ID} if specified
			 */
			FindParent<T>(id?: string): T;

			/**
			 * Finds a control in the parent hierarchy with the specified type and
			 * {@link Eto.Widget.ID} if specified
			 */
			FindParent(
				type: unknown,
				id?: string,
			): Eto.Widget;

			/** Finds a control in the parent hierarchy with the specified `id` */
			FindParent(id: string): Eto.Widget;

			/**
			 * Unbinds any bindings in the {@link Eto.Forms.BindableWidget.Bindings} collection and
			 * removes the bindings
			 *
			 * When you implement {@link Eto.Forms.IBindableWidgetContainer}, this will also unbind
			 * any of its children.
			 */
			Unbind(): void;

			/**
			 * Updates all bindings in this widget
			 *
			 * When you implement {@link Eto.Forms.IBindableWidgetContainer}, this will also update
			 * bindings for all of its children.
			 */
			UpdateBindings(mode?: Eto.Forms.BindingUpdateMode): void;

			/** Disposes of this widget, supressing the finalizer */
			dispose(): void;

			/** Gets a string that represents the current object with its ID if specified. */
			ToString(): string;
		}
	}

	export namespace Eto.Forms {
		/**
		 * Text box with masking capabilities.
		 *
		 * This uses the {@link Eto.Forms.IMaskedTextProvider} as its interface to the mask.
		 * The mask can implement any format it wishes, including both fixed or variable length
		 * masks. The MaskedTextBox allows you to mask, or limit which characters can be entered
		 * in the text box with either a fixed, variable, or custom mask. A fixed mask can be a
		 * phone number, postal code, or something that requires a specific format and can be
		 * created using the {@link Eto.Forms.FixedMaskedTextProvider}.  A variable mask limits
		 * which characters can be entered but is not limited to a fixed number of characters. An
		 * implementation of a variable mask is the {@link Eto.Forms.NumericMaskedTextBox<>}
		 * which allows you to enter only numeric values in a text box, and places the positive /
		 * negative symbol at the beginning regardless of where you type it.
		 */
		export class MaskedTextBox implements
			Eto.IHandlerSource,
			Eto.Forms.IBindable,
			Eto.Forms.IMouseInputSource,
			Eto.Forms.IKeyboardInputSource {
			/** Initializes a new instance of the {@link Eto.Forms.MaskedTextBox} class. */
			constructor();

			/**
			 * Initializes a new instance of the {@link Eto.Forms.MaskedTextBox} class with the
			 * specified masked text provider.
			 */
			constructor(provider: Eto.Forms.IMaskedTextProvider);

			/** Gets or sets the masked text provider to specify the mask format. */
			Provider: Eto.Forms.IMaskedTextProvider;

			/**
			 * Gets or sets the mode for insertion. Use {@link Eto.Forms.MaskedTextBox.IsOverwrite}
			 * to determine the current mode.
			 */
			InsertMode: Eto.Forms.InsertKeyMode;

			/** Gets a value indicating whether typing will overwrite text. */
			readonly IsOverwrite: boolean;

			/**
			 * Gets or sets a value indicating that the prompt characters should only be shown when
			 * the control has focus.
			 */
			ShowPromptOnFocus: boolean;

			/** Gets or sets the mode for when the input prompts should be shown */
			ShowPromptMode: Eto.Forms.ShowPromptMode;

			/**
			 * Gets or sets a value indicating that the placeholder should be shown when the mask is
			 * empty and the control does not have focus.
			 */
			ShowPlaceholderWhenEmpty: boolean;

			/** Gets or sets the text of the control including any mask characters. */
			Text: string;

			/** Gets a value indicating whether the mask is completed. */
			readonly MaskCompleted: boolean;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Forms.TextBox} is read only.
			 *
			 * A user can selected and copied text when the read only, however the user will not be
			 * able to change any of the text. This differs from the
			 * {@link Eto.Forms.Control.Enabled} property, which disables all user interaction.
			 */
			ReadOnly: boolean;

			/**
			 * Gets or sets the maximum length of the text that can be entered in the control, 0 for
			 * no limit.
			 *
			 * This typically does not affect the value set using {@link Eto.Forms.TextControl.Text},
			 * only the limit of what the user can  enter into the control.
			 */
			MaxLength: number;

			/**
			 * Gets or sets the placeholder text to show as a hint of what the user should enter.
			 *
			 * Typically this will be shown when the control is blank, and will dissappear when the
			 * user enters text or if it has an existing value.
			 */
			PlaceholderText: string;

			/**
			 * Gets or sets a value indicating whether to show the control's border.
			 *
			 * This is a hint to omit the border of the control and show it as plainly as possible.
			 * Typically used when you want to show the control within a cell of the
			 * {@link Eto.Forms.GridView}.
			 */
			ShowBorder: boolean;

			/** Gets or sets the alignment of the text in the entry box. */
			TextAlignment: Eto.Forms.TextAlignment;

			/**
			 * Gets or sets the index of the current insertion point.
			 *
			 * When there is selected text, this is usually the start of the selection.
			 */
			CaretIndex: number;

			/** Gets or sets the current text selection. */
			Selection: Eto.Forms.Range$1<number>;

			/** Gets or sets the selected text. */
			SelectedText: string;

			/** Gets or sets the auto selection mode. */
			AutoSelectMode: Eto.Forms.AutoSelectMode;

			/**
			 * Gets or sets the color of the text.
			 *
			 * By default, the text will get a color based on the user's theme. However, this is
			 * usually black.
			 */
			TextColor: Eto.Drawing.Color;

			/** Gets the binding for the {@link Eto.Forms.TextControl.Text} property. */
			readonly TextBinding: Eto.Forms.BindableBinding$2<Eto.Forms.TextControl, string>;

			/** Gets or sets the font for the text of the control */
			Font: Eto.Drawing.Font;

			/**
			 * Gets a value indicating that the control is loaded onto a form, that is it has been
			 * created, added to a parent, and shown
			 *
			 * The {@link Eto.Forms.Control.OnLoad(System.EventArgs)} method sets this value to true
			 * after cascading to all children (for a {@link Eto.Forms.Container} ) and calling the
			 * platform handler's implementation.  It is called after adding to a loaded form, or
			 * when showing a new form.  The {@link Eto.Forms.Control.OnUnLoad(System.EventArgs)}
			 * method will set this value to false when the control is removed from its parent
			 */
			readonly Loaded: boolean;

			/**
			 * Gets an enumeration of controls that are in the visual tree.
			 *
			 * This is used to specify which controls are contained by this instance that are part of
			 * the visual tree. This should include all controls including non-logical Eto controls
			 * used for layout.
			 */
			readonly VisualControls: Iterable<Eto.Forms.Control>;

			/**
			 * Gets or sets a user-defined object that contains data about the control
			 *
			 * A common use of the tag property is to store data that is associated with the control
			 * that you can later retrieve.
			 */
			Tag: unknown;

			/**
			 * Gets the logical parent control.
			 *
			 * When the control is part of the visual tree (
				 * {@link Eto.Forms.Control.IsVisualControl} is true), this returns the logical parent
				 * that contains this control. Otherwise this is the same as
				 * {@link Eto.Forms.Control.Parent}.
				 */
				readonly LogicalParent: Eto.Forms.Container;

			/** Gets a value indicating this {@link Eto.Forms.Control} is part of the visual tree. */
			IsVisualControl: boolean;

			/**
			 * Gets or sets the size of the control. Use -1 to specify auto sizing for either the
			 * width and/or height.
			 *
			 * Setting the size of controls is entirely optional as most controls will size
			 * themselves appropriately. When specifying a size, it will be used as the desired size
			 * of the control.  The container will reposition and resize the control depending on the
			 * available size.  For a {@link Eto.Forms.Window}, it is preferred to set the
			 * {@link Eto.Forms.Container.ClientSize} instead, as various platforms have different
			 * sizes of window decorations, toolbars, etc.
			 */
			Size: Eto.Drawing.Size;

			/**
			 * Gets a value indicating this control currently has mouse capture
			 *
			 * Mouse capture can happen during a handled MouseDown event until MouseUp, or it can be
			 * captured explicitly via {@link Eto.Forms.Control.CaptureMouse}.
			 */
			readonly IsMouseCaptured: boolean;

			/** Gets or sets the width of the control size. */
			Width: number;

			/** Gets or sets the height of the control size. */
			Height: number;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Forms.Control} (or its
			 * children) are enabled and accept user input.
			 *
			 * Typically when a control is disabled, the user cannot do anything with the control or
			 * any of its children. Including for example, selecting text in a text control. Certain
			 * controls can have a 'Read Only' mode, such as {@link Eto.Forms.TextBox.ReadOnly} which
			 * allow the user to  select text, but not change its contents.
			 */
			Enabled: boolean;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Forms.Control} is visible to
			 * the user.
			 *
			 * When the visibility of a control is set to false, it will not occupy space in the
			 * layout.
			 */
			Visible: boolean;

			/** Gets the container which this control has been added to, if any */
			readonly Parent: Eto.Forms.Container;

			/**
			 * Gets the visual container of this control, if any.
			 *
			 * Some containers may use other Eto controls to layout its children, such as the
			 * {@link Eto.Forms.StackLayout}. This will return the parent control that visually
			 * contains this control as opposed to {@link Eto.Forms.Control.Parent} which will return
			 * the logical parent.
			 */
			VisualParent: Eto.Forms.Container;

			/** Gets a value indicating this control has been attached to a native container */
			readonly IsAttached: boolean;

			/**
			 * Gets or sets the color for the background of the control
			 *
			 * Note that on some platforms (e.g. Mac), setting the background color of a control can
			 * change the performance characteristics of the control and its children, since it must
			 * enable layers to do so.
			 */
			BackgroundColor: Eto.Drawing.Color;

			/** Gets a value indicating whether this instance has the keyboard input focus. */
			readonly HasFocus: boolean;

			/** Gets a value indicating whether the layout of child controls is suspended. */
			readonly IsSuspended: boolean;

			/** Gets the window this control is contained in */
			readonly ParentWindow: Eto.Forms.Window;

			/**
			 * Gets the supported platform commands that can be used to hook up system functions to
			 * user defined logic
			 *
			 * This lists all available commands that can be mapped using the
			 * {@link Eto.Forms.Control.MapPlatformCommand(System.String,Eto.Forms.Command)} method
			 * of the control.
			 */
			readonly SupportedPlatformCommands: Iterable<string>;

			/** Gets the bounding rectangle of this control relative to its container */
			readonly Bounds: Eto.Drawing.Rectangle;

			/**
			 * Gets the location of the control as positioned by the container
			 *
			 * A control's location is set by the container. This can be used to determine where the
			 * control is for overlaying floating windows, menus, etc.
			 */
			readonly Location: Eto.Drawing.Point;

			/** Gets or sets the type of cursor to use when the mouse is hovering over the control */
			Cursor: Eto.Forms.Cursor;

			/** Gets or sets the tool tip to show when the mouse is hovered over the control */
			ToolTip: string;

			/**
			 * Gets or sets the tab index order for this control within its container.
			 *
			 * This sets the order when using the tab key to cycle through controls  Note that some
			 * platforms (Gtk and WinForms) may not support setting the context of the tab order to
			 * StackLayout  or DynamicLayout containers and may not behave exactly as expected. Use
			 * the {@link Eto.PlatformFeatures.TabIndexWithCustomContainers} flag to determine if it
			 * is supported.
			 */
			TabIndex: number;

			/** Gets or sets a value indicating whether this control can serve as drop target. */
			AllowDrop: boolean;

			/**
			 * Gets or sets the parent widget which this widget has been added to, if any
			 *
			 * When implementing child widgets that can participate in the context based binding
			 * (MVVM), You can set this to the parent widget when it is added or removed to it
			 * (usually via a collection).  Note that you should typically provide a public new
			 * [ParentWidget] Parent { get; } property  so that consumers of your API cannot set the
			 * parent to an invalid value.
			 */
			Parent: Eto.Widget;

			/**
			 * Gets an enumeration of all parent widgets in the heirarchy by traversing the
			 * {@link Eto.Forms.BindableWidget.Parent} property.
			 */
			readonly Parents: Iterable<Eto.Widget>;

			/**
			 * Gets or sets the data context for this widget for binding
			 *
			 * Subclasses may override the standard behaviour so that hierarchy of widgets can be
			 * taken into account.  For example, a Control may return the data context of a parent,
			 * if it is not set explicitly.
			 */
			DataContext: unknown;

			/** Gets the collection of bindings that are attached to this widget */
			readonly Bindings: Eto.Forms.BindingCollection;

			/**
			 * Gets a value indicating that the {@link Eto.Forms.BindableWidget.DataContext} property
			 * is changing.
			 *
			 * This can be used to determine when to allow certain logic during the update of the
			 * data context.  It is used to disable binding setters on the model when the data
			 * context changes so that a binding does not cause the view model to be updated when the
			 * state hasn't been fully set yet.
			 */
			IsDataContextChanging: boolean;

			/**
			 * Gets the platform that was used to create the {@link Eto.Widget.Handler} for this
			 * widget
			 *
			 * This gets set to the current {@link Eto.Platform.Instance} during the construction of
			 * the object
			 */
			readonly Platform: Eto.Platform;

			/** Gets the platform-specific handler for this widget */
			Handler: unknown;

			/** Gets the native platform-specific handle for integration purposes */
			readonly NativeHandle: unknown;

			/** Gets the dictionary of properties for this widget */
			readonly Properties: Eto.PropertyStore;

			/** Gets or sets the ID of this widget */
			ID: string;

			/**
			 * Gets or sets the style of this widget
			 *
			 * Styles allow you to attach custom platform-specific logic to a widget. In your
			 * platform-specific assembly, use {@link Style.Add{H}(string, StyleHandler{H})} to add
			 * the style logic with the same id.
			 */
			Style: string;

			/**
			 * Gets the instance of the platform-specific object
			 *
			 * This can sometimes be useful to get the platform-specific object. Some handlers may
			 * not have any backing object for its functionality, so this may be null.  It is more
			 * preferred to use the {@link Eto.Widget.Handler} and cast that to the platform-specific
			 * handler class which can give you additional methods and helpers to do common tasks.
			 * For example, the {@link Eto.Forms.Application} object's handler for OS X has a
			 * AddFullScreenMenuItem property to specify if you want full screen support in your app.
			 */
			readonly ControlObject: unknown;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Widget} has been disposed.
			 *
			 * When the widget is disposed, it can no longer be used.
			 */
			IsDisposed: boolean;

			/**
			 * Selects all of the text in the control.
			 *
			 * When setting the selection, the control will be focussed and the associated keyboard
			 * may appear on mobile platforms.
			 */
			SelectAll(): void;

			/**
			 * Queues a repaint of the entire control on the screen and any of its children.
			 *
			 * This is only useful when the control is visible.
			 */
			Invalidate(): void;

			/**
			 * Queues a repaint of the entire control on the screen
			 *
			 * This is only useful when the control is visible.
			 */
			Invalidate(invalidateChildren: boolean): void;

			/**
			 * Queues a repaint of the specified `rect` of the control and any children.
			 *
			 * This is only useful when the control is visible.
			 */
			Invalidate(rect: Eto.Drawing.Rectangle): void;

			/**
			 * Queues a repaint of the specified `rect` of the control
			 *
			 * This is only useful when the control is visible.
			 */
			Invalidate(
				rect: Eto.Drawing.Rectangle,
				invalidateChildren: boolean,
			): void;

			/**
			 * Updates the layout of this control if necessary.
			 *
			 * This will ensure the control has had all of its layout applied so you can use its
			 * position and size right after this call. Most platforms (except WinForms) use a
			 * deferred layout system so that after adding your control to the form dynamically it
			 * won't get laid out until the next idle loop. This is useful when you need to know the
			 * dimensions of the control immediately. Note that this can be an expensive operation,
			 * so it is recommended to only call this method when necessary and after all of the
			 * controls have been added/updated.
			 */
			UpdateLayout(): void;

			/** Gets the preferred size of this control given infinite space available. */
			GetPreferredSize(): Eto.Drawing.SizeF;

			/** Gets the preferred size of this control given the specified `availableSize`. */
			GetPreferredSize(availableSize: Eto.Drawing.SizeF): Eto.Drawing.SizeF;

			/**
			 * Captures all mouse events to this control.
			 *
			 * This captures all mouse events until {@link Eto.Forms.Control.ReleaseMouseCapture} is
			 * called.  Note that not all platforms will allow a mouse capture unless the mouse is
			 * currently down.
			 */
			CaptureMouse(): boolean;

			/** Releases the mouse capture after a call to {@link Eto.Forms.Control.CaptureMouse}. */
			ReleaseMouseCapture(): void;

			/**
			 * Finds a control in the parent hierarchy with the specified type and
			 * {@link Eto.Widget.ID} if specified
			 */
			FindParent(
				type: unknown,
				id?: string,
			): Eto.Forms.Container;

			/** Finds a control in the parent hierarchy with the specified `id` */
			FindParent(id: string): Eto.Forms.Container;

			/**
			 * Detaches the control by removing it from its parent
			 *
			 * This is essentially a shortcut to myControl.Parent.Remove(myControl);
			 */
			Detach(): void;

			/**
			 * Attaches the control for direct use in a native application
			 *
			 * Use this to use a control directly in a native application.  Note that the native
			 * application must be running the same framework as the current platform.  E.g. a
			 * WinForms application can use an Eto.Forms control when using the Eto.WinForms
			 * platform.  This prepares the control by firing the {@link Eto.Forms.Control.PreLoad},
			 * {@link Eto.Forms.Control.Load}, etc. events.
			 */
			AttachNative(): void;

			/**
			 * Detaches the control when it is used in a native application, when you want to reuse
			 * the control.
			 *
			 * This should only be called after {@link Eto.Forms.Control.AttachNative} has been
			 * called, which is usually done by calling to ToNative(true) .
			 */
			DetachNative(): void;

			/**
			 * Attempts to set the keyboard input focus to this control, or the first child that
			 * accepts focus. For Windows, this will bring it to front and activate it.
			 */
			Focus(): void;

			/**
			 * Suspends the layout of child controls
			 *
			 * This can be used to optimize some platforms while adding, removing, or changing many
			 * child controls at once. It disables the calculation of control positioning until
			 * {@link Eto.Forms.Control.ResumeLayout} is called. Each call to SuspendLayout() must be
			 * balanced with a call to {@link Eto.Forms.Control.ResumeLayout}.
			 */
			SuspendLayout(): void;

			/**
			 * Resumes the layout after it has been suspended, and performs a layout
			 *
			 * This can be used to optimize some platforms while adding, removing, or changing many
			 * child controls at once. Each call to ResumeLayout() must be balanced with a call to
			 * {@link Eto.Forms.Control.SuspendLayout} before it.
			 */
			ResumeLayout(): void;

			/**
			 * Specifies a command to execute for a platform-specific command
			 *
			 * Some platforms have specific system-defined commands that can be associated with a
			 * control. For example, the Mac platform's cut/copy/paste functionality is defined by
			 * the system, and if you want to hook into it, you can use this to map it to your own
			 * defined logic. The valid values of the `systemCommand` parameter are defined by each
			 * platform, and a list can be retrieved using
			 * {@link Eto.Forms.Control.SupportedPlatformCommands}
			 */
			MapPlatformCommand(
				systemCommand: string,
				command: Eto.Forms.Command,
			): void;

			/** Converts a point from screen space to control space. */
			PointFromScreen(point: Eto.Drawing.PointF): Eto.Drawing.PointF;

			/** Converts a point from control space to screen space */
			PointToScreen(point: Eto.Drawing.PointF): Eto.Drawing.PointF;

			/** Converts a rectangle from screen space to control space. */
			RectangleToScreen(rect: Eto.Drawing.RectangleF): Eto.Drawing.RectangleF;

			/** Converts a rectangle from control space to screen space */
			RectangleFromScreen(rect: Eto.Drawing.RectangleF): Eto.Drawing.RectangleF;

			/**
			 * Starts drag operation using this control as drag source.
			 *
			 * This method can be blocking on some platforms (Wpf, WinForms), and non-blocking on
			 * others (Mac, Gtk). Use the {@link Eto.Forms.Control.DragEnd} event to determine when
			 * the drag operation is completed and get its resulting DragEffects.
			 */
			DoDragDrop(
				data: Eto.Forms.DataObject,
				allowedEffects: Eto.Forms.DragEffects,
			): void;

			/**
			 * Starts drag operation using this control as drag source.
			 *
			 * This method can be blocking on some platforms (Wpf, WinForms), and non-blocking on
			 * others (Mac, Gtk). Use the {@link Eto.Forms.Control.DragEnd} event to determine when
			 * the drag operation is completed and get its resulting DragEffects.
			 */
			DoDragDrop(
				data: Eto.Forms.DataObject,
				allowedEffects: Eto.Forms.DragEffects,
				image: Eto.Drawing.Image,
				cursorOffset: Eto.Drawing.PointF,
			): void;

			/**
			 * Triggers the StyleChanged event and re-applies the styles to this control and its
			 * children.
			 */
			TriggerStyleChanged(): void;

			/** Shows a print dialog to print the specified control */
			Print(): void;

			/**
			 * Finds a control in the parent hierarchy with the specified type and
			 * {@link Eto.Widget.ID} if specified
			 */
			FindParent<T>(id?: string): T;

			/**
			 * Finds a control in the parent hierarchy with the specified type and
			 * {@link Eto.Widget.ID} if specified
			 */
			FindParent(
				type: unknown,
				id?: string,
			): Eto.Widget;

			/** Finds a control in the parent hierarchy with the specified `id` */
			FindParent(id: string): Eto.Widget;

			/**
			 * Unbinds any bindings in the {@link Eto.Forms.BindableWidget.Bindings} collection and
			 * removes the bindings
			 *
			 * When you implement {@link Eto.Forms.IBindableWidgetContainer}, this will also unbind
			 * any of its children.
			 */
			Unbind(): void;

			/**
			 * Updates all bindings in this widget
			 *
			 * When you implement {@link Eto.Forms.IBindableWidgetContainer}, this will also update
			 * bindings for all of its children.
			 */
			UpdateBindings(mode?: Eto.Forms.BindingUpdateMode): void;

			/** Disposes of this widget, supressing the finalizer */
			dispose(): void;

			/** Gets a string that represents the current object with its ID if specified. */
			ToString(): string;
		}
	}

	export namespace Eto.Forms {
		/**
		 * [Generic type factory] Masked text box with a variable length numeric mask.
		 *
		 * This provides a text box that limits the user input to only allow numeric values.
		 */
		export function NumericMaskedTextStepper$(T: IType): typeof NumericMaskedTextStepper$1<any>;

		/**
		 * Masked text box with a variable length numeric mask.
		 *
		 * This provides a text box that limits the user input to only allow numeric values.
		 */
		export class NumericMaskedTextStepper$1<T> implements
			Eto.IHandlerSource,
			Eto.Forms.IBindable,
			Eto.Forms.IMouseInputSource,
			Eto.Forms.IKeyboardInputSource {
			/**
			 * Initializes a new instance of the {@link Eto.Forms.NumericMaskedTextStepper<>} class.
			 */
			new(): NumericMaskedTextStepper$1<T>;

			/** Gets the numeric provider. */
			readonly Provider: Eto.Forms.NumericMaskedTextProvider$1<T>;

			/**
			 * Gets or sets a value indicating whether the mask can accept a sign.
			 *
			 * This defaults to whether the type specified by  allows negative values.
			 */
			AllowSign: boolean;

			/**
			 * Gets or sets a value indicating whether the mask can input a decimal.
			 *
			 * This defaults to whether the type specified by  allows decimals, such as when it is a
			 * decimal, double, or float.
			 */
			AllowDecimal: boolean;

			/**
			 * Gets or sets the culture for the
			 * {@link Eto.Forms.NumericMaskedTextProvider.DecimalCharacter} and
			 * {@link Eto.Forms.NumericMaskedTextProvider.SignCharacters} formatting characters.
			 */
			Culture: unknown;

			Provider: Eto.Forms.IMaskedTextProvider$1<T>;

			Value: T;

			readonly ValueBinding: Eto.Forms.BindableBinding$2<Eto.Forms.MaskedTextStepper$1<T>, T>;

			/** Gets or sets the masked text provider to specify the mask format. */
			Provider: Eto.Forms.IMaskedTextProvider;

			/**
			 * Gets or sets the mode for insertion. Use
			 * {@link Eto.Forms.MaskedTextStepper.IsOverwrite} to determine the current mode.
			 */
			InsertMode: Eto.Forms.InsertKeyMode;

			/** Gets a value indicating whether typing will overwrite text. */
			readonly IsOverwrite: boolean;

			/**
			 * Gets or sets a value indicating that the prompt characters should only be shown when
			 * the control has focus.
			 */
			ShowPromptOnFocus: boolean;

			/** Gets or sets the mode for when the input prompts should be shown */
			ShowPromptMode: Eto.Forms.ShowPromptMode;

			/**
			 * Gets or sets a value indicating that the placeholder should be shown when the mask is
			 * empty and the control does not have focus.
			 */
			ShowPlaceholderWhenEmpty: boolean;

			/** Gets or sets the text of the control including any mask characters. */
			Text: string;

			/** Gets a value indicating whether the mask is completed. */
			readonly MaskCompleted: boolean;

			/**
			 * Gets or sets the valid directions the stepper will allow the user to click.
			 *
			 * On some platforms, the up and/or down buttons will not appear disabled, but will not
			 * trigger any events when they are  not set as a valid direction.
			 */
			ValidDirection: Eto.Forms.StepperValidDirections;

			/**
			 * Gets or sets a value indicating whether the Stepper will be shown.
			 *
			 * This is a hint only, some platforms (currently Gtk) may ignore this setting.
			 */
			ShowStepper: boolean;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Forms.TextBox} is read only.
			 *
			 * A user can selected and copied text when the read only, however the user will not be
			 * able to change any of the text. This differs from the
			 * {@link Eto.Forms.Control.Enabled} property, which disables all user interaction.
			 */
			ReadOnly: boolean;

			/**
			 * Gets or sets the maximum length of the text that can be entered in the control, 0 for
			 * no limit.
			 *
			 * This typically does not affect the value set using {@link Eto.Forms.TextControl.Text},
			 * only the limit of what the user can  enter into the control.
			 */
			MaxLength: number;

			/**
			 * Gets or sets the placeholder text to show as a hint of what the user should enter.
			 *
			 * Typically this will be shown when the control is blank, and will dissappear when the
			 * user enters text or if it has an existing value.
			 */
			PlaceholderText: string;

			/**
			 * Gets or sets a value indicating whether to show the control's border.
			 *
			 * This is a hint to omit the border of the control and show it as plainly as possible.
			 * Typically used when you want to show the control within a cell of the
			 * {@link Eto.Forms.GridView}.
			 */
			ShowBorder: boolean;

			/** Gets or sets the alignment of the text in the entry box. */
			TextAlignment: Eto.Forms.TextAlignment;

			/**
			 * Gets or sets the index of the current insertion point.
			 *
			 * When there is selected text, this is usually the start of the selection.
			 */
			CaretIndex: number;

			/** Gets or sets the current text selection. */
			Selection: Eto.Forms.Range$1<number>;

			/** Gets or sets the selected text. */
			SelectedText: string;

			/** Gets or sets the auto selection mode. */
			AutoSelectMode: Eto.Forms.AutoSelectMode;

			/**
			 * Gets or sets the color of the text.
			 *
			 * By default, the text will get a color based on the user's theme. However, this is
			 * usually black.
			 */
			TextColor: Eto.Drawing.Color;

			/** Gets the binding for the {@link Eto.Forms.TextControl.Text} property. */
			readonly TextBinding: Eto.Forms.BindableBinding$2<Eto.Forms.TextControl, string>;

			/** Gets or sets the font for the text of the control */
			Font: Eto.Drawing.Font;

			/**
			 * Gets a value indicating that the control is loaded onto a form, that is it has been
			 * created, added to a parent, and shown
			 *
			 * The {@link Eto.Forms.Control.OnLoad(System.EventArgs)} method sets this value to true
			 * after cascading to all children (for a {@link Eto.Forms.Container} ) and calling the
			 * platform handler's implementation.  It is called after adding to a loaded form, or
			 * when showing a new form.  The {@link Eto.Forms.Control.OnUnLoad(System.EventArgs)}
			 * method will set this value to false when the control is removed from its parent
			 */
			readonly Loaded: boolean;

			/**
			 * Gets an enumeration of controls that are in the visual tree.
			 *
			 * This is used to specify which controls are contained by this instance that are part of
			 * the visual tree. This should include all controls including non-logical Eto controls
			 * used for layout.
			 */
			readonly VisualControls: Iterable<Eto.Forms.Control>;

			/**
			 * Gets or sets a user-defined object that contains data about the control
			 *
			 * A common use of the tag property is to store data that is associated with the control
			 * that you can later retrieve.
			 */
			Tag: unknown;

			/**
			 * Gets the logical parent control.
			 *
			 * When the control is part of the visual tree (
				 * {@link Eto.Forms.Control.IsVisualControl} is true), this returns the logical parent
				 * that contains this control. Otherwise this is the same as
				 * {@link Eto.Forms.Control.Parent}.
				 */
				readonly LogicalParent: Eto.Forms.Container;

			/** Gets a value indicating this {@link Eto.Forms.Control} is part of the visual tree. */
			IsVisualControl: boolean;

			/**
			 * Gets or sets the size of the control. Use -1 to specify auto sizing for either the
			 * width and/or height.
			 *
			 * Setting the size of controls is entirely optional as most controls will size
			 * themselves appropriately. When specifying a size, it will be used as the desired size
			 * of the control.  The container will reposition and resize the control depending on the
			 * available size.  For a {@link Eto.Forms.Window}, it is preferred to set the
			 * {@link Eto.Forms.Container.ClientSize} instead, as various platforms have different
			 * sizes of window decorations, toolbars, etc.
			 */
			Size: Eto.Drawing.Size;

			/**
			 * Gets a value indicating this control currently has mouse capture
			 *
			 * Mouse capture can happen during a handled MouseDown event until MouseUp, or it can be
			 * captured explicitly via {@link Eto.Forms.Control.CaptureMouse}.
			 */
			readonly IsMouseCaptured: boolean;

			/** Gets or sets the width of the control size. */
			Width: number;

			/** Gets or sets the height of the control size. */
			Height: number;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Forms.Control} (or its
			 * children) are enabled and accept user input.
			 *
			 * Typically when a control is disabled, the user cannot do anything with the control or
			 * any of its children. Including for example, selecting text in a text control. Certain
			 * controls can have a 'Read Only' mode, such as {@link Eto.Forms.TextBox.ReadOnly} which
			 * allow the user to  select text, but not change its contents.
			 */
			Enabled: boolean;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Forms.Control} is visible to
			 * the user.
			 *
			 * When the visibility of a control is set to false, it will not occupy space in the
			 * layout.
			 */
			Visible: boolean;

			/** Gets the container which this control has been added to, if any */
			readonly Parent: Eto.Forms.Container;

			/**
			 * Gets the visual container of this control, if any.
			 *
			 * Some containers may use other Eto controls to layout its children, such as the
			 * {@link Eto.Forms.StackLayout}. This will return the parent control that visually
			 * contains this control as opposed to {@link Eto.Forms.Control.Parent} which will return
			 * the logical parent.
			 */
			VisualParent: Eto.Forms.Container;

			/** Gets a value indicating this control has been attached to a native container */
			readonly IsAttached: boolean;

			/**
			 * Gets or sets the color for the background of the control
			 *
			 * Note that on some platforms (e.g. Mac), setting the background color of a control can
			 * change the performance characteristics of the control and its children, since it must
			 * enable layers to do so.
			 */
			BackgroundColor: Eto.Drawing.Color;

			/** Gets a value indicating whether this instance has the keyboard input focus. */
			readonly HasFocus: boolean;

			/** Gets a value indicating whether the layout of child controls is suspended. */
			readonly IsSuspended: boolean;

			/** Gets the window this control is contained in */
			readonly ParentWindow: Eto.Forms.Window;

			/**
			 * Gets the supported platform commands that can be used to hook up system functions to
			 * user defined logic
			 *
			 * This lists all available commands that can be mapped using the
			 * {@link Eto.Forms.Control.MapPlatformCommand(System.String,Eto.Forms.Command)} method
			 * of the control.
			 */
			readonly SupportedPlatformCommands: Iterable<string>;

			/** Gets the bounding rectangle of this control relative to its container */
			readonly Bounds: Eto.Drawing.Rectangle;

			/**
			 * Gets the location of the control as positioned by the container
			 *
			 * A control's location is set by the container. This can be used to determine where the
			 * control is for overlaying floating windows, menus, etc.
			 */
			readonly Location: Eto.Drawing.Point;

			/** Gets or sets the type of cursor to use when the mouse is hovering over the control */
			Cursor: Eto.Forms.Cursor;

			/** Gets or sets the tool tip to show when the mouse is hovered over the control */
			ToolTip: string;

			/**
			 * Gets or sets the tab index order for this control within its container.
			 *
			 * This sets the order when using the tab key to cycle through controls  Note that some
			 * platforms (Gtk and WinForms) may not support setting the context of the tab order to
			 * StackLayout  or DynamicLayout containers and may not behave exactly as expected. Use
			 * the {@link Eto.PlatformFeatures.TabIndexWithCustomContainers} flag to determine if it
			 * is supported.
			 */
			TabIndex: number;

			/** Gets or sets a value indicating whether this control can serve as drop target. */
			AllowDrop: boolean;

			/**
			 * Gets or sets the parent widget which this widget has been added to, if any
			 *
			 * When implementing child widgets that can participate in the context based binding
			 * (MVVM), You can set this to the parent widget when it is added or removed to it
			 * (usually via a collection).  Note that you should typically provide a public new
			 * [ParentWidget] Parent { get; } property  so that consumers of your API cannot set the
			 * parent to an invalid value.
			 */
			Parent: Eto.Widget;

			/**
			 * Gets an enumeration of all parent widgets in the heirarchy by traversing the
			 * {@link Eto.Forms.BindableWidget.Parent} property.
			 */
			readonly Parents: Iterable<Eto.Widget>;

			/**
			 * Gets or sets the data context for this widget for binding
			 *
			 * Subclasses may override the standard behaviour so that hierarchy of widgets can be
			 * taken into account.  For example, a Control may return the data context of a parent,
			 * if it is not set explicitly.
			 */
			DataContext: unknown;

			/** Gets the collection of bindings that are attached to this widget */
			readonly Bindings: Eto.Forms.BindingCollection;

			/**
			 * Gets a value indicating that the {@link Eto.Forms.BindableWidget.DataContext} property
			 * is changing.
			 *
			 * This can be used to determine when to allow certain logic during the update of the
			 * data context.  It is used to disable binding setters on the model when the data
			 * context changes so that a binding does not cause the view model to be updated when the
			 * state hasn't been fully set yet.
			 */
			IsDataContextChanging: boolean;

			/**
			 * Gets the platform that was used to create the {@link Eto.Widget.Handler} for this
			 * widget
			 *
			 * This gets set to the current {@link Eto.Platform.Instance} during the construction of
			 * the object
			 */
			readonly Platform: Eto.Platform;

			/** Gets the platform-specific handler for this widget */
			Handler: unknown;

			/** Gets the native platform-specific handle for integration purposes */
			readonly NativeHandle: unknown;

			/** Gets the dictionary of properties for this widget */
			readonly Properties: Eto.PropertyStore;

			/** Gets or sets the ID of this widget */
			ID: string;

			/**
			 * Gets or sets the style of this widget
			 *
			 * Styles allow you to attach custom platform-specific logic to a widget. In your
			 * platform-specific assembly, use {@link Style.Add{H}(string, StyleHandler{H})} to add
			 * the style logic with the same id.
			 */
			Style: string;

			/**
			 * Gets the instance of the platform-specific object
			 *
			 * This can sometimes be useful to get the platform-specific object. Some handlers may
			 * not have any backing object for its functionality, so this may be null.  It is more
			 * preferred to use the {@link Eto.Widget.Handler} and cast that to the platform-specific
			 * handler class which can give you additional methods and helpers to do common tasks.
			 * For example, the {@link Eto.Forms.Application} object's handler for OS X has a
			 * AddFullScreenMenuItem property to specify if you want full screen support in your app.
			 */
			readonly ControlObject: unknown;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Widget} has been disposed.
			 *
			 * When the widget is disposed, it can no longer be used.
			 */
			IsDisposed: boolean;

			/**
			 * Selects all of the text in the control.
			 *
			 * When setting the selection, the control will be focussed and the associated keyboard
			 * may appear on mobile platforms.
			 */
			SelectAll(): void;

			/**
			 * Queues a repaint of the entire control on the screen and any of its children.
			 *
			 * This is only useful when the control is visible.
			 */
			Invalidate(): void;

			/**
			 * Queues a repaint of the entire control on the screen
			 *
			 * This is only useful when the control is visible.
			 */
			Invalidate(invalidateChildren: boolean): void;

			/**
			 * Queues a repaint of the specified `rect` of the control and any children.
			 *
			 * This is only useful when the control is visible.
			 */
			Invalidate(rect: Eto.Drawing.Rectangle): void;

			/**
			 * Queues a repaint of the specified `rect` of the control
			 *
			 * This is only useful when the control is visible.
			 */
			Invalidate(
				rect: Eto.Drawing.Rectangle,
				invalidateChildren: boolean,
			): void;

			/**
			 * Updates the layout of this control if necessary.
			 *
			 * This will ensure the control has had all of its layout applied so you can use its
			 * position and size right after this call. Most platforms (except WinForms) use a
			 * deferred layout system so that after adding your control to the form dynamically it
			 * won't get laid out until the next idle loop. This is useful when you need to know the
			 * dimensions of the control immediately. Note that this can be an expensive operation,
			 * so it is recommended to only call this method when necessary and after all of the
			 * controls have been added/updated.
			 */
			UpdateLayout(): void;

			/** Gets the preferred size of this control given infinite space available. */
			GetPreferredSize(): Eto.Drawing.SizeF;

			/** Gets the preferred size of this control given the specified `availableSize`. */
			GetPreferredSize(availableSize: Eto.Drawing.SizeF): Eto.Drawing.SizeF;

			/**
			 * Captures all mouse events to this control.
			 *
			 * This captures all mouse events until {@link Eto.Forms.Control.ReleaseMouseCapture} is
			 * called.  Note that not all platforms will allow a mouse capture unless the mouse is
			 * currently down.
			 */
			CaptureMouse(): boolean;

			/** Releases the mouse capture after a call to {@link Eto.Forms.Control.CaptureMouse}. */
			ReleaseMouseCapture(): void;

			/**
			 * Finds a control in the parent hierarchy with the specified type and
			 * {@link Eto.Widget.ID} if specified
			 */
			FindParent(
				type: unknown,
				id?: string,
			): Eto.Forms.Container;

			/** Finds a control in the parent hierarchy with the specified `id` */
			FindParent(id: string): Eto.Forms.Container;

			/**
			 * Detaches the control by removing it from its parent
			 *
			 * This is essentially a shortcut to myControl.Parent.Remove(myControl);
			 */
			Detach(): void;

			/**
			 * Attaches the control for direct use in a native application
			 *
			 * Use this to use a control directly in a native application.  Note that the native
			 * application must be running the same framework as the current platform.  E.g. a
			 * WinForms application can use an Eto.Forms control when using the Eto.WinForms
			 * platform.  This prepares the control by firing the {@link Eto.Forms.Control.PreLoad},
			 * {@link Eto.Forms.Control.Load}, etc. events.
			 */
			AttachNative(): void;

			/**
			 * Detaches the control when it is used in a native application, when you want to reuse
			 * the control.
			 *
			 * This should only be called after {@link Eto.Forms.Control.AttachNative} has been
			 * called, which is usually done by calling to ToNative(true) .
			 */
			DetachNative(): void;

			/**
			 * Attempts to set the keyboard input focus to this control, or the first child that
			 * accepts focus. For Windows, this will bring it to front and activate it.
			 */
			Focus(): void;

			/**
			 * Suspends the layout of child controls
			 *
			 * This can be used to optimize some platforms while adding, removing, or changing many
			 * child controls at once. It disables the calculation of control positioning until
			 * {@link Eto.Forms.Control.ResumeLayout} is called. Each call to SuspendLayout() must be
			 * balanced with a call to {@link Eto.Forms.Control.ResumeLayout}.
			 */
			SuspendLayout(): void;

			/**
			 * Resumes the layout after it has been suspended, and performs a layout
			 *
			 * This can be used to optimize some platforms while adding, removing, or changing many
			 * child controls at once. Each call to ResumeLayout() must be balanced with a call to
			 * {@link Eto.Forms.Control.SuspendLayout} before it.
			 */
			ResumeLayout(): void;

			/**
			 * Specifies a command to execute for a platform-specific command
			 *
			 * Some platforms have specific system-defined commands that can be associated with a
			 * control. For example, the Mac platform's cut/copy/paste functionality is defined by
			 * the system, and if you want to hook into it, you can use this to map it to your own
			 * defined logic. The valid values of the `systemCommand` parameter are defined by each
			 * platform, and a list can be retrieved using
			 * {@link Eto.Forms.Control.SupportedPlatformCommands}
			 */
			MapPlatformCommand(
				systemCommand: string,
				command: Eto.Forms.Command,
			): void;

			/** Converts a point from screen space to control space. */
			PointFromScreen(point: Eto.Drawing.PointF): Eto.Drawing.PointF;

			/** Converts a point from control space to screen space */
			PointToScreen(point: Eto.Drawing.PointF): Eto.Drawing.PointF;

			/** Converts a rectangle from screen space to control space. */
			RectangleToScreen(rect: Eto.Drawing.RectangleF): Eto.Drawing.RectangleF;

			/** Converts a rectangle from control space to screen space */
			RectangleFromScreen(rect: Eto.Drawing.RectangleF): Eto.Drawing.RectangleF;

			/**
			 * Starts drag operation using this control as drag source.
			 *
			 * This method can be blocking on some platforms (Wpf, WinForms), and non-blocking on
			 * others (Mac, Gtk). Use the {@link Eto.Forms.Control.DragEnd} event to determine when
			 * the drag operation is completed and get its resulting DragEffects.
			 */
			DoDragDrop(
				data: Eto.Forms.DataObject,
				allowedEffects: Eto.Forms.DragEffects,
			): void;

			/**
			 * Starts drag operation using this control as drag source.
			 *
			 * This method can be blocking on some platforms (Wpf, WinForms), and non-blocking on
			 * others (Mac, Gtk). Use the {@link Eto.Forms.Control.DragEnd} event to determine when
			 * the drag operation is completed and get its resulting DragEffects.
			 */
			DoDragDrop(
				data: Eto.Forms.DataObject,
				allowedEffects: Eto.Forms.DragEffects,
				image: Eto.Drawing.Image,
				cursorOffset: Eto.Drawing.PointF,
			): void;

			/**
			 * Triggers the StyleChanged event and re-applies the styles to this control and its
			 * children.
			 */
			TriggerStyleChanged(): void;

			/** Shows a print dialog to print the specified control */
			Print(): void;

			/**
			 * Finds a control in the parent hierarchy with the specified type and
			 * {@link Eto.Widget.ID} if specified
			 */
			FindParent<T>(id?: string): T;

			/**
			 * Finds a control in the parent hierarchy with the specified type and
			 * {@link Eto.Widget.ID} if specified
			 */
			FindParent(
				type: unknown,
				id?: string,
			): Eto.Widget;

			/** Finds a control in the parent hierarchy with the specified `id` */
			FindParent(id: string): Eto.Widget;

			/**
			 * Unbinds any bindings in the {@link Eto.Forms.BindableWidget.Bindings} collection and
			 * removes the bindings
			 *
			 * When you implement {@link Eto.Forms.IBindableWidgetContainer}, this will also unbind
			 * any of its children.
			 */
			Unbind(): void;

			/**
			 * Updates all bindings in this widget
			 *
			 * When you implement {@link Eto.Forms.IBindableWidgetContainer}, this will also update
			 * bindings for all of its children.
			 */
			UpdateBindings(mode?: Eto.Forms.BindingUpdateMode): void;

			/** Disposes of this widget, supressing the finalizer */
			dispose(): void;

			/** Gets a string that represents the current object with its ID if specified. */
			ToString(): string;
		}
	}

	export namespace Eto.Forms {
		/**
		 * [Generic type factory] Masked text box that provides a value converted to/from text
		 *
		 * This is useful when the text can be converted to another type (e.g. DateTime, numeric,
		 * etc).  The {@link Eto.Forms.MaskedTextStepper`1.Provider} specified for the control is
		 * responsible for converting the value.
		 */
		export function MaskedTextStepper$(T: IType): typeof MaskedTextStepper$1<any>;

		/**
		 * Masked text box that provides a value converted to/from text
		 *
		 * This is useful when the text can be converted to another type (e.g. DateTime, numeric,
		 * etc).  The {@link Eto.Forms.MaskedTextStepper`1.Provider} specified for the control is
		 * responsible for converting the value.
		 */
		export class MaskedTextStepper$1<T> implements
			Eto.IHandlerSource,
			Eto.Forms.IBindable,
			Eto.Forms.IMouseInputSource,
			Eto.Forms.IKeyboardInputSource {
			/** Initializes a new instance of the {@link Eto.Forms.MaskedTextStepper<>} class. */
			new(): MaskedTextStepper$1<T>;

			/**
			 * Initializes a new instance of the {@link Eto.Forms.MaskedTextStepper<>} class with the
			 * specified masked text provider.
			 */
			new(provider: Eto.Forms.IMaskedTextProvider$1<T>): MaskedTextStepper$1<T>;

			/** Gets or sets the provider for the text box */
			Provider: Eto.Forms.IMaskedTextProvider$1<T>;

			/** Gets or sets the translated value of the masked text. */
			Value: T;

			/** Gets a binding for the {@link Eto.Forms.MaskedTextStepper`1.Value} property. */
			readonly ValueBinding: Eto.Forms.BindableBinding$2<Eto.Forms.MaskedTextStepper$1<T>, T>;

			/** Gets or sets the masked text provider to specify the mask format. */
			Provider: Eto.Forms.IMaskedTextProvider;

			/**
			 * Gets or sets the mode for insertion. Use
			 * {@link Eto.Forms.MaskedTextStepper.IsOverwrite} to determine the current mode.
			 */
			InsertMode: Eto.Forms.InsertKeyMode;

			/** Gets a value indicating whether typing will overwrite text. */
			readonly IsOverwrite: boolean;

			/**
			 * Gets or sets a value indicating that the prompt characters should only be shown when
			 * the control has focus.
			 */
			ShowPromptOnFocus: boolean;

			/** Gets or sets the mode for when the input prompts should be shown */
			ShowPromptMode: Eto.Forms.ShowPromptMode;

			/**
			 * Gets or sets a value indicating that the placeholder should be shown when the mask is
			 * empty and the control does not have focus.
			 */
			ShowPlaceholderWhenEmpty: boolean;

			/** Gets or sets the text of the control including any mask characters. */
			Text: string;

			/** Gets a value indicating whether the mask is completed. */
			readonly MaskCompleted: boolean;

			/**
			 * Gets or sets the valid directions the stepper will allow the user to click.
			 *
			 * On some platforms, the up and/or down buttons will not appear disabled, but will not
			 * trigger any events when they are  not set as a valid direction.
			 */
			ValidDirection: Eto.Forms.StepperValidDirections;

			/**
			 * Gets or sets a value indicating whether the Stepper will be shown.
			 *
			 * This is a hint only, some platforms (currently Gtk) may ignore this setting.
			 */
			ShowStepper: boolean;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Forms.TextBox} is read only.
			 *
			 * A user can selected and copied text when the read only, however the user will not be
			 * able to change any of the text. This differs from the
			 * {@link Eto.Forms.Control.Enabled} property, which disables all user interaction.
			 */
			ReadOnly: boolean;

			/**
			 * Gets or sets the maximum length of the text that can be entered in the control, 0 for
			 * no limit.
			 *
			 * This typically does not affect the value set using {@link Eto.Forms.TextControl.Text},
			 * only the limit of what the user can  enter into the control.
			 */
			MaxLength: number;

			/**
			 * Gets or sets the placeholder text to show as a hint of what the user should enter.
			 *
			 * Typically this will be shown when the control is blank, and will dissappear when the
			 * user enters text or if it has an existing value.
			 */
			PlaceholderText: string;

			/**
			 * Gets or sets a value indicating whether to show the control's border.
			 *
			 * This is a hint to omit the border of the control and show it as plainly as possible.
			 * Typically used when you want to show the control within a cell of the
			 * {@link Eto.Forms.GridView}.
			 */
			ShowBorder: boolean;

			/** Gets or sets the alignment of the text in the entry box. */
			TextAlignment: Eto.Forms.TextAlignment;

			/**
			 * Gets or sets the index of the current insertion point.
			 *
			 * When there is selected text, this is usually the start of the selection.
			 */
			CaretIndex: number;

			/** Gets or sets the current text selection. */
			Selection: Eto.Forms.Range$1<number>;

			/** Gets or sets the selected text. */
			SelectedText: string;

			/** Gets or sets the auto selection mode. */
			AutoSelectMode: Eto.Forms.AutoSelectMode;

			/**
			 * Gets or sets the color of the text.
			 *
			 * By default, the text will get a color based on the user's theme. However, this is
			 * usually black.
			 */
			TextColor: Eto.Drawing.Color;

			/** Gets the binding for the {@link Eto.Forms.TextControl.Text} property. */
			readonly TextBinding: Eto.Forms.BindableBinding$2<Eto.Forms.TextControl, string>;

			/** Gets or sets the font for the text of the control */
			Font: Eto.Drawing.Font;

			/**
			 * Gets a value indicating that the control is loaded onto a form, that is it has been
			 * created, added to a parent, and shown
			 *
			 * The {@link Eto.Forms.Control.OnLoad(System.EventArgs)} method sets this value to true
			 * after cascading to all children (for a {@link Eto.Forms.Container} ) and calling the
			 * platform handler's implementation.  It is called after adding to a loaded form, or
			 * when showing a new form.  The {@link Eto.Forms.Control.OnUnLoad(System.EventArgs)}
			 * method will set this value to false when the control is removed from its parent
			 */
			readonly Loaded: boolean;

			/**
			 * Gets an enumeration of controls that are in the visual tree.
			 *
			 * This is used to specify which controls are contained by this instance that are part of
			 * the visual tree. This should include all controls including non-logical Eto controls
			 * used for layout.
			 */
			readonly VisualControls: Iterable<Eto.Forms.Control>;

			/**
			 * Gets or sets a user-defined object that contains data about the control
			 *
			 * A common use of the tag property is to store data that is associated with the control
			 * that you can later retrieve.
			 */
			Tag: unknown;

			/**
			 * Gets the logical parent control.
			 *
			 * When the control is part of the visual tree (
				 * {@link Eto.Forms.Control.IsVisualControl} is true), this returns the logical parent
				 * that contains this control. Otherwise this is the same as
				 * {@link Eto.Forms.Control.Parent}.
				 */
				readonly LogicalParent: Eto.Forms.Container;

			/** Gets a value indicating this {@link Eto.Forms.Control} is part of the visual tree. */
			IsVisualControl: boolean;

			/**
			 * Gets or sets the size of the control. Use -1 to specify auto sizing for either the
			 * width and/or height.
			 *
			 * Setting the size of controls is entirely optional as most controls will size
			 * themselves appropriately. When specifying a size, it will be used as the desired size
			 * of the control.  The container will reposition and resize the control depending on the
			 * available size.  For a {@link Eto.Forms.Window}, it is preferred to set the
			 * {@link Eto.Forms.Container.ClientSize} instead, as various platforms have different
			 * sizes of window decorations, toolbars, etc.
			 */
			Size: Eto.Drawing.Size;

			/**
			 * Gets a value indicating this control currently has mouse capture
			 *
			 * Mouse capture can happen during a handled MouseDown event until MouseUp, or it can be
			 * captured explicitly via {@link Eto.Forms.Control.CaptureMouse}.
			 */
			readonly IsMouseCaptured: boolean;

			/** Gets or sets the width of the control size. */
			Width: number;

			/** Gets or sets the height of the control size. */
			Height: number;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Forms.Control} (or its
			 * children) are enabled and accept user input.
			 *
			 * Typically when a control is disabled, the user cannot do anything with the control or
			 * any of its children. Including for example, selecting text in a text control. Certain
			 * controls can have a 'Read Only' mode, such as {@link Eto.Forms.TextBox.ReadOnly} which
			 * allow the user to  select text, but not change its contents.
			 */
			Enabled: boolean;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Forms.Control} is visible to
			 * the user.
			 *
			 * When the visibility of a control is set to false, it will not occupy space in the
			 * layout.
			 */
			Visible: boolean;

			/** Gets the container which this control has been added to, if any */
			readonly Parent: Eto.Forms.Container;

			/**
			 * Gets the visual container of this control, if any.
			 *
			 * Some containers may use other Eto controls to layout its children, such as the
			 * {@link Eto.Forms.StackLayout}. This will return the parent control that visually
			 * contains this control as opposed to {@link Eto.Forms.Control.Parent} which will return
			 * the logical parent.
			 */
			VisualParent: Eto.Forms.Container;

			/** Gets a value indicating this control has been attached to a native container */
			readonly IsAttached: boolean;

			/**
			 * Gets or sets the color for the background of the control
			 *
			 * Note that on some platforms (e.g. Mac), setting the background color of a control can
			 * change the performance characteristics of the control and its children, since it must
			 * enable layers to do so.
			 */
			BackgroundColor: Eto.Drawing.Color;

			/** Gets a value indicating whether this instance has the keyboard input focus. */
			readonly HasFocus: boolean;

			/** Gets a value indicating whether the layout of child controls is suspended. */
			readonly IsSuspended: boolean;

			/** Gets the window this control is contained in */
			readonly ParentWindow: Eto.Forms.Window;

			/**
			 * Gets the supported platform commands that can be used to hook up system functions to
			 * user defined logic
			 *
			 * This lists all available commands that can be mapped using the
			 * {@link Eto.Forms.Control.MapPlatformCommand(System.String,Eto.Forms.Command)} method
			 * of the control.
			 */
			readonly SupportedPlatformCommands: Iterable<string>;

			/** Gets the bounding rectangle of this control relative to its container */
			readonly Bounds: Eto.Drawing.Rectangle;

			/**
			 * Gets the location of the control as positioned by the container
			 *
			 * A control's location is set by the container. This can be used to determine where the
			 * control is for overlaying floating windows, menus, etc.
			 */
			readonly Location: Eto.Drawing.Point;

			/** Gets or sets the type of cursor to use when the mouse is hovering over the control */
			Cursor: Eto.Forms.Cursor;

			/** Gets or sets the tool tip to show when the mouse is hovered over the control */
			ToolTip: string;

			/**
			 * Gets or sets the tab index order for this control within its container.
			 *
			 * This sets the order when using the tab key to cycle through controls  Note that some
			 * platforms (Gtk and WinForms) may not support setting the context of the tab order to
			 * StackLayout  or DynamicLayout containers and may not behave exactly as expected. Use
			 * the {@link Eto.PlatformFeatures.TabIndexWithCustomContainers} flag to determine if it
			 * is supported.
			 */
			TabIndex: number;

			/** Gets or sets a value indicating whether this control can serve as drop target. */
			AllowDrop: boolean;

			/**
			 * Gets or sets the parent widget which this widget has been added to, if any
			 *
			 * When implementing child widgets that can participate in the context based binding
			 * (MVVM), You can set this to the parent widget when it is added or removed to it
			 * (usually via a collection).  Note that you should typically provide a public new
			 * [ParentWidget] Parent { get; } property  so that consumers of your API cannot set the
			 * parent to an invalid value.
			 */
			Parent: Eto.Widget;

			/**
			 * Gets an enumeration of all parent widgets in the heirarchy by traversing the
			 * {@link Eto.Forms.BindableWidget.Parent} property.
			 */
			readonly Parents: Iterable<Eto.Widget>;

			/**
			 * Gets or sets the data context for this widget for binding
			 *
			 * Subclasses may override the standard behaviour so that hierarchy of widgets can be
			 * taken into account.  For example, a Control may return the data context of a parent,
			 * if it is not set explicitly.
			 */
			DataContext: unknown;

			/** Gets the collection of bindings that are attached to this widget */
			readonly Bindings: Eto.Forms.BindingCollection;

			/**
			 * Gets a value indicating that the {@link Eto.Forms.BindableWidget.DataContext} property
			 * is changing.
			 *
			 * This can be used to determine when to allow certain logic during the update of the
			 * data context.  It is used to disable binding setters on the model when the data
			 * context changes so that a binding does not cause the view model to be updated when the
			 * state hasn't been fully set yet.
			 */
			IsDataContextChanging: boolean;

			/**
			 * Gets the platform that was used to create the {@link Eto.Widget.Handler} for this
			 * widget
			 *
			 * This gets set to the current {@link Eto.Platform.Instance} during the construction of
			 * the object
			 */
			readonly Platform: Eto.Platform;

			/** Gets the platform-specific handler for this widget */
			Handler: unknown;

			/** Gets the native platform-specific handle for integration purposes */
			readonly NativeHandle: unknown;

			/** Gets the dictionary of properties for this widget */
			readonly Properties: Eto.PropertyStore;

			/** Gets or sets the ID of this widget */
			ID: string;

			/**
			 * Gets or sets the style of this widget
			 *
			 * Styles allow you to attach custom platform-specific logic to a widget. In your
			 * platform-specific assembly, use {@link Style.Add{H}(string, StyleHandler{H})} to add
			 * the style logic with the same id.
			 */
			Style: string;

			/**
			 * Gets the instance of the platform-specific object
			 *
			 * This can sometimes be useful to get the platform-specific object. Some handlers may
			 * not have any backing object for its functionality, so this may be null.  It is more
			 * preferred to use the {@link Eto.Widget.Handler} and cast that to the platform-specific
			 * handler class which can give you additional methods and helpers to do common tasks.
			 * For example, the {@link Eto.Forms.Application} object's handler for OS X has a
			 * AddFullScreenMenuItem property to specify if you want full screen support in your app.
			 */
			readonly ControlObject: unknown;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Widget} has been disposed.
			 *
			 * When the widget is disposed, it can no longer be used.
			 */
			IsDisposed: boolean;

			/**
			 * Selects all of the text in the control.
			 *
			 * When setting the selection, the control will be focussed and the associated keyboard
			 * may appear on mobile platforms.
			 */
			SelectAll(): void;

			/**
			 * Queues a repaint of the entire control on the screen and any of its children.
			 *
			 * This is only useful when the control is visible.
			 */
			Invalidate(): void;

			/**
			 * Queues a repaint of the entire control on the screen
			 *
			 * This is only useful when the control is visible.
			 */
			Invalidate(invalidateChildren: boolean): void;

			/**
			 * Queues a repaint of the specified `rect` of the control and any children.
			 *
			 * This is only useful when the control is visible.
			 */
			Invalidate(rect: Eto.Drawing.Rectangle): void;

			/**
			 * Queues a repaint of the specified `rect` of the control
			 *
			 * This is only useful when the control is visible.
			 */
			Invalidate(
				rect: Eto.Drawing.Rectangle,
				invalidateChildren: boolean,
			): void;

			/**
			 * Updates the layout of this control if necessary.
			 *
			 * This will ensure the control has had all of its layout applied so you can use its
			 * position and size right after this call. Most platforms (except WinForms) use a
			 * deferred layout system so that after adding your control to the form dynamically it
			 * won't get laid out until the next idle loop. This is useful when you need to know the
			 * dimensions of the control immediately. Note that this can be an expensive operation,
			 * so it is recommended to only call this method when necessary and after all of the
			 * controls have been added/updated.
			 */
			UpdateLayout(): void;

			/** Gets the preferred size of this control given infinite space available. */
			GetPreferredSize(): Eto.Drawing.SizeF;

			/** Gets the preferred size of this control given the specified `availableSize`. */
			GetPreferredSize(availableSize: Eto.Drawing.SizeF): Eto.Drawing.SizeF;

			/**
			 * Captures all mouse events to this control.
			 *
			 * This captures all mouse events until {@link Eto.Forms.Control.ReleaseMouseCapture} is
			 * called.  Note that not all platforms will allow a mouse capture unless the mouse is
			 * currently down.
			 */
			CaptureMouse(): boolean;

			/** Releases the mouse capture after a call to {@link Eto.Forms.Control.CaptureMouse}. */
			ReleaseMouseCapture(): void;

			/**
			 * Finds a control in the parent hierarchy with the specified type and
			 * {@link Eto.Widget.ID} if specified
			 */
			FindParent(
				type: unknown,
				id?: string,
			): Eto.Forms.Container;

			/** Finds a control in the parent hierarchy with the specified `id` */
			FindParent(id: string): Eto.Forms.Container;

			/**
			 * Detaches the control by removing it from its parent
			 *
			 * This is essentially a shortcut to myControl.Parent.Remove(myControl);
			 */
			Detach(): void;

			/**
			 * Attaches the control for direct use in a native application
			 *
			 * Use this to use a control directly in a native application.  Note that the native
			 * application must be running the same framework as the current platform.  E.g. a
			 * WinForms application can use an Eto.Forms control when using the Eto.WinForms
			 * platform.  This prepares the control by firing the {@link Eto.Forms.Control.PreLoad},
			 * {@link Eto.Forms.Control.Load}, etc. events.
			 */
			AttachNative(): void;

			/**
			 * Detaches the control when it is used in a native application, when you want to reuse
			 * the control.
			 *
			 * This should only be called after {@link Eto.Forms.Control.AttachNative} has been
			 * called, which is usually done by calling to ToNative(true) .
			 */
			DetachNative(): void;

			/**
			 * Attempts to set the keyboard input focus to this control, or the first child that
			 * accepts focus. For Windows, this will bring it to front and activate it.
			 */
			Focus(): void;

			/**
			 * Suspends the layout of child controls
			 *
			 * This can be used to optimize some platforms while adding, removing, or changing many
			 * child controls at once. It disables the calculation of control positioning until
			 * {@link Eto.Forms.Control.ResumeLayout} is called. Each call to SuspendLayout() must be
			 * balanced with a call to {@link Eto.Forms.Control.ResumeLayout}.
			 */
			SuspendLayout(): void;

			/**
			 * Resumes the layout after it has been suspended, and performs a layout
			 *
			 * This can be used to optimize some platforms while adding, removing, or changing many
			 * child controls at once. Each call to ResumeLayout() must be balanced with a call to
			 * {@link Eto.Forms.Control.SuspendLayout} before it.
			 */
			ResumeLayout(): void;

			/**
			 * Specifies a command to execute for a platform-specific command
			 *
			 * Some platforms have specific system-defined commands that can be associated with a
			 * control. For example, the Mac platform's cut/copy/paste functionality is defined by
			 * the system, and if you want to hook into it, you can use this to map it to your own
			 * defined logic. The valid values of the `systemCommand` parameter are defined by each
			 * platform, and a list can be retrieved using
			 * {@link Eto.Forms.Control.SupportedPlatformCommands}
			 */
			MapPlatformCommand(
				systemCommand: string,
				command: Eto.Forms.Command,
			): void;

			/** Converts a point from screen space to control space. */
			PointFromScreen(point: Eto.Drawing.PointF): Eto.Drawing.PointF;

			/** Converts a point from control space to screen space */
			PointToScreen(point: Eto.Drawing.PointF): Eto.Drawing.PointF;

			/** Converts a rectangle from screen space to control space. */
			RectangleToScreen(rect: Eto.Drawing.RectangleF): Eto.Drawing.RectangleF;

			/** Converts a rectangle from control space to screen space */
			RectangleFromScreen(rect: Eto.Drawing.RectangleF): Eto.Drawing.RectangleF;

			/**
			 * Starts drag operation using this control as drag source.
			 *
			 * This method can be blocking on some platforms (Wpf, WinForms), and non-blocking on
			 * others (Mac, Gtk). Use the {@link Eto.Forms.Control.DragEnd} event to determine when
			 * the drag operation is completed and get its resulting DragEffects.
			 */
			DoDragDrop(
				data: Eto.Forms.DataObject,
				allowedEffects: Eto.Forms.DragEffects,
			): void;

			/**
			 * Starts drag operation using this control as drag source.
			 *
			 * This method can be blocking on some platforms (Wpf, WinForms), and non-blocking on
			 * others (Mac, Gtk). Use the {@link Eto.Forms.Control.DragEnd} event to determine when
			 * the drag operation is completed and get its resulting DragEffects.
			 */
			DoDragDrop(
				data: Eto.Forms.DataObject,
				allowedEffects: Eto.Forms.DragEffects,
				image: Eto.Drawing.Image,
				cursorOffset: Eto.Drawing.PointF,
			): void;

			/**
			 * Triggers the StyleChanged event and re-applies the styles to this control and its
			 * children.
			 */
			TriggerStyleChanged(): void;

			/** Shows a print dialog to print the specified control */
			Print(): void;

			/**
			 * Finds a control in the parent hierarchy with the specified type and
			 * {@link Eto.Widget.ID} if specified
			 */
			FindParent<T>(id?: string): T;

			/**
			 * Finds a control in the parent hierarchy with the specified type and
			 * {@link Eto.Widget.ID} if specified
			 */
			FindParent(
				type: unknown,
				id?: string,
			): Eto.Widget;

			/** Finds a control in the parent hierarchy with the specified `id` */
			FindParent(id: string): Eto.Widget;

			/**
			 * Unbinds any bindings in the {@link Eto.Forms.BindableWidget.Bindings} collection and
			 * removes the bindings
			 *
			 * When you implement {@link Eto.Forms.IBindableWidgetContainer}, this will also unbind
			 * any of its children.
			 */
			Unbind(): void;

			/**
			 * Updates all bindings in this widget
			 *
			 * When you implement {@link Eto.Forms.IBindableWidgetContainer}, this will also update
			 * bindings for all of its children.
			 */
			UpdateBindings(mode?: Eto.Forms.BindingUpdateMode): void;

			/** Disposes of this widget, supressing the finalizer */
			dispose(): void;

			/** Gets a string that represents the current object with its ID if specified. */
			ToString(): string;
		}
	}

	export namespace Eto.Forms {
		/**
		 * Text box with masking capabilities.
		 *
		 * This uses the {@link Eto.Forms.IMaskedTextProvider} as its interface to the mask.
		 * The mask can implement any format it wishes, including both fixed or variable length
		 * masks. The MaskedTextStepper allows you to mask, or limit which characters can be
		 * entered in the text box with either a fixed, variable, or custom mask. A fixed mask
		 * can be a phone number, postal code, or something that requires a specific format and
		 * can be created using the {@link Eto.Forms.FixedMaskedTextProvider}.  A variable mask
		 * limits which characters can be entered but is not limited to a fixed number of
		 * characters. An implementation of a variable mask is the
		 * {@link Eto.Forms.NumericMaskedTextBox<>} which allows you to enter only numeric values
		 * in a text box, and places the positive / negative symbol at the beginning regardless
		 * of where you type it.
		 */
		export class MaskedTextStepper implements
			Eto.IHandlerSource,
			Eto.Forms.IBindable,
			Eto.Forms.IMouseInputSource,
			Eto.Forms.IKeyboardInputSource {
			/** Initializes a new instance of the {@link Eto.Forms.MaskedTextStepper} class. */
			constructor();

			/**
			 * Initializes a new instance of the {@link Eto.Forms.MaskedTextStepper} class with the
			 * specified masked text provider.
			 */
			constructor(provider: Eto.Forms.IMaskedTextProvider);

			/** Gets or sets the masked text provider to specify the mask format. */
			Provider: Eto.Forms.IMaskedTextProvider;

			/**
			 * Gets or sets the mode for insertion. Use
			 * {@link Eto.Forms.MaskedTextStepper.IsOverwrite} to determine the current mode.
			 */
			InsertMode: Eto.Forms.InsertKeyMode;

			/** Gets a value indicating whether typing will overwrite text. */
			readonly IsOverwrite: boolean;

			/**
			 * Gets or sets a value indicating that the prompt characters should only be shown when
			 * the control has focus.
			 */
			ShowPromptOnFocus: boolean;

			/** Gets or sets the mode for when the input prompts should be shown */
			ShowPromptMode: Eto.Forms.ShowPromptMode;

			/**
			 * Gets or sets a value indicating that the placeholder should be shown when the mask is
			 * empty and the control does not have focus.
			 */
			ShowPlaceholderWhenEmpty: boolean;

			/** Gets or sets the text of the control including any mask characters. */
			Text: string;

			/** Gets a value indicating whether the mask is completed. */
			readonly MaskCompleted: boolean;

			/**
			 * Gets or sets the valid directions the stepper will allow the user to click.
			 *
			 * On some platforms, the up and/or down buttons will not appear disabled, but will not
			 * trigger any events when they are  not set as a valid direction.
			 */
			ValidDirection: Eto.Forms.StepperValidDirections;

			/**
			 * Gets or sets a value indicating whether the Stepper will be shown.
			 *
			 * This is a hint only, some platforms (currently Gtk) may ignore this setting.
			 */
			ShowStepper: boolean;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Forms.TextBox} is read only.
			 *
			 * A user can selected and copied text when the read only, however the user will not be
			 * able to change any of the text. This differs from the
			 * {@link Eto.Forms.Control.Enabled} property, which disables all user interaction.
			 */
			ReadOnly: boolean;

			/**
			 * Gets or sets the maximum length of the text that can be entered in the control, 0 for
			 * no limit.
			 *
			 * This typically does not affect the value set using {@link Eto.Forms.TextControl.Text},
			 * only the limit of what the user can  enter into the control.
			 */
			MaxLength: number;

			/**
			 * Gets or sets the placeholder text to show as a hint of what the user should enter.
			 *
			 * Typically this will be shown when the control is blank, and will dissappear when the
			 * user enters text or if it has an existing value.
			 */
			PlaceholderText: string;

			/**
			 * Gets or sets a value indicating whether to show the control's border.
			 *
			 * This is a hint to omit the border of the control and show it as plainly as possible.
			 * Typically used when you want to show the control within a cell of the
			 * {@link Eto.Forms.GridView}.
			 */
			ShowBorder: boolean;

			/** Gets or sets the alignment of the text in the entry box. */
			TextAlignment: Eto.Forms.TextAlignment;

			/**
			 * Gets or sets the index of the current insertion point.
			 *
			 * When there is selected text, this is usually the start of the selection.
			 */
			CaretIndex: number;

			/** Gets or sets the current text selection. */
			Selection: Eto.Forms.Range$1<number>;

			/** Gets or sets the selected text. */
			SelectedText: string;

			/** Gets or sets the auto selection mode. */
			AutoSelectMode: Eto.Forms.AutoSelectMode;

			/**
			 * Gets or sets the color of the text.
			 *
			 * By default, the text will get a color based on the user's theme. However, this is
			 * usually black.
			 */
			TextColor: Eto.Drawing.Color;

			/** Gets the binding for the {@link Eto.Forms.TextControl.Text} property. */
			readonly TextBinding: Eto.Forms.BindableBinding$2<Eto.Forms.TextControl, string>;

			/** Gets or sets the font for the text of the control */
			Font: Eto.Drawing.Font;

			/**
			 * Gets a value indicating that the control is loaded onto a form, that is it has been
			 * created, added to a parent, and shown
			 *
			 * The {@link Eto.Forms.Control.OnLoad(System.EventArgs)} method sets this value to true
			 * after cascading to all children (for a {@link Eto.Forms.Container} ) and calling the
			 * platform handler's implementation.  It is called after adding to a loaded form, or
			 * when showing a new form.  The {@link Eto.Forms.Control.OnUnLoad(System.EventArgs)}
			 * method will set this value to false when the control is removed from its parent
			 */
			readonly Loaded: boolean;

			/**
			 * Gets an enumeration of controls that are in the visual tree.
			 *
			 * This is used to specify which controls are contained by this instance that are part of
			 * the visual tree. This should include all controls including non-logical Eto controls
			 * used for layout.
			 */
			readonly VisualControls: Iterable<Eto.Forms.Control>;

			/**
			 * Gets or sets a user-defined object that contains data about the control
			 *
			 * A common use of the tag property is to store data that is associated with the control
			 * that you can later retrieve.
			 */
			Tag: unknown;

			/**
			 * Gets the logical parent control.
			 *
			 * When the control is part of the visual tree (
				 * {@link Eto.Forms.Control.IsVisualControl} is true), this returns the logical parent
				 * that contains this control. Otherwise this is the same as
				 * {@link Eto.Forms.Control.Parent}.
				 */
				readonly LogicalParent: Eto.Forms.Container;

			/** Gets a value indicating this {@link Eto.Forms.Control} is part of the visual tree. */
			IsVisualControl: boolean;

			/**
			 * Gets or sets the size of the control. Use -1 to specify auto sizing for either the
			 * width and/or height.
			 *
			 * Setting the size of controls is entirely optional as most controls will size
			 * themselves appropriately. When specifying a size, it will be used as the desired size
			 * of the control.  The container will reposition and resize the control depending on the
			 * available size.  For a {@link Eto.Forms.Window}, it is preferred to set the
			 * {@link Eto.Forms.Container.ClientSize} instead, as various platforms have different
			 * sizes of window decorations, toolbars, etc.
			 */
			Size: Eto.Drawing.Size;

			/**
			 * Gets a value indicating this control currently has mouse capture
			 *
			 * Mouse capture can happen during a handled MouseDown event until MouseUp, or it can be
			 * captured explicitly via {@link Eto.Forms.Control.CaptureMouse}.
			 */
			readonly IsMouseCaptured: boolean;

			/** Gets or sets the width of the control size. */
			Width: number;

			/** Gets or sets the height of the control size. */
			Height: number;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Forms.Control} (or its
			 * children) are enabled and accept user input.
			 *
			 * Typically when a control is disabled, the user cannot do anything with the control or
			 * any of its children. Including for example, selecting text in a text control. Certain
			 * controls can have a 'Read Only' mode, such as {@link Eto.Forms.TextBox.ReadOnly} which
			 * allow the user to  select text, but not change its contents.
			 */
			Enabled: boolean;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Forms.Control} is visible to
			 * the user.
			 *
			 * When the visibility of a control is set to false, it will not occupy space in the
			 * layout.
			 */
			Visible: boolean;

			/** Gets the container which this control has been added to, if any */
			readonly Parent: Eto.Forms.Container;

			/**
			 * Gets the visual container of this control, if any.
			 *
			 * Some containers may use other Eto controls to layout its children, such as the
			 * {@link Eto.Forms.StackLayout}. This will return the parent control that visually
			 * contains this control as opposed to {@link Eto.Forms.Control.Parent} which will return
			 * the logical parent.
			 */
			VisualParent: Eto.Forms.Container;

			/** Gets a value indicating this control has been attached to a native container */
			readonly IsAttached: boolean;

			/**
			 * Gets or sets the color for the background of the control
			 *
			 * Note that on some platforms (e.g. Mac), setting the background color of a control can
			 * change the performance characteristics of the control and its children, since it must
			 * enable layers to do so.
			 */
			BackgroundColor: Eto.Drawing.Color;

			/** Gets a value indicating whether this instance has the keyboard input focus. */
			readonly HasFocus: boolean;

			/** Gets a value indicating whether the layout of child controls is suspended. */
			readonly IsSuspended: boolean;

			/** Gets the window this control is contained in */
			readonly ParentWindow: Eto.Forms.Window;

			/**
			 * Gets the supported platform commands that can be used to hook up system functions to
			 * user defined logic
			 *
			 * This lists all available commands that can be mapped using the
			 * {@link Eto.Forms.Control.MapPlatformCommand(System.String,Eto.Forms.Command)} method
			 * of the control.
			 */
			readonly SupportedPlatformCommands: Iterable<string>;

			/** Gets the bounding rectangle of this control relative to its container */
			readonly Bounds: Eto.Drawing.Rectangle;

			/**
			 * Gets the location of the control as positioned by the container
			 *
			 * A control's location is set by the container. This can be used to determine where the
			 * control is for overlaying floating windows, menus, etc.
			 */
			readonly Location: Eto.Drawing.Point;

			/** Gets or sets the type of cursor to use when the mouse is hovering over the control */
			Cursor: Eto.Forms.Cursor;

			/** Gets or sets the tool tip to show when the mouse is hovered over the control */
			ToolTip: string;

			/**
			 * Gets or sets the tab index order for this control within its container.
			 *
			 * This sets the order when using the tab key to cycle through controls  Note that some
			 * platforms (Gtk and WinForms) may not support setting the context of the tab order to
			 * StackLayout  or DynamicLayout containers and may not behave exactly as expected. Use
			 * the {@link Eto.PlatformFeatures.TabIndexWithCustomContainers} flag to determine if it
			 * is supported.
			 */
			TabIndex: number;

			/** Gets or sets a value indicating whether this control can serve as drop target. */
			AllowDrop: boolean;

			/**
			 * Gets or sets the parent widget which this widget has been added to, if any
			 *
			 * When implementing child widgets that can participate in the context based binding
			 * (MVVM), You can set this to the parent widget when it is added or removed to it
			 * (usually via a collection).  Note that you should typically provide a public new
			 * [ParentWidget] Parent { get; } property  so that consumers of your API cannot set the
			 * parent to an invalid value.
			 */
			Parent: Eto.Widget;

			/**
			 * Gets an enumeration of all parent widgets in the heirarchy by traversing the
			 * {@link Eto.Forms.BindableWidget.Parent} property.
			 */
			readonly Parents: Iterable<Eto.Widget>;

			/**
			 * Gets or sets the data context for this widget for binding
			 *
			 * Subclasses may override the standard behaviour so that hierarchy of widgets can be
			 * taken into account.  For example, a Control may return the data context of a parent,
			 * if it is not set explicitly.
			 */
			DataContext: unknown;

			/** Gets the collection of bindings that are attached to this widget */
			readonly Bindings: Eto.Forms.BindingCollection;

			/**
			 * Gets a value indicating that the {@link Eto.Forms.BindableWidget.DataContext} property
			 * is changing.
			 *
			 * This can be used to determine when to allow certain logic during the update of the
			 * data context.  It is used to disable binding setters on the model when the data
			 * context changes so that a binding does not cause the view model to be updated when the
			 * state hasn't been fully set yet.
			 */
			IsDataContextChanging: boolean;

			/**
			 * Gets the platform that was used to create the {@link Eto.Widget.Handler} for this
			 * widget
			 *
			 * This gets set to the current {@link Eto.Platform.Instance} during the construction of
			 * the object
			 */
			readonly Platform: Eto.Platform;

			/** Gets the platform-specific handler for this widget */
			Handler: unknown;

			/** Gets the native platform-specific handle for integration purposes */
			readonly NativeHandle: unknown;

			/** Gets the dictionary of properties for this widget */
			readonly Properties: Eto.PropertyStore;

			/** Gets or sets the ID of this widget */
			ID: string;

			/**
			 * Gets or sets the style of this widget
			 *
			 * Styles allow you to attach custom platform-specific logic to a widget. In your
			 * platform-specific assembly, use {@link Style.Add{H}(string, StyleHandler{H})} to add
			 * the style logic with the same id.
			 */
			Style: string;

			/**
			 * Gets the instance of the platform-specific object
			 *
			 * This can sometimes be useful to get the platform-specific object. Some handlers may
			 * not have any backing object for its functionality, so this may be null.  It is more
			 * preferred to use the {@link Eto.Widget.Handler} and cast that to the platform-specific
			 * handler class which can give you additional methods and helpers to do common tasks.
			 * For example, the {@link Eto.Forms.Application} object's handler for OS X has a
			 * AddFullScreenMenuItem property to specify if you want full screen support in your app.
			 */
			readonly ControlObject: unknown;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Widget} has been disposed.
			 *
			 * When the widget is disposed, it can no longer be used.
			 */
			IsDisposed: boolean;

			/**
			 * Selects all of the text in the control.
			 *
			 * When setting the selection, the control will be focussed and the associated keyboard
			 * may appear on mobile platforms.
			 */
			SelectAll(): void;

			/**
			 * Queues a repaint of the entire control on the screen and any of its children.
			 *
			 * This is only useful when the control is visible.
			 */
			Invalidate(): void;

			/**
			 * Queues a repaint of the entire control on the screen
			 *
			 * This is only useful when the control is visible.
			 */
			Invalidate(invalidateChildren: boolean): void;

			/**
			 * Queues a repaint of the specified `rect` of the control and any children.
			 *
			 * This is only useful when the control is visible.
			 */
			Invalidate(rect: Eto.Drawing.Rectangle): void;

			/**
			 * Queues a repaint of the specified `rect` of the control
			 *
			 * This is only useful when the control is visible.
			 */
			Invalidate(
				rect: Eto.Drawing.Rectangle,
				invalidateChildren: boolean,
			): void;

			/**
			 * Updates the layout of this control if necessary.
			 *
			 * This will ensure the control has had all of its layout applied so you can use its
			 * position and size right after this call. Most platforms (except WinForms) use a
			 * deferred layout system so that after adding your control to the form dynamically it
			 * won't get laid out until the next idle loop. This is useful when you need to know the
			 * dimensions of the control immediately. Note that this can be an expensive operation,
			 * so it is recommended to only call this method when necessary and after all of the
			 * controls have been added/updated.
			 */
			UpdateLayout(): void;

			/** Gets the preferred size of this control given infinite space available. */
			GetPreferredSize(): Eto.Drawing.SizeF;

			/** Gets the preferred size of this control given the specified `availableSize`. */
			GetPreferredSize(availableSize: Eto.Drawing.SizeF): Eto.Drawing.SizeF;

			/**
			 * Captures all mouse events to this control.
			 *
			 * This captures all mouse events until {@link Eto.Forms.Control.ReleaseMouseCapture} is
			 * called.  Note that not all platforms will allow a mouse capture unless the mouse is
			 * currently down.
			 */
			CaptureMouse(): boolean;

			/** Releases the mouse capture after a call to {@link Eto.Forms.Control.CaptureMouse}. */
			ReleaseMouseCapture(): void;

			/**
			 * Finds a control in the parent hierarchy with the specified type and
			 * {@link Eto.Widget.ID} if specified
			 */
			FindParent(
				type: unknown,
				id?: string,
			): Eto.Forms.Container;

			/** Finds a control in the parent hierarchy with the specified `id` */
			FindParent(id: string): Eto.Forms.Container;

			/**
			 * Detaches the control by removing it from its parent
			 *
			 * This is essentially a shortcut to myControl.Parent.Remove(myControl);
			 */
			Detach(): void;

			/**
			 * Attaches the control for direct use in a native application
			 *
			 * Use this to use a control directly in a native application.  Note that the native
			 * application must be running the same framework as the current platform.  E.g. a
			 * WinForms application can use an Eto.Forms control when using the Eto.WinForms
			 * platform.  This prepares the control by firing the {@link Eto.Forms.Control.PreLoad},
			 * {@link Eto.Forms.Control.Load}, etc. events.
			 */
			AttachNative(): void;

			/**
			 * Detaches the control when it is used in a native application, when you want to reuse
			 * the control.
			 *
			 * This should only be called after {@link Eto.Forms.Control.AttachNative} has been
			 * called, which is usually done by calling to ToNative(true) .
			 */
			DetachNative(): void;

			/**
			 * Attempts to set the keyboard input focus to this control, or the first child that
			 * accepts focus. For Windows, this will bring it to front and activate it.
			 */
			Focus(): void;

			/**
			 * Suspends the layout of child controls
			 *
			 * This can be used to optimize some platforms while adding, removing, or changing many
			 * child controls at once. It disables the calculation of control positioning until
			 * {@link Eto.Forms.Control.ResumeLayout} is called. Each call to SuspendLayout() must be
			 * balanced with a call to {@link Eto.Forms.Control.ResumeLayout}.
			 */
			SuspendLayout(): void;

			/**
			 * Resumes the layout after it has been suspended, and performs a layout
			 *
			 * This can be used to optimize some platforms while adding, removing, or changing many
			 * child controls at once. Each call to ResumeLayout() must be balanced with a call to
			 * {@link Eto.Forms.Control.SuspendLayout} before it.
			 */
			ResumeLayout(): void;

			/**
			 * Specifies a command to execute for a platform-specific command
			 *
			 * Some platforms have specific system-defined commands that can be associated with a
			 * control. For example, the Mac platform's cut/copy/paste functionality is defined by
			 * the system, and if you want to hook into it, you can use this to map it to your own
			 * defined logic. The valid values of the `systemCommand` parameter are defined by each
			 * platform, and a list can be retrieved using
			 * {@link Eto.Forms.Control.SupportedPlatformCommands}
			 */
			MapPlatformCommand(
				systemCommand: string,
				command: Eto.Forms.Command,
			): void;

			/** Converts a point from screen space to control space. */
			PointFromScreen(point: Eto.Drawing.PointF): Eto.Drawing.PointF;

			/** Converts a point from control space to screen space */
			PointToScreen(point: Eto.Drawing.PointF): Eto.Drawing.PointF;

			/** Converts a rectangle from screen space to control space. */
			RectangleToScreen(rect: Eto.Drawing.RectangleF): Eto.Drawing.RectangleF;

			/** Converts a rectangle from control space to screen space */
			RectangleFromScreen(rect: Eto.Drawing.RectangleF): Eto.Drawing.RectangleF;

			/**
			 * Starts drag operation using this control as drag source.
			 *
			 * This method can be blocking on some platforms (Wpf, WinForms), and non-blocking on
			 * others (Mac, Gtk). Use the {@link Eto.Forms.Control.DragEnd} event to determine when
			 * the drag operation is completed and get its resulting DragEffects.
			 */
			DoDragDrop(
				data: Eto.Forms.DataObject,
				allowedEffects: Eto.Forms.DragEffects,
			): void;

			/**
			 * Starts drag operation using this control as drag source.
			 *
			 * This method can be blocking on some platforms (Wpf, WinForms), and non-blocking on
			 * others (Mac, Gtk). Use the {@link Eto.Forms.Control.DragEnd} event to determine when
			 * the drag operation is completed and get its resulting DragEffects.
			 */
			DoDragDrop(
				data: Eto.Forms.DataObject,
				allowedEffects: Eto.Forms.DragEffects,
				image: Eto.Drawing.Image,
				cursorOffset: Eto.Drawing.PointF,
			): void;

			/**
			 * Triggers the StyleChanged event and re-applies the styles to this control and its
			 * children.
			 */
			TriggerStyleChanged(): void;

			/** Shows a print dialog to print the specified control */
			Print(): void;

			/**
			 * Finds a control in the parent hierarchy with the specified type and
			 * {@link Eto.Widget.ID} if specified
			 */
			FindParent<T>(id?: string): T;

			/**
			 * Finds a control in the parent hierarchy with the specified type and
			 * {@link Eto.Widget.ID} if specified
			 */
			FindParent(
				type: unknown,
				id?: string,
			): Eto.Widget;

			/** Finds a control in the parent hierarchy with the specified `id` */
			FindParent(id: string): Eto.Widget;

			/**
			 * Unbinds any bindings in the {@link Eto.Forms.BindableWidget.Bindings} collection and
			 * removes the bindings
			 *
			 * When you implement {@link Eto.Forms.IBindableWidgetContainer}, this will also unbind
			 * any of its children.
			 */
			Unbind(): void;

			/**
			 * Updates all bindings in this widget
			 *
			 * When you implement {@link Eto.Forms.IBindableWidgetContainer}, this will also update
			 * bindings for all of its children.
			 */
			UpdateBindings(mode?: Eto.Forms.BindingUpdateMode): void;

			/** Disposes of this widget, supressing the finalizer */
			dispose(): void;

			/** Gets a string that represents the current object with its ID if specified. */
			ToString(): string;
		}
	}

	export namespace Eto.Forms {
		/** Enumeration of mouse buttons */
		export enum MouseButtons {
			/** No mouse button */
			None = 0,

			/**
			 * The primary button, usually Left but can be Right depending on the user's preferences
			 * for a right handed mouse.
			 */
			Primary = 1,

			/**
			 * The alternate button, usually Right but can be Left depending on the user's
			 * preferences for a right handed mouse.
			 */
			Alternate = 2,

			/** The middle mouse button */
			Middle = 4,
		}
	}

	export namespace Eto.Forms {
		/** Mouse event arguments. */
		export class MouseEventArgs {
			/** Initializes a new instance of the {@link Eto.Forms.MouseEventArgs} class. */
			constructor(
				buttons: Eto.Forms.MouseButtons,
				modifiers: Eto.Forms.Keys,
				location: Eto.Drawing.PointF,
				delta?: Eto.Drawing.SizeF,
				pressure?: number,
			);

			/**
			 * Gets the key modifiers such as {@link Eto.Forms.Keys.Control},
			 * {@link Eto.Forms.Keys.Alt}, or {@link Eto.Forms.Keys.Shift}.
			 */
			Modifiers: Eto.Forms.Keys;

			/** Gets the mouse buttons involved in the event. */
			Buttons: Eto.Forms.MouseButtons;

			/** Gets the location of the mouse relative to the control that raised the event. */
			Location: Eto.Drawing.PointF;

			/**
			 * Gets or sets a value indicating whether the event is handled.
			 *
			 * Set this to true if you perform logic with the event and wish the default event to be
			 * cancelled. Some platforms may cause audio feedback if the user's action does not
			 * perform anything.
			 */
			Handled: boolean;

			/**
			 * Gets or sets the pressure of the mouse/stylus press, if applicable. 1.0 if full
			 * pressure or not supported.
			 */
			Pressure: number;

			/** Gets or sets the delta change of the scroll wheel for the event. */
			Delta: Eto.Drawing.SizeF;
		}
	}

	export namespace Eto.Forms {
		/**
		 * Arguments when creating a native control for the {@link Eto.Forms.NativeControlHost}
		 */
		export class CreateNativeControlArgs {
			constructor();

			/**
			 * Native control or handle to use. See comments for {@link Eto.Forms.NativeControlHost}
			 * on what types are supported for each platform.
			 */
			NativeControl: unknown;
		}
	}

	export namespace Eto.Forms {
		/**
		 * Control to host a native control within Eto
		 *
		 * This can be used as a cross platform way to convert a native control to an eto control
		 * without having to reference Eto's platform-specific assemblies and using its ToNatve()
		 * method or creating custom handlers.  The type of the supplied controlObject supported
		 * depends on the platform you are running on. - Wpf:         FrameworkElement, HWND
		 * (IntPtr), System.Windows.Forms.Control, or IWin32Window - WinForms:    HWND,
		 * System.Windows.Forms.Control, or IWin32Window - Mac64/macOS: AppKit.NSView, handle to
		 * NSView (IntPtr) - Gtk:         Gtk.Widget, or handle to Gtk.Widget (IntPtr)
		 */
		export class NativeControlHost implements
			Eto.IHandlerSource,
			Eto.Forms.IBindable,
			Eto.Forms.IMouseInputSource,
			Eto.Forms.IKeyboardInputSource {
			/**
			 * Initializes a new instance of the native control host with the specified native
			 * control
			 */
			constructor(nativeControl: unknown);

			/**
			 * Initializes a new instance of the native control host with a native hosting control
			 * that the caller can use directly.
			 */
			constructor();

			/**
			 * Gets a value indicating that the control is loaded onto a form, that is it has been
			 * created, added to a parent, and shown
			 *
			 * The {@link Eto.Forms.Control.OnLoad(System.EventArgs)} method sets this value to true
			 * after cascading to all children (for a {@link Eto.Forms.Container} ) and calling the
			 * platform handler's implementation.  It is called after adding to a loaded form, or
			 * when showing a new form.  The {@link Eto.Forms.Control.OnUnLoad(System.EventArgs)}
			 * method will set this value to false when the control is removed from its parent
			 */
			readonly Loaded: boolean;

			/**
			 * Gets an enumeration of controls that are in the visual tree.
			 *
			 * This is used to specify which controls are contained by this instance that are part of
			 * the visual tree. This should include all controls including non-logical Eto controls
			 * used for layout.
			 */
			readonly VisualControls: Iterable<Eto.Forms.Control>;

			/**
			 * Gets or sets a user-defined object that contains data about the control
			 *
			 * A common use of the tag property is to store data that is associated with the control
			 * that you can later retrieve.
			 */
			Tag: unknown;

			/**
			 * Gets the logical parent control.
			 *
			 * When the control is part of the visual tree (
				 * {@link Eto.Forms.Control.IsVisualControl} is true), this returns the logical parent
				 * that contains this control. Otherwise this is the same as
				 * {@link Eto.Forms.Control.Parent}.
				 */
				readonly LogicalParent: Eto.Forms.Container;

			/** Gets a value indicating this {@link Eto.Forms.Control} is part of the visual tree. */
			IsVisualControl: boolean;

			/**
			 * Gets or sets the size of the control. Use -1 to specify auto sizing for either the
			 * width and/or height.
			 *
			 * Setting the size of controls is entirely optional as most controls will size
			 * themselves appropriately. When specifying a size, it will be used as the desired size
			 * of the control.  The container will reposition and resize the control depending on the
			 * available size.  For a {@link Eto.Forms.Window}, it is preferred to set the
			 * {@link Eto.Forms.Container.ClientSize} instead, as various platforms have different
			 * sizes of window decorations, toolbars, etc.
			 */
			Size: Eto.Drawing.Size;

			/**
			 * Gets a value indicating this control currently has mouse capture
			 *
			 * Mouse capture can happen during a handled MouseDown event until MouseUp, or it can be
			 * captured explicitly via {@link Eto.Forms.Control.CaptureMouse}.
			 */
			readonly IsMouseCaptured: boolean;

			/** Gets or sets the width of the control size. */
			Width: number;

			/** Gets or sets the height of the control size. */
			Height: number;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Forms.Control} (or its
			 * children) are enabled and accept user input.
			 *
			 * Typically when a control is disabled, the user cannot do anything with the control or
			 * any of its children. Including for example, selecting text in a text control. Certain
			 * controls can have a 'Read Only' mode, such as {@link Eto.Forms.TextBox.ReadOnly} which
			 * allow the user to  select text, but not change its contents.
			 */
			Enabled: boolean;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Forms.Control} is visible to
			 * the user.
			 *
			 * When the visibility of a control is set to false, it will not occupy space in the
			 * layout.
			 */
			Visible: boolean;

			/** Gets the container which this control has been added to, if any */
			readonly Parent: Eto.Forms.Container;

			/**
			 * Gets the visual container of this control, if any.
			 *
			 * Some containers may use other Eto controls to layout its children, such as the
			 * {@link Eto.Forms.StackLayout}. This will return the parent control that visually
			 * contains this control as opposed to {@link Eto.Forms.Control.Parent} which will return
			 * the logical parent.
			 */
			VisualParent: Eto.Forms.Container;

			/** Gets a value indicating this control has been attached to a native container */
			readonly IsAttached: boolean;

			/**
			 * Gets or sets the color for the background of the control
			 *
			 * Note that on some platforms (e.g. Mac), setting the background color of a control can
			 * change the performance characteristics of the control and its children, since it must
			 * enable layers to do so.
			 */
			BackgroundColor: Eto.Drawing.Color;

			/** Gets a value indicating whether this instance has the keyboard input focus. */
			readonly HasFocus: boolean;

			/** Gets a value indicating whether the layout of child controls is suspended. */
			readonly IsSuspended: boolean;

			/** Gets the window this control is contained in */
			readonly ParentWindow: Eto.Forms.Window;

			/**
			 * Gets the supported platform commands that can be used to hook up system functions to
			 * user defined logic
			 *
			 * This lists all available commands that can be mapped using the
			 * {@link Eto.Forms.Control.MapPlatformCommand(System.String,Eto.Forms.Command)} method
			 * of the control.
			 */
			readonly SupportedPlatformCommands: Iterable<string>;

			/** Gets the bounding rectangle of this control relative to its container */
			readonly Bounds: Eto.Drawing.Rectangle;

			/**
			 * Gets the location of the control as positioned by the container
			 *
			 * A control's location is set by the container. This can be used to determine where the
			 * control is for overlaying floating windows, menus, etc.
			 */
			readonly Location: Eto.Drawing.Point;

			/** Gets or sets the type of cursor to use when the mouse is hovering over the control */
			Cursor: Eto.Forms.Cursor;

			/** Gets or sets the tool tip to show when the mouse is hovered over the control */
			ToolTip: string;

			/**
			 * Gets or sets the tab index order for this control within its container.
			 *
			 * This sets the order when using the tab key to cycle through controls  Note that some
			 * platforms (Gtk and WinForms) may not support setting the context of the tab order to
			 * StackLayout  or DynamicLayout containers and may not behave exactly as expected. Use
			 * the {@link Eto.PlatformFeatures.TabIndexWithCustomContainers} flag to determine if it
			 * is supported.
			 */
			TabIndex: number;

			/** Gets or sets a value indicating whether this control can serve as drop target. */
			AllowDrop: boolean;

			/**
			 * Gets or sets the parent widget which this widget has been added to, if any
			 *
			 * When implementing child widgets that can participate in the context based binding
			 * (MVVM), You can set this to the parent widget when it is added or removed to it
			 * (usually via a collection).  Note that you should typically provide a public new
			 * [ParentWidget] Parent { get; } property  so that consumers of your API cannot set the
			 * parent to an invalid value.
			 */
			Parent: Eto.Widget;

			/**
			 * Gets an enumeration of all parent widgets in the heirarchy by traversing the
			 * {@link Eto.Forms.BindableWidget.Parent} property.
			 */
			readonly Parents: Iterable<Eto.Widget>;

			/**
			 * Gets or sets the data context for this widget for binding
			 *
			 * Subclasses may override the standard behaviour so that hierarchy of widgets can be
			 * taken into account.  For example, a Control may return the data context of a parent,
			 * if it is not set explicitly.
			 */
			DataContext: unknown;

			/** Gets the collection of bindings that are attached to this widget */
			readonly Bindings: Eto.Forms.BindingCollection;

			/**
			 * Gets a value indicating that the {@link Eto.Forms.BindableWidget.DataContext} property
			 * is changing.
			 *
			 * This can be used to determine when to allow certain logic during the update of the
			 * data context.  It is used to disable binding setters on the model when the data
			 * context changes so that a binding does not cause the view model to be updated when the
			 * state hasn't been fully set yet.
			 */
			IsDataContextChanging: boolean;

			/**
			 * Gets the platform that was used to create the {@link Eto.Widget.Handler} for this
			 * widget
			 *
			 * This gets set to the current {@link Eto.Platform.Instance} during the construction of
			 * the object
			 */
			readonly Platform: Eto.Platform;

			/** Gets the platform-specific handler for this widget */
			Handler: unknown;

			/** Gets the native platform-specific handle for integration purposes */
			readonly NativeHandle: unknown;

			/** Gets the dictionary of properties for this widget */
			readonly Properties: Eto.PropertyStore;

			/** Gets or sets the ID of this widget */
			ID: string;

			/**
			 * Gets or sets the style of this widget
			 *
			 * Styles allow you to attach custom platform-specific logic to a widget. In your
			 * platform-specific assembly, use {@link Style.Add{H}(string, StyleHandler{H})} to add
			 * the style logic with the same id.
			 */
			Style: string;

			/**
			 * Gets the instance of the platform-specific object
			 *
			 * This can sometimes be useful to get the platform-specific object. Some handlers may
			 * not have any backing object for its functionality, so this may be null.  It is more
			 * preferred to use the {@link Eto.Widget.Handler} and cast that to the platform-specific
			 * handler class which can give you additional methods and helpers to do common tasks.
			 * For example, the {@link Eto.Forms.Application} object's handler for OS X has a
			 * AddFullScreenMenuItem property to specify if you want full screen support in your app.
			 */
			readonly ControlObject: unknown;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Widget} has been disposed.
			 *
			 * When the widget is disposed, it can no longer be used.
			 */
			IsDisposed: boolean;

			/**
			 * Queues a repaint of the entire control on the screen and any of its children.
			 *
			 * This is only useful when the control is visible.
			 */
			Invalidate(): void;

			/**
			 * Queues a repaint of the entire control on the screen
			 *
			 * This is only useful when the control is visible.
			 */
			Invalidate(invalidateChildren: boolean): void;

			/**
			 * Queues a repaint of the specified `rect` of the control and any children.
			 *
			 * This is only useful when the control is visible.
			 */
			Invalidate(rect: Eto.Drawing.Rectangle): void;

			/**
			 * Queues a repaint of the specified `rect` of the control
			 *
			 * This is only useful when the control is visible.
			 */
			Invalidate(
				rect: Eto.Drawing.Rectangle,
				invalidateChildren: boolean,
			): void;

			/**
			 * Updates the layout of this control if necessary.
			 *
			 * This will ensure the control has had all of its layout applied so you can use its
			 * position and size right after this call. Most platforms (except WinForms) use a
			 * deferred layout system so that after adding your control to the form dynamically it
			 * won't get laid out until the next idle loop. This is useful when you need to know the
			 * dimensions of the control immediately. Note that this can be an expensive operation,
			 * so it is recommended to only call this method when necessary and after all of the
			 * controls have been added/updated.
			 */
			UpdateLayout(): void;

			/** Gets the preferred size of this control given infinite space available. */
			GetPreferredSize(): Eto.Drawing.SizeF;

			/** Gets the preferred size of this control given the specified `availableSize`. */
			GetPreferredSize(availableSize: Eto.Drawing.SizeF): Eto.Drawing.SizeF;

			/**
			 * Captures all mouse events to this control.
			 *
			 * This captures all mouse events until {@link Eto.Forms.Control.ReleaseMouseCapture} is
			 * called.  Note that not all platforms will allow a mouse capture unless the mouse is
			 * currently down.
			 */
			CaptureMouse(): boolean;

			/** Releases the mouse capture after a call to {@link Eto.Forms.Control.CaptureMouse}. */
			ReleaseMouseCapture(): void;

			/**
			 * Finds a control in the parent hierarchy with the specified type and
			 * {@link Eto.Widget.ID} if specified
			 */
			FindParent(
				type: unknown,
				id?: string,
			): Eto.Forms.Container;

			/** Finds a control in the parent hierarchy with the specified `id` */
			FindParent(id: string): Eto.Forms.Container;

			/**
			 * Detaches the control by removing it from its parent
			 *
			 * This is essentially a shortcut to myControl.Parent.Remove(myControl);
			 */
			Detach(): void;

			/**
			 * Attaches the control for direct use in a native application
			 *
			 * Use this to use a control directly in a native application.  Note that the native
			 * application must be running the same framework as the current platform.  E.g. a
			 * WinForms application can use an Eto.Forms control when using the Eto.WinForms
			 * platform.  This prepares the control by firing the {@link Eto.Forms.Control.PreLoad},
			 * {@link Eto.Forms.Control.Load}, etc. events.
			 */
			AttachNative(): void;

			/**
			 * Detaches the control when it is used in a native application, when you want to reuse
			 * the control.
			 *
			 * This should only be called after {@link Eto.Forms.Control.AttachNative} has been
			 * called, which is usually done by calling to ToNative(true) .
			 */
			DetachNative(): void;

			/**
			 * Attempts to set the keyboard input focus to this control, or the first child that
			 * accepts focus. For Windows, this will bring it to front and activate it.
			 */
			Focus(): void;

			/**
			 * Suspends the layout of child controls
			 *
			 * This can be used to optimize some platforms while adding, removing, or changing many
			 * child controls at once. It disables the calculation of control positioning until
			 * {@link Eto.Forms.Control.ResumeLayout} is called. Each call to SuspendLayout() must be
			 * balanced with a call to {@link Eto.Forms.Control.ResumeLayout}.
			 */
			SuspendLayout(): void;

			/**
			 * Resumes the layout after it has been suspended, and performs a layout
			 *
			 * This can be used to optimize some platforms while adding, removing, or changing many
			 * child controls at once. Each call to ResumeLayout() must be balanced with a call to
			 * {@link Eto.Forms.Control.SuspendLayout} before it.
			 */
			ResumeLayout(): void;

			/**
			 * Specifies a command to execute for a platform-specific command
			 *
			 * Some platforms have specific system-defined commands that can be associated with a
			 * control. For example, the Mac platform's cut/copy/paste functionality is defined by
			 * the system, and if you want to hook into it, you can use this to map it to your own
			 * defined logic. The valid values of the `systemCommand` parameter are defined by each
			 * platform, and a list can be retrieved using
			 * {@link Eto.Forms.Control.SupportedPlatformCommands}
			 */
			MapPlatformCommand(
				systemCommand: string,
				command: Eto.Forms.Command,
			): void;

			/** Converts a point from screen space to control space. */
			PointFromScreen(point: Eto.Drawing.PointF): Eto.Drawing.PointF;

			/** Converts a point from control space to screen space */
			PointToScreen(point: Eto.Drawing.PointF): Eto.Drawing.PointF;

			/** Converts a rectangle from screen space to control space. */
			RectangleToScreen(rect: Eto.Drawing.RectangleF): Eto.Drawing.RectangleF;

			/** Converts a rectangle from control space to screen space */
			RectangleFromScreen(rect: Eto.Drawing.RectangleF): Eto.Drawing.RectangleF;

			/**
			 * Starts drag operation using this control as drag source.
			 *
			 * This method can be blocking on some platforms (Wpf, WinForms), and non-blocking on
			 * others (Mac, Gtk). Use the {@link Eto.Forms.Control.DragEnd} event to determine when
			 * the drag operation is completed and get its resulting DragEffects.
			 */
			DoDragDrop(
				data: Eto.Forms.DataObject,
				allowedEffects: Eto.Forms.DragEffects,
			): void;

			/**
			 * Starts drag operation using this control as drag source.
			 *
			 * This method can be blocking on some platforms (Wpf, WinForms), and non-blocking on
			 * others (Mac, Gtk). Use the {@link Eto.Forms.Control.DragEnd} event to determine when
			 * the drag operation is completed and get its resulting DragEffects.
			 */
			DoDragDrop(
				data: Eto.Forms.DataObject,
				allowedEffects: Eto.Forms.DragEffects,
				image: Eto.Drawing.Image,
				cursorOffset: Eto.Drawing.PointF,
			): void;

			/**
			 * Triggers the StyleChanged event and re-applies the styles to this control and its
			 * children.
			 */
			TriggerStyleChanged(): void;

			/** Shows a print dialog to print the specified control */
			Print(): void;

			/**
			 * Finds a control in the parent hierarchy with the specified type and
			 * {@link Eto.Widget.ID} if specified
			 */
			FindParent<T>(id?: string): T;

			/**
			 * Finds a control in the parent hierarchy with the specified type and
			 * {@link Eto.Widget.ID} if specified
			 */
			FindParent(
				type: unknown,
				id?: string,
			): Eto.Widget;

			/** Finds a control in the parent hierarchy with the specified `id` */
			FindParent(id: string): Eto.Widget;

			/**
			 * Unbinds any bindings in the {@link Eto.Forms.BindableWidget.Bindings} collection and
			 * removes the bindings
			 *
			 * When you implement {@link Eto.Forms.IBindableWidgetContainer}, this will also unbind
			 * any of its children.
			 */
			Unbind(): void;

			/**
			 * Updates all bindings in this widget
			 *
			 * When you implement {@link Eto.Forms.IBindableWidgetContainer}, this will also update
			 * bindings for all of its children.
			 */
			UpdateBindings(mode?: Eto.Forms.BindingUpdateMode): void;

			/** Disposes of this widget, supressing the finalizer */
			dispose(): void;

			/** Gets a string that represents the current object with its ID if specified. */
			ToString(): string;
		}
	}

	export namespace Eto.Forms.NativeControlHost {
		export interface ICallback extends
			Eto.Forms.Control.ICallback,
			Eto.Widget.ICallback {
			OnCreateNativeControl(
				widget: Eto.Forms.NativeControlHost,
				e: Eto.Forms.CreateNativeControlArgs,
			): void;
		}
	}

	export namespace Eto.Forms.NativeControlHost {
		export interface IHandler extends
			Eto.Forms.Control.IHandler,
			Eto.Widget.IHandler {
			Create(nativeControl: unknown): void;
		}
	}

	export namespace Eto.Forms {
		/** Event arguments with a {@link Eto.Forms.NavigationItem} reference */
		export class NavigationItemEventArgs {
			/** Initializes a new instance of the {@link Eto.Forms.NavigationItemEventArgs} class. */
			constructor(item: Eto.Forms.INavigationItem);

			/** Gets the item that triggered the event */
			Item: Eto.Forms.INavigationItem;
		}
	}

	export namespace Eto.Forms {
		/**
		 * Control to show child panels in a hirarchical stack using a navigation button to go
		 * back to a previous panel.
		 *
		 * Typically only available on mobile platforms, this allows you to show multiple panes
		 * of information in a hierarchical fashion, keeping the state of previous panes.
		 */
		export class Navigation implements
			Eto.IHandlerSource,
			Eto.Forms.IBindable,
			Eto.Forms.IMouseInputSource,
			Eto.Forms.IKeyboardInputSource {
			/** Initializes a new instance of the {@link Eto.Forms.Navigation} class. */
			constructor();

			/**
			 * Initializes a new instance of the {@link Eto.Forms.Navigation} class with the initial
			 * `content` and `title`.
			 */
			constructor(
				content: Eto.Forms.Control,
				title?: string,
			);

			/**
			 * Initializes a new instance of the {@link Eto.Forms.Navigation} class with the initial
			 * navigation item.
			 */
			constructor(item: Eto.Forms.INavigationItem);

			/** Gets an enumeration of controls that are directly contained by this container */
			readonly Controls: Iterable<Eto.Forms.Control>;

			/**
			 * Gets a value indicating that the Navigation control is supported by the current
			 * platform.
			 */
			static readonly IsSupported: boolean;

			/**
			 * Gets or sets the size for the client area of the control
			 *
			 * The client size differs from the {@link Eto.Forms.Control.Size} in that it excludes
			 * the decorations of the container, such as the title bar and border around a
			 * {@link Eto.Forms.Window}, or the title and line  around a {@link Eto.Forms.GroupBox}.
			 */
			ClientSize: Eto.Drawing.Size;

			/**
			 * Gets an enumeration of all contained child controls, including controls within child
			 * containers
			 */
			readonly Children: Iterable<Eto.Forms.Control>;

			/**
			 * Gets an enumeration of all contained child controls in the visual tree, including
			 * controls within child containers.
			 */
			readonly VisualChildren: Iterable<Eto.Forms.Control>;

			/**
			 * Gets or sets the style provider for this container.
			 *
			 * The style provider is used to style this container and its children.
			 */
			StyleProvider: Eto.IStyleProvider;

			/**
			 * Gets the default style provider for this container.
			 *
			 * Use this to apply styles to any child controls of this container. By default, styles
			 * will apply to all children, including children of children unless
			 * {@link Eto.DefaultStyleProvider.Inherit} is set to false .  Typically, you would set
			 * Inherit to false when creating composite controls that already have all their styles
			 * applied and you don't want any other styles to be inherited.
			 */
			readonly Styles: Eto.DefaultStyleProvider;

			/**
			 * Gets a value indicating that the control is loaded onto a form, that is it has been
			 * created, added to a parent, and shown
			 *
			 * The {@link Eto.Forms.Control.OnLoad(System.EventArgs)} method sets this value to true
			 * after cascading to all children (for a {@link Eto.Forms.Container} ) and calling the
			 * platform handler's implementation.  It is called after adding to a loaded form, or
			 * when showing a new form.  The {@link Eto.Forms.Control.OnUnLoad(System.EventArgs)}
			 * method will set this value to false when the control is removed from its parent
			 */
			readonly Loaded: boolean;

			/**
			 * Gets an enumeration of controls that are in the visual tree.
			 *
			 * This is used to specify which controls are contained by this instance that are part of
			 * the visual tree. This should include all controls including non-logical Eto controls
			 * used for layout.
			 */
			readonly VisualControls: Iterable<Eto.Forms.Control>;

			/**
			 * Gets or sets a user-defined object that contains data about the control
			 *
			 * A common use of the tag property is to store data that is associated with the control
			 * that you can later retrieve.
			 */
			Tag: unknown;

			/**
			 * Gets the logical parent control.
			 *
			 * When the control is part of the visual tree (
				 * {@link Eto.Forms.Control.IsVisualControl} is true), this returns the logical parent
				 * that contains this control. Otherwise this is the same as
				 * {@link Eto.Forms.Control.Parent}.
				 */
				readonly LogicalParent: Eto.Forms.Container;

			/** Gets a value indicating this {@link Eto.Forms.Control} is part of the visual tree. */
			IsVisualControl: boolean;

			/**
			 * Gets or sets the size of the control. Use -1 to specify auto sizing for either the
			 * width and/or height.
			 *
			 * Setting the size of controls is entirely optional as most controls will size
			 * themselves appropriately. When specifying a size, it will be used as the desired size
			 * of the control.  The container will reposition and resize the control depending on the
			 * available size.  For a {@link Eto.Forms.Window}, it is preferred to set the
			 * {@link Eto.Forms.Container.ClientSize} instead, as various platforms have different
			 * sizes of window decorations, toolbars, etc.
			 */
			Size: Eto.Drawing.Size;

			/**
			 * Gets a value indicating this control currently has mouse capture
			 *
			 * Mouse capture can happen during a handled MouseDown event until MouseUp, or it can be
			 * captured explicitly via {@link Eto.Forms.Control.CaptureMouse}.
			 */
			readonly IsMouseCaptured: boolean;

			/** Gets or sets the width of the control size. */
			Width: number;

			/** Gets or sets the height of the control size. */
			Height: number;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Forms.Control} (or its
			 * children) are enabled and accept user input.
			 *
			 * Typically when a control is disabled, the user cannot do anything with the control or
			 * any of its children. Including for example, selecting text in a text control. Certain
			 * controls can have a 'Read Only' mode, such as {@link Eto.Forms.TextBox.ReadOnly} which
			 * allow the user to  select text, but not change its contents.
			 */
			Enabled: boolean;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Forms.Control} is visible to
			 * the user.
			 *
			 * When the visibility of a control is set to false, it will not occupy space in the
			 * layout.
			 */
			Visible: boolean;

			/** Gets the container which this control has been added to, if any */
			readonly Parent: Eto.Forms.Container;

			/**
			 * Gets the visual container of this control, if any.
			 *
			 * Some containers may use other Eto controls to layout its children, such as the
			 * {@link Eto.Forms.StackLayout}. This will return the parent control that visually
			 * contains this control as opposed to {@link Eto.Forms.Control.Parent} which will return
			 * the logical parent.
			 */
			VisualParent: Eto.Forms.Container;

			/** Gets a value indicating this control has been attached to a native container */
			readonly IsAttached: boolean;

			/**
			 * Gets or sets the color for the background of the control
			 *
			 * Note that on some platforms (e.g. Mac), setting the background color of a control can
			 * change the performance characteristics of the control and its children, since it must
			 * enable layers to do so.
			 */
			BackgroundColor: Eto.Drawing.Color;

			/** Gets a value indicating whether this instance has the keyboard input focus. */
			readonly HasFocus: boolean;

			/** Gets a value indicating whether the layout of child controls is suspended. */
			readonly IsSuspended: boolean;

			/** Gets the window this control is contained in */
			readonly ParentWindow: Eto.Forms.Window;

			/**
			 * Gets the supported platform commands that can be used to hook up system functions to
			 * user defined logic
			 *
			 * This lists all available commands that can be mapped using the
			 * {@link Eto.Forms.Control.MapPlatformCommand(System.String,Eto.Forms.Command)} method
			 * of the control.
			 */
			readonly SupportedPlatformCommands: Iterable<string>;

			/** Gets the bounding rectangle of this control relative to its container */
			readonly Bounds: Eto.Drawing.Rectangle;

			/**
			 * Gets the location of the control as positioned by the container
			 *
			 * A control's location is set by the container. This can be used to determine where the
			 * control is for overlaying floating windows, menus, etc.
			 */
			readonly Location: Eto.Drawing.Point;

			/** Gets or sets the type of cursor to use when the mouse is hovering over the control */
			Cursor: Eto.Forms.Cursor;

			/** Gets or sets the tool tip to show when the mouse is hovered over the control */
			ToolTip: string;

			/**
			 * Gets or sets the tab index order for this control within its container.
			 *
			 * This sets the order when using the tab key to cycle through controls  Note that some
			 * platforms (Gtk and WinForms) may not support setting the context of the tab order to
			 * StackLayout  or DynamicLayout containers and may not behave exactly as expected. Use
			 * the {@link Eto.PlatformFeatures.TabIndexWithCustomContainers} flag to determine if it
			 * is supported.
			 */
			TabIndex: number;

			/** Gets or sets a value indicating whether this control can serve as drop target. */
			AllowDrop: boolean;

			/**
			 * Gets or sets the parent widget which this widget has been added to, if any
			 *
			 * When implementing child widgets that can participate in the context based binding
			 * (MVVM), You can set this to the parent widget when it is added or removed to it
			 * (usually via a collection).  Note that you should typically provide a public new
			 * [ParentWidget] Parent { get; } property  so that consumers of your API cannot set the
			 * parent to an invalid value.
			 */
			Parent: Eto.Widget;

			/**
			 * Gets an enumeration of all parent widgets in the heirarchy by traversing the
			 * {@link Eto.Forms.BindableWidget.Parent} property.
			 */
			readonly Parents: Iterable<Eto.Widget>;

			/**
			 * Gets or sets the data context for this widget for binding
			 *
			 * Subclasses may override the standard behaviour so that hierarchy of widgets can be
			 * taken into account.  For example, a Control may return the data context of a parent,
			 * if it is not set explicitly.
			 */
			DataContext: unknown;

			/** Gets the collection of bindings that are attached to this widget */
			readonly Bindings: Eto.Forms.BindingCollection;

			/**
			 * Gets a value indicating that the {@link Eto.Forms.BindableWidget.DataContext} property
			 * is changing.
			 *
			 * This can be used to determine when to allow certain logic during the update of the
			 * data context.  It is used to disable binding setters on the model when the data
			 * context changes so that a binding does not cause the view model to be updated when the
			 * state hasn't been fully set yet.
			 */
			IsDataContextChanging: boolean;

			/**
			 * Gets the platform that was used to create the {@link Eto.Widget.Handler} for this
			 * widget
			 *
			 * This gets set to the current {@link Eto.Platform.Instance} during the construction of
			 * the object
			 */
			readonly Platform: Eto.Platform;

			/** Gets the platform-specific handler for this widget */
			Handler: unknown;

			/** Gets the native platform-specific handle for integration purposes */
			readonly NativeHandle: unknown;

			/** Gets the dictionary of properties for this widget */
			readonly Properties: Eto.PropertyStore;

			/** Gets or sets the ID of this widget */
			ID: string;

			/**
			 * Gets or sets the style of this widget
			 *
			 * Styles allow you to attach custom platform-specific logic to a widget. In your
			 * platform-specific assembly, use {@link Style.Add{H}(string, StyleHandler{H})} to add
			 * the style logic with the same id.
			 */
			Style: string;

			/**
			 * Gets the instance of the platform-specific object
			 *
			 * This can sometimes be useful to get the platform-specific object. Some handlers may
			 * not have any backing object for its functionality, so this may be null.  It is more
			 * preferred to use the {@link Eto.Widget.Handler} and cast that to the platform-specific
			 * handler class which can give you additional methods and helpers to do common tasks.
			 * For example, the {@link Eto.Forms.Application} object's handler for OS X has a
			 * AddFullScreenMenuItem property to specify if you want full screen support in your app.
			 */
			readonly ControlObject: unknown;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Widget} has been disposed.
			 *
			 * When the widget is disposed, it can no longer be used.
			 */
			IsDisposed: boolean;

			/**
			 * Pushes a new pane onto the navigation stack with the specified `content` and `title`.
			 */
			Push(
				content: Eto.Forms.Control,
				title?: string,
			): void;

			/** Pushes a new navigation item onto the stack. */
			Push(item: Eto.Forms.INavigationItem): void;

			/** Pops the last item from the navigation stack. */
			Pop(): void;

			/** Removes the specified child. */
			Remove(child: Eto.Forms.Control): void;

			/** Remove the specified `controls` from this container */
			Remove(controls: Iterable<Eto.Forms.Control>): void;

			/** Removes all controls from this container */
			RemoveAll(): void;

			/**
			 * Finds a child control in this container or any of its child containers with the
			 * specified `id`
			 */
			FindChild<T>(id?: string): T;

			/**
			 * Finds a child control in this container or any of its child containers with the
			 * specified `type`
			 */
			FindChild(
				type: unknown,
				id?: string,
			): Eto.Forms.Control;

			/**
			 * Finds a child control in this container or any of its child containers with the
			 * specified `id`.
			 */
			FindChild(id: string): Eto.Forms.Control;

			/**
			 * Queues a repaint of the entire control on the screen and any of its children.
			 *
			 * This is only useful when the control is visible.
			 */
			Invalidate(): void;

			/**
			 * Queues a repaint of the entire control on the screen
			 *
			 * This is only useful when the control is visible.
			 */
			Invalidate(invalidateChildren: boolean): void;

			/**
			 * Queues a repaint of the specified `rect` of the control and any children.
			 *
			 * This is only useful when the control is visible.
			 */
			Invalidate(rect: Eto.Drawing.Rectangle): void;

			/**
			 * Queues a repaint of the specified `rect` of the control
			 *
			 * This is only useful when the control is visible.
			 */
			Invalidate(
				rect: Eto.Drawing.Rectangle,
				invalidateChildren: boolean,
			): void;

			/**
			 * Updates the layout of this control if necessary.
			 *
			 * This will ensure the control has had all of its layout applied so you can use its
			 * position and size right after this call. Most platforms (except WinForms) use a
			 * deferred layout system so that after adding your control to the form dynamically it
			 * won't get laid out until the next idle loop. This is useful when you need to know the
			 * dimensions of the control immediately. Note that this can be an expensive operation,
			 * so it is recommended to only call this method when necessary and after all of the
			 * controls have been added/updated.
			 */
			UpdateLayout(): void;

			/** Gets the preferred size of this control given infinite space available. */
			GetPreferredSize(): Eto.Drawing.SizeF;

			/** Gets the preferred size of this control given the specified `availableSize`. */
			GetPreferredSize(availableSize: Eto.Drawing.SizeF): Eto.Drawing.SizeF;

			/**
			 * Captures all mouse events to this control.
			 *
			 * This captures all mouse events until {@link Eto.Forms.Control.ReleaseMouseCapture} is
			 * called.  Note that not all platforms will allow a mouse capture unless the mouse is
			 * currently down.
			 */
			CaptureMouse(): boolean;

			/** Releases the mouse capture after a call to {@link Eto.Forms.Control.CaptureMouse}. */
			ReleaseMouseCapture(): void;

			/**
			 * Finds a control in the parent hierarchy with the specified type and
			 * {@link Eto.Widget.ID} if specified
			 */
			FindParent(
				type: unknown,
				id?: string,
			): Eto.Forms.Container;

			/** Finds a control in the parent hierarchy with the specified `id` */
			FindParent(id: string): Eto.Forms.Container;

			/**
			 * Detaches the control by removing it from its parent
			 *
			 * This is essentially a shortcut to myControl.Parent.Remove(myControl);
			 */
			Detach(): void;

			/**
			 * Attaches the control for direct use in a native application
			 *
			 * Use this to use a control directly in a native application.  Note that the native
			 * application must be running the same framework as the current platform.  E.g. a
			 * WinForms application can use an Eto.Forms control when using the Eto.WinForms
			 * platform.  This prepares the control by firing the {@link Eto.Forms.Control.PreLoad},
			 * {@link Eto.Forms.Control.Load}, etc. events.
			 */
			AttachNative(): void;

			/**
			 * Detaches the control when it is used in a native application, when you want to reuse
			 * the control.
			 *
			 * This should only be called after {@link Eto.Forms.Control.AttachNative} has been
			 * called, which is usually done by calling to ToNative(true) .
			 */
			DetachNative(): void;

			/**
			 * Attempts to set the keyboard input focus to this control, or the first child that
			 * accepts focus. For Windows, this will bring it to front and activate it.
			 */
			Focus(): void;

			/**
			 * Suspends the layout of child controls
			 *
			 * This can be used to optimize some platforms while adding, removing, or changing many
			 * child controls at once. It disables the calculation of control positioning until
			 * {@link Eto.Forms.Control.ResumeLayout} is called. Each call to SuspendLayout() must be
			 * balanced with a call to {@link Eto.Forms.Control.ResumeLayout}.
			 */
			SuspendLayout(): void;

			/**
			 * Resumes the layout after it has been suspended, and performs a layout
			 *
			 * This can be used to optimize some platforms while adding, removing, or changing many
			 * child controls at once. Each call to ResumeLayout() must be balanced with a call to
			 * {@link Eto.Forms.Control.SuspendLayout} before it.
			 */
			ResumeLayout(): void;

			/**
			 * Specifies a command to execute for a platform-specific command
			 *
			 * Some platforms have specific system-defined commands that can be associated with a
			 * control. For example, the Mac platform's cut/copy/paste functionality is defined by
			 * the system, and if you want to hook into it, you can use this to map it to your own
			 * defined logic. The valid values of the `systemCommand` parameter are defined by each
			 * platform, and a list can be retrieved using
			 * {@link Eto.Forms.Control.SupportedPlatformCommands}
			 */
			MapPlatformCommand(
				systemCommand: string,
				command: Eto.Forms.Command,
			): void;

			/** Converts a point from screen space to control space. */
			PointFromScreen(point: Eto.Drawing.PointF): Eto.Drawing.PointF;

			/** Converts a point from control space to screen space */
			PointToScreen(point: Eto.Drawing.PointF): Eto.Drawing.PointF;

			/** Converts a rectangle from screen space to control space. */
			RectangleToScreen(rect: Eto.Drawing.RectangleF): Eto.Drawing.RectangleF;

			/** Converts a rectangle from control space to screen space */
			RectangleFromScreen(rect: Eto.Drawing.RectangleF): Eto.Drawing.RectangleF;

			/**
			 * Starts drag operation using this control as drag source.
			 *
			 * This method can be blocking on some platforms (Wpf, WinForms), and non-blocking on
			 * others (Mac, Gtk). Use the {@link Eto.Forms.Control.DragEnd} event to determine when
			 * the drag operation is completed and get its resulting DragEffects.
			 */
			DoDragDrop(
				data: Eto.Forms.DataObject,
				allowedEffects: Eto.Forms.DragEffects,
			): void;

			/**
			 * Starts drag operation using this control as drag source.
			 *
			 * This method can be blocking on some platforms (Wpf, WinForms), and non-blocking on
			 * others (Mac, Gtk). Use the {@link Eto.Forms.Control.DragEnd} event to determine when
			 * the drag operation is completed and get its resulting DragEffects.
			 */
			DoDragDrop(
				data: Eto.Forms.DataObject,
				allowedEffects: Eto.Forms.DragEffects,
				image: Eto.Drawing.Image,
				cursorOffset: Eto.Drawing.PointF,
			): void;

			/**
			 * Triggers the StyleChanged event and re-applies the styles to this control and its
			 * children.
			 */
			TriggerStyleChanged(): void;

			/** Shows a print dialog to print the specified control */
			Print(): void;

			/**
			 * Finds a control in the parent hierarchy with the specified type and
			 * {@link Eto.Widget.ID} if specified
			 */
			FindParent<T>(id?: string): T;

			/**
			 * Finds a control in the parent hierarchy with the specified type and
			 * {@link Eto.Widget.ID} if specified
			 */
			FindParent(
				type: unknown,
				id?: string,
			): Eto.Widget;

			/** Finds a control in the parent hierarchy with the specified `id` */
			FindParent(id: string): Eto.Widget;

			/**
			 * Unbinds any bindings in the {@link Eto.Forms.BindableWidget.Bindings} collection and
			 * removes the bindings
			 *
			 * When you implement {@link Eto.Forms.IBindableWidgetContainer}, this will also unbind
			 * any of its children.
			 */
			Unbind(): void;

			/**
			 * Updates all bindings in this widget
			 *
			 * When you implement {@link Eto.Forms.IBindableWidgetContainer}, this will also update
			 * bindings for all of its children.
			 */
			UpdateBindings(mode?: Eto.Forms.BindingUpdateMode): void;

			/** Disposes of this widget, supressing the finalizer */
			dispose(): void;

			/** Gets a string that represents the current object with its ID if specified. */
			ToString(): string;
		}
	}

	export namespace Eto.Forms.Navigation {
		export interface ICallback extends
			Eto.Forms.Control.ICallback,
			Eto.Widget.ICallback {
			OnItemShown(
				widget: Eto.Forms.Navigation,
				e: Eto.Forms.NavigationItemEventArgs,
			): void;

			OnItemRemoved(
				widget: Eto.Forms.Navigation,
				e: Eto.Forms.NavigationItemEventArgs,
			): void;
		}
	}

	export namespace Eto.Forms.Navigation {
		export interface IHandler extends
			Eto.Forms.Container.IHandler,
			Eto.Forms.Control.IHandler,
			Eto.Widget.IHandler {
			Push(item: Eto.Forms.INavigationItem): void;

			Pop(): void;
		}
	}

	export namespace Eto.Forms {
		/** Item for panes on a {@link Eto.Forms.Navigation} control. */
		export interface INavigationItem extends Eto.Forms.IListItem {
			/** Gets the content for the pane. */
			readonly Content: Eto.Forms.Control;
		}
	}

	export namespace Eto.Forms {
		/**
		 * Item for a pane on a {@link Eto.Forms.Navigation} control.
		 *
		 * This defines an item on a {@link Eto.Forms.Navigation} control that contains the
		 * item's content and title.
		 */
		export class NavigationItem implements
			Eto.Forms.IListItem,
			Eto.Forms.INavigationItem {
			constructor();

			/** Gets the content for the pane. */
			Content: Eto.Forms.Control;

			/** Gets or sets the text of the item. */
			Text: string;

			/**
			 * Gets or sets the unique key of the item.
			 *
			 * The key is typically used to identify each item uniquely.  If no key is specified, the
			 * {@link Eto.Forms.ListItem.Text} is used as the key.
			 */
			Key: string;

			/** Gets or sets custom data for the item. */
			Tag: unknown;

			/** Gets the listItem's string */
			ToString(): string;
		}
	}

	export namespace Eto.Forms {
		/**
		 * Control for the user to enter a numeric value (obsolete, use NumericStepper instead)
		 *
		 * This usually presents with a {@link Eto.Forms.Stepper} to increase/decrease the value,
		 * or a specific numeric keyboard.
		 */
		export class NumericUpDown implements
			Eto.IHandlerSource,
			Eto.Forms.IBindable,
			Eto.Forms.IMouseInputSource,
			Eto.Forms.IKeyboardInputSource {
			constructor();

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Forms.NumericStepper} is read
			 * only.
			 *
			 * A read only control can copy the value and focus the control, but cannot edit or
			 * change the value.
			 */
			ReadOnly: boolean;

			/**
			 * Gets or sets the value.
			 *
			 * The value will be limited to a value between the
			 * {@link Eto.Forms.NumericStepper.MinValue} and
			 * {@link Eto.Forms.NumericStepper.MaxValue}.
			 */
			Value: number;

			/**
			 * Gets or sets the minimum value that can be entered.
			 *
			 * Changing this will limit the current {@link Eto.Forms.NumericStepper.Value} of the
			 * control.
			 */
			MinValue: number;

			/**
			 * Gets or sets the maximum value that can be entered.
			 *
			 * Changing this will limit the current {@link Eto.Forms.NumericStepper.Value} of the
			 * control.
			 */
			MaxValue: number;

			/**
			 * Gets or sets the color of the text.
			 *
			 * By default, the text will get a color based on the user's theme. However, this is
			 * usually black.
			 */
			TextColor: Eto.Drawing.Color;

			/**
			 * Gets or sets the number of digits to display after the decimal.
			 *
			 * The NumericStepper control will at least show the number of fraction digits as
			 * specified by this value, padded by zeros.  The
			 * {@link Eto.Forms.NumericStepper.MaximumDecimalPlaces} specifies the maximum number of
			 * fraction digits the control will display if the value has a value that can be
			 * represented by more digits. The {@link Eto.Forms.NumericStepper.Value} property is
			 * rounded to the number of fraction digits specified by
			 * {@link Eto.Forms.NumericStepper.MaximumDecimalPlaces}.  Note that this does not apply
			 * if you have specified {@link Eto.Forms.NumericStepper.FormatString}
			 */
			DecimalPlaces: number;

			/** Gets or sets the value to increment when the user clicks on the stepper buttons. */
			Increment: number;

			/**
			 * Gets or sets the maximum number of decimal places that can be shown.
			 *
			 * Specifies how many fraction digits can be shown if required to display the specified
			 * {@link Eto.Forms.NumericStepper.Value}. The number of digits shown will be at least
			 * the number of digits specified by {@link Eto.Forms.NumericStepper.DecimalPlaces}. The
			 * {@link Eto.Forms.NumericStepper.Value} and the display is rounded to the number of
			 * fraction digits specified by this value.
			 * {@link Eto.Forms.NumericStepper.DecimalPlaces} for an example of how the
			 * MaximumDecimalPlaces can be used.  Note that this does not apply if you have specified
			 * {@link Eto.Forms.NumericStepper.FormatString}.
			 */
			MaximumDecimalPlaces: number;

			/**
			 * Gets or sets the format string for the display of the numeric value.
			 *
			 * This can be used to specify standard or custom format strings used via
			 * {@link System.Double.ToString(System.String,System.IFormatProvider)}. The exact output
			 * is determined using the specified {@link Eto.Forms.NumericStepper.CultureInfo}.  For
			 * example "c" would show a currency value.  Any extra non-numeric or separator
			 * characters are stripped when parsing the string so that you can include extra
			 * (non-numeric)  string values while still allowing the user to change the numeric
			 * string.
			 */
			FormatString: string;

			/**
			 * Specifies the culture to show the numeric value in (default is
			 * {@link System.Globalization.CultureInfo.CurrentCulture} ).
			 *
			 * This is used to format the numeric value, and when using the
			 * {@link Eto.Forms.NumericStepper.FormatString} it determines the character(s) used for
			 * the thousands separator, decimal separator, and currency symbol.
			 */
			CultureInfo: unknown;

			/**
			 * A value indicating whether to wrap the value after the user steps past the min or max
			 * value
			 */
			Wrap: boolean;

			/** Gets the binding for the {@link Eto.Forms.NumericStepper.Value} property. */
			readonly ValueBinding: Eto.Forms.BindableBinding$2<Eto.Forms.NumericStepper, number>;

			/** Gets or sets the font for the text of the control */
			Font: Eto.Drawing.Font;

			/**
			 * Gets a value indicating that the control is loaded onto a form, that is it has been
			 * created, added to a parent, and shown
			 *
			 * The {@link Eto.Forms.Control.OnLoad(System.EventArgs)} method sets this value to true
			 * after cascading to all children (for a {@link Eto.Forms.Container} ) and calling the
			 * platform handler's implementation.  It is called after adding to a loaded form, or
			 * when showing a new form.  The {@link Eto.Forms.Control.OnUnLoad(System.EventArgs)}
			 * method will set this value to false when the control is removed from its parent
			 */
			readonly Loaded: boolean;

			/**
			 * Gets an enumeration of controls that are in the visual tree.
			 *
			 * This is used to specify which controls are contained by this instance that are part of
			 * the visual tree. This should include all controls including non-logical Eto controls
			 * used for layout.
			 */
			readonly VisualControls: Iterable<Eto.Forms.Control>;

			/**
			 * Gets or sets a user-defined object that contains data about the control
			 *
			 * A common use of the tag property is to store data that is associated with the control
			 * that you can later retrieve.
			 */
			Tag: unknown;

			/**
			 * Gets the logical parent control.
			 *
			 * When the control is part of the visual tree (
				 * {@link Eto.Forms.Control.IsVisualControl} is true), this returns the logical parent
				 * that contains this control. Otherwise this is the same as
				 * {@link Eto.Forms.Control.Parent}.
				 */
				readonly LogicalParent: Eto.Forms.Container;

			/** Gets a value indicating this {@link Eto.Forms.Control} is part of the visual tree. */
			IsVisualControl: boolean;

			/**
			 * Gets or sets the size of the control. Use -1 to specify auto sizing for either the
			 * width and/or height.
			 *
			 * Setting the size of controls is entirely optional as most controls will size
			 * themselves appropriately. When specifying a size, it will be used as the desired size
			 * of the control.  The container will reposition and resize the control depending on the
			 * available size.  For a {@link Eto.Forms.Window}, it is preferred to set the
			 * {@link Eto.Forms.Container.ClientSize} instead, as various platforms have different
			 * sizes of window decorations, toolbars, etc.
			 */
			Size: Eto.Drawing.Size;

			/**
			 * Gets a value indicating this control currently has mouse capture
			 *
			 * Mouse capture can happen during a handled MouseDown event until MouseUp, or it can be
			 * captured explicitly via {@link Eto.Forms.Control.CaptureMouse}.
			 */
			readonly IsMouseCaptured: boolean;

			/** Gets or sets the width of the control size. */
			Width: number;

			/** Gets or sets the height of the control size. */
			Height: number;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Forms.Control} (or its
			 * children) are enabled and accept user input.
			 *
			 * Typically when a control is disabled, the user cannot do anything with the control or
			 * any of its children. Including for example, selecting text in a text control. Certain
			 * controls can have a 'Read Only' mode, such as {@link Eto.Forms.TextBox.ReadOnly} which
			 * allow the user to  select text, but not change its contents.
			 */
			Enabled: boolean;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Forms.Control} is visible to
			 * the user.
			 *
			 * When the visibility of a control is set to false, it will not occupy space in the
			 * layout.
			 */
			Visible: boolean;

			/** Gets the container which this control has been added to, if any */
			readonly Parent: Eto.Forms.Container;

			/**
			 * Gets the visual container of this control, if any.
			 *
			 * Some containers may use other Eto controls to layout its children, such as the
			 * {@link Eto.Forms.StackLayout}. This will return the parent control that visually
			 * contains this control as opposed to {@link Eto.Forms.Control.Parent} which will return
			 * the logical parent.
			 */
			VisualParent: Eto.Forms.Container;

			/** Gets a value indicating this control has been attached to a native container */
			readonly IsAttached: boolean;

			/**
			 * Gets or sets the color for the background of the control
			 *
			 * Note that on some platforms (e.g. Mac), setting the background color of a control can
			 * change the performance characteristics of the control and its children, since it must
			 * enable layers to do so.
			 */
			BackgroundColor: Eto.Drawing.Color;

			/** Gets a value indicating whether this instance has the keyboard input focus. */
			readonly HasFocus: boolean;

			/** Gets a value indicating whether the layout of child controls is suspended. */
			readonly IsSuspended: boolean;

			/** Gets the window this control is contained in */
			readonly ParentWindow: Eto.Forms.Window;

			/**
			 * Gets the supported platform commands that can be used to hook up system functions to
			 * user defined logic
			 *
			 * This lists all available commands that can be mapped using the
			 * {@link Eto.Forms.Control.MapPlatformCommand(System.String,Eto.Forms.Command)} method
			 * of the control.
			 */
			readonly SupportedPlatformCommands: Iterable<string>;

			/** Gets the bounding rectangle of this control relative to its container */
			readonly Bounds: Eto.Drawing.Rectangle;

			/**
			 * Gets the location of the control as positioned by the container
			 *
			 * A control's location is set by the container. This can be used to determine where the
			 * control is for overlaying floating windows, menus, etc.
			 */
			readonly Location: Eto.Drawing.Point;

			/** Gets or sets the type of cursor to use when the mouse is hovering over the control */
			Cursor: Eto.Forms.Cursor;

			/** Gets or sets the tool tip to show when the mouse is hovered over the control */
			ToolTip: string;

			/**
			 * Gets or sets the tab index order for this control within its container.
			 *
			 * This sets the order when using the tab key to cycle through controls  Note that some
			 * platforms (Gtk and WinForms) may not support setting the context of the tab order to
			 * StackLayout  or DynamicLayout containers and may not behave exactly as expected. Use
			 * the {@link Eto.PlatformFeatures.TabIndexWithCustomContainers} flag to determine if it
			 * is supported.
			 */
			TabIndex: number;

			/** Gets or sets a value indicating whether this control can serve as drop target. */
			AllowDrop: boolean;

			/**
			 * Gets or sets the parent widget which this widget has been added to, if any
			 *
			 * When implementing child widgets that can participate in the context based binding
			 * (MVVM), You can set this to the parent widget when it is added or removed to it
			 * (usually via a collection).  Note that you should typically provide a public new
			 * [ParentWidget] Parent { get; } property  so that consumers of your API cannot set the
			 * parent to an invalid value.
			 */
			Parent: Eto.Widget;

			/**
			 * Gets an enumeration of all parent widgets in the heirarchy by traversing the
			 * {@link Eto.Forms.BindableWidget.Parent} property.
			 */
			readonly Parents: Iterable<Eto.Widget>;

			/**
			 * Gets or sets the data context for this widget for binding
			 *
			 * Subclasses may override the standard behaviour so that hierarchy of widgets can be
			 * taken into account.  For example, a Control may return the data context of a parent,
			 * if it is not set explicitly.
			 */
			DataContext: unknown;

			/** Gets the collection of bindings that are attached to this widget */
			readonly Bindings: Eto.Forms.BindingCollection;

			/**
			 * Gets a value indicating that the {@link Eto.Forms.BindableWidget.DataContext} property
			 * is changing.
			 *
			 * This can be used to determine when to allow certain logic during the update of the
			 * data context.  It is used to disable binding setters on the model when the data
			 * context changes so that a binding does not cause the view model to be updated when the
			 * state hasn't been fully set yet.
			 */
			IsDataContextChanging: boolean;

			/**
			 * Gets the platform that was used to create the {@link Eto.Widget.Handler} for this
			 * widget
			 *
			 * This gets set to the current {@link Eto.Platform.Instance} during the construction of
			 * the object
			 */
			readonly Platform: Eto.Platform;

			/** Gets the platform-specific handler for this widget */
			Handler: unknown;

			/** Gets the native platform-specific handle for integration purposes */
			readonly NativeHandle: unknown;

			/** Gets the dictionary of properties for this widget */
			readonly Properties: Eto.PropertyStore;

			/** Gets or sets the ID of this widget */
			ID: string;

			/**
			 * Gets or sets the style of this widget
			 *
			 * Styles allow you to attach custom platform-specific logic to a widget. In your
			 * platform-specific assembly, use {@link Style.Add{H}(string, StyleHandler{H})} to add
			 * the style logic with the same id.
			 */
			Style: string;

			/**
			 * Gets the instance of the platform-specific object
			 *
			 * This can sometimes be useful to get the platform-specific object. Some handlers may
			 * not have any backing object for its functionality, so this may be null.  It is more
			 * preferred to use the {@link Eto.Widget.Handler} and cast that to the platform-specific
			 * handler class which can give you additional methods and helpers to do common tasks.
			 * For example, the {@link Eto.Forms.Application} object's handler for OS X has a
			 * AddFullScreenMenuItem property to specify if you want full screen support in your app.
			 */
			readonly ControlObject: unknown;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Widget} has been disposed.
			 *
			 * When the widget is disposed, it can no longer be used.
			 */
			IsDisposed: boolean;

			/**
			 * Queues a repaint of the entire control on the screen and any of its children.
			 *
			 * This is only useful when the control is visible.
			 */
			Invalidate(): void;

			/**
			 * Queues a repaint of the entire control on the screen
			 *
			 * This is only useful when the control is visible.
			 */
			Invalidate(invalidateChildren: boolean): void;

			/**
			 * Queues a repaint of the specified `rect` of the control and any children.
			 *
			 * This is only useful when the control is visible.
			 */
			Invalidate(rect: Eto.Drawing.Rectangle): void;

			/**
			 * Queues a repaint of the specified `rect` of the control
			 *
			 * This is only useful when the control is visible.
			 */
			Invalidate(
				rect: Eto.Drawing.Rectangle,
				invalidateChildren: boolean,
			): void;

			/**
			 * Updates the layout of this control if necessary.
			 *
			 * This will ensure the control has had all of its layout applied so you can use its
			 * position and size right after this call. Most platforms (except WinForms) use a
			 * deferred layout system so that after adding your control to the form dynamically it
			 * won't get laid out until the next idle loop. This is useful when you need to know the
			 * dimensions of the control immediately. Note that this can be an expensive operation,
			 * so it is recommended to only call this method when necessary and after all of the
			 * controls have been added/updated.
			 */
			UpdateLayout(): void;

			/** Gets the preferred size of this control given infinite space available. */
			GetPreferredSize(): Eto.Drawing.SizeF;

			/** Gets the preferred size of this control given the specified `availableSize`. */
			GetPreferredSize(availableSize: Eto.Drawing.SizeF): Eto.Drawing.SizeF;

			/**
			 * Captures all mouse events to this control.
			 *
			 * This captures all mouse events until {@link Eto.Forms.Control.ReleaseMouseCapture} is
			 * called.  Note that not all platforms will allow a mouse capture unless the mouse is
			 * currently down.
			 */
			CaptureMouse(): boolean;

			/** Releases the mouse capture after a call to {@link Eto.Forms.Control.CaptureMouse}. */
			ReleaseMouseCapture(): void;

			/**
			 * Finds a control in the parent hierarchy with the specified type and
			 * {@link Eto.Widget.ID} if specified
			 */
			FindParent(
				type: unknown,
				id?: string,
			): Eto.Forms.Container;

			/** Finds a control in the parent hierarchy with the specified `id` */
			FindParent(id: string): Eto.Forms.Container;

			/**
			 * Detaches the control by removing it from its parent
			 *
			 * This is essentially a shortcut to myControl.Parent.Remove(myControl);
			 */
			Detach(): void;

			/**
			 * Attaches the control for direct use in a native application
			 *
			 * Use this to use a control directly in a native application.  Note that the native
			 * application must be running the same framework as the current platform.  E.g. a
			 * WinForms application can use an Eto.Forms control when using the Eto.WinForms
			 * platform.  This prepares the control by firing the {@link Eto.Forms.Control.PreLoad},
			 * {@link Eto.Forms.Control.Load}, etc. events.
			 */
			AttachNative(): void;

			/**
			 * Detaches the control when it is used in a native application, when you want to reuse
			 * the control.
			 *
			 * This should only be called after {@link Eto.Forms.Control.AttachNative} has been
			 * called, which is usually done by calling to ToNative(true) .
			 */
			DetachNative(): void;

			/**
			 * Attempts to set the keyboard input focus to this control, or the first child that
			 * accepts focus. For Windows, this will bring it to front and activate it.
			 */
			Focus(): void;

			/**
			 * Suspends the layout of child controls
			 *
			 * This can be used to optimize some platforms while adding, removing, or changing many
			 * child controls at once. It disables the calculation of control positioning until
			 * {@link Eto.Forms.Control.ResumeLayout} is called. Each call to SuspendLayout() must be
			 * balanced with a call to {@link Eto.Forms.Control.ResumeLayout}.
			 */
			SuspendLayout(): void;

			/**
			 * Resumes the layout after it has been suspended, and performs a layout
			 *
			 * This can be used to optimize some platforms while adding, removing, or changing many
			 * child controls at once. Each call to ResumeLayout() must be balanced with a call to
			 * {@link Eto.Forms.Control.SuspendLayout} before it.
			 */
			ResumeLayout(): void;

			/**
			 * Specifies a command to execute for a platform-specific command
			 *
			 * Some platforms have specific system-defined commands that can be associated with a
			 * control. For example, the Mac platform's cut/copy/paste functionality is defined by
			 * the system, and if you want to hook into it, you can use this to map it to your own
			 * defined logic. The valid values of the `systemCommand` parameter are defined by each
			 * platform, and a list can be retrieved using
			 * {@link Eto.Forms.Control.SupportedPlatformCommands}
			 */
			MapPlatformCommand(
				systemCommand: string,
				command: Eto.Forms.Command,
			): void;

			/** Converts a point from screen space to control space. */
			PointFromScreen(point: Eto.Drawing.PointF): Eto.Drawing.PointF;

			/** Converts a point from control space to screen space */
			PointToScreen(point: Eto.Drawing.PointF): Eto.Drawing.PointF;

			/** Converts a rectangle from screen space to control space. */
			RectangleToScreen(rect: Eto.Drawing.RectangleF): Eto.Drawing.RectangleF;

			/** Converts a rectangle from control space to screen space */
			RectangleFromScreen(rect: Eto.Drawing.RectangleF): Eto.Drawing.RectangleF;

			/**
			 * Starts drag operation using this control as drag source.
			 *
			 * This method can be blocking on some platforms (Wpf, WinForms), and non-blocking on
			 * others (Mac, Gtk). Use the {@link Eto.Forms.Control.DragEnd} event to determine when
			 * the drag operation is completed and get its resulting DragEffects.
			 */
			DoDragDrop(
				data: Eto.Forms.DataObject,
				allowedEffects: Eto.Forms.DragEffects,
			): void;

			/**
			 * Starts drag operation using this control as drag source.
			 *
			 * This method can be blocking on some platforms (Wpf, WinForms), and non-blocking on
			 * others (Mac, Gtk). Use the {@link Eto.Forms.Control.DragEnd} event to determine when
			 * the drag operation is completed and get its resulting DragEffects.
			 */
			DoDragDrop(
				data: Eto.Forms.DataObject,
				allowedEffects: Eto.Forms.DragEffects,
				image: Eto.Drawing.Image,
				cursorOffset: Eto.Drawing.PointF,
			): void;

			/**
			 * Triggers the StyleChanged event and re-applies the styles to this control and its
			 * children.
			 */
			TriggerStyleChanged(): void;

			/** Shows a print dialog to print the specified control */
			Print(): void;

			/**
			 * Finds a control in the parent hierarchy with the specified type and
			 * {@link Eto.Widget.ID} if specified
			 */
			FindParent<T>(id?: string): T;

			/**
			 * Finds a control in the parent hierarchy with the specified type and
			 * {@link Eto.Widget.ID} if specified
			 */
			FindParent(
				type: unknown,
				id?: string,
			): Eto.Widget;

			/** Finds a control in the parent hierarchy with the specified `id` */
			FindParent(id: string): Eto.Widget;

			/**
			 * Unbinds any bindings in the {@link Eto.Forms.BindableWidget.Bindings} collection and
			 * removes the bindings
			 *
			 * When you implement {@link Eto.Forms.IBindableWidgetContainer}, this will also unbind
			 * any of its children.
			 */
			Unbind(): void;

			/**
			 * Updates all bindings in this widget
			 *
			 * When you implement {@link Eto.Forms.IBindableWidgetContainer}, this will also update
			 * bindings for all of its children.
			 */
			UpdateBindings(mode?: Eto.Forms.BindingUpdateMode): void;

			/** Disposes of this widget, supressing the finalizer */
			dispose(): void;

			/** Gets a string that represents the current object with its ID if specified. */
			ToString(): string;
		}
	}

	export namespace Eto.Forms {
		/**
		 * Control for the user to enter a numeric value
		 *
		 * This usually presents with a {@link Eto.Forms.Stepper} to increase/decrease the value,
		 * or a specific numeric keyboard.
		 */
		export class NumericStepper implements
			Eto.IHandlerSource,
			Eto.Forms.IBindable,
			Eto.Forms.IMouseInputSource,
			Eto.Forms.IKeyboardInputSource {
			constructor();

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Forms.NumericStepper} is read
			 * only.
			 *
			 * A read only control can copy the value and focus the control, but cannot edit or
			 * change the value.
			 */
			ReadOnly: boolean;

			/**
			 * Gets or sets the value.
			 *
			 * The value will be limited to a value between the
			 * {@link Eto.Forms.NumericStepper.MinValue} and
			 * {@link Eto.Forms.NumericStepper.MaxValue}.
			 */
			Value: number;

			/**
			 * Gets or sets the minimum value that can be entered.
			 *
			 * Changing this will limit the current {@link Eto.Forms.NumericStepper.Value} of the
			 * control.
			 */
			MinValue: number;

			/**
			 * Gets or sets the maximum value that can be entered.
			 *
			 * Changing this will limit the current {@link Eto.Forms.NumericStepper.Value} of the
			 * control.
			 */
			MaxValue: number;

			/**
			 * Gets or sets the color of the text.
			 *
			 * By default, the text will get a color based on the user's theme. However, this is
			 * usually black.
			 */
			TextColor: Eto.Drawing.Color;

			/**
			 * Gets or sets the number of digits to display after the decimal.
			 *
			 * The NumericStepper control will at least show the number of fraction digits as
			 * specified by this value, padded by zeros.  The
			 * {@link Eto.Forms.NumericStepper.MaximumDecimalPlaces} specifies the maximum number of
			 * fraction digits the control will display if the value has a value that can be
			 * represented by more digits. The {@link Eto.Forms.NumericStepper.Value} property is
			 * rounded to the number of fraction digits specified by
			 * {@link Eto.Forms.NumericStepper.MaximumDecimalPlaces}.  Note that this does not apply
			 * if you have specified {@link Eto.Forms.NumericStepper.FormatString}
			 */
			DecimalPlaces: number;

			/** Gets or sets the value to increment when the user clicks on the stepper buttons. */
			Increment: number;

			/**
			 * Gets or sets the maximum number of decimal places that can be shown.
			 *
			 * Specifies how many fraction digits can be shown if required to display the specified
			 * {@link Eto.Forms.NumericStepper.Value}. The number of digits shown will be at least
			 * the number of digits specified by {@link Eto.Forms.NumericStepper.DecimalPlaces}. The
			 * {@link Eto.Forms.NumericStepper.Value} and the display is rounded to the number of
			 * fraction digits specified by this value.
			 * {@link Eto.Forms.NumericStepper.DecimalPlaces} for an example of how the
			 * MaximumDecimalPlaces can be used.  Note that this does not apply if you have specified
			 * {@link Eto.Forms.NumericStepper.FormatString}.
			 */
			MaximumDecimalPlaces: number;

			/**
			 * Gets or sets the format string for the display of the numeric value.
			 *
			 * This can be used to specify standard or custom format strings used via
			 * {@link System.Double.ToString(System.String,System.IFormatProvider)}. The exact output
			 * is determined using the specified {@link Eto.Forms.NumericStepper.CultureInfo}.  For
			 * example "c" would show a currency value.  Any extra non-numeric or separator
			 * characters are stripped when parsing the string so that you can include extra
			 * (non-numeric)  string values while still allowing the user to change the numeric
			 * string.
			 */
			FormatString: string;

			/**
			 * Specifies the culture to show the numeric value in (default is
			 * {@link System.Globalization.CultureInfo.CurrentCulture} ).
			 *
			 * This is used to format the numeric value, and when using the
			 * {@link Eto.Forms.NumericStepper.FormatString} it determines the character(s) used for
			 * the thousands separator, decimal separator, and currency symbol.
			 */
			CultureInfo: unknown;

			/**
			 * A value indicating whether to wrap the value after the user steps past the min or max
			 * value
			 */
			Wrap: boolean;

			/** Gets the binding for the {@link Eto.Forms.NumericStepper.Value} property. */
			readonly ValueBinding: Eto.Forms.BindableBinding$2<Eto.Forms.NumericStepper, number>;

			/** Gets or sets the font for the text of the control */
			Font: Eto.Drawing.Font;

			/**
			 * Gets a value indicating that the control is loaded onto a form, that is it has been
			 * created, added to a parent, and shown
			 *
			 * The {@link Eto.Forms.Control.OnLoad(System.EventArgs)} method sets this value to true
			 * after cascading to all children (for a {@link Eto.Forms.Container} ) and calling the
			 * platform handler's implementation.  It is called after adding to a loaded form, or
			 * when showing a new form.  The {@link Eto.Forms.Control.OnUnLoad(System.EventArgs)}
			 * method will set this value to false when the control is removed from its parent
			 */
			readonly Loaded: boolean;

			/**
			 * Gets an enumeration of controls that are in the visual tree.
			 *
			 * This is used to specify which controls are contained by this instance that are part of
			 * the visual tree. This should include all controls including non-logical Eto controls
			 * used for layout.
			 */
			readonly VisualControls: Iterable<Eto.Forms.Control>;

			/**
			 * Gets or sets a user-defined object that contains data about the control
			 *
			 * A common use of the tag property is to store data that is associated with the control
			 * that you can later retrieve.
			 */
			Tag: unknown;

			/**
			 * Gets the logical parent control.
			 *
			 * When the control is part of the visual tree (
				 * {@link Eto.Forms.Control.IsVisualControl} is true), this returns the logical parent
				 * that contains this control. Otherwise this is the same as
				 * {@link Eto.Forms.Control.Parent}.
				 */
				readonly LogicalParent: Eto.Forms.Container;

			/** Gets a value indicating this {@link Eto.Forms.Control} is part of the visual tree. */
			IsVisualControl: boolean;

			/**
			 * Gets or sets the size of the control. Use -1 to specify auto sizing for either the
			 * width and/or height.
			 *
			 * Setting the size of controls is entirely optional as most controls will size
			 * themselves appropriately. When specifying a size, it will be used as the desired size
			 * of the control.  The container will reposition and resize the control depending on the
			 * available size.  For a {@link Eto.Forms.Window}, it is preferred to set the
			 * {@link Eto.Forms.Container.ClientSize} instead, as various platforms have different
			 * sizes of window decorations, toolbars, etc.
			 */
			Size: Eto.Drawing.Size;

			/**
			 * Gets a value indicating this control currently has mouse capture
			 *
			 * Mouse capture can happen during a handled MouseDown event until MouseUp, or it can be
			 * captured explicitly via {@link Eto.Forms.Control.CaptureMouse}.
			 */
			readonly IsMouseCaptured: boolean;

			/** Gets or sets the width of the control size. */
			Width: number;

			/** Gets or sets the height of the control size. */
			Height: number;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Forms.Control} (or its
			 * children) are enabled and accept user input.
			 *
			 * Typically when a control is disabled, the user cannot do anything with the control or
			 * any of its children. Including for example, selecting text in a text control. Certain
			 * controls can have a 'Read Only' mode, such as {@link Eto.Forms.TextBox.ReadOnly} which
			 * allow the user to  select text, but not change its contents.
			 */
			Enabled: boolean;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Forms.Control} is visible to
			 * the user.
			 *
			 * When the visibility of a control is set to false, it will not occupy space in the
			 * layout.
			 */
			Visible: boolean;

			/** Gets the container which this control has been added to, if any */
			readonly Parent: Eto.Forms.Container;

			/**
			 * Gets the visual container of this control, if any.
			 *
			 * Some containers may use other Eto controls to layout its children, such as the
			 * {@link Eto.Forms.StackLayout}. This will return the parent control that visually
			 * contains this control as opposed to {@link Eto.Forms.Control.Parent} which will return
			 * the logical parent.
			 */
			VisualParent: Eto.Forms.Container;

			/** Gets a value indicating this control has been attached to a native container */
			readonly IsAttached: boolean;

			/**
			 * Gets or sets the color for the background of the control
			 *
			 * Note that on some platforms (e.g. Mac), setting the background color of a control can
			 * change the performance characteristics of the control and its children, since it must
			 * enable layers to do so.
			 */
			BackgroundColor: Eto.Drawing.Color;

			/** Gets a value indicating whether this instance has the keyboard input focus. */
			readonly HasFocus: boolean;

			/** Gets a value indicating whether the layout of child controls is suspended. */
			readonly IsSuspended: boolean;

			/** Gets the window this control is contained in */
			readonly ParentWindow: Eto.Forms.Window;

			/**
			 * Gets the supported platform commands that can be used to hook up system functions to
			 * user defined logic
			 *
			 * This lists all available commands that can be mapped using the
			 * {@link Eto.Forms.Control.MapPlatformCommand(System.String,Eto.Forms.Command)} method
			 * of the control.
			 */
			readonly SupportedPlatformCommands: Iterable<string>;

			/** Gets the bounding rectangle of this control relative to its container */
			readonly Bounds: Eto.Drawing.Rectangle;

			/**
			 * Gets the location of the control as positioned by the container
			 *
			 * A control's location is set by the container. This can be used to determine where the
			 * control is for overlaying floating windows, menus, etc.
			 */
			readonly Location: Eto.Drawing.Point;

			/** Gets or sets the type of cursor to use when the mouse is hovering over the control */
			Cursor: Eto.Forms.Cursor;

			/** Gets or sets the tool tip to show when the mouse is hovered over the control */
			ToolTip: string;

			/**
			 * Gets or sets the tab index order for this control within its container.
			 *
			 * This sets the order when using the tab key to cycle through controls  Note that some
			 * platforms (Gtk and WinForms) may not support setting the context of the tab order to
			 * StackLayout  or DynamicLayout containers and may not behave exactly as expected. Use
			 * the {@link Eto.PlatformFeatures.TabIndexWithCustomContainers} flag to determine if it
			 * is supported.
			 */
			TabIndex: number;

			/** Gets or sets a value indicating whether this control can serve as drop target. */
			AllowDrop: boolean;

			/**
			 * Gets or sets the parent widget which this widget has been added to, if any
			 *
			 * When implementing child widgets that can participate in the context based binding
			 * (MVVM), You can set this to the parent widget when it is added or removed to it
			 * (usually via a collection).  Note that you should typically provide a public new
			 * [ParentWidget] Parent { get; } property  so that consumers of your API cannot set the
			 * parent to an invalid value.
			 */
			Parent: Eto.Widget;

			/**
			 * Gets an enumeration of all parent widgets in the heirarchy by traversing the
			 * {@link Eto.Forms.BindableWidget.Parent} property.
			 */
			readonly Parents: Iterable<Eto.Widget>;

			/**
			 * Gets or sets the data context for this widget for binding
			 *
			 * Subclasses may override the standard behaviour so that hierarchy of widgets can be
			 * taken into account.  For example, a Control may return the data context of a parent,
			 * if it is not set explicitly.
			 */
			DataContext: unknown;

			/** Gets the collection of bindings that are attached to this widget */
			readonly Bindings: Eto.Forms.BindingCollection;

			/**
			 * Gets a value indicating that the {@link Eto.Forms.BindableWidget.DataContext} property
			 * is changing.
			 *
			 * This can be used to determine when to allow certain logic during the update of the
			 * data context.  It is used to disable binding setters on the model when the data
			 * context changes so that a binding does not cause the view model to be updated when the
			 * state hasn't been fully set yet.
			 */
			IsDataContextChanging: boolean;

			/**
			 * Gets the platform that was used to create the {@link Eto.Widget.Handler} for this
			 * widget
			 *
			 * This gets set to the current {@link Eto.Platform.Instance} during the construction of
			 * the object
			 */
			readonly Platform: Eto.Platform;

			/** Gets the platform-specific handler for this widget */
			Handler: unknown;

			/** Gets the native platform-specific handle for integration purposes */
			readonly NativeHandle: unknown;

			/** Gets the dictionary of properties for this widget */
			readonly Properties: Eto.PropertyStore;

			/** Gets or sets the ID of this widget */
			ID: string;

			/**
			 * Gets or sets the style of this widget
			 *
			 * Styles allow you to attach custom platform-specific logic to a widget. In your
			 * platform-specific assembly, use {@link Style.Add{H}(string, StyleHandler{H})} to add
			 * the style logic with the same id.
			 */
			Style: string;

			/**
			 * Gets the instance of the platform-specific object
			 *
			 * This can sometimes be useful to get the platform-specific object. Some handlers may
			 * not have any backing object for its functionality, so this may be null.  It is more
			 * preferred to use the {@link Eto.Widget.Handler} and cast that to the platform-specific
			 * handler class which can give you additional methods and helpers to do common tasks.
			 * For example, the {@link Eto.Forms.Application} object's handler for OS X has a
			 * AddFullScreenMenuItem property to specify if you want full screen support in your app.
			 */
			readonly ControlObject: unknown;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Widget} has been disposed.
			 *
			 * When the widget is disposed, it can no longer be used.
			 */
			IsDisposed: boolean;

			/**
			 * Queues a repaint of the entire control on the screen and any of its children.
			 *
			 * This is only useful when the control is visible.
			 */
			Invalidate(): void;

			/**
			 * Queues a repaint of the entire control on the screen
			 *
			 * This is only useful when the control is visible.
			 */
			Invalidate(invalidateChildren: boolean): void;

			/**
			 * Queues a repaint of the specified `rect` of the control and any children.
			 *
			 * This is only useful when the control is visible.
			 */
			Invalidate(rect: Eto.Drawing.Rectangle): void;

			/**
			 * Queues a repaint of the specified `rect` of the control
			 *
			 * This is only useful when the control is visible.
			 */
			Invalidate(
				rect: Eto.Drawing.Rectangle,
				invalidateChildren: boolean,
			): void;

			/**
			 * Updates the layout of this control if necessary.
			 *
			 * This will ensure the control has had all of its layout applied so you can use its
			 * position and size right after this call. Most platforms (except WinForms) use a
			 * deferred layout system so that after adding your control to the form dynamically it
			 * won't get laid out until the next idle loop. This is useful when you need to know the
			 * dimensions of the control immediately. Note that this can be an expensive operation,
			 * so it is recommended to only call this method when necessary and after all of the
			 * controls have been added/updated.
			 */
			UpdateLayout(): void;

			/** Gets the preferred size of this control given infinite space available. */
			GetPreferredSize(): Eto.Drawing.SizeF;

			/** Gets the preferred size of this control given the specified `availableSize`. */
			GetPreferredSize(availableSize: Eto.Drawing.SizeF): Eto.Drawing.SizeF;

			/**
			 * Captures all mouse events to this control.
			 *
			 * This captures all mouse events until {@link Eto.Forms.Control.ReleaseMouseCapture} is
			 * called.  Note that not all platforms will allow a mouse capture unless the mouse is
			 * currently down.
			 */
			CaptureMouse(): boolean;

			/** Releases the mouse capture after a call to {@link Eto.Forms.Control.CaptureMouse}. */
			ReleaseMouseCapture(): void;

			/**
			 * Finds a control in the parent hierarchy with the specified type and
			 * {@link Eto.Widget.ID} if specified
			 */
			FindParent(
				type: unknown,
				id?: string,
			): Eto.Forms.Container;

			/** Finds a control in the parent hierarchy with the specified `id` */
			FindParent(id: string): Eto.Forms.Container;

			/**
			 * Detaches the control by removing it from its parent
			 *
			 * This is essentially a shortcut to myControl.Parent.Remove(myControl);
			 */
			Detach(): void;

			/**
			 * Attaches the control for direct use in a native application
			 *
			 * Use this to use a control directly in a native application.  Note that the native
			 * application must be running the same framework as the current platform.  E.g. a
			 * WinForms application can use an Eto.Forms control when using the Eto.WinForms
			 * platform.  This prepares the control by firing the {@link Eto.Forms.Control.PreLoad},
			 * {@link Eto.Forms.Control.Load}, etc. events.
			 */
			AttachNative(): void;

			/**
			 * Detaches the control when it is used in a native application, when you want to reuse
			 * the control.
			 *
			 * This should only be called after {@link Eto.Forms.Control.AttachNative} has been
			 * called, which is usually done by calling to ToNative(true) .
			 */
			DetachNative(): void;

			/**
			 * Attempts to set the keyboard input focus to this control, or the first child that
			 * accepts focus. For Windows, this will bring it to front and activate it.
			 */
			Focus(): void;

			/**
			 * Suspends the layout of child controls
			 *
			 * This can be used to optimize some platforms while adding, removing, or changing many
			 * child controls at once. It disables the calculation of control positioning until
			 * {@link Eto.Forms.Control.ResumeLayout} is called. Each call to SuspendLayout() must be
			 * balanced with a call to {@link Eto.Forms.Control.ResumeLayout}.
			 */
			SuspendLayout(): void;

			/**
			 * Resumes the layout after it has been suspended, and performs a layout
			 *
			 * This can be used to optimize some platforms while adding, removing, or changing many
			 * child controls at once. Each call to ResumeLayout() must be balanced with a call to
			 * {@link Eto.Forms.Control.SuspendLayout} before it.
			 */
			ResumeLayout(): void;

			/**
			 * Specifies a command to execute for a platform-specific command
			 *
			 * Some platforms have specific system-defined commands that can be associated with a
			 * control. For example, the Mac platform's cut/copy/paste functionality is defined by
			 * the system, and if you want to hook into it, you can use this to map it to your own
			 * defined logic. The valid values of the `systemCommand` parameter are defined by each
			 * platform, and a list can be retrieved using
			 * {@link Eto.Forms.Control.SupportedPlatformCommands}
			 */
			MapPlatformCommand(
				systemCommand: string,
				command: Eto.Forms.Command,
			): void;

			/** Converts a point from screen space to control space. */
			PointFromScreen(point: Eto.Drawing.PointF): Eto.Drawing.PointF;

			/** Converts a point from control space to screen space */
			PointToScreen(point: Eto.Drawing.PointF): Eto.Drawing.PointF;

			/** Converts a rectangle from screen space to control space. */
			RectangleToScreen(rect: Eto.Drawing.RectangleF): Eto.Drawing.RectangleF;

			/** Converts a rectangle from control space to screen space */
			RectangleFromScreen(rect: Eto.Drawing.RectangleF): Eto.Drawing.RectangleF;

			/**
			 * Starts drag operation using this control as drag source.
			 *
			 * This method can be blocking on some platforms (Wpf, WinForms), and non-blocking on
			 * others (Mac, Gtk). Use the {@link Eto.Forms.Control.DragEnd} event to determine when
			 * the drag operation is completed and get its resulting DragEffects.
			 */
			DoDragDrop(
				data: Eto.Forms.DataObject,
				allowedEffects: Eto.Forms.DragEffects,
			): void;

			/**
			 * Starts drag operation using this control as drag source.
			 *
			 * This method can be blocking on some platforms (Wpf, WinForms), and non-blocking on
			 * others (Mac, Gtk). Use the {@link Eto.Forms.Control.DragEnd} event to determine when
			 * the drag operation is completed and get its resulting DragEffects.
			 */
			DoDragDrop(
				data: Eto.Forms.DataObject,
				allowedEffects: Eto.Forms.DragEffects,
				image: Eto.Drawing.Image,
				cursorOffset: Eto.Drawing.PointF,
			): void;

			/**
			 * Triggers the StyleChanged event and re-applies the styles to this control and its
			 * children.
			 */
			TriggerStyleChanged(): void;

			/** Shows a print dialog to print the specified control */
			Print(): void;

			/**
			 * Finds a control in the parent hierarchy with the specified type and
			 * {@link Eto.Widget.ID} if specified
			 */
			FindParent<T>(id?: string): T;

			/**
			 * Finds a control in the parent hierarchy with the specified type and
			 * {@link Eto.Widget.ID} if specified
			 */
			FindParent(
				type: unknown,
				id?: string,
			): Eto.Widget;

			/** Finds a control in the parent hierarchy with the specified `id` */
			FindParent(id: string): Eto.Widget;

			/**
			 * Unbinds any bindings in the {@link Eto.Forms.BindableWidget.Bindings} collection and
			 * removes the bindings
			 *
			 * When you implement {@link Eto.Forms.IBindableWidgetContainer}, this will also unbind
			 * any of its children.
			 */
			Unbind(): void;

			/**
			 * Updates all bindings in this widget
			 *
			 * When you implement {@link Eto.Forms.IBindableWidgetContainer}, this will also update
			 * bindings for all of its children.
			 */
			UpdateBindings(mode?: Eto.Forms.BindingUpdateMode): void;

			/** Disposes of this widget, supressing the finalizer */
			dispose(): void;

			/** Gets a string that represents the current object with its ID if specified. */
			ToString(): string;
		}
	}

	export namespace Eto.Forms.NumericStepper {
		export interface ICallback extends
			Eto.Forms.Control.ICallback,
			Eto.Widget.ICallback {
			OnValueChanged(
				widget: Eto.Forms.NumericStepper,
				e: unknown,
			): void;
		}
	}

	export namespace Eto.Forms.NumericStepper {
		export interface IHandler extends
			Eto.Forms.CommonControl.IHandler,
			Eto.Forms.Control.IHandler,
			Eto.Widget.IHandler {
			ReadOnly: boolean;

			Value: number;

			MinValue: number;

			MaxValue: number;

			DecimalPlaces: number;

			Increment: number;

			TextColor: Eto.Drawing.Color;

			MaximumDecimalPlaces: number;

			FormatString: string;

			CultureInfo: unknown;

			Wrap: boolean;
		}
	}

	export namespace Eto.Forms {
		/**
		 * Control to display a panel containing a single {@link Eto.Forms.Panel.Content} control
		 *
		 * This can be instantiated directly to provide padding around a control, and is also the
		 * base of other containers that have only a single child control.
		 */
		export class Panel implements
			Eto.IHandlerSource,
			Eto.Forms.IBindable,
			Eto.Forms.IMouseInputSource,
			Eto.Forms.IKeyboardInputSource {
			/** Initializes a new instance of the {@link Eto.Forms.Panel} class. */
			constructor();

			/** Gets an enumeration of controls that are directly contained by this container */
			readonly Controls: Iterable<Eto.Forms.Control>;

			/** Gets or sets the padding around the {@link Eto.Forms.Panel.Content} of the panel. */
			Padding: Eto.Drawing.Padding;

			/** Gets or sets the minimum size of the panel. */
			MinimumSize: Eto.Drawing.Size;

			/**
			 * Gets or sets the context menu for the panel.
			 *
			 * The context menu is usually shown when the user right clicks the control, or in mobile
			 * platforms when the user taps and holds their finger down on the control.
			 */
			ContextMenu: Eto.Forms.ContextMenu;

			/**
			 * Gets or sets the main content of the panel.
			 *
			 * The main content will be offset by the {@link Eto.Forms.Panel.Padding} value
			 * specified, and will take up the entire content area of the control. Some controls may
			 * have decorations that will surround the content, such as a {@link Eto.Forms.GroupBox},
			 * {@link Eto.Forms.TabControl}, or {@link Eto.Forms.Window}
			 */
			Content: Eto.Forms.Control;

			/**
			 * Gets or sets the size for the client area of the control
			 *
			 * The client size differs from the {@link Eto.Forms.Control.Size} in that it excludes
			 * the decorations of the container, such as the title bar and border around a
			 * {@link Eto.Forms.Window}, or the title and line  around a {@link Eto.Forms.GroupBox}.
			 */
			ClientSize: Eto.Drawing.Size;

			/**
			 * Gets an enumeration of all contained child controls, including controls within child
			 * containers
			 */
			readonly Children: Iterable<Eto.Forms.Control>;

			/**
			 * Gets an enumeration of all contained child controls in the visual tree, including
			 * controls within child containers.
			 */
			readonly VisualChildren: Iterable<Eto.Forms.Control>;

			/**
			 * Gets or sets the style provider for this container.
			 *
			 * The style provider is used to style this container and its children.
			 */
			StyleProvider: Eto.IStyleProvider;

			/**
			 * Gets the default style provider for this container.
			 *
			 * Use this to apply styles to any child controls of this container. By default, styles
			 * will apply to all children, including children of children unless
			 * {@link Eto.DefaultStyleProvider.Inherit} is set to false .  Typically, you would set
			 * Inherit to false when creating composite controls that already have all their styles
			 * applied and you don't want any other styles to be inherited.
			 */
			readonly Styles: Eto.DefaultStyleProvider;

			/**
			 * Gets a value indicating that the control is loaded onto a form, that is it has been
			 * created, added to a parent, and shown
			 *
			 * The {@link Eto.Forms.Control.OnLoad(System.EventArgs)} method sets this value to true
			 * after cascading to all children (for a {@link Eto.Forms.Container} ) and calling the
			 * platform handler's implementation.  It is called after adding to a loaded form, or
			 * when showing a new form.  The {@link Eto.Forms.Control.OnUnLoad(System.EventArgs)}
			 * method will set this value to false when the control is removed from its parent
			 */
			readonly Loaded: boolean;

			/**
			 * Gets an enumeration of controls that are in the visual tree.
			 *
			 * This is used to specify which controls are contained by this instance that are part of
			 * the visual tree. This should include all controls including non-logical Eto controls
			 * used for layout.
			 */
			readonly VisualControls: Iterable<Eto.Forms.Control>;

			/**
			 * Gets or sets a user-defined object that contains data about the control
			 *
			 * A common use of the tag property is to store data that is associated with the control
			 * that you can later retrieve.
			 */
			Tag: unknown;

			/**
			 * Gets the logical parent control.
			 *
			 * When the control is part of the visual tree (
				 * {@link Eto.Forms.Control.IsVisualControl} is true), this returns the logical parent
				 * that contains this control. Otherwise this is the same as
				 * {@link Eto.Forms.Control.Parent}.
				 */
				readonly LogicalParent: Eto.Forms.Container;

			/** Gets a value indicating this {@link Eto.Forms.Control} is part of the visual tree. */
			IsVisualControl: boolean;

			/**
			 * Gets or sets the size of the control. Use -1 to specify auto sizing for either the
			 * width and/or height.
			 *
			 * Setting the size of controls is entirely optional as most controls will size
			 * themselves appropriately. When specifying a size, it will be used as the desired size
			 * of the control.  The container will reposition and resize the control depending on the
			 * available size.  For a {@link Eto.Forms.Window}, it is preferred to set the
			 * {@link Eto.Forms.Container.ClientSize} instead, as various platforms have different
			 * sizes of window decorations, toolbars, etc.
			 */
			Size: Eto.Drawing.Size;

			/**
			 * Gets a value indicating this control currently has mouse capture
			 *
			 * Mouse capture can happen during a handled MouseDown event until MouseUp, or it can be
			 * captured explicitly via {@link Eto.Forms.Control.CaptureMouse}.
			 */
			readonly IsMouseCaptured: boolean;

			/** Gets or sets the width of the control size. */
			Width: number;

			/** Gets or sets the height of the control size. */
			Height: number;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Forms.Control} (or its
			 * children) are enabled and accept user input.
			 *
			 * Typically when a control is disabled, the user cannot do anything with the control or
			 * any of its children. Including for example, selecting text in a text control. Certain
			 * controls can have a 'Read Only' mode, such as {@link Eto.Forms.TextBox.ReadOnly} which
			 * allow the user to  select text, but not change its contents.
			 */
			Enabled: boolean;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Forms.Control} is visible to
			 * the user.
			 *
			 * When the visibility of a control is set to false, it will not occupy space in the
			 * layout.
			 */
			Visible: boolean;

			/** Gets the container which this control has been added to, if any */
			readonly Parent: Eto.Forms.Container;

			/**
			 * Gets the visual container of this control, if any.
			 *
			 * Some containers may use other Eto controls to layout its children, such as the
			 * {@link Eto.Forms.StackLayout}. This will return the parent control that visually
			 * contains this control as opposed to {@link Eto.Forms.Control.Parent} which will return
			 * the logical parent.
			 */
			VisualParent: Eto.Forms.Container;

			/** Gets a value indicating this control has been attached to a native container */
			readonly IsAttached: boolean;

			/**
			 * Gets or sets the color for the background of the control
			 *
			 * Note that on some platforms (e.g. Mac), setting the background color of a control can
			 * change the performance characteristics of the control and its children, since it must
			 * enable layers to do so.
			 */
			BackgroundColor: Eto.Drawing.Color;

			/** Gets a value indicating whether this instance has the keyboard input focus. */
			readonly HasFocus: boolean;

			/** Gets a value indicating whether the layout of child controls is suspended. */
			readonly IsSuspended: boolean;

			/** Gets the window this control is contained in */
			readonly ParentWindow: Eto.Forms.Window;

			/**
			 * Gets the supported platform commands that can be used to hook up system functions to
			 * user defined logic
			 *
			 * This lists all available commands that can be mapped using the
			 * {@link Eto.Forms.Control.MapPlatformCommand(System.String,Eto.Forms.Command)} method
			 * of the control.
			 */
			readonly SupportedPlatformCommands: Iterable<string>;

			/** Gets the bounding rectangle of this control relative to its container */
			readonly Bounds: Eto.Drawing.Rectangle;

			/**
			 * Gets the location of the control as positioned by the container
			 *
			 * A control's location is set by the container. This can be used to determine where the
			 * control is for overlaying floating windows, menus, etc.
			 */
			readonly Location: Eto.Drawing.Point;

			/** Gets or sets the type of cursor to use when the mouse is hovering over the control */
			Cursor: Eto.Forms.Cursor;

			/** Gets or sets the tool tip to show when the mouse is hovered over the control */
			ToolTip: string;

			/**
			 * Gets or sets the tab index order for this control within its container.
			 *
			 * This sets the order when using the tab key to cycle through controls  Note that some
			 * platforms (Gtk and WinForms) may not support setting the context of the tab order to
			 * StackLayout  or DynamicLayout containers and may not behave exactly as expected. Use
			 * the {@link Eto.PlatformFeatures.TabIndexWithCustomContainers} flag to determine if it
			 * is supported.
			 */
			TabIndex: number;

			/** Gets or sets a value indicating whether this control can serve as drop target. */
			AllowDrop: boolean;

			/**
			 * Gets or sets the parent widget which this widget has been added to, if any
			 *
			 * When implementing child widgets that can participate in the context based binding
			 * (MVVM), You can set this to the parent widget when it is added or removed to it
			 * (usually via a collection).  Note that you should typically provide a public new
			 * [ParentWidget] Parent { get; } property  so that consumers of your API cannot set the
			 * parent to an invalid value.
			 */
			Parent: Eto.Widget;

			/**
			 * Gets an enumeration of all parent widgets in the heirarchy by traversing the
			 * {@link Eto.Forms.BindableWidget.Parent} property.
			 */
			readonly Parents: Iterable<Eto.Widget>;

			/**
			 * Gets or sets the data context for this widget for binding
			 *
			 * Subclasses may override the standard behaviour so that hierarchy of widgets can be
			 * taken into account.  For example, a Control may return the data context of a parent,
			 * if it is not set explicitly.
			 */
			DataContext: unknown;

			/** Gets the collection of bindings that are attached to this widget */
			readonly Bindings: Eto.Forms.BindingCollection;

			/**
			 * Gets a value indicating that the {@link Eto.Forms.BindableWidget.DataContext} property
			 * is changing.
			 *
			 * This can be used to determine when to allow certain logic during the update of the
			 * data context.  It is used to disable binding setters on the model when the data
			 * context changes so that a binding does not cause the view model to be updated when the
			 * state hasn't been fully set yet.
			 */
			IsDataContextChanging: boolean;

			/**
			 * Gets the platform that was used to create the {@link Eto.Widget.Handler} for this
			 * widget
			 *
			 * This gets set to the current {@link Eto.Platform.Instance} during the construction of
			 * the object
			 */
			readonly Platform: Eto.Platform;

			/** Gets the platform-specific handler for this widget */
			Handler: unknown;

			/** Gets the native platform-specific handle for integration purposes */
			readonly NativeHandle: unknown;

			/** Gets the dictionary of properties for this widget */
			readonly Properties: Eto.PropertyStore;

			/** Gets or sets the ID of this widget */
			ID: string;

			/**
			 * Gets or sets the style of this widget
			 *
			 * Styles allow you to attach custom platform-specific logic to a widget. In your
			 * platform-specific assembly, use {@link Style.Add{H}(string, StyleHandler{H})} to add
			 * the style logic with the same id.
			 */
			Style: string;

			/**
			 * Gets the instance of the platform-specific object
			 *
			 * This can sometimes be useful to get the platform-specific object. Some handlers may
			 * not have any backing object for its functionality, so this may be null.  It is more
			 * preferred to use the {@link Eto.Widget.Handler} and cast that to the platform-specific
			 * handler class which can give you additional methods and helpers to do common tasks.
			 * For example, the {@link Eto.Forms.Application} object's handler for OS X has a
			 * AddFullScreenMenuItem property to specify if you want full screen support in your app.
			 */
			readonly ControlObject: unknown;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Widget} has been disposed.
			 *
			 * When the widget is disposed, it can no longer be used.
			 */
			IsDisposed: boolean;

			/** Removes the specified child from the container */
			Remove(child: Eto.Forms.Control): void;

			/** Remove the specified `controls` from this container */
			Remove(controls: Iterable<Eto.Forms.Control>): void;

			/** Removes all controls from this container */
			RemoveAll(): void;

			/**
			 * Finds a child control in this container or any of its child containers with the
			 * specified `id`
			 */
			FindChild<T>(id?: string): T;

			/**
			 * Finds a child control in this container or any of its child containers with the
			 * specified `type`
			 */
			FindChild(
				type: unknown,
				id?: string,
			): Eto.Forms.Control;

			/**
			 * Finds a child control in this container or any of its child containers with the
			 * specified `id`.
			 */
			FindChild(id: string): Eto.Forms.Control;

			/**
			 * Queues a repaint of the entire control on the screen and any of its children.
			 *
			 * This is only useful when the control is visible.
			 */
			Invalidate(): void;

			/**
			 * Queues a repaint of the entire control on the screen
			 *
			 * This is only useful when the control is visible.
			 */
			Invalidate(invalidateChildren: boolean): void;

			/**
			 * Queues a repaint of the specified `rect` of the control and any children.
			 *
			 * This is only useful when the control is visible.
			 */
			Invalidate(rect: Eto.Drawing.Rectangle): void;

			/**
			 * Queues a repaint of the specified `rect` of the control
			 *
			 * This is only useful when the control is visible.
			 */
			Invalidate(
				rect: Eto.Drawing.Rectangle,
				invalidateChildren: boolean,
			): void;

			/**
			 * Updates the layout of this control if necessary.
			 *
			 * This will ensure the control has had all of its layout applied so you can use its
			 * position and size right after this call. Most platforms (except WinForms) use a
			 * deferred layout system so that after adding your control to the form dynamically it
			 * won't get laid out until the next idle loop. This is useful when you need to know the
			 * dimensions of the control immediately. Note that this can be an expensive operation,
			 * so it is recommended to only call this method when necessary and after all of the
			 * controls have been added/updated.
			 */
			UpdateLayout(): void;

			/** Gets the preferred size of this control given infinite space available. */
			GetPreferredSize(): Eto.Drawing.SizeF;

			/** Gets the preferred size of this control given the specified `availableSize`. */
			GetPreferredSize(availableSize: Eto.Drawing.SizeF): Eto.Drawing.SizeF;

			/**
			 * Captures all mouse events to this control.
			 *
			 * This captures all mouse events until {@link Eto.Forms.Control.ReleaseMouseCapture} is
			 * called.  Note that not all platforms will allow a mouse capture unless the mouse is
			 * currently down.
			 */
			CaptureMouse(): boolean;

			/** Releases the mouse capture after a call to {@link Eto.Forms.Control.CaptureMouse}. */
			ReleaseMouseCapture(): void;

			/**
			 * Finds a control in the parent hierarchy with the specified type and
			 * {@link Eto.Widget.ID} if specified
			 */
			FindParent(
				type: unknown,
				id?: string,
			): Eto.Forms.Container;

			/** Finds a control in the parent hierarchy with the specified `id` */
			FindParent(id: string): Eto.Forms.Container;

			/**
			 * Detaches the control by removing it from its parent
			 *
			 * This is essentially a shortcut to myControl.Parent.Remove(myControl);
			 */
			Detach(): void;

			/**
			 * Attaches the control for direct use in a native application
			 *
			 * Use this to use a control directly in a native application.  Note that the native
			 * application must be running the same framework as the current platform.  E.g. a
			 * WinForms application can use an Eto.Forms control when using the Eto.WinForms
			 * platform.  This prepares the control by firing the {@link Eto.Forms.Control.PreLoad},
			 * {@link Eto.Forms.Control.Load}, etc. events.
			 */
			AttachNative(): void;

			/**
			 * Detaches the control when it is used in a native application, when you want to reuse
			 * the control.
			 *
			 * This should only be called after {@link Eto.Forms.Control.AttachNative} has been
			 * called, which is usually done by calling to ToNative(true) .
			 */
			DetachNative(): void;

			/**
			 * Attempts to set the keyboard input focus to this control, or the first child that
			 * accepts focus. For Windows, this will bring it to front and activate it.
			 */
			Focus(): void;

			/**
			 * Suspends the layout of child controls
			 *
			 * This can be used to optimize some platforms while adding, removing, or changing many
			 * child controls at once. It disables the calculation of control positioning until
			 * {@link Eto.Forms.Control.ResumeLayout} is called. Each call to SuspendLayout() must be
			 * balanced with a call to {@link Eto.Forms.Control.ResumeLayout}.
			 */
			SuspendLayout(): void;

			/**
			 * Resumes the layout after it has been suspended, and performs a layout
			 *
			 * This can be used to optimize some platforms while adding, removing, or changing many
			 * child controls at once. Each call to ResumeLayout() must be balanced with a call to
			 * {@link Eto.Forms.Control.SuspendLayout} before it.
			 */
			ResumeLayout(): void;

			/**
			 * Specifies a command to execute for a platform-specific command
			 *
			 * Some platforms have specific system-defined commands that can be associated with a
			 * control. For example, the Mac platform's cut/copy/paste functionality is defined by
			 * the system, and if you want to hook into it, you can use this to map it to your own
			 * defined logic. The valid values of the `systemCommand` parameter are defined by each
			 * platform, and a list can be retrieved using
			 * {@link Eto.Forms.Control.SupportedPlatformCommands}
			 */
			MapPlatformCommand(
				systemCommand: string,
				command: Eto.Forms.Command,
			): void;

			/** Converts a point from screen space to control space. */
			PointFromScreen(point: Eto.Drawing.PointF): Eto.Drawing.PointF;

			/** Converts a point from control space to screen space */
			PointToScreen(point: Eto.Drawing.PointF): Eto.Drawing.PointF;

			/** Converts a rectangle from screen space to control space. */
			RectangleToScreen(rect: Eto.Drawing.RectangleF): Eto.Drawing.RectangleF;

			/** Converts a rectangle from control space to screen space */
			RectangleFromScreen(rect: Eto.Drawing.RectangleF): Eto.Drawing.RectangleF;

			/**
			 * Starts drag operation using this control as drag source.
			 *
			 * This method can be blocking on some platforms (Wpf, WinForms), and non-blocking on
			 * others (Mac, Gtk). Use the {@link Eto.Forms.Control.DragEnd} event to determine when
			 * the drag operation is completed and get its resulting DragEffects.
			 */
			DoDragDrop(
				data: Eto.Forms.DataObject,
				allowedEffects: Eto.Forms.DragEffects,
			): void;

			/**
			 * Starts drag operation using this control as drag source.
			 *
			 * This method can be blocking on some platforms (Wpf, WinForms), and non-blocking on
			 * others (Mac, Gtk). Use the {@link Eto.Forms.Control.DragEnd} event to determine when
			 * the drag operation is completed and get its resulting DragEffects.
			 */
			DoDragDrop(
				data: Eto.Forms.DataObject,
				allowedEffects: Eto.Forms.DragEffects,
				image: Eto.Drawing.Image,
				cursorOffset: Eto.Drawing.PointF,
			): void;

			/**
			 * Triggers the StyleChanged event and re-applies the styles to this control and its
			 * children.
			 */
			TriggerStyleChanged(): void;

			/** Shows a print dialog to print the specified control */
			Print(): void;

			/**
			 * Finds a control in the parent hierarchy with the specified type and
			 * {@link Eto.Widget.ID} if specified
			 */
			FindParent<T>(id?: string): T;

			/**
			 * Finds a control in the parent hierarchy with the specified type and
			 * {@link Eto.Widget.ID} if specified
			 */
			FindParent(
				type: unknown,
				id?: string,
			): Eto.Widget;

			/** Finds a control in the parent hierarchy with the specified `id` */
			FindParent(id: string): Eto.Widget;

			/**
			 * Unbinds any bindings in the {@link Eto.Forms.BindableWidget.Bindings} collection and
			 * removes the bindings
			 *
			 * When you implement {@link Eto.Forms.IBindableWidgetContainer}, this will also unbind
			 * any of its children.
			 */
			Unbind(): void;

			/**
			 * Updates all bindings in this widget
			 *
			 * When you implement {@link Eto.Forms.IBindableWidgetContainer}, this will also update
			 * bindings for all of its children.
			 */
			UpdateBindings(mode?: Eto.Forms.BindingUpdateMode): void;

			/** Disposes of this widget, supressing the finalizer */
			dispose(): void;

			/** Gets a string that represents the current object with its ID if specified. */
			ToString(): string;
		}
	}

	export namespace Eto.Forms.Panel {
		export interface IHandler extends
			Eto.Forms.Container.IHandler,
			Eto.Forms.Control.IHandler,
			Eto.Widget.IHandler,
			Eto.Forms.IContextMenuHost {
			Content: Eto.Forms.Control;

			Padding: Eto.Drawing.Padding;

			MinimumSize: Eto.Drawing.Size;
		}
	}

	export namespace Eto.Forms {
		/**
		 * An entry box for the user to enter a password without displaying the contents of the
		 * password while typed.
		 */
		export class PasswordBox implements
			Eto.IHandlerSource,
			Eto.Forms.IBindable,
			Eto.Forms.IMouseInputSource,
			Eto.Forms.IKeyboardInputSource {
			constructor();

			/** Gets or sets a value indicating whether the value is read only */
			ReadOnly: boolean;

			/** Gets or sets the maximum length of password the user can enter */
			MaxLength: number;

			/**
			 * Gets or sets the password display character hint
			 *
			 * Some platforms may not support changing the password display character
			 */
			PasswordChar: unknown;

			/**
			 * Gets or sets the text of the control.
			 *
			 * Usually, the caret and selection will be set to the end of the string after its set.
			 */
			Text: string;

			/**
			 * Gets or sets the color of the text.
			 *
			 * By default, the text will get a color based on the user's theme. However, this is
			 * usually black.
			 */
			TextColor: Eto.Drawing.Color;

			/** Gets the binding for the {@link Eto.Forms.TextControl.Text} property. */
			readonly TextBinding: Eto.Forms.BindableBinding$2<Eto.Forms.TextControl, string>;

			/** Gets or sets the font for the text of the control */
			Font: Eto.Drawing.Font;

			/**
			 * Gets a value indicating that the control is loaded onto a form, that is it has been
			 * created, added to a parent, and shown
			 *
			 * The {@link Eto.Forms.Control.OnLoad(System.EventArgs)} method sets this value to true
			 * after cascading to all children (for a {@link Eto.Forms.Container} ) and calling the
			 * platform handler's implementation.  It is called after adding to a loaded form, or
			 * when showing a new form.  The {@link Eto.Forms.Control.OnUnLoad(System.EventArgs)}
			 * method will set this value to false when the control is removed from its parent
			 */
			readonly Loaded: boolean;

			/**
			 * Gets an enumeration of controls that are in the visual tree.
			 *
			 * This is used to specify which controls are contained by this instance that are part of
			 * the visual tree. This should include all controls including non-logical Eto controls
			 * used for layout.
			 */
			readonly VisualControls: Iterable<Eto.Forms.Control>;

			/**
			 * Gets or sets a user-defined object that contains data about the control
			 *
			 * A common use of the tag property is to store data that is associated with the control
			 * that you can later retrieve.
			 */
			Tag: unknown;

			/**
			 * Gets the logical parent control.
			 *
			 * When the control is part of the visual tree (
				 * {@link Eto.Forms.Control.IsVisualControl} is true), this returns the logical parent
				 * that contains this control. Otherwise this is the same as
				 * {@link Eto.Forms.Control.Parent}.
				 */
				readonly LogicalParent: Eto.Forms.Container;

			/** Gets a value indicating this {@link Eto.Forms.Control} is part of the visual tree. */
			IsVisualControl: boolean;

			/**
			 * Gets or sets the size of the control. Use -1 to specify auto sizing for either the
			 * width and/or height.
			 *
			 * Setting the size of controls is entirely optional as most controls will size
			 * themselves appropriately. When specifying a size, it will be used as the desired size
			 * of the control.  The container will reposition and resize the control depending on the
			 * available size.  For a {@link Eto.Forms.Window}, it is preferred to set the
			 * {@link Eto.Forms.Container.ClientSize} instead, as various platforms have different
			 * sizes of window decorations, toolbars, etc.
			 */
			Size: Eto.Drawing.Size;

			/**
			 * Gets a value indicating this control currently has mouse capture
			 *
			 * Mouse capture can happen during a handled MouseDown event until MouseUp, or it can be
			 * captured explicitly via {@link Eto.Forms.Control.CaptureMouse}.
			 */
			readonly IsMouseCaptured: boolean;

			/** Gets or sets the width of the control size. */
			Width: number;

			/** Gets or sets the height of the control size. */
			Height: number;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Forms.Control} (or its
			 * children) are enabled and accept user input.
			 *
			 * Typically when a control is disabled, the user cannot do anything with the control or
			 * any of its children. Including for example, selecting text in a text control. Certain
			 * controls can have a 'Read Only' mode, such as {@link Eto.Forms.TextBox.ReadOnly} which
			 * allow the user to  select text, but not change its contents.
			 */
			Enabled: boolean;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Forms.Control} is visible to
			 * the user.
			 *
			 * When the visibility of a control is set to false, it will not occupy space in the
			 * layout.
			 */
			Visible: boolean;

			/** Gets the container which this control has been added to, if any */
			readonly Parent: Eto.Forms.Container;

			/**
			 * Gets the visual container of this control, if any.
			 *
			 * Some containers may use other Eto controls to layout its children, such as the
			 * {@link Eto.Forms.StackLayout}. This will return the parent control that visually
			 * contains this control as opposed to {@link Eto.Forms.Control.Parent} which will return
			 * the logical parent.
			 */
			VisualParent: Eto.Forms.Container;

			/** Gets a value indicating this control has been attached to a native container */
			readonly IsAttached: boolean;

			/**
			 * Gets or sets the color for the background of the control
			 *
			 * Note that on some platforms (e.g. Mac), setting the background color of a control can
			 * change the performance characteristics of the control and its children, since it must
			 * enable layers to do so.
			 */
			BackgroundColor: Eto.Drawing.Color;

			/** Gets a value indicating whether this instance has the keyboard input focus. */
			readonly HasFocus: boolean;

			/** Gets a value indicating whether the layout of child controls is suspended. */
			readonly IsSuspended: boolean;

			/** Gets the window this control is contained in */
			readonly ParentWindow: Eto.Forms.Window;

			/**
			 * Gets the supported platform commands that can be used to hook up system functions to
			 * user defined logic
			 *
			 * This lists all available commands that can be mapped using the
			 * {@link Eto.Forms.Control.MapPlatformCommand(System.String,Eto.Forms.Command)} method
			 * of the control.
			 */
			readonly SupportedPlatformCommands: Iterable<string>;

			/** Gets the bounding rectangle of this control relative to its container */
			readonly Bounds: Eto.Drawing.Rectangle;

			/**
			 * Gets the location of the control as positioned by the container
			 *
			 * A control's location is set by the container. This can be used to determine where the
			 * control is for overlaying floating windows, menus, etc.
			 */
			readonly Location: Eto.Drawing.Point;

			/** Gets or sets the type of cursor to use when the mouse is hovering over the control */
			Cursor: Eto.Forms.Cursor;

			/** Gets or sets the tool tip to show when the mouse is hovered over the control */
			ToolTip: string;

			/**
			 * Gets or sets the tab index order for this control within its container.
			 *
			 * This sets the order when using the tab key to cycle through controls  Note that some
			 * platforms (Gtk and WinForms) may not support setting the context of the tab order to
			 * StackLayout  or DynamicLayout containers and may not behave exactly as expected. Use
			 * the {@link Eto.PlatformFeatures.TabIndexWithCustomContainers} flag to determine if it
			 * is supported.
			 */
			TabIndex: number;

			/** Gets or sets a value indicating whether this control can serve as drop target. */
			AllowDrop: boolean;

			/**
			 * Gets or sets the parent widget which this widget has been added to, if any
			 *
			 * When implementing child widgets that can participate in the context based binding
			 * (MVVM), You can set this to the parent widget when it is added or removed to it
			 * (usually via a collection).  Note that you should typically provide a public new
			 * [ParentWidget] Parent { get; } property  so that consumers of your API cannot set the
			 * parent to an invalid value.
			 */
			Parent: Eto.Widget;

			/**
			 * Gets an enumeration of all parent widgets in the heirarchy by traversing the
			 * {@link Eto.Forms.BindableWidget.Parent} property.
			 */
			readonly Parents: Iterable<Eto.Widget>;

			/**
			 * Gets or sets the data context for this widget for binding
			 *
			 * Subclasses may override the standard behaviour so that hierarchy of widgets can be
			 * taken into account.  For example, a Control may return the data context of a parent,
			 * if it is not set explicitly.
			 */
			DataContext: unknown;

			/** Gets the collection of bindings that are attached to this widget */
			readonly Bindings: Eto.Forms.BindingCollection;

			/**
			 * Gets a value indicating that the {@link Eto.Forms.BindableWidget.DataContext} property
			 * is changing.
			 *
			 * This can be used to determine when to allow certain logic during the update of the
			 * data context.  It is used to disable binding setters on the model when the data
			 * context changes so that a binding does not cause the view model to be updated when the
			 * state hasn't been fully set yet.
			 */
			IsDataContextChanging: boolean;

			/**
			 * Gets the platform that was used to create the {@link Eto.Widget.Handler} for this
			 * widget
			 *
			 * This gets set to the current {@link Eto.Platform.Instance} during the construction of
			 * the object
			 */
			readonly Platform: Eto.Platform;

			/** Gets the platform-specific handler for this widget */
			Handler: unknown;

			/** Gets the native platform-specific handle for integration purposes */
			readonly NativeHandle: unknown;

			/** Gets the dictionary of properties for this widget */
			readonly Properties: Eto.PropertyStore;

			/** Gets or sets the ID of this widget */
			ID: string;

			/**
			 * Gets or sets the style of this widget
			 *
			 * Styles allow you to attach custom platform-specific logic to a widget. In your
			 * platform-specific assembly, use {@link Style.Add{H}(string, StyleHandler{H})} to add
			 * the style logic with the same id.
			 */
			Style: string;

			/**
			 * Gets the instance of the platform-specific object
			 *
			 * This can sometimes be useful to get the platform-specific object. Some handlers may
			 * not have any backing object for its functionality, so this may be null.  It is more
			 * preferred to use the {@link Eto.Widget.Handler} and cast that to the platform-specific
			 * handler class which can give you additional methods and helpers to do common tasks.
			 * For example, the {@link Eto.Forms.Application} object's handler for OS X has a
			 * AddFullScreenMenuItem property to specify if you want full screen support in your app.
			 */
			readonly ControlObject: unknown;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Widget} has been disposed.
			 *
			 * When the widget is disposed, it can no longer be used.
			 */
			IsDisposed: boolean;

			/**
			 * Queues a repaint of the entire control on the screen and any of its children.
			 *
			 * This is only useful when the control is visible.
			 */
			Invalidate(): void;

			/**
			 * Queues a repaint of the entire control on the screen
			 *
			 * This is only useful when the control is visible.
			 */
			Invalidate(invalidateChildren: boolean): void;

			/**
			 * Queues a repaint of the specified `rect` of the control and any children.
			 *
			 * This is only useful when the control is visible.
			 */
			Invalidate(rect: Eto.Drawing.Rectangle): void;

			/**
			 * Queues a repaint of the specified `rect` of the control
			 *
			 * This is only useful when the control is visible.
			 */
			Invalidate(
				rect: Eto.Drawing.Rectangle,
				invalidateChildren: boolean,
			): void;

			/**
			 * Updates the layout of this control if necessary.
			 *
			 * This will ensure the control has had all of its layout applied so you can use its
			 * position and size right after this call. Most platforms (except WinForms) use a
			 * deferred layout system so that after adding your control to the form dynamically it
			 * won't get laid out until the next idle loop. This is useful when you need to know the
			 * dimensions of the control immediately. Note that this can be an expensive operation,
			 * so it is recommended to only call this method when necessary and after all of the
			 * controls have been added/updated.
			 */
			UpdateLayout(): void;

			/** Gets the preferred size of this control given infinite space available. */
			GetPreferredSize(): Eto.Drawing.SizeF;

			/** Gets the preferred size of this control given the specified `availableSize`. */
			GetPreferredSize(availableSize: Eto.Drawing.SizeF): Eto.Drawing.SizeF;

			/**
			 * Captures all mouse events to this control.
			 *
			 * This captures all mouse events until {@link Eto.Forms.Control.ReleaseMouseCapture} is
			 * called.  Note that not all platforms will allow a mouse capture unless the mouse is
			 * currently down.
			 */
			CaptureMouse(): boolean;

			/** Releases the mouse capture after a call to {@link Eto.Forms.Control.CaptureMouse}. */
			ReleaseMouseCapture(): void;

			/**
			 * Finds a control in the parent hierarchy with the specified type and
			 * {@link Eto.Widget.ID} if specified
			 */
			FindParent(
				type: unknown,
				id?: string,
			): Eto.Forms.Container;

			/** Finds a control in the parent hierarchy with the specified `id` */
			FindParent(id: string): Eto.Forms.Container;

			/**
			 * Detaches the control by removing it from its parent
			 *
			 * This is essentially a shortcut to myControl.Parent.Remove(myControl);
			 */
			Detach(): void;

			/**
			 * Attaches the control for direct use in a native application
			 *
			 * Use this to use a control directly in a native application.  Note that the native
			 * application must be running the same framework as the current platform.  E.g. a
			 * WinForms application can use an Eto.Forms control when using the Eto.WinForms
			 * platform.  This prepares the control by firing the {@link Eto.Forms.Control.PreLoad},
			 * {@link Eto.Forms.Control.Load}, etc. events.
			 */
			AttachNative(): void;

			/**
			 * Detaches the control when it is used in a native application, when you want to reuse
			 * the control.
			 *
			 * This should only be called after {@link Eto.Forms.Control.AttachNative} has been
			 * called, which is usually done by calling to ToNative(true) .
			 */
			DetachNative(): void;

			/**
			 * Attempts to set the keyboard input focus to this control, or the first child that
			 * accepts focus. For Windows, this will bring it to front and activate it.
			 */
			Focus(): void;

			/**
			 * Suspends the layout of child controls
			 *
			 * This can be used to optimize some platforms while adding, removing, or changing many
			 * child controls at once. It disables the calculation of control positioning until
			 * {@link Eto.Forms.Control.ResumeLayout} is called. Each call to SuspendLayout() must be
			 * balanced with a call to {@link Eto.Forms.Control.ResumeLayout}.
			 */
			SuspendLayout(): void;

			/**
			 * Resumes the layout after it has been suspended, and performs a layout
			 *
			 * This can be used to optimize some platforms while adding, removing, or changing many
			 * child controls at once. Each call to ResumeLayout() must be balanced with a call to
			 * {@link Eto.Forms.Control.SuspendLayout} before it.
			 */
			ResumeLayout(): void;

			/**
			 * Specifies a command to execute for a platform-specific command
			 *
			 * Some platforms have specific system-defined commands that can be associated with a
			 * control. For example, the Mac platform's cut/copy/paste functionality is defined by
			 * the system, and if you want to hook into it, you can use this to map it to your own
			 * defined logic. The valid values of the `systemCommand` parameter are defined by each
			 * platform, and a list can be retrieved using
			 * {@link Eto.Forms.Control.SupportedPlatformCommands}
			 */
			MapPlatformCommand(
				systemCommand: string,
				command: Eto.Forms.Command,
			): void;

			/** Converts a point from screen space to control space. */
			PointFromScreen(point: Eto.Drawing.PointF): Eto.Drawing.PointF;

			/** Converts a point from control space to screen space */
			PointToScreen(point: Eto.Drawing.PointF): Eto.Drawing.PointF;

			/** Converts a rectangle from screen space to control space. */
			RectangleToScreen(rect: Eto.Drawing.RectangleF): Eto.Drawing.RectangleF;

			/** Converts a rectangle from control space to screen space */
			RectangleFromScreen(rect: Eto.Drawing.RectangleF): Eto.Drawing.RectangleF;

			/**
			 * Starts drag operation using this control as drag source.
			 *
			 * This method can be blocking on some platforms (Wpf, WinForms), and non-blocking on
			 * others (Mac, Gtk). Use the {@link Eto.Forms.Control.DragEnd} event to determine when
			 * the drag operation is completed and get its resulting DragEffects.
			 */
			DoDragDrop(
				data: Eto.Forms.DataObject,
				allowedEffects: Eto.Forms.DragEffects,
			): void;

			/**
			 * Starts drag operation using this control as drag source.
			 *
			 * This method can be blocking on some platforms (Wpf, WinForms), and non-blocking on
			 * others (Mac, Gtk). Use the {@link Eto.Forms.Control.DragEnd} event to determine when
			 * the drag operation is completed and get its resulting DragEffects.
			 */
			DoDragDrop(
				data: Eto.Forms.DataObject,
				allowedEffects: Eto.Forms.DragEffects,
				image: Eto.Drawing.Image,
				cursorOffset: Eto.Drawing.PointF,
			): void;

			/**
			 * Triggers the StyleChanged event and re-applies the styles to this control and its
			 * children.
			 */
			TriggerStyleChanged(): void;

			/** Shows a print dialog to print the specified control */
			Print(): void;

			/**
			 * Finds a control in the parent hierarchy with the specified type and
			 * {@link Eto.Widget.ID} if specified
			 */
			FindParent<T>(id?: string): T;

			/**
			 * Finds a control in the parent hierarchy with the specified type and
			 * {@link Eto.Widget.ID} if specified
			 */
			FindParent(
				type: unknown,
				id?: string,
			): Eto.Widget;

			/** Finds a control in the parent hierarchy with the specified `id` */
			FindParent(id: string): Eto.Widget;

			/**
			 * Unbinds any bindings in the {@link Eto.Forms.BindableWidget.Bindings} collection and
			 * removes the bindings
			 *
			 * When you implement {@link Eto.Forms.IBindableWidgetContainer}, this will also unbind
			 * any of its children.
			 */
			Unbind(): void;

			/**
			 * Updates all bindings in this widget
			 *
			 * When you implement {@link Eto.Forms.IBindableWidgetContainer}, this will also update
			 * bindings for all of its children.
			 */
			UpdateBindings(mode?: Eto.Forms.BindingUpdateMode): void;

			/** Disposes of this widget, supressing the finalizer */
			dispose(): void;

			/** Gets a string that represents the current object with its ID if specified. */
			ToString(): string;
		}
	}

	export namespace Eto.Forms.PasswordBox {
		export interface IHandler extends
			Eto.Forms.TextControl.IHandler,
			Eto.Forms.CommonControl.IHandler,
			Eto.Forms.Control.IHandler,
			Eto.Widget.IHandler {
			ReadOnly: boolean;

			MaxLength: number;

			PasswordChar: unknown;
		}
	}

	export namespace Eto.Forms {
		/** Control to show progress of a long running task */
		export class ProgressBar implements
			Eto.IHandlerSource,
			Eto.Forms.IBindable,
			Eto.Forms.IMouseInputSource,
			Eto.Forms.IKeyboardInputSource {
			constructor();

			/**
			 * Gets or sets the value of the progress bar that represents 100% complete. The default
			 * is 100.
			 */
			MaxValue: number;

			/**
			 * Gets or sets the minimum value of the progress that represents 0% complete. The
			 * default is 0.
			 */
			MinValue: number;

			/**
			 * Gets or sets the current progress that falls between
			 * {@link Eto.Forms.ProgressBar.MinValue} and {@link Eto.Forms.ProgressBar.MaxValue}
			 */
			Value: number;

			/**
			 * Gets or sets a value indicating whether the progress is indeterminate
			 *
			 * When indeterminate is true, the {@link Eto.Forms.ProgressBar.MaxValue} /
			 * {@link Eto.Forms.ProgressBar.MinValue} / {@link Eto.Forms.ProgressBar.Value} are
			 * ignored and will typically show in a continuous style.
			 */
			Indeterminate: boolean;

			/**
			 * Gets a value indicating that the control is loaded onto a form, that is it has been
			 * created, added to a parent, and shown
			 *
			 * The {@link Eto.Forms.Control.OnLoad(System.EventArgs)} method sets this value to true
			 * after cascading to all children (for a {@link Eto.Forms.Container} ) and calling the
			 * platform handler's implementation.  It is called after adding to a loaded form, or
			 * when showing a new form.  The {@link Eto.Forms.Control.OnUnLoad(System.EventArgs)}
			 * method will set this value to false when the control is removed from its parent
			 */
			readonly Loaded: boolean;

			/**
			 * Gets an enumeration of controls that are in the visual tree.
			 *
			 * This is used to specify which controls are contained by this instance that are part of
			 * the visual tree. This should include all controls including non-logical Eto controls
			 * used for layout.
			 */
			readonly VisualControls: Iterable<Eto.Forms.Control>;

			/**
			 * Gets or sets a user-defined object that contains data about the control
			 *
			 * A common use of the tag property is to store data that is associated with the control
			 * that you can later retrieve.
			 */
			Tag: unknown;

			/**
			 * Gets the logical parent control.
			 *
			 * When the control is part of the visual tree (
				 * {@link Eto.Forms.Control.IsVisualControl} is true), this returns the logical parent
				 * that contains this control. Otherwise this is the same as
				 * {@link Eto.Forms.Control.Parent}.
				 */
				readonly LogicalParent: Eto.Forms.Container;

			/** Gets a value indicating this {@link Eto.Forms.Control} is part of the visual tree. */
			IsVisualControl: boolean;

			/**
			 * Gets or sets the size of the control. Use -1 to specify auto sizing for either the
			 * width and/or height.
			 *
			 * Setting the size of controls is entirely optional as most controls will size
			 * themselves appropriately. When specifying a size, it will be used as the desired size
			 * of the control.  The container will reposition and resize the control depending on the
			 * available size.  For a {@link Eto.Forms.Window}, it is preferred to set the
			 * {@link Eto.Forms.Container.ClientSize} instead, as various platforms have different
			 * sizes of window decorations, toolbars, etc.
			 */
			Size: Eto.Drawing.Size;

			/**
			 * Gets a value indicating this control currently has mouse capture
			 *
			 * Mouse capture can happen during a handled MouseDown event until MouseUp, or it can be
			 * captured explicitly via {@link Eto.Forms.Control.CaptureMouse}.
			 */
			readonly IsMouseCaptured: boolean;

			/** Gets or sets the width of the control size. */
			Width: number;

			/** Gets or sets the height of the control size. */
			Height: number;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Forms.Control} (or its
			 * children) are enabled and accept user input.
			 *
			 * Typically when a control is disabled, the user cannot do anything with the control or
			 * any of its children. Including for example, selecting text in a text control. Certain
			 * controls can have a 'Read Only' mode, such as {@link Eto.Forms.TextBox.ReadOnly} which
			 * allow the user to  select text, but not change its contents.
			 */
			Enabled: boolean;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Forms.Control} is visible to
			 * the user.
			 *
			 * When the visibility of a control is set to false, it will not occupy space in the
			 * layout.
			 */
			Visible: boolean;

			/** Gets the container which this control has been added to, if any */
			readonly Parent: Eto.Forms.Container;

			/**
			 * Gets the visual container of this control, if any.
			 *
			 * Some containers may use other Eto controls to layout its children, such as the
			 * {@link Eto.Forms.StackLayout}. This will return the parent control that visually
			 * contains this control as opposed to {@link Eto.Forms.Control.Parent} which will return
			 * the logical parent.
			 */
			VisualParent: Eto.Forms.Container;

			/** Gets a value indicating this control has been attached to a native container */
			readonly IsAttached: boolean;

			/**
			 * Gets or sets the color for the background of the control
			 *
			 * Note that on some platforms (e.g. Mac), setting the background color of a control can
			 * change the performance characteristics of the control and its children, since it must
			 * enable layers to do so.
			 */
			BackgroundColor: Eto.Drawing.Color;

			/** Gets a value indicating whether this instance has the keyboard input focus. */
			readonly HasFocus: boolean;

			/** Gets a value indicating whether the layout of child controls is suspended. */
			readonly IsSuspended: boolean;

			/** Gets the window this control is contained in */
			readonly ParentWindow: Eto.Forms.Window;

			/**
			 * Gets the supported platform commands that can be used to hook up system functions to
			 * user defined logic
			 *
			 * This lists all available commands that can be mapped using the
			 * {@link Eto.Forms.Control.MapPlatformCommand(System.String,Eto.Forms.Command)} method
			 * of the control.
			 */
			readonly SupportedPlatformCommands: Iterable<string>;

			/** Gets the bounding rectangle of this control relative to its container */
			readonly Bounds: Eto.Drawing.Rectangle;

			/**
			 * Gets the location of the control as positioned by the container
			 *
			 * A control's location is set by the container. This can be used to determine where the
			 * control is for overlaying floating windows, menus, etc.
			 */
			readonly Location: Eto.Drawing.Point;

			/** Gets or sets the type of cursor to use when the mouse is hovering over the control */
			Cursor: Eto.Forms.Cursor;

			/** Gets or sets the tool tip to show when the mouse is hovered over the control */
			ToolTip: string;

			/**
			 * Gets or sets the tab index order for this control within its container.
			 *
			 * This sets the order when using the tab key to cycle through controls  Note that some
			 * platforms (Gtk and WinForms) may not support setting the context of the tab order to
			 * StackLayout  or DynamicLayout containers and may not behave exactly as expected. Use
			 * the {@link Eto.PlatformFeatures.TabIndexWithCustomContainers} flag to determine if it
			 * is supported.
			 */
			TabIndex: number;

			/** Gets or sets a value indicating whether this control can serve as drop target. */
			AllowDrop: boolean;

			/**
			 * Gets or sets the parent widget which this widget has been added to, if any
			 *
			 * When implementing child widgets that can participate in the context based binding
			 * (MVVM), You can set this to the parent widget when it is added or removed to it
			 * (usually via a collection).  Note that you should typically provide a public new
			 * [ParentWidget] Parent { get; } property  so that consumers of your API cannot set the
			 * parent to an invalid value.
			 */
			Parent: Eto.Widget;

			/**
			 * Gets an enumeration of all parent widgets in the heirarchy by traversing the
			 * {@link Eto.Forms.BindableWidget.Parent} property.
			 */
			readonly Parents: Iterable<Eto.Widget>;

			/**
			 * Gets or sets the data context for this widget for binding
			 *
			 * Subclasses may override the standard behaviour so that hierarchy of widgets can be
			 * taken into account.  For example, a Control may return the data context of a parent,
			 * if it is not set explicitly.
			 */
			DataContext: unknown;

			/** Gets the collection of bindings that are attached to this widget */
			readonly Bindings: Eto.Forms.BindingCollection;

			/**
			 * Gets a value indicating that the {@link Eto.Forms.BindableWidget.DataContext} property
			 * is changing.
			 *
			 * This can be used to determine when to allow certain logic during the update of the
			 * data context.  It is used to disable binding setters on the model when the data
			 * context changes so that a binding does not cause the view model to be updated when the
			 * state hasn't been fully set yet.
			 */
			IsDataContextChanging: boolean;

			/**
			 * Gets the platform that was used to create the {@link Eto.Widget.Handler} for this
			 * widget
			 *
			 * This gets set to the current {@link Eto.Platform.Instance} during the construction of
			 * the object
			 */
			readonly Platform: Eto.Platform;

			/** Gets the platform-specific handler for this widget */
			Handler: unknown;

			/** Gets the native platform-specific handle for integration purposes */
			readonly NativeHandle: unknown;

			/** Gets the dictionary of properties for this widget */
			readonly Properties: Eto.PropertyStore;

			/** Gets or sets the ID of this widget */
			ID: string;

			/**
			 * Gets or sets the style of this widget
			 *
			 * Styles allow you to attach custom platform-specific logic to a widget. In your
			 * platform-specific assembly, use {@link Style.Add{H}(string, StyleHandler{H})} to add
			 * the style logic with the same id.
			 */
			Style: string;

			/**
			 * Gets the instance of the platform-specific object
			 *
			 * This can sometimes be useful to get the platform-specific object. Some handlers may
			 * not have any backing object for its functionality, so this may be null.  It is more
			 * preferred to use the {@link Eto.Widget.Handler} and cast that to the platform-specific
			 * handler class which can give you additional methods and helpers to do common tasks.
			 * For example, the {@link Eto.Forms.Application} object's handler for OS X has a
			 * AddFullScreenMenuItem property to specify if you want full screen support in your app.
			 */
			readonly ControlObject: unknown;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Widget} has been disposed.
			 *
			 * When the widget is disposed, it can no longer be used.
			 */
			IsDisposed: boolean;

			/**
			 * Queues a repaint of the entire control on the screen and any of its children.
			 *
			 * This is only useful when the control is visible.
			 */
			Invalidate(): void;

			/**
			 * Queues a repaint of the entire control on the screen
			 *
			 * This is only useful when the control is visible.
			 */
			Invalidate(invalidateChildren: boolean): void;

			/**
			 * Queues a repaint of the specified `rect` of the control and any children.
			 *
			 * This is only useful when the control is visible.
			 */
			Invalidate(rect: Eto.Drawing.Rectangle): void;

			/**
			 * Queues a repaint of the specified `rect` of the control
			 *
			 * This is only useful when the control is visible.
			 */
			Invalidate(
				rect: Eto.Drawing.Rectangle,
				invalidateChildren: boolean,
			): void;

			/**
			 * Updates the layout of this control if necessary.
			 *
			 * This will ensure the control has had all of its layout applied so you can use its
			 * position and size right after this call. Most platforms (except WinForms) use a
			 * deferred layout system so that after adding your control to the form dynamically it
			 * won't get laid out until the next idle loop. This is useful when you need to know the
			 * dimensions of the control immediately. Note that this can be an expensive operation,
			 * so it is recommended to only call this method when necessary and after all of the
			 * controls have been added/updated.
			 */
			UpdateLayout(): void;

			/** Gets the preferred size of this control given infinite space available. */
			GetPreferredSize(): Eto.Drawing.SizeF;

			/** Gets the preferred size of this control given the specified `availableSize`. */
			GetPreferredSize(availableSize: Eto.Drawing.SizeF): Eto.Drawing.SizeF;

			/**
			 * Captures all mouse events to this control.
			 *
			 * This captures all mouse events until {@link Eto.Forms.Control.ReleaseMouseCapture} is
			 * called.  Note that not all platforms will allow a mouse capture unless the mouse is
			 * currently down.
			 */
			CaptureMouse(): boolean;

			/** Releases the mouse capture after a call to {@link Eto.Forms.Control.CaptureMouse}. */
			ReleaseMouseCapture(): void;

			/**
			 * Finds a control in the parent hierarchy with the specified type and
			 * {@link Eto.Widget.ID} if specified
			 */
			FindParent(
				type: unknown,
				id?: string,
			): Eto.Forms.Container;

			/** Finds a control in the parent hierarchy with the specified `id` */
			FindParent(id: string): Eto.Forms.Container;

			/**
			 * Detaches the control by removing it from its parent
			 *
			 * This is essentially a shortcut to myControl.Parent.Remove(myControl);
			 */
			Detach(): void;

			/**
			 * Attaches the control for direct use in a native application
			 *
			 * Use this to use a control directly in a native application.  Note that the native
			 * application must be running the same framework as the current platform.  E.g. a
			 * WinForms application can use an Eto.Forms control when using the Eto.WinForms
			 * platform.  This prepares the control by firing the {@link Eto.Forms.Control.PreLoad},
			 * {@link Eto.Forms.Control.Load}, etc. events.
			 */
			AttachNative(): void;

			/**
			 * Detaches the control when it is used in a native application, when you want to reuse
			 * the control.
			 *
			 * This should only be called after {@link Eto.Forms.Control.AttachNative} has been
			 * called, which is usually done by calling to ToNative(true) .
			 */
			DetachNative(): void;

			/**
			 * Attempts to set the keyboard input focus to this control, or the first child that
			 * accepts focus. For Windows, this will bring it to front and activate it.
			 */
			Focus(): void;

			/**
			 * Suspends the layout of child controls
			 *
			 * This can be used to optimize some platforms while adding, removing, or changing many
			 * child controls at once. It disables the calculation of control positioning until
			 * {@link Eto.Forms.Control.ResumeLayout} is called. Each call to SuspendLayout() must be
			 * balanced with a call to {@link Eto.Forms.Control.ResumeLayout}.
			 */
			SuspendLayout(): void;

			/**
			 * Resumes the layout after it has been suspended, and performs a layout
			 *
			 * This can be used to optimize some platforms while adding, removing, or changing many
			 * child controls at once. Each call to ResumeLayout() must be balanced with a call to
			 * {@link Eto.Forms.Control.SuspendLayout} before it.
			 */
			ResumeLayout(): void;

			/**
			 * Specifies a command to execute for a platform-specific command
			 *
			 * Some platforms have specific system-defined commands that can be associated with a
			 * control. For example, the Mac platform's cut/copy/paste functionality is defined by
			 * the system, and if you want to hook into it, you can use this to map it to your own
			 * defined logic. The valid values of the `systemCommand` parameter are defined by each
			 * platform, and a list can be retrieved using
			 * {@link Eto.Forms.Control.SupportedPlatformCommands}
			 */
			MapPlatformCommand(
				systemCommand: string,
				command: Eto.Forms.Command,
			): void;

			/** Converts a point from screen space to control space. */
			PointFromScreen(point: Eto.Drawing.PointF): Eto.Drawing.PointF;

			/** Converts a point from control space to screen space */
			PointToScreen(point: Eto.Drawing.PointF): Eto.Drawing.PointF;

			/** Converts a rectangle from screen space to control space. */
			RectangleToScreen(rect: Eto.Drawing.RectangleF): Eto.Drawing.RectangleF;

			/** Converts a rectangle from control space to screen space */
			RectangleFromScreen(rect: Eto.Drawing.RectangleF): Eto.Drawing.RectangleF;

			/**
			 * Starts drag operation using this control as drag source.
			 *
			 * This method can be blocking on some platforms (Wpf, WinForms), and non-blocking on
			 * others (Mac, Gtk). Use the {@link Eto.Forms.Control.DragEnd} event to determine when
			 * the drag operation is completed and get its resulting DragEffects.
			 */
			DoDragDrop(
				data: Eto.Forms.DataObject,
				allowedEffects: Eto.Forms.DragEffects,
			): void;

			/**
			 * Starts drag operation using this control as drag source.
			 *
			 * This method can be blocking on some platforms (Wpf, WinForms), and non-blocking on
			 * others (Mac, Gtk). Use the {@link Eto.Forms.Control.DragEnd} event to determine when
			 * the drag operation is completed and get its resulting DragEffects.
			 */
			DoDragDrop(
				data: Eto.Forms.DataObject,
				allowedEffects: Eto.Forms.DragEffects,
				image: Eto.Drawing.Image,
				cursorOffset: Eto.Drawing.PointF,
			): void;

			/**
			 * Triggers the StyleChanged event and re-applies the styles to this control and its
			 * children.
			 */
			TriggerStyleChanged(): void;

			/** Shows a print dialog to print the specified control */
			Print(): void;

			/**
			 * Finds a control in the parent hierarchy with the specified type and
			 * {@link Eto.Widget.ID} if specified
			 */
			FindParent<T>(id?: string): T;

			/**
			 * Finds a control in the parent hierarchy with the specified type and
			 * {@link Eto.Widget.ID} if specified
			 */
			FindParent(
				type: unknown,
				id?: string,
			): Eto.Widget;

			/** Finds a control in the parent hierarchy with the specified `id` */
			FindParent(id: string): Eto.Widget;

			/**
			 * Unbinds any bindings in the {@link Eto.Forms.BindableWidget.Bindings} collection and
			 * removes the bindings
			 *
			 * When you implement {@link Eto.Forms.IBindableWidgetContainer}, this will also unbind
			 * any of its children.
			 */
			Unbind(): void;

			/**
			 * Updates all bindings in this widget
			 *
			 * When you implement {@link Eto.Forms.IBindableWidgetContainer}, this will also update
			 * bindings for all of its children.
			 */
			UpdateBindings(mode?: Eto.Forms.BindingUpdateMode): void;

			/** Disposes of this widget, supressing the finalizer */
			dispose(): void;

			/** Gets a string that represents the current object with its ID if specified. */
			ToString(): string;
		}
	}

	export namespace Eto.Forms.ProgressBar {
		export interface IHandler extends
			Eto.Forms.Control.IHandler,
			Eto.Widget.IHandler {
			MaxValue: number;

			MinValue: number;

			Value: number;

			Indeterminate: boolean;
		}
	}

	export namespace Eto.Forms {
		/** Event arguments for the {@link Eto.Forms.PropertyGrid} when a value changes. */
		export class PropertyValueChangedEventArgs {
			/** Initializes a new instance of the PropertyValueChangedEventArgs class. */
			constructor(
				propertyName: string,
				oldValue: unknown,
				item: unknown,
			);

			/** Gets the old value of the property */
			readonly OldValue: unknown;

			/** Name of the property that was changed */
			readonly PropertyName: string;

			/** Item that the property was set on */
			readonly Item: unknown;
		}
	}

	export namespace Eto.Forms {
		/**
		 * Interface for custom type editors of the {@link Eto.Forms.PropertyGrid}
		 *
		 * Use the System.ComponentModel.EditorAttribute to specify the editor for a particular
		 * property or type. For example: [Editor(typeof(MyEditorClass),
		 * typeof(PropertyGridTypeEditor))]
		 */
		export class PropertyGridTypeEditor {
			/** Creates the control for editing (and viewing for platforms that support it) */
			CreateControl(args: Eto.Forms.CellEventArgs): Eto.Forms.Control;

			/**
			 * Paints the cell when viewing for platforms that don't support custom controls for
			 * non-editing cells (E.g. Gtk, WinForms).
			 */
			PaintCell(args: Eto.Forms.CellPaintEventArgs): void;
		}
	}

	export namespace Eto.Forms {
		/** Control to edit the properties of one or more objects. */
		export class PropertyGrid implements
			Eto.IHandlerSource,
			Eto.Forms.IBindable,
			Eto.Forms.IMouseInputSource,
			Eto.Forms.IKeyboardInputSource {
			constructor();

			/** Gets or sets the selected object for the grid to edit */
			SelectedObject: unknown;

			/**
			 * Gets or sets the selected objects for the grid to edit
			 *
			 * Only common properties (with the same name and type) will be shown.
			 */
			SelectedObjects: Iterable<unknown>;

			/** Gets or sets a value indicating that the categories should be shown */
			ShowCategories: boolean;

			/**
			 * Gets or sets a value indicating that the description panel should be shown
			 *
			 * The description panel shows the name and description of the selected property
			 */
			ShowDescription: boolean;

			/**
			 * Gets a value indicating that the control is loaded onto a form, that is it has been
			 * created, added to a parent, and shown
			 *
			 * The {@link Eto.Forms.Control.OnLoad(System.EventArgs)} method sets this value to true
			 * after cascading to all children (for a {@link Eto.Forms.Container} ) and calling the
			 * platform handler's implementation.  It is called after adding to a loaded form, or
			 * when showing a new form.  The {@link Eto.Forms.Control.OnUnLoad(System.EventArgs)}
			 * method will set this value to false when the control is removed from its parent
			 */
			readonly Loaded: boolean;

			/**
			 * Gets an enumeration of controls that are in the visual tree.
			 *
			 * This is used to specify which controls are contained by this instance that are part of
			 * the visual tree. This should include all controls including non-logical Eto controls
			 * used for layout.
			 */
			readonly VisualControls: Iterable<Eto.Forms.Control>;

			/**
			 * Gets or sets a user-defined object that contains data about the control
			 *
			 * A common use of the tag property is to store data that is associated with the control
			 * that you can later retrieve.
			 */
			Tag: unknown;

			/**
			 * Gets the logical parent control.
			 *
			 * When the control is part of the visual tree (
				 * {@link Eto.Forms.Control.IsVisualControl} is true), this returns the logical parent
				 * that contains this control. Otherwise this is the same as
				 * {@link Eto.Forms.Control.Parent}.
				 */
				readonly LogicalParent: Eto.Forms.Container;

			/** Gets a value indicating this {@link Eto.Forms.Control} is part of the visual tree. */
			IsVisualControl: boolean;

			/**
			 * Gets or sets the size of the control. Use -1 to specify auto sizing for either the
			 * width and/or height.
			 *
			 * Setting the size of controls is entirely optional as most controls will size
			 * themselves appropriately. When specifying a size, it will be used as the desired size
			 * of the control.  The container will reposition and resize the control depending on the
			 * available size.  For a {@link Eto.Forms.Window}, it is preferred to set the
			 * {@link Eto.Forms.Container.ClientSize} instead, as various platforms have different
			 * sizes of window decorations, toolbars, etc.
			 */
			Size: Eto.Drawing.Size;

			/**
			 * Gets a value indicating this control currently has mouse capture
			 *
			 * Mouse capture can happen during a handled MouseDown event until MouseUp, or it can be
			 * captured explicitly via {@link Eto.Forms.Control.CaptureMouse}.
			 */
			readonly IsMouseCaptured: boolean;

			/** Gets or sets the width of the control size. */
			Width: number;

			/** Gets or sets the height of the control size. */
			Height: number;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Forms.Control} (or its
			 * children) are enabled and accept user input.
			 *
			 * Typically when a control is disabled, the user cannot do anything with the control or
			 * any of its children. Including for example, selecting text in a text control. Certain
			 * controls can have a 'Read Only' mode, such as {@link Eto.Forms.TextBox.ReadOnly} which
			 * allow the user to  select text, but not change its contents.
			 */
			Enabled: boolean;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Forms.Control} is visible to
			 * the user.
			 *
			 * When the visibility of a control is set to false, it will not occupy space in the
			 * layout.
			 */
			Visible: boolean;

			/** Gets the container which this control has been added to, if any */
			readonly Parent: Eto.Forms.Container;

			/**
			 * Gets the visual container of this control, if any.
			 *
			 * Some containers may use other Eto controls to layout its children, such as the
			 * {@link Eto.Forms.StackLayout}. This will return the parent control that visually
			 * contains this control as opposed to {@link Eto.Forms.Control.Parent} which will return
			 * the logical parent.
			 */
			VisualParent: Eto.Forms.Container;

			/** Gets a value indicating this control has been attached to a native container */
			readonly IsAttached: boolean;

			/**
			 * Gets or sets the color for the background of the control
			 *
			 * Note that on some platforms (e.g. Mac), setting the background color of a control can
			 * change the performance characteristics of the control and its children, since it must
			 * enable layers to do so.
			 */
			BackgroundColor: Eto.Drawing.Color;

			/** Gets a value indicating whether this instance has the keyboard input focus. */
			readonly HasFocus: boolean;

			/** Gets a value indicating whether the layout of child controls is suspended. */
			readonly IsSuspended: boolean;

			/** Gets the window this control is contained in */
			readonly ParentWindow: Eto.Forms.Window;

			/**
			 * Gets the supported platform commands that can be used to hook up system functions to
			 * user defined logic
			 *
			 * This lists all available commands that can be mapped using the
			 * {@link Eto.Forms.Control.MapPlatformCommand(System.String,Eto.Forms.Command)} method
			 * of the control.
			 */
			readonly SupportedPlatformCommands: Iterable<string>;

			/** Gets the bounding rectangle of this control relative to its container */
			readonly Bounds: Eto.Drawing.Rectangle;

			/**
			 * Gets the location of the control as positioned by the container
			 *
			 * A control's location is set by the container. This can be used to determine where the
			 * control is for overlaying floating windows, menus, etc.
			 */
			readonly Location: Eto.Drawing.Point;

			/** Gets or sets the type of cursor to use when the mouse is hovering over the control */
			Cursor: Eto.Forms.Cursor;

			/** Gets or sets the tool tip to show when the mouse is hovered over the control */
			ToolTip: string;

			/**
			 * Gets or sets the tab index order for this control within its container.
			 *
			 * This sets the order when using the tab key to cycle through controls  Note that some
			 * platforms (Gtk and WinForms) may not support setting the context of the tab order to
			 * StackLayout  or DynamicLayout containers and may not behave exactly as expected. Use
			 * the {@link Eto.PlatformFeatures.TabIndexWithCustomContainers} flag to determine if it
			 * is supported.
			 */
			TabIndex: number;

			/** Gets or sets a value indicating whether this control can serve as drop target. */
			AllowDrop: boolean;

			/**
			 * Gets or sets the parent widget which this widget has been added to, if any
			 *
			 * When implementing child widgets that can participate in the context based binding
			 * (MVVM), You can set this to the parent widget when it is added or removed to it
			 * (usually via a collection).  Note that you should typically provide a public new
			 * [ParentWidget] Parent { get; } property  so that consumers of your API cannot set the
			 * parent to an invalid value.
			 */
			Parent: Eto.Widget;

			/**
			 * Gets an enumeration of all parent widgets in the heirarchy by traversing the
			 * {@link Eto.Forms.BindableWidget.Parent} property.
			 */
			readonly Parents: Iterable<Eto.Widget>;

			/**
			 * Gets or sets the data context for this widget for binding
			 *
			 * Subclasses may override the standard behaviour so that hierarchy of widgets can be
			 * taken into account.  For example, a Control may return the data context of a parent,
			 * if it is not set explicitly.
			 */
			DataContext: unknown;

			/** Gets the collection of bindings that are attached to this widget */
			readonly Bindings: Eto.Forms.BindingCollection;

			/**
			 * Gets a value indicating that the {@link Eto.Forms.BindableWidget.DataContext} property
			 * is changing.
			 *
			 * This can be used to determine when to allow certain logic during the update of the
			 * data context.  It is used to disable binding setters on the model when the data
			 * context changes so that a binding does not cause the view model to be updated when the
			 * state hasn't been fully set yet.
			 */
			IsDataContextChanging: boolean;

			/**
			 * Gets the platform that was used to create the {@link Eto.Widget.Handler} for this
			 * widget
			 *
			 * This gets set to the current {@link Eto.Platform.Instance} during the construction of
			 * the object
			 */
			readonly Platform: Eto.Platform;

			/** Gets the platform-specific handler for this widget */
			Handler: unknown;

			/** Gets the native platform-specific handle for integration purposes */
			readonly NativeHandle: unknown;

			/** Gets the dictionary of properties for this widget */
			readonly Properties: Eto.PropertyStore;

			/** Gets or sets the ID of this widget */
			ID: string;

			/**
			 * Gets or sets the style of this widget
			 *
			 * Styles allow you to attach custom platform-specific logic to a widget. In your
			 * platform-specific assembly, use {@link Style.Add{H}(string, StyleHandler{H})} to add
			 * the style logic with the same id.
			 */
			Style: string;

			/**
			 * Gets the instance of the platform-specific object
			 *
			 * This can sometimes be useful to get the platform-specific object. Some handlers may
			 * not have any backing object for its functionality, so this may be null.  It is more
			 * preferred to use the {@link Eto.Widget.Handler} and cast that to the platform-specific
			 * handler class which can give you additional methods and helpers to do common tasks.
			 * For example, the {@link Eto.Forms.Application} object's handler for OS X has a
			 * AddFullScreenMenuItem property to specify if you want full screen support in your app.
			 */
			readonly ControlObject: unknown;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Widget} has been disposed.
			 *
			 * When the widget is disposed, it can no longer be used.
			 */
			IsDisposed: boolean;

			/** Refreshes the grid with new values from the selected object(s) */
			Refresh(): void;

			/**
			 * Queues a repaint of the entire control on the screen and any of its children.
			 *
			 * This is only useful when the control is visible.
			 */
			Invalidate(): void;

			/**
			 * Queues a repaint of the entire control on the screen
			 *
			 * This is only useful when the control is visible.
			 */
			Invalidate(invalidateChildren: boolean): void;

			/**
			 * Queues a repaint of the specified `rect` of the control and any children.
			 *
			 * This is only useful when the control is visible.
			 */
			Invalidate(rect: Eto.Drawing.Rectangle): void;

			/**
			 * Queues a repaint of the specified `rect` of the control
			 *
			 * This is only useful when the control is visible.
			 */
			Invalidate(
				rect: Eto.Drawing.Rectangle,
				invalidateChildren: boolean,
			): void;

			/**
			 * Updates the layout of this control if necessary.
			 *
			 * This will ensure the control has had all of its layout applied so you can use its
			 * position and size right after this call. Most platforms (except WinForms) use a
			 * deferred layout system so that after adding your control to the form dynamically it
			 * won't get laid out until the next idle loop. This is useful when you need to know the
			 * dimensions of the control immediately. Note that this can be an expensive operation,
			 * so it is recommended to only call this method when necessary and after all of the
			 * controls have been added/updated.
			 */
			UpdateLayout(): void;

			/** Gets the preferred size of this control given infinite space available. */
			GetPreferredSize(): Eto.Drawing.SizeF;

			/** Gets the preferred size of this control given the specified `availableSize`. */
			GetPreferredSize(availableSize: Eto.Drawing.SizeF): Eto.Drawing.SizeF;

			/**
			 * Captures all mouse events to this control.
			 *
			 * This captures all mouse events until {@link Eto.Forms.Control.ReleaseMouseCapture} is
			 * called.  Note that not all platforms will allow a mouse capture unless the mouse is
			 * currently down.
			 */
			CaptureMouse(): boolean;

			/** Releases the mouse capture after a call to {@link Eto.Forms.Control.CaptureMouse}. */
			ReleaseMouseCapture(): void;

			/**
			 * Finds a control in the parent hierarchy with the specified type and
			 * {@link Eto.Widget.ID} if specified
			 */
			FindParent(
				type: unknown,
				id?: string,
			): Eto.Forms.Container;

			/** Finds a control in the parent hierarchy with the specified `id` */
			FindParent(id: string): Eto.Forms.Container;

			/**
			 * Detaches the control by removing it from its parent
			 *
			 * This is essentially a shortcut to myControl.Parent.Remove(myControl);
			 */
			Detach(): void;

			/**
			 * Attaches the control for direct use in a native application
			 *
			 * Use this to use a control directly in a native application.  Note that the native
			 * application must be running the same framework as the current platform.  E.g. a
			 * WinForms application can use an Eto.Forms control when using the Eto.WinForms
			 * platform.  This prepares the control by firing the {@link Eto.Forms.Control.PreLoad},
			 * {@link Eto.Forms.Control.Load}, etc. events.
			 */
			AttachNative(): void;

			/**
			 * Detaches the control when it is used in a native application, when you want to reuse
			 * the control.
			 *
			 * This should only be called after {@link Eto.Forms.Control.AttachNative} has been
			 * called, which is usually done by calling to ToNative(true) .
			 */
			DetachNative(): void;

			/**
			 * Attempts to set the keyboard input focus to this control, or the first child that
			 * accepts focus. For Windows, this will bring it to front and activate it.
			 */
			Focus(): void;

			/**
			 * Suspends the layout of child controls
			 *
			 * This can be used to optimize some platforms while adding, removing, or changing many
			 * child controls at once. It disables the calculation of control positioning until
			 * {@link Eto.Forms.Control.ResumeLayout} is called. Each call to SuspendLayout() must be
			 * balanced with a call to {@link Eto.Forms.Control.ResumeLayout}.
			 */
			SuspendLayout(): void;

			/**
			 * Resumes the layout after it has been suspended, and performs a layout
			 *
			 * This can be used to optimize some platforms while adding, removing, or changing many
			 * child controls at once. Each call to ResumeLayout() must be balanced with a call to
			 * {@link Eto.Forms.Control.SuspendLayout} before it.
			 */
			ResumeLayout(): void;

			/**
			 * Specifies a command to execute for a platform-specific command
			 *
			 * Some platforms have specific system-defined commands that can be associated with a
			 * control. For example, the Mac platform's cut/copy/paste functionality is defined by
			 * the system, and if you want to hook into it, you can use this to map it to your own
			 * defined logic. The valid values of the `systemCommand` parameter are defined by each
			 * platform, and a list can be retrieved using
			 * {@link Eto.Forms.Control.SupportedPlatformCommands}
			 */
			MapPlatformCommand(
				systemCommand: string,
				command: Eto.Forms.Command,
			): void;

			/** Converts a point from screen space to control space. */
			PointFromScreen(point: Eto.Drawing.PointF): Eto.Drawing.PointF;

			/** Converts a point from control space to screen space */
			PointToScreen(point: Eto.Drawing.PointF): Eto.Drawing.PointF;

			/** Converts a rectangle from screen space to control space. */
			RectangleToScreen(rect: Eto.Drawing.RectangleF): Eto.Drawing.RectangleF;

			/** Converts a rectangle from control space to screen space */
			RectangleFromScreen(rect: Eto.Drawing.RectangleF): Eto.Drawing.RectangleF;

			/**
			 * Starts drag operation using this control as drag source.
			 *
			 * This method can be blocking on some platforms (Wpf, WinForms), and non-blocking on
			 * others (Mac, Gtk). Use the {@link Eto.Forms.Control.DragEnd} event to determine when
			 * the drag operation is completed and get its resulting DragEffects.
			 */
			DoDragDrop(
				data: Eto.Forms.DataObject,
				allowedEffects: Eto.Forms.DragEffects,
			): void;

			/**
			 * Starts drag operation using this control as drag source.
			 *
			 * This method can be blocking on some platforms (Wpf, WinForms), and non-blocking on
			 * others (Mac, Gtk). Use the {@link Eto.Forms.Control.DragEnd} event to determine when
			 * the drag operation is completed and get its resulting DragEffects.
			 */
			DoDragDrop(
				data: Eto.Forms.DataObject,
				allowedEffects: Eto.Forms.DragEffects,
				image: Eto.Drawing.Image,
				cursorOffset: Eto.Drawing.PointF,
			): void;

			/**
			 * Triggers the StyleChanged event and re-applies the styles to this control and its
			 * children.
			 */
			TriggerStyleChanged(): void;

			/** Shows a print dialog to print the specified control */
			Print(): void;

			/**
			 * Finds a control in the parent hierarchy with the specified type and
			 * {@link Eto.Widget.ID} if specified
			 */
			FindParent<T>(id?: string): T;

			/**
			 * Finds a control in the parent hierarchy with the specified type and
			 * {@link Eto.Widget.ID} if specified
			 */
			FindParent(
				type: unknown,
				id?: string,
			): Eto.Widget;

			/** Finds a control in the parent hierarchy with the specified `id` */
			FindParent(id: string): Eto.Widget;

			/**
			 * Unbinds any bindings in the {@link Eto.Forms.BindableWidget.Bindings} collection and
			 * removes the bindings
			 *
			 * When you implement {@link Eto.Forms.IBindableWidgetContainer}, this will also unbind
			 * any of its children.
			 */
			Unbind(): void;

			/**
			 * Updates all bindings in this widget
			 *
			 * When you implement {@link Eto.Forms.IBindableWidgetContainer}, this will also update
			 * bindings for all of its children.
			 */
			UpdateBindings(mode?: Eto.Forms.BindingUpdateMode): void;

			/** Disposes of this widget, supressing the finalizer */
			dispose(): void;

			/** Gets a string that represents the current object with its ID if specified. */
			ToString(): string;
		}
	}

	export namespace Eto.Forms.PropertyGrid {
		export interface ICallback extends
			Eto.Forms.Control.ICallback,
			Eto.Widget.ICallback {
			OnPropertyValueChanged(
				widget: Eto.Forms.PropertyGrid,
				e: Eto.Forms.PropertyValueChangedEventArgs,
			): void;
		}
	}

	export namespace Eto.Forms.PropertyGrid {
		export interface IHandler extends
			Eto.Forms.Control.IHandler,
			Eto.Widget.IHandler {
			SelectedObject: unknown;

			SelectedObjects: Iterable<unknown>;

			ShowCategories: boolean;

			ShowDescription: boolean;

			Refresh(): void;
		}
	}

	export namespace Eto.Forms {
		/**
		 * Control to present a button to choose from a set of options
		 *
		 * The RadioButton works with other radio buttons to present a list of options that the
		 * user can select from. When a radio button is toggled on, all others that are linked
		 * together will be toggled off.  To link radio buttons together, use the
		 * {@link Eto.Forms.RadioButton(RadioButton)} constructor to specify the controller radio
		 * button, which can be created with the default constructor.
		 */
		export class RadioButton implements
			Eto.IHandlerSource,
			Eto.Forms.IBindable,
			Eto.Forms.IMouseInputSource,
			Eto.Forms.IKeyboardInputSource {
			/** Initializes a new instance of the {@link Eto.Forms.RadioButton} class. */
			constructor();

			/** Initializes a new instance of the {@link Eto.Forms.RadioButton} class. */
			constructor(controller?: Eto.Forms.RadioButton);

			/**
			 * Gets or sets the command to invoke when the radio button is pressed.
			 *
			 * This will invoke the specified command when the radio button is pressed. The
			 * {@link System.Windows.Input.ICommand.CanExecute(System.Object)} will also used to set
			 * the enabled/disabled state of the button.
			 */
			Command: unknown;

			/**
			 * Gets or sets the parameter to pass to the {@link Eto.Forms.RadioButton.Command} when
			 * executing or determining its CanExecute state.
			 */
			CommandParameter: unknown;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Forms.RadioButton} is checked.
			 */
			Checked: boolean;

			/**
			 * Gets or sets the text of the control.
			 *
			 * Usually, the caret and selection will be set to the end of the string after its set.
			 */
			Text: string;

			/**
			 * Gets or sets the color of the text.
			 *
			 * By default, the text will get a color based on the user's theme. However, this is
			 * usually black.
			 */
			TextColor: Eto.Drawing.Color;

			/** Gets the binding for the {@link Eto.Forms.TextControl.Text} property. */
			readonly TextBinding: Eto.Forms.BindableBinding$2<Eto.Forms.TextControl, string>;

			/** Gets or sets the font for the text of the control */
			Font: Eto.Drawing.Font;

			/**
			 * Gets a value indicating that the control is loaded onto a form, that is it has been
			 * created, added to a parent, and shown
			 *
			 * The {@link Eto.Forms.Control.OnLoad(System.EventArgs)} method sets this value to true
			 * after cascading to all children (for a {@link Eto.Forms.Container} ) and calling the
			 * platform handler's implementation.  It is called after adding to a loaded form, or
			 * when showing a new form.  The {@link Eto.Forms.Control.OnUnLoad(System.EventArgs)}
			 * method will set this value to false when the control is removed from its parent
			 */
			readonly Loaded: boolean;

			/**
			 * Gets an enumeration of controls that are in the visual tree.
			 *
			 * This is used to specify which controls are contained by this instance that are part of
			 * the visual tree. This should include all controls including non-logical Eto controls
			 * used for layout.
			 */
			readonly VisualControls: Iterable<Eto.Forms.Control>;

			/**
			 * Gets or sets a user-defined object that contains data about the control
			 *
			 * A common use of the tag property is to store data that is associated with the control
			 * that you can later retrieve.
			 */
			Tag: unknown;

			/**
			 * Gets the logical parent control.
			 *
			 * When the control is part of the visual tree (
				 * {@link Eto.Forms.Control.IsVisualControl} is true), this returns the logical parent
				 * that contains this control. Otherwise this is the same as
				 * {@link Eto.Forms.Control.Parent}.
				 */
				readonly LogicalParent: Eto.Forms.Container;

			/** Gets a value indicating this {@link Eto.Forms.Control} is part of the visual tree. */
			IsVisualControl: boolean;

			/**
			 * Gets or sets the size of the control. Use -1 to specify auto sizing for either the
			 * width and/or height.
			 *
			 * Setting the size of controls is entirely optional as most controls will size
			 * themselves appropriately. When specifying a size, it will be used as the desired size
			 * of the control.  The container will reposition and resize the control depending on the
			 * available size.  For a {@link Eto.Forms.Window}, it is preferred to set the
			 * {@link Eto.Forms.Container.ClientSize} instead, as various platforms have different
			 * sizes of window decorations, toolbars, etc.
			 */
			Size: Eto.Drawing.Size;

			/**
			 * Gets a value indicating this control currently has mouse capture
			 *
			 * Mouse capture can happen during a handled MouseDown event until MouseUp, or it can be
			 * captured explicitly via {@link Eto.Forms.Control.CaptureMouse}.
			 */
			readonly IsMouseCaptured: boolean;

			/** Gets or sets the width of the control size. */
			Width: number;

			/** Gets or sets the height of the control size. */
			Height: number;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Forms.Control} (or its
			 * children) are enabled and accept user input.
			 *
			 * Typically when a control is disabled, the user cannot do anything with the control or
			 * any of its children. Including for example, selecting text in a text control. Certain
			 * controls can have a 'Read Only' mode, such as {@link Eto.Forms.TextBox.ReadOnly} which
			 * allow the user to  select text, but not change its contents.
			 */
			Enabled: boolean;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Forms.Control} is visible to
			 * the user.
			 *
			 * When the visibility of a control is set to false, it will not occupy space in the
			 * layout.
			 */
			Visible: boolean;

			/** Gets the container which this control has been added to, if any */
			readonly Parent: Eto.Forms.Container;

			/**
			 * Gets the visual container of this control, if any.
			 *
			 * Some containers may use other Eto controls to layout its children, such as the
			 * {@link Eto.Forms.StackLayout}. This will return the parent control that visually
			 * contains this control as opposed to {@link Eto.Forms.Control.Parent} which will return
			 * the logical parent.
			 */
			VisualParent: Eto.Forms.Container;

			/** Gets a value indicating this control has been attached to a native container */
			readonly IsAttached: boolean;

			/**
			 * Gets or sets the color for the background of the control
			 *
			 * Note that on some platforms (e.g. Mac), setting the background color of a control can
			 * change the performance characteristics of the control and its children, since it must
			 * enable layers to do so.
			 */
			BackgroundColor: Eto.Drawing.Color;

			/** Gets a value indicating whether this instance has the keyboard input focus. */
			readonly HasFocus: boolean;

			/** Gets a value indicating whether the layout of child controls is suspended. */
			readonly IsSuspended: boolean;

			/** Gets the window this control is contained in */
			readonly ParentWindow: Eto.Forms.Window;

			/**
			 * Gets the supported platform commands that can be used to hook up system functions to
			 * user defined logic
			 *
			 * This lists all available commands that can be mapped using the
			 * {@link Eto.Forms.Control.MapPlatformCommand(System.String,Eto.Forms.Command)} method
			 * of the control.
			 */
			readonly SupportedPlatformCommands: Iterable<string>;

			/** Gets the bounding rectangle of this control relative to its container */
			readonly Bounds: Eto.Drawing.Rectangle;

			/**
			 * Gets the location of the control as positioned by the container
			 *
			 * A control's location is set by the container. This can be used to determine where the
			 * control is for overlaying floating windows, menus, etc.
			 */
			readonly Location: Eto.Drawing.Point;

			/** Gets or sets the type of cursor to use when the mouse is hovering over the control */
			Cursor: Eto.Forms.Cursor;

			/** Gets or sets the tool tip to show when the mouse is hovered over the control */
			ToolTip: string;

			/**
			 * Gets or sets the tab index order for this control within its container.
			 *
			 * This sets the order when using the tab key to cycle through controls  Note that some
			 * platforms (Gtk and WinForms) may not support setting the context of the tab order to
			 * StackLayout  or DynamicLayout containers and may not behave exactly as expected. Use
			 * the {@link Eto.PlatformFeatures.TabIndexWithCustomContainers} flag to determine if it
			 * is supported.
			 */
			TabIndex: number;

			/** Gets or sets a value indicating whether this control can serve as drop target. */
			AllowDrop: boolean;

			/**
			 * Gets or sets the parent widget which this widget has been added to, if any
			 *
			 * When implementing child widgets that can participate in the context based binding
			 * (MVVM), You can set this to the parent widget when it is added or removed to it
			 * (usually via a collection).  Note that you should typically provide a public new
			 * [ParentWidget] Parent { get; } property  so that consumers of your API cannot set the
			 * parent to an invalid value.
			 */
			Parent: Eto.Widget;

			/**
			 * Gets an enumeration of all parent widgets in the heirarchy by traversing the
			 * {@link Eto.Forms.BindableWidget.Parent} property.
			 */
			readonly Parents: Iterable<Eto.Widget>;

			/**
			 * Gets or sets the data context for this widget for binding
			 *
			 * Subclasses may override the standard behaviour so that hierarchy of widgets can be
			 * taken into account.  For example, a Control may return the data context of a parent,
			 * if it is not set explicitly.
			 */
			DataContext: unknown;

			/** Gets the collection of bindings that are attached to this widget */
			readonly Bindings: Eto.Forms.BindingCollection;

			/**
			 * Gets a value indicating that the {@link Eto.Forms.BindableWidget.DataContext} property
			 * is changing.
			 *
			 * This can be used to determine when to allow certain logic during the update of the
			 * data context.  It is used to disable binding setters on the model when the data
			 * context changes so that a binding does not cause the view model to be updated when the
			 * state hasn't been fully set yet.
			 */
			IsDataContextChanging: boolean;

			/**
			 * Gets the platform that was used to create the {@link Eto.Widget.Handler} for this
			 * widget
			 *
			 * This gets set to the current {@link Eto.Platform.Instance} during the construction of
			 * the object
			 */
			readonly Platform: Eto.Platform;

			/** Gets the platform-specific handler for this widget */
			Handler: unknown;

			/** Gets the native platform-specific handle for integration purposes */
			readonly NativeHandle: unknown;

			/** Gets the dictionary of properties for this widget */
			readonly Properties: Eto.PropertyStore;

			/** Gets or sets the ID of this widget */
			ID: string;

			/**
			 * Gets or sets the style of this widget
			 *
			 * Styles allow you to attach custom platform-specific logic to a widget. In your
			 * platform-specific assembly, use {@link Style.Add{H}(string, StyleHandler{H})} to add
			 * the style logic with the same id.
			 */
			Style: string;

			/**
			 * Gets the instance of the platform-specific object
			 *
			 * This can sometimes be useful to get the platform-specific object. Some handlers may
			 * not have any backing object for its functionality, so this may be null.  It is more
			 * preferred to use the {@link Eto.Widget.Handler} and cast that to the platform-specific
			 * handler class which can give you additional methods and helpers to do common tasks.
			 * For example, the {@link Eto.Forms.Application} object's handler for OS X has a
			 * AddFullScreenMenuItem property to specify if you want full screen support in your app.
			 */
			readonly ControlObject: unknown;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Widget} has been disposed.
			 *
			 * When the widget is disposed, it can no longer be used.
			 */
			IsDisposed: boolean;

			/**
			 * Queues a repaint of the entire control on the screen and any of its children.
			 *
			 * This is only useful when the control is visible.
			 */
			Invalidate(): void;

			/**
			 * Queues a repaint of the entire control on the screen
			 *
			 * This is only useful when the control is visible.
			 */
			Invalidate(invalidateChildren: boolean): void;

			/**
			 * Queues a repaint of the specified `rect` of the control and any children.
			 *
			 * This is only useful when the control is visible.
			 */
			Invalidate(rect: Eto.Drawing.Rectangle): void;

			/**
			 * Queues a repaint of the specified `rect` of the control
			 *
			 * This is only useful when the control is visible.
			 */
			Invalidate(
				rect: Eto.Drawing.Rectangle,
				invalidateChildren: boolean,
			): void;

			/**
			 * Updates the layout of this control if necessary.
			 *
			 * This will ensure the control has had all of its layout applied so you can use its
			 * position and size right after this call. Most platforms (except WinForms) use a
			 * deferred layout system so that after adding your control to the form dynamically it
			 * won't get laid out until the next idle loop. This is useful when you need to know the
			 * dimensions of the control immediately. Note that this can be an expensive operation,
			 * so it is recommended to only call this method when necessary and after all of the
			 * controls have been added/updated.
			 */
			UpdateLayout(): void;

			/** Gets the preferred size of this control given infinite space available. */
			GetPreferredSize(): Eto.Drawing.SizeF;

			/** Gets the preferred size of this control given the specified `availableSize`. */
			GetPreferredSize(availableSize: Eto.Drawing.SizeF): Eto.Drawing.SizeF;

			/**
			 * Captures all mouse events to this control.
			 *
			 * This captures all mouse events until {@link Eto.Forms.Control.ReleaseMouseCapture} is
			 * called.  Note that not all platforms will allow a mouse capture unless the mouse is
			 * currently down.
			 */
			CaptureMouse(): boolean;

			/** Releases the mouse capture after a call to {@link Eto.Forms.Control.CaptureMouse}. */
			ReleaseMouseCapture(): void;

			/**
			 * Finds a control in the parent hierarchy with the specified type and
			 * {@link Eto.Widget.ID} if specified
			 */
			FindParent(
				type: unknown,
				id?: string,
			): Eto.Forms.Container;

			/** Finds a control in the parent hierarchy with the specified `id` */
			FindParent(id: string): Eto.Forms.Container;

			/**
			 * Detaches the control by removing it from its parent
			 *
			 * This is essentially a shortcut to myControl.Parent.Remove(myControl);
			 */
			Detach(): void;

			/**
			 * Attaches the control for direct use in a native application
			 *
			 * Use this to use a control directly in a native application.  Note that the native
			 * application must be running the same framework as the current platform.  E.g. a
			 * WinForms application can use an Eto.Forms control when using the Eto.WinForms
			 * platform.  This prepares the control by firing the {@link Eto.Forms.Control.PreLoad},
			 * {@link Eto.Forms.Control.Load}, etc. events.
			 */
			AttachNative(): void;

			/**
			 * Detaches the control when it is used in a native application, when you want to reuse
			 * the control.
			 *
			 * This should only be called after {@link Eto.Forms.Control.AttachNative} has been
			 * called, which is usually done by calling to ToNative(true) .
			 */
			DetachNative(): void;

			/**
			 * Attempts to set the keyboard input focus to this control, or the first child that
			 * accepts focus. For Windows, this will bring it to front and activate it.
			 */
			Focus(): void;

			/**
			 * Suspends the layout of child controls
			 *
			 * This can be used to optimize some platforms while adding, removing, or changing many
			 * child controls at once. It disables the calculation of control positioning until
			 * {@link Eto.Forms.Control.ResumeLayout} is called. Each call to SuspendLayout() must be
			 * balanced with a call to {@link Eto.Forms.Control.ResumeLayout}.
			 */
			SuspendLayout(): void;

			/**
			 * Resumes the layout after it has been suspended, and performs a layout
			 *
			 * This can be used to optimize some platforms while adding, removing, or changing many
			 * child controls at once. Each call to ResumeLayout() must be balanced with a call to
			 * {@link Eto.Forms.Control.SuspendLayout} before it.
			 */
			ResumeLayout(): void;

			/**
			 * Specifies a command to execute for a platform-specific command
			 *
			 * Some platforms have specific system-defined commands that can be associated with a
			 * control. For example, the Mac platform's cut/copy/paste functionality is defined by
			 * the system, and if you want to hook into it, you can use this to map it to your own
			 * defined logic. The valid values of the `systemCommand` parameter are defined by each
			 * platform, and a list can be retrieved using
			 * {@link Eto.Forms.Control.SupportedPlatformCommands}
			 */
			MapPlatformCommand(
				systemCommand: string,
				command: Eto.Forms.Command,
			): void;

			/** Converts a point from screen space to control space. */
			PointFromScreen(point: Eto.Drawing.PointF): Eto.Drawing.PointF;

			/** Converts a point from control space to screen space */
			PointToScreen(point: Eto.Drawing.PointF): Eto.Drawing.PointF;

			/** Converts a rectangle from screen space to control space. */
			RectangleToScreen(rect: Eto.Drawing.RectangleF): Eto.Drawing.RectangleF;

			/** Converts a rectangle from control space to screen space */
			RectangleFromScreen(rect: Eto.Drawing.RectangleF): Eto.Drawing.RectangleF;

			/**
			 * Starts drag operation using this control as drag source.
			 *
			 * This method can be blocking on some platforms (Wpf, WinForms), and non-blocking on
			 * others (Mac, Gtk). Use the {@link Eto.Forms.Control.DragEnd} event to determine when
			 * the drag operation is completed and get its resulting DragEffects.
			 */
			DoDragDrop(
				data: Eto.Forms.DataObject,
				allowedEffects: Eto.Forms.DragEffects,
			): void;

			/**
			 * Starts drag operation using this control as drag source.
			 *
			 * This method can be blocking on some platforms (Wpf, WinForms), and non-blocking on
			 * others (Mac, Gtk). Use the {@link Eto.Forms.Control.DragEnd} event to determine when
			 * the drag operation is completed and get its resulting DragEffects.
			 */
			DoDragDrop(
				data: Eto.Forms.DataObject,
				allowedEffects: Eto.Forms.DragEffects,
				image: Eto.Drawing.Image,
				cursorOffset: Eto.Drawing.PointF,
			): void;

			/**
			 * Triggers the StyleChanged event and re-applies the styles to this control and its
			 * children.
			 */
			TriggerStyleChanged(): void;

			/** Shows a print dialog to print the specified control */
			Print(): void;

			/**
			 * Finds a control in the parent hierarchy with the specified type and
			 * {@link Eto.Widget.ID} if specified
			 */
			FindParent<T>(id?: string): T;

			/**
			 * Finds a control in the parent hierarchy with the specified type and
			 * {@link Eto.Widget.ID} if specified
			 */
			FindParent(
				type: unknown,
				id?: string,
			): Eto.Widget;

			/** Finds a control in the parent hierarchy with the specified `id` */
			FindParent(id: string): Eto.Widget;

			/**
			 * Unbinds any bindings in the {@link Eto.Forms.BindableWidget.Bindings} collection and
			 * removes the bindings
			 *
			 * When you implement {@link Eto.Forms.IBindableWidgetContainer}, this will also unbind
			 * any of its children.
			 */
			Unbind(): void;

			/**
			 * Updates all bindings in this widget
			 *
			 * When you implement {@link Eto.Forms.IBindableWidgetContainer}, this will also update
			 * bindings for all of its children.
			 */
			UpdateBindings(mode?: Eto.Forms.BindingUpdateMode): void;

			/** Disposes of this widget, supressing the finalizer */
			dispose(): void;

			/** Gets a string that represents the current object with its ID if specified. */
			ToString(): string;
		}
	}

	export namespace Eto.Forms.RadioButton {
		export interface ICallback extends
			Eto.Forms.TextControl.ICallback,
			Eto.Forms.Control.ICallback,
			Eto.Widget.ICallback {
			OnClick(
				widget: Eto.Forms.RadioButton,
				e: unknown,
			): void;

			OnCheckedChanged(
				widget: Eto.Forms.RadioButton,
				e: unknown,
			): void;
		}
	}

	export namespace Eto.Forms.RadioButton {
		export interface IHandler extends
			Eto.Forms.TextControl.IHandler,
			Eto.Forms.CommonControl.IHandler,
			Eto.Forms.Control.IHandler,
			Eto.Widget.IHandler {
			Checked: boolean;

			Create(controller: Eto.Forms.RadioButton): void;
		}
	}

	export namespace Eto.Forms {
		/**
		 * Shows a list of radio buttons.
		 *
		 * The list of items can be added manually using {@link Eto.Forms.RadioButtonList.Items},
		 * or  use the {@link Eto.Forms.RadioButtonList.DataStore} to have a dynamic list of
		 * items controlled by a custom collection.
		 */
		export class RadioButtonList implements
			Eto.IHandlerSource,
			Eto.Forms.IBindable,
			Eto.Forms.IMouseInputSource,
			Eto.Forms.IKeyboardInputSource {
			/** Initializes a new instance of the {@link Eto.Forms.RadioButtonList} class. */
			constructor();

			/**
			 * Gets or sets the binding to get the text for each radio button.
			 *
			 * By default, this will bind to a "Text" property, or {@link Eto.Forms.IListItem.Text}
			 * when implemented.
			 */
			ItemTextBinding: Eto.Forms.IIndirectBinding$1<string>;

			/**
			 * Gets or sets the binding to get the key for each radio button.
			 *
			 * By default, this will bind to a "Key" property, or {@link Eto.Forms.IListItem.Key}
			 * when implemented.
			 */
			ItemKeyBinding: Eto.Forms.IIndirectBinding$1<string>;

			/** Gets or sets the binding to get the tooltip text for each radio button. */
			ItemToolTipBinding: Eto.Forms.IIndirectBinding$1<string>;

			/**
			 * Gets or sets the binding to get the text for each radio button.
			 *
			 * By default, this will bind to a "Text" property, or {@link Eto.Forms.IListItem.Text}
			 * when implemented.
			 */
			TextBinding: Eto.Forms.IIndirectBinding$1<string>;

			/**
			 * Gets or sets the binding to get the key for each radio button.
			 *
			 * By default, this will bind to a "Key" property, or {@link Eto.Forms.IListItem.Key}
			 * when implemented.
			 */
			KeyBinding: Eto.Forms.IIndirectBinding$1<string>;

			/**
			 * Gets or sets the selected key of the currently selected item using the
			 * {@link Eto.Forms.RadioButtonList.ItemKeyBinding}.
			 */
			SelectedKey: string;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Forms.RadioButtonList} is
			 * enabled.
			 *
			 * When the control is disabled, the user will not be able to change the selected radio
			 * button. However, you can still programatically change the selection.
			 */
			Enabled: boolean;

			/**
			 * Gets or sets the selected value, which is the {@link Eto.Forms.ListItem} or object in
			 * your custom data store.
			 */
			SelectedValue: unknown;

			/** Gets or sets the index of the selected item. */
			SelectedIndex: number;

			/** Gets or sets the color of the radio button text. */
			TextColor: Eto.Drawing.Color;

			/** Gets or sets the orientation of the radio buttons. */
			Orientation: Eto.Forms.Orientation;

			/** Gets or sets the spacing between each radio button. */
			Spacing: Eto.Drawing.Size;

			/**
			 * Gets the item collection, when adding items programatically.
			 *
			 * This is used when you want to add items manually.  Use the
			 * {@link Eto.Forms.RadioButtonList.DataStore} when you have an existing collection you
			 * want to bind to directly.
			 */
			readonly Items: Eto.Forms.ListItemCollection;

			/**
			 * Gets or sets the data store of the items shown in the list.
			 *
			 * When using a custom object collection, you can use the
			 * {@link Eto.Forms.RadioButtonList.ItemTextBinding} and
			 * {@link Eto.Forms.RadioButtonList.ItemKeyBinding} to specify how to get the text/key
			 * values for each item.
			 */
			DataStore: Iterable<unknown>;

			/** Gets a binding to the {@link Eto.Forms.RadioButtonList.SelectedValue} property. */
			readonly SelectedValueBinding: Eto.Forms.BindableBinding$2<Eto.Forms.RadioButtonList, unknown>;

			/** Gets a binding to the {@link Eto.Forms.RadioButtonList.SelectedIndex} property. */
			readonly SelectedIndexBinding: Eto.Forms.BindableBinding$2<Eto.Forms.RadioButtonList, number>;

			/** Gets a binding to the {@link Eto.Forms.RadioButtonList.SelectedKey} property. */
			readonly SelectedKeyBinding: Eto.Forms.BindableBinding$2<Eto.Forms.RadioButtonList, string>;

			/** Gets an enumeration of controls that are directly contained by this container */
			readonly Controls: Iterable<Eto.Forms.Control>;

			/** Gets or sets the padding around the {@link Eto.Forms.Panel.Content} of the panel. */
			Padding: Eto.Drawing.Padding;

			/** Gets or sets the minimum size of the panel. */
			MinimumSize: Eto.Drawing.Size;

			/**
			 * Gets or sets the context menu for the panel.
			 *
			 * The context menu is usually shown when the user right clicks the control, or in mobile
			 * platforms when the user taps and holds their finger down on the control.
			 */
			ContextMenu: Eto.Forms.ContextMenu;

			/**
			 * Gets or sets the main content of the panel.
			 *
			 * The main content will be offset by the {@link Eto.Forms.Panel.Padding} value
			 * specified, and will take up the entire content area of the control. Some controls may
			 * have decorations that will surround the content, such as a {@link Eto.Forms.GroupBox},
			 * {@link Eto.Forms.TabControl}, or {@link Eto.Forms.Window}
			 */
			Content: Eto.Forms.Control;

			/**
			 * Gets or sets the size for the client area of the control
			 *
			 * The client size differs from the {@link Eto.Forms.Control.Size} in that it excludes
			 * the decorations of the container, such as the title bar and border around a
			 * {@link Eto.Forms.Window}, or the title and line  around a {@link Eto.Forms.GroupBox}.
			 */
			ClientSize: Eto.Drawing.Size;

			/**
			 * Gets an enumeration of all contained child controls, including controls within child
			 * containers
			 */
			readonly Children: Iterable<Eto.Forms.Control>;

			/**
			 * Gets an enumeration of all contained child controls in the visual tree, including
			 * controls within child containers.
			 */
			readonly VisualChildren: Iterable<Eto.Forms.Control>;

			/**
			 * Gets or sets the style provider for this container.
			 *
			 * The style provider is used to style this container and its children.
			 */
			StyleProvider: Eto.IStyleProvider;

			/**
			 * Gets the default style provider for this container.
			 *
			 * Use this to apply styles to any child controls of this container. By default, styles
			 * will apply to all children, including children of children unless
			 * {@link Eto.DefaultStyleProvider.Inherit} is set to false .  Typically, you would set
			 * Inherit to false when creating composite controls that already have all their styles
			 * applied and you don't want any other styles to be inherited.
			 */
			readonly Styles: Eto.DefaultStyleProvider;

			/**
			 * Gets a value indicating that the control is loaded onto a form, that is it has been
			 * created, added to a parent, and shown
			 *
			 * The {@link Eto.Forms.Control.OnLoad(System.EventArgs)} method sets this value to true
			 * after cascading to all children (for a {@link Eto.Forms.Container} ) and calling the
			 * platform handler's implementation.  It is called after adding to a loaded form, or
			 * when showing a new form.  The {@link Eto.Forms.Control.OnUnLoad(System.EventArgs)}
			 * method will set this value to false when the control is removed from its parent
			 */
			readonly Loaded: boolean;

			/**
			 * Gets an enumeration of controls that are in the visual tree.
			 *
			 * This is used to specify which controls are contained by this instance that are part of
			 * the visual tree. This should include all controls including non-logical Eto controls
			 * used for layout.
			 */
			readonly VisualControls: Iterable<Eto.Forms.Control>;

			/**
			 * Gets or sets a user-defined object that contains data about the control
			 *
			 * A common use of the tag property is to store data that is associated with the control
			 * that you can later retrieve.
			 */
			Tag: unknown;

			/**
			 * Gets the logical parent control.
			 *
			 * When the control is part of the visual tree (
				 * {@link Eto.Forms.Control.IsVisualControl} is true), this returns the logical parent
				 * that contains this control. Otherwise this is the same as
				 * {@link Eto.Forms.Control.Parent}.
				 */
				readonly LogicalParent: Eto.Forms.Container;

			/** Gets a value indicating this {@link Eto.Forms.Control} is part of the visual tree. */
			IsVisualControl: boolean;

			/**
			 * Gets or sets the size of the control. Use -1 to specify auto sizing for either the
			 * width and/or height.
			 *
			 * Setting the size of controls is entirely optional as most controls will size
			 * themselves appropriately. When specifying a size, it will be used as the desired size
			 * of the control.  The container will reposition and resize the control depending on the
			 * available size.  For a {@link Eto.Forms.Window}, it is preferred to set the
			 * {@link Eto.Forms.Container.ClientSize} instead, as various platforms have different
			 * sizes of window decorations, toolbars, etc.
			 */
			Size: Eto.Drawing.Size;

			/**
			 * Gets a value indicating this control currently has mouse capture
			 *
			 * Mouse capture can happen during a handled MouseDown event until MouseUp, or it can be
			 * captured explicitly via {@link Eto.Forms.Control.CaptureMouse}.
			 */
			readonly IsMouseCaptured: boolean;

			/** Gets or sets the width of the control size. */
			Width: number;

			/** Gets or sets the height of the control size. */
			Height: number;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Forms.Control} is visible to
			 * the user.
			 *
			 * When the visibility of a control is set to false, it will not occupy space in the
			 * layout.
			 */
			Visible: boolean;

			/** Gets the container which this control has been added to, if any */
			readonly Parent: Eto.Forms.Container;

			/**
			 * Gets the visual container of this control, if any.
			 *
			 * Some containers may use other Eto controls to layout its children, such as the
			 * {@link Eto.Forms.StackLayout}. This will return the parent control that visually
			 * contains this control as opposed to {@link Eto.Forms.Control.Parent} which will return
			 * the logical parent.
			 */
			VisualParent: Eto.Forms.Container;

			/** Gets a value indicating this control has been attached to a native container */
			readonly IsAttached: boolean;

			/**
			 * Gets or sets the color for the background of the control
			 *
			 * Note that on some platforms (e.g. Mac), setting the background color of a control can
			 * change the performance characteristics of the control and its children, since it must
			 * enable layers to do so.
			 */
			BackgroundColor: Eto.Drawing.Color;

			/** Gets a value indicating whether this instance has the keyboard input focus. */
			readonly HasFocus: boolean;

			/** Gets a value indicating whether the layout of child controls is suspended. */
			readonly IsSuspended: boolean;

			/** Gets the window this control is contained in */
			readonly ParentWindow: Eto.Forms.Window;

			/**
			 * Gets the supported platform commands that can be used to hook up system functions to
			 * user defined logic
			 *
			 * This lists all available commands that can be mapped using the
			 * {@link Eto.Forms.Control.MapPlatformCommand(System.String,Eto.Forms.Command)} method
			 * of the control.
			 */
			readonly SupportedPlatformCommands: Iterable<string>;

			/** Gets the bounding rectangle of this control relative to its container */
			readonly Bounds: Eto.Drawing.Rectangle;

			/**
			 * Gets the location of the control as positioned by the container
			 *
			 * A control's location is set by the container. This can be used to determine where the
			 * control is for overlaying floating windows, menus, etc.
			 */
			readonly Location: Eto.Drawing.Point;

			/** Gets or sets the type of cursor to use when the mouse is hovering over the control */
			Cursor: Eto.Forms.Cursor;

			/** Gets or sets the tool tip to show when the mouse is hovered over the control */
			ToolTip: string;

			/**
			 * Gets or sets the tab index order for this control within its container.
			 *
			 * This sets the order when using the tab key to cycle through controls  Note that some
			 * platforms (Gtk and WinForms) may not support setting the context of the tab order to
			 * StackLayout  or DynamicLayout containers and may not behave exactly as expected. Use
			 * the {@link Eto.PlatformFeatures.TabIndexWithCustomContainers} flag to determine if it
			 * is supported.
			 */
			TabIndex: number;

			/** Gets or sets a value indicating whether this control can serve as drop target. */
			AllowDrop: boolean;

			/**
			 * Gets or sets the parent widget which this widget has been added to, if any
			 *
			 * When implementing child widgets that can participate in the context based binding
			 * (MVVM), You can set this to the parent widget when it is added or removed to it
			 * (usually via a collection).  Note that you should typically provide a public new
			 * [ParentWidget] Parent { get; } property  so that consumers of your API cannot set the
			 * parent to an invalid value.
			 */
			Parent: Eto.Widget;

			/**
			 * Gets an enumeration of all parent widgets in the heirarchy by traversing the
			 * {@link Eto.Forms.BindableWidget.Parent} property.
			 */
			readonly Parents: Iterable<Eto.Widget>;

			/**
			 * Gets or sets the data context for this widget for binding
			 *
			 * Subclasses may override the standard behaviour so that hierarchy of widgets can be
			 * taken into account.  For example, a Control may return the data context of a parent,
			 * if it is not set explicitly.
			 */
			DataContext: unknown;

			/** Gets the collection of bindings that are attached to this widget */
			readonly Bindings: Eto.Forms.BindingCollection;

			/**
			 * Gets a value indicating that the {@link Eto.Forms.BindableWidget.DataContext} property
			 * is changing.
			 *
			 * This can be used to determine when to allow certain logic during the update of the
			 * data context.  It is used to disable binding setters on the model when the data
			 * context changes so that a binding does not cause the view model to be updated when the
			 * state hasn't been fully set yet.
			 */
			IsDataContextChanging: boolean;

			/**
			 * Gets the platform that was used to create the {@link Eto.Widget.Handler} for this
			 * widget
			 *
			 * This gets set to the current {@link Eto.Platform.Instance} during the construction of
			 * the object
			 */
			readonly Platform: Eto.Platform;

			/** Gets the platform-specific handler for this widget */
			Handler: unknown;

			/** Gets the native platform-specific handle for integration purposes */
			readonly NativeHandle: unknown;

			/** Gets the dictionary of properties for this widget */
			readonly Properties: Eto.PropertyStore;

			/** Gets or sets the ID of this widget */
			ID: string;

			/**
			 * Gets or sets the style of this widget
			 *
			 * Styles allow you to attach custom platform-specific logic to a widget. In your
			 * platform-specific assembly, use {@link Style.Add{H}(string, StyleHandler{H})} to add
			 * the style logic with the same id.
			 */
			Style: string;

			/**
			 * Gets the instance of the platform-specific object
			 *
			 * This can sometimes be useful to get the platform-specific object. Some handlers may
			 * not have any backing object for its functionality, so this may be null.  It is more
			 * preferred to use the {@link Eto.Widget.Handler} and cast that to the platform-specific
			 * handler class which can give you additional methods and helpers to do common tasks.
			 * For example, the {@link Eto.Forms.Application} object's handler for OS X has a
			 * AddFullScreenMenuItem property to specify if you want full screen support in your app.
			 */
			readonly ControlObject: unknown;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Widget} has been disposed.
			 *
			 * When the widget is disposed, it can no longer be used.
			 */
			IsDisposed: boolean;

			/** Removes the specified child from the container */
			Remove(child: Eto.Forms.Control): void;

			/** Remove the specified `controls` from this container */
			Remove(controls: Iterable<Eto.Forms.Control>): void;

			/** Removes all controls from this container */
			RemoveAll(): void;

			/**
			 * Finds a child control in this container or any of its child containers with the
			 * specified `id`
			 */
			FindChild<T>(id?: string): T;

			/**
			 * Finds a child control in this container or any of its child containers with the
			 * specified `type`
			 */
			FindChild(
				type: unknown,
				id?: string,
			): Eto.Forms.Control;

			/**
			 * Finds a child control in this container or any of its child containers with the
			 * specified `id`.
			 */
			FindChild(id: string): Eto.Forms.Control;

			/**
			 * Queues a repaint of the entire control on the screen and any of its children.
			 *
			 * This is only useful when the control is visible.
			 */
			Invalidate(): void;

			/**
			 * Queues a repaint of the entire control on the screen
			 *
			 * This is only useful when the control is visible.
			 */
			Invalidate(invalidateChildren: boolean): void;

			/**
			 * Queues a repaint of the specified `rect` of the control and any children.
			 *
			 * This is only useful when the control is visible.
			 */
			Invalidate(rect: Eto.Drawing.Rectangle): void;

			/**
			 * Queues a repaint of the specified `rect` of the control
			 *
			 * This is only useful when the control is visible.
			 */
			Invalidate(
				rect: Eto.Drawing.Rectangle,
				invalidateChildren: boolean,
			): void;

			/**
			 * Updates the layout of this control if necessary.
			 *
			 * This will ensure the control has had all of its layout applied so you can use its
			 * position and size right after this call. Most platforms (except WinForms) use a
			 * deferred layout system so that after adding your control to the form dynamically it
			 * won't get laid out until the next idle loop. This is useful when you need to know the
			 * dimensions of the control immediately. Note that this can be an expensive operation,
			 * so it is recommended to only call this method when necessary and after all of the
			 * controls have been added/updated.
			 */
			UpdateLayout(): void;

			/** Gets the preferred size of this control given infinite space available. */
			GetPreferredSize(): Eto.Drawing.SizeF;

			/** Gets the preferred size of this control given the specified `availableSize`. */
			GetPreferredSize(availableSize: Eto.Drawing.SizeF): Eto.Drawing.SizeF;

			/**
			 * Captures all mouse events to this control.
			 *
			 * This captures all mouse events until {@link Eto.Forms.Control.ReleaseMouseCapture} is
			 * called.  Note that not all platforms will allow a mouse capture unless the mouse is
			 * currently down.
			 */
			CaptureMouse(): boolean;

			/** Releases the mouse capture after a call to {@link Eto.Forms.Control.CaptureMouse}. */
			ReleaseMouseCapture(): void;

			/**
			 * Finds a control in the parent hierarchy with the specified type and
			 * {@link Eto.Widget.ID} if specified
			 */
			FindParent(
				type: unknown,
				id?: string,
			): Eto.Forms.Container;

			/** Finds a control in the parent hierarchy with the specified `id` */
			FindParent(id: string): Eto.Forms.Container;

			/**
			 * Detaches the control by removing it from its parent
			 *
			 * This is essentially a shortcut to myControl.Parent.Remove(myControl);
			 */
			Detach(): void;

			/**
			 * Attaches the control for direct use in a native application
			 *
			 * Use this to use a control directly in a native application.  Note that the native
			 * application must be running the same framework as the current platform.  E.g. a
			 * WinForms application can use an Eto.Forms control when using the Eto.WinForms
			 * platform.  This prepares the control by firing the {@link Eto.Forms.Control.PreLoad},
			 * {@link Eto.Forms.Control.Load}, etc. events.
			 */
			AttachNative(): void;

			/**
			 * Detaches the control when it is used in a native application, when you want to reuse
			 * the control.
			 *
			 * This should only be called after {@link Eto.Forms.Control.AttachNative} has been
			 * called, which is usually done by calling to ToNative(true) .
			 */
			DetachNative(): void;

			/**
			 * Attempts to set the keyboard input focus to this control, or the first child that
			 * accepts focus. For Windows, this will bring it to front and activate it.
			 */
			Focus(): void;

			/**
			 * Suspends the layout of child controls
			 *
			 * This can be used to optimize some platforms while adding, removing, or changing many
			 * child controls at once. It disables the calculation of control positioning until
			 * {@link Eto.Forms.Control.ResumeLayout} is called. Each call to SuspendLayout() must be
			 * balanced with a call to {@link Eto.Forms.Control.ResumeLayout}.
			 */
			SuspendLayout(): void;

			/**
			 * Resumes the layout after it has been suspended, and performs a layout
			 *
			 * This can be used to optimize some platforms while adding, removing, or changing many
			 * child controls at once. Each call to ResumeLayout() must be balanced with a call to
			 * {@link Eto.Forms.Control.SuspendLayout} before it.
			 */
			ResumeLayout(): void;

			/**
			 * Specifies a command to execute for a platform-specific command
			 *
			 * Some platforms have specific system-defined commands that can be associated with a
			 * control. For example, the Mac platform's cut/copy/paste functionality is defined by
			 * the system, and if you want to hook into it, you can use this to map it to your own
			 * defined logic. The valid values of the `systemCommand` parameter are defined by each
			 * platform, and a list can be retrieved using
			 * {@link Eto.Forms.Control.SupportedPlatformCommands}
			 */
			MapPlatformCommand(
				systemCommand: string,
				command: Eto.Forms.Command,
			): void;

			/** Converts a point from screen space to control space. */
			PointFromScreen(point: Eto.Drawing.PointF): Eto.Drawing.PointF;

			/** Converts a point from control space to screen space */
			PointToScreen(point: Eto.Drawing.PointF): Eto.Drawing.PointF;

			/** Converts a rectangle from screen space to control space. */
			RectangleToScreen(rect: Eto.Drawing.RectangleF): Eto.Drawing.RectangleF;

			/** Converts a rectangle from control space to screen space */
			RectangleFromScreen(rect: Eto.Drawing.RectangleF): Eto.Drawing.RectangleF;

			/**
			 * Starts drag operation using this control as drag source.
			 *
			 * This method can be blocking on some platforms (Wpf, WinForms), and non-blocking on
			 * others (Mac, Gtk). Use the {@link Eto.Forms.Control.DragEnd} event to determine when
			 * the drag operation is completed and get its resulting DragEffects.
			 */
			DoDragDrop(
				data: Eto.Forms.DataObject,
				allowedEffects: Eto.Forms.DragEffects,
			): void;

			/**
			 * Starts drag operation using this control as drag source.
			 *
			 * This method can be blocking on some platforms (Wpf, WinForms), and non-blocking on
			 * others (Mac, Gtk). Use the {@link Eto.Forms.Control.DragEnd} event to determine when
			 * the drag operation is completed and get its resulting DragEffects.
			 */
			DoDragDrop(
				data: Eto.Forms.DataObject,
				allowedEffects: Eto.Forms.DragEffects,
				image: Eto.Drawing.Image,
				cursorOffset: Eto.Drawing.PointF,
			): void;

			/**
			 * Triggers the StyleChanged event and re-applies the styles to this control and its
			 * children.
			 */
			TriggerStyleChanged(): void;

			/** Shows a print dialog to print the specified control */
			Print(): void;

			/**
			 * Finds a control in the parent hierarchy with the specified type and
			 * {@link Eto.Widget.ID} if specified
			 */
			FindParent<T>(id?: string): T;

			/**
			 * Finds a control in the parent hierarchy with the specified type and
			 * {@link Eto.Widget.ID} if specified
			 */
			FindParent(
				type: unknown,
				id?: string,
			): Eto.Widget;

			/** Finds a control in the parent hierarchy with the specified `id` */
			FindParent(id: string): Eto.Widget;

			/**
			 * Unbinds any bindings in the {@link Eto.Forms.BindableWidget.Bindings} collection and
			 * removes the bindings
			 *
			 * When you implement {@link Eto.Forms.IBindableWidgetContainer}, this will also unbind
			 * any of its children.
			 */
			Unbind(): void;

			/**
			 * Updates all bindings in this widget
			 *
			 * When you implement {@link Eto.Forms.IBindableWidgetContainer}, this will also update
			 * bindings for all of its children.
			 */
			UpdateBindings(mode?: Eto.Forms.BindingUpdateMode): void;

			/** Disposes of this widget, supressing the finalizer */
			dispose(): void;

			/** Gets a string that represents the current object with its ID if specified. */
			ToString(): string;
		}
	}

	export namespace Eto.Forms {
		/** Orientation of buttons in a {@link Eto.Forms.RadioButtonList} */
		export class RadioButtonListOrientation {
			/** Radio buttons are displayed horizontally. */
			static readonly Horizontal: Eto.Forms.RadioButtonListOrientation;

			/** Radio buttons are displayed vertically. */
			static readonly Vertical: Eto.Forms.RadioButtonListOrientation;

			/**
			 * Determines whether the specified {@link System.Object} is equal to the current
			 * {@link Eto.Forms.SliderOrientation}.
			 */
			Equals(obj: unknown): boolean;

			/** Serves as a hash function for a {@link Eto.Forms.SliderOrientation} object. */
			GetHashCode(): number;
		}
	}

	export namespace Eto.Forms {
		/** Format for loading and saving text from the {@link Eto.Forms.RichTextArea} */
		export enum RichTextAreaFormat {
			/** Standard Rich Text format */
			Rtf = 0,

			/** Plain Text only */
			PlainText = 1,
		}
	}

	export namespace Eto.Forms {
		/** Extensions for {@link Eto.Forms.ITextBuffer} */
		export namespace TextBufferExtensions {
			/**
			 * Gets the content of the specified buffer as an RTF formatted string. Note that some
			 * platforms don't support RTF (e.g. Gtk).
			 */
			export function GetRtf(buffer: Eto.Forms.ITextBuffer): string;

			/**
			 * Sets the content of the buffer to the specified `rtf` string. Note that some platforms
			 * don't support RTF (e.g. Gtk).
			 *
			 * The CaretIndex and Selection will be set to the end of the string after set.
			 */
			export function SetRtf(
				buffer: Eto.Forms.ITextBuffer,
				rtf: string,
			): void;
		}
	}

	export namespace Eto.Forms {
		/** Extension methods from {@link Eto.Forms.TextBufferExtensions} */
		export interface ITextBuffer {
			/**
			 * Gets the content of the specified buffer as an RTF formatted string. Note that some
			 * platforms don't support RTF (e.g. Gtk).
			 */
			GetRtf(): string;

			/**
			 * Sets the content of the buffer to the specified `rtf` string. Note that some platforms
			 * don't support RTF (e.g. Gtk).
			 *
			 * The CaretIndex and Selection will be set to the end of the string after set.
			 */
			SetRtf(rtf: string): void;
		}
	}

	export namespace Eto.Forms {
		/** Interface for a formatted text buffer */
		export interface ITextBuffer {
			/**
			 * Gets an enumeration of formats supported for the
			 * {@link Eto.Forms.ITextBuffer.Load(System.IO.Stream,Eto.Forms.RichTextAreaFormat)} and
			 * {@link Eto.Forms.ITextBuffer.Save(System.IO.Stream,Eto.Forms.RichTextAreaFormat)}
			 * methods.
			 */
			readonly SupportedFormats: Iterable<Eto.Forms.RichTextAreaFormat>;

			/** Sets the bold flag for the specified text range. */
			SetBold(
				range: Eto.Forms.Range$1<number>,
				bold: boolean,
			): void;

			/** Sets the italic flag for the specified text range. */
			SetItalic(
				range: Eto.Forms.Range$1<number>,
				italic: boolean,
			): void;

			/** Sets the underline flag for the specified text range. */
			SetUnderline(
				range: Eto.Forms.Range$1<number>,
				underline: boolean,
			): void;

			/** Sets the strikethrough for the specified text range. */
			SetStrikethrough(
				range: Eto.Forms.Range$1<number>,
				strikethrough: boolean,
			): void;

			/** Sets the font for the specified text range. */
			SetFont(
				range: Eto.Forms.Range$1<number>,
				font: Eto.Drawing.Font,
			): void;

			/** Sets the foreground color for the specified text range. */
			SetForeground(
				range: Eto.Forms.Range$1<number>,
				color: Eto.Drawing.Color,
			): void;

			/** Sets the background color for the specified range. */
			SetBackground(
				range: Eto.Forms.Range$1<number>,
				color: Eto.Drawing.Color,
			): void;

			/** Sets the font family for the specified text range. */
			SetFamily(
				range: Eto.Forms.Range$1<number>,
				family: Eto.Drawing.FontFamily,
			): void;

			/**
			 * Loads the specified format from the stream, replacing the content of the buffer.
			 *
			 * The CaretIndex and Selection will be set to the end of the string after set.
			 */
			Load(
				stream: Duplex,
				format: Eto.Forms.RichTextAreaFormat,
			): void;

			/** Saves the buffer into a stream with the specified format. */
			Save(
				stream: Duplex,
				format: Eto.Forms.RichTextAreaFormat,
			): void;

			/** Clears the buffer of all text and formatting. */
			Clear(): void;

			/** Deletes text from the specified range */
			Delete(range: Eto.Forms.Range$1<number>): void;

			/** Inserts text with the format of the text at the specified position. */
			Insert(
				position: number,
				text: string,
			): void;
		}
	}

	export namespace Eto.Forms {
		/**
		 * Text area with ability to specify rich text formatting such as font attributes and
		 * colors.
		 */
		export class RichTextArea implements
			Eto.IHandlerSource,
			Eto.Forms.IBindable,
			Eto.Forms.IMouseInputSource,
			Eto.Forms.IKeyboardInputSource {
			constructor();

			/** Gets or sets the font of the selected text or insertion point. */
			SelectionFont: Eto.Drawing.Font;

			/** Gets or sets the foreground color of the selected text or insertion point. */
			SelectionForeground: Eto.Drawing.Color;

			/** Gets or sets the background color of the selected text or insertion point. */
			SelectionBackground: Eto.Drawing.Color;

			/**
			 * Gets or sets a value indicating whether the selected text or insertion point has bold
			 * text.
			 */
			SelectionBold: boolean;

			/**
			 * Gets or sets a value indicating whether the selected text or insertion point has
			 * italic style.
			 */
			SelectionItalic: boolean;

			/**
			 * Gets or sets a value indicating whether the selected text or insertion point has
			 * underline decorations.
			 */
			SelectionUnderline: boolean;

			/**
			 * Gets or sets a value indicating whether the selected text or insertion point has
			 * strikethrough decorations.
			 */
			SelectionStrikethrough: boolean;

			/** Gets or sets the font family of the selected text or insertion point. */
			SelectionFamily: Eto.Drawing.FontFamily;

			/** Gets or sets the font typeface of the selected text or insertion point. */
			SelectionTypeface: Eto.Drawing.FontTypeface;

			/**
			 * Gets the formatted text buffer to set formatting and load/save to file.
			 *
			 * The text buffer allows you to control the formatting of the text.
			 */
			readonly Buffer: Eto.Forms.ITextBuffer;

			/**
			 * Gets or sets the content as a RTF (Rich Text Format) string. Note that some platforms
			 * don't support RTF (e.g. Gtk).
			 *
			 * The CaretIndex and Selection will be set to the end of the string after set.
			 */
			Rtf: string;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Forms.TextArea} is read only.
			 *
			 * A read only text box can be scrolled, text can be selected and copied, etc. However,
			 * the user will not be able to change any of the text. This differs from the
			 * {@link Eto.Forms.Control.Enabled} property, which disables all user interaction.
			 */
			ReadOnly: boolean;

			/**
			 * Gets or sets a value indicating whether text will wrap if lines are longer than the
			 * width of the control.
			 *
			 * Typically, a platform will word wrap the text.
			 */
			Wrap: boolean;

			/**
			 * Gets or sets the selected text.
			 *
			 * When setting the selected text, the text within the
			 * {@link Eto.Forms.TextArea.Selection} range will be replaced with the new value.
			 */
			SelectedText: string;

			/**
			 * Gets or sets the range of selected text.
			 *
			 * When setting the selection, the control will be focussed and the associated keyboard
			 * may appear on mobile platforms.
			 */
			Selection: Eto.Forms.Range$1<number>;

			/**
			 * Gets or sets the index of the insertion caret.
			 *
			 * When setting the caret, the control will be focussed and the associated keyboard may
			 * appear on mobile platforms.
			 */
			CaretIndex: number;

			/**
			 * Gets or sets a value indicating whether the tab key is inserted into the text area, or
			 * if it should be ignored by this control and used for navigating to the next control.
			 */
			AcceptsTab: boolean;

			/**
			 * Gets or sets a value indicating whether the return key is inserted into the text area,
			 * or if it should be ignored by this control.
			 */
			AcceptsReturn: boolean;

			/** Gets or sets the horizontal alignment of the text. */
			TextAlignment: Eto.Forms.TextAlignment;

			/** Gets or sets the horizontal alignment of the text. */
			HorizontalAlign: Eto.Forms.HorizontalAlign;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Forms.TextArea} will perform
			 * spell checking.
			 *
			 * When true , platforms will typically show misspelled or unknown words with a red
			 * underline. This is a hint, and is only supported by the platform when
			 * {@link Eto.Forms.TextArea.SpellCheckIsSupported} is true. When not supported, setting
			 * this property will do nothing.
			 */
			SpellCheck: boolean;

			/**
			 * Gets a value indicating whether the {@link Eto.Forms.TextArea.SpellCheck} property is
			 * supported on the control's platform.
			 */
			readonly SpellCheckIsSupported: boolean;

			/**
			 * Gets or sets a hint value indicating whether this {@link Eto.Forms.TextArea} will
			 * automatically correct text.
			 *
			 * On some platforms, autocorrection or text replacements such as quotes, etc may be
			 * default. Set this to {@link Eto.Forms.TextReplacements.None} to disable any text
			 * replacement.  Note this is only supported on OS X currently, all other platforms will
			 * be ignored.
			 */
			TextReplacements: Eto.Forms.TextReplacements;

			/**
			 * Gets the text replacements that this control supports on the current platform.
			 *
			 * You can use this to determine which flags in the
			 * {@link Eto.Forms.TextArea.TextReplacements} will take effect.
			 */
			readonly SupportedTextReplacements: Eto.Forms.TextReplacements;

			/** Gets or sets the border type */
			Border: Eto.Forms.BorderType;

			/**
			 * Gets the current length of the text
			 *
			 * When there is lots of text, this can be more performant than using Text.Length.
			 */
			readonly TextLength: number;

			/**
			 * Gets or sets the text of the control.
			 *
			 * Usually, the caret and selection will be set to the end of the string after its set.
			 */
			Text: string;

			/**
			 * Gets or sets the color of the text.
			 *
			 * By default, the text will get a color based on the user's theme. However, this is
			 * usually black.
			 */
			TextColor: Eto.Drawing.Color;

			/** Gets the binding for the {@link Eto.Forms.TextControl.Text} property. */
			readonly TextBinding: Eto.Forms.BindableBinding$2<Eto.Forms.TextControl, string>;

			/** Gets or sets the font for the text of the control */
			Font: Eto.Drawing.Font;

			/**
			 * Gets a value indicating that the control is loaded onto a form, that is it has been
			 * created, added to a parent, and shown
			 *
			 * The {@link Eto.Forms.Control.OnLoad(System.EventArgs)} method sets this value to true
			 * after cascading to all children (for a {@link Eto.Forms.Container} ) and calling the
			 * platform handler's implementation.  It is called after adding to a loaded form, or
			 * when showing a new form.  The {@link Eto.Forms.Control.OnUnLoad(System.EventArgs)}
			 * method will set this value to false when the control is removed from its parent
			 */
			readonly Loaded: boolean;

			/**
			 * Gets an enumeration of controls that are in the visual tree.
			 *
			 * This is used to specify which controls are contained by this instance that are part of
			 * the visual tree. This should include all controls including non-logical Eto controls
			 * used for layout.
			 */
			readonly VisualControls: Iterable<Eto.Forms.Control>;

			/**
			 * Gets or sets a user-defined object that contains data about the control
			 *
			 * A common use of the tag property is to store data that is associated with the control
			 * that you can later retrieve.
			 */
			Tag: unknown;

			/**
			 * Gets the logical parent control.
			 *
			 * When the control is part of the visual tree (
				 * {@link Eto.Forms.Control.IsVisualControl} is true), this returns the logical parent
				 * that contains this control. Otherwise this is the same as
				 * {@link Eto.Forms.Control.Parent}.
				 */
				readonly LogicalParent: Eto.Forms.Container;

			/** Gets a value indicating this {@link Eto.Forms.Control} is part of the visual tree. */
			IsVisualControl: boolean;

			/**
			 * Gets or sets the size of the control. Use -1 to specify auto sizing for either the
			 * width and/or height.
			 *
			 * Setting the size of controls is entirely optional as most controls will size
			 * themselves appropriately. When specifying a size, it will be used as the desired size
			 * of the control.  The container will reposition and resize the control depending on the
			 * available size.  For a {@link Eto.Forms.Window}, it is preferred to set the
			 * {@link Eto.Forms.Container.ClientSize} instead, as various platforms have different
			 * sizes of window decorations, toolbars, etc.
			 */
			Size: Eto.Drawing.Size;

			/**
			 * Gets a value indicating this control currently has mouse capture
			 *
			 * Mouse capture can happen during a handled MouseDown event until MouseUp, or it can be
			 * captured explicitly via {@link Eto.Forms.Control.CaptureMouse}.
			 */
			readonly IsMouseCaptured: boolean;

			/** Gets or sets the width of the control size. */
			Width: number;

			/** Gets or sets the height of the control size. */
			Height: number;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Forms.Control} (or its
			 * children) are enabled and accept user input.
			 *
			 * Typically when a control is disabled, the user cannot do anything with the control or
			 * any of its children. Including for example, selecting text in a text control. Certain
			 * controls can have a 'Read Only' mode, such as {@link Eto.Forms.TextBox.ReadOnly} which
			 * allow the user to  select text, but not change its contents.
			 */
			Enabled: boolean;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Forms.Control} is visible to
			 * the user.
			 *
			 * When the visibility of a control is set to false, it will not occupy space in the
			 * layout.
			 */
			Visible: boolean;

			/** Gets the container which this control has been added to, if any */
			readonly Parent: Eto.Forms.Container;

			/**
			 * Gets the visual container of this control, if any.
			 *
			 * Some containers may use other Eto controls to layout its children, such as the
			 * {@link Eto.Forms.StackLayout}. This will return the parent control that visually
			 * contains this control as opposed to {@link Eto.Forms.Control.Parent} which will return
			 * the logical parent.
			 */
			VisualParent: Eto.Forms.Container;

			/** Gets a value indicating this control has been attached to a native container */
			readonly IsAttached: boolean;

			/**
			 * Gets or sets the color for the background of the control
			 *
			 * Note that on some platforms (e.g. Mac), setting the background color of a control can
			 * change the performance characteristics of the control and its children, since it must
			 * enable layers to do so.
			 */
			BackgroundColor: Eto.Drawing.Color;

			/** Gets a value indicating whether this instance has the keyboard input focus. */
			readonly HasFocus: boolean;

			/** Gets a value indicating whether the layout of child controls is suspended. */
			readonly IsSuspended: boolean;

			/** Gets the window this control is contained in */
			readonly ParentWindow: Eto.Forms.Window;

			/**
			 * Gets the supported platform commands that can be used to hook up system functions to
			 * user defined logic
			 *
			 * This lists all available commands that can be mapped using the
			 * {@link Eto.Forms.Control.MapPlatformCommand(System.String,Eto.Forms.Command)} method
			 * of the control.
			 */
			readonly SupportedPlatformCommands: Iterable<string>;

			/** Gets the bounding rectangle of this control relative to its container */
			readonly Bounds: Eto.Drawing.Rectangle;

			/**
			 * Gets the location of the control as positioned by the container
			 *
			 * A control's location is set by the container. This can be used to determine where the
			 * control is for overlaying floating windows, menus, etc.
			 */
			readonly Location: Eto.Drawing.Point;

			/** Gets or sets the type of cursor to use when the mouse is hovering over the control */
			Cursor: Eto.Forms.Cursor;

			/** Gets or sets the tool tip to show when the mouse is hovered over the control */
			ToolTip: string;

			/**
			 * Gets or sets the tab index order for this control within its container.
			 *
			 * This sets the order when using the tab key to cycle through controls  Note that some
			 * platforms (Gtk and WinForms) may not support setting the context of the tab order to
			 * StackLayout  or DynamicLayout containers and may not behave exactly as expected. Use
			 * the {@link Eto.PlatformFeatures.TabIndexWithCustomContainers} flag to determine if it
			 * is supported.
			 */
			TabIndex: number;

			/** Gets or sets a value indicating whether this control can serve as drop target. */
			AllowDrop: boolean;

			/**
			 * Gets or sets the parent widget which this widget has been added to, if any
			 *
			 * When implementing child widgets that can participate in the context based binding
			 * (MVVM), You can set this to the parent widget when it is added or removed to it
			 * (usually via a collection).  Note that you should typically provide a public new
			 * [ParentWidget] Parent { get; } property  so that consumers of your API cannot set the
			 * parent to an invalid value.
			 */
			Parent: Eto.Widget;

			/**
			 * Gets an enumeration of all parent widgets in the heirarchy by traversing the
			 * {@link Eto.Forms.BindableWidget.Parent} property.
			 */
			readonly Parents: Iterable<Eto.Widget>;

			/**
			 * Gets or sets the data context for this widget for binding
			 *
			 * Subclasses may override the standard behaviour so that hierarchy of widgets can be
			 * taken into account.  For example, a Control may return the data context of a parent,
			 * if it is not set explicitly.
			 */
			DataContext: unknown;

			/** Gets the collection of bindings that are attached to this widget */
			readonly Bindings: Eto.Forms.BindingCollection;

			/**
			 * Gets a value indicating that the {@link Eto.Forms.BindableWidget.DataContext} property
			 * is changing.
			 *
			 * This can be used to determine when to allow certain logic during the update of the
			 * data context.  It is used to disable binding setters on the model when the data
			 * context changes so that a binding does not cause the view model to be updated when the
			 * state hasn't been fully set yet.
			 */
			IsDataContextChanging: boolean;

			/**
			 * Gets the platform that was used to create the {@link Eto.Widget.Handler} for this
			 * widget
			 *
			 * This gets set to the current {@link Eto.Platform.Instance} during the construction of
			 * the object
			 */
			readonly Platform: Eto.Platform;

			/** Gets the platform-specific handler for this widget */
			Handler: unknown;

			/** Gets the native platform-specific handle for integration purposes */
			readonly NativeHandle: unknown;

			/** Gets the dictionary of properties for this widget */
			readonly Properties: Eto.PropertyStore;

			/** Gets or sets the ID of this widget */
			ID: string;

			/**
			 * Gets or sets the style of this widget
			 *
			 * Styles allow you to attach custom platform-specific logic to a widget. In your
			 * platform-specific assembly, use {@link Style.Add{H}(string, StyleHandler{H})} to add
			 * the style logic with the same id.
			 */
			Style: string;

			/**
			 * Gets the instance of the platform-specific object
			 *
			 * This can sometimes be useful to get the platform-specific object. Some handlers may
			 * not have any backing object for its functionality, so this may be null.  It is more
			 * preferred to use the {@link Eto.Widget.Handler} and cast that to the platform-specific
			 * handler class which can give you additional methods and helpers to do common tasks.
			 * For example, the {@link Eto.Forms.Application} object's handler for OS X has a
			 * AddFullScreenMenuItem property to specify if you want full screen support in your app.
			 */
			readonly ControlObject: unknown;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Widget} has been disposed.
			 *
			 * When the widget is disposed, it can no longer be used.
			 */
			IsDisposed: boolean;

			/**
			 * Selects all text.
			 *
			 * When setting the selection, the control will be focussed and the associated keyboard
			 * may appear on mobile platforms.
			 */
			SelectAll(): void;

			/**
			 * Append the specified text to the control and optionally scrolls to make the inserted
			 * text visible.
			 *
			 * This is an optimized way of inserting text into a TextArea when its content gets
			 * large.
			 */
			Append(
				text: string,
				scrollToCursor?: boolean,
			): void;

			/**
			 * Scrolls the specified range into view.
			 *
			 * On some platforms, this may just scroll to the end of the range.
			 */
			ScrollTo(range: Eto.Forms.Range$1<number>): void;

			/** Scrolls to the start of the text in the text area. */
			ScrollToStart(): void;

			/** Scrolls to the end of the text in the text area. */
			ScrollToEnd(): void;

			/**
			 * Queues a repaint of the entire control on the screen and any of its children.
			 *
			 * This is only useful when the control is visible.
			 */
			Invalidate(): void;

			/**
			 * Queues a repaint of the entire control on the screen
			 *
			 * This is only useful when the control is visible.
			 */
			Invalidate(invalidateChildren: boolean): void;

			/**
			 * Queues a repaint of the specified `rect` of the control and any children.
			 *
			 * This is only useful when the control is visible.
			 */
			Invalidate(rect: Eto.Drawing.Rectangle): void;

			/**
			 * Queues a repaint of the specified `rect` of the control
			 *
			 * This is only useful when the control is visible.
			 */
			Invalidate(
				rect: Eto.Drawing.Rectangle,
				invalidateChildren: boolean,
			): void;

			/**
			 * Updates the layout of this control if necessary.
			 *
			 * This will ensure the control has had all of its layout applied so you can use its
			 * position and size right after this call. Most platforms (except WinForms) use a
			 * deferred layout system so that after adding your control to the form dynamically it
			 * won't get laid out until the next idle loop. This is useful when you need to know the
			 * dimensions of the control immediately. Note that this can be an expensive operation,
			 * so it is recommended to only call this method when necessary and after all of the
			 * controls have been added/updated.
			 */
			UpdateLayout(): void;

			/** Gets the preferred size of this control given infinite space available. */
			GetPreferredSize(): Eto.Drawing.SizeF;

			/** Gets the preferred size of this control given the specified `availableSize`. */
			GetPreferredSize(availableSize: Eto.Drawing.SizeF): Eto.Drawing.SizeF;

			/**
			 * Captures all mouse events to this control.
			 *
			 * This captures all mouse events until {@link Eto.Forms.Control.ReleaseMouseCapture} is
			 * called.  Note that not all platforms will allow a mouse capture unless the mouse is
			 * currently down.
			 */
			CaptureMouse(): boolean;

			/** Releases the mouse capture after a call to {@link Eto.Forms.Control.CaptureMouse}. */
			ReleaseMouseCapture(): void;

			/**
			 * Finds a control in the parent hierarchy with the specified type and
			 * {@link Eto.Widget.ID} if specified
			 */
			FindParent(
				type: unknown,
				id?: string,
			): Eto.Forms.Container;

			/** Finds a control in the parent hierarchy with the specified `id` */
			FindParent(id: string): Eto.Forms.Container;

			/**
			 * Detaches the control by removing it from its parent
			 *
			 * This is essentially a shortcut to myControl.Parent.Remove(myControl);
			 */
			Detach(): void;

			/**
			 * Attaches the control for direct use in a native application
			 *
			 * Use this to use a control directly in a native application.  Note that the native
			 * application must be running the same framework as the current platform.  E.g. a
			 * WinForms application can use an Eto.Forms control when using the Eto.WinForms
			 * platform.  This prepares the control by firing the {@link Eto.Forms.Control.PreLoad},
			 * {@link Eto.Forms.Control.Load}, etc. events.
			 */
			AttachNative(): void;

			/**
			 * Detaches the control when it is used in a native application, when you want to reuse
			 * the control.
			 *
			 * This should only be called after {@link Eto.Forms.Control.AttachNative} has been
			 * called, which is usually done by calling to ToNative(true) .
			 */
			DetachNative(): void;

			/**
			 * Attempts to set the keyboard input focus to this control, or the first child that
			 * accepts focus. For Windows, this will bring it to front and activate it.
			 */
			Focus(): void;

			/**
			 * Suspends the layout of child controls
			 *
			 * This can be used to optimize some platforms while adding, removing, or changing many
			 * child controls at once. It disables the calculation of control positioning until
			 * {@link Eto.Forms.Control.ResumeLayout} is called. Each call to SuspendLayout() must be
			 * balanced with a call to {@link Eto.Forms.Control.ResumeLayout}.
			 */
			SuspendLayout(): void;

			/**
			 * Resumes the layout after it has been suspended, and performs a layout
			 *
			 * This can be used to optimize some platforms while adding, removing, or changing many
			 * child controls at once. Each call to ResumeLayout() must be balanced with a call to
			 * {@link Eto.Forms.Control.SuspendLayout} before it.
			 */
			ResumeLayout(): void;

			/**
			 * Specifies a command to execute for a platform-specific command
			 *
			 * Some platforms have specific system-defined commands that can be associated with a
			 * control. For example, the Mac platform's cut/copy/paste functionality is defined by
			 * the system, and if you want to hook into it, you can use this to map it to your own
			 * defined logic. The valid values of the `systemCommand` parameter are defined by each
			 * platform, and a list can be retrieved using
			 * {@link Eto.Forms.Control.SupportedPlatformCommands}
			 */
			MapPlatformCommand(
				systemCommand: string,
				command: Eto.Forms.Command,
			): void;

			/** Converts a point from screen space to control space. */
			PointFromScreen(point: Eto.Drawing.PointF): Eto.Drawing.PointF;

			/** Converts a point from control space to screen space */
			PointToScreen(point: Eto.Drawing.PointF): Eto.Drawing.PointF;

			/** Converts a rectangle from screen space to control space. */
			RectangleToScreen(rect: Eto.Drawing.RectangleF): Eto.Drawing.RectangleF;

			/** Converts a rectangle from control space to screen space */
			RectangleFromScreen(rect: Eto.Drawing.RectangleF): Eto.Drawing.RectangleF;

			/**
			 * Starts drag operation using this control as drag source.
			 *
			 * This method can be blocking on some platforms (Wpf, WinForms), and non-blocking on
			 * others (Mac, Gtk). Use the {@link Eto.Forms.Control.DragEnd} event to determine when
			 * the drag operation is completed and get its resulting DragEffects.
			 */
			DoDragDrop(
				data: Eto.Forms.DataObject,
				allowedEffects: Eto.Forms.DragEffects,
			): void;

			/**
			 * Starts drag operation using this control as drag source.
			 *
			 * This method can be blocking on some platforms (Wpf, WinForms), and non-blocking on
			 * others (Mac, Gtk). Use the {@link Eto.Forms.Control.DragEnd} event to determine when
			 * the drag operation is completed and get its resulting DragEffects.
			 */
			DoDragDrop(
				data: Eto.Forms.DataObject,
				allowedEffects: Eto.Forms.DragEffects,
				image: Eto.Drawing.Image,
				cursorOffset: Eto.Drawing.PointF,
			): void;

			/**
			 * Triggers the StyleChanged event and re-applies the styles to this control and its
			 * children.
			 */
			TriggerStyleChanged(): void;

			/** Shows a print dialog to print the specified control */
			Print(): void;

			/**
			 * Finds a control in the parent hierarchy with the specified type and
			 * {@link Eto.Widget.ID} if specified
			 */
			FindParent<T>(id?: string): T;

			/**
			 * Finds a control in the parent hierarchy with the specified type and
			 * {@link Eto.Widget.ID} if specified
			 */
			FindParent(
				type: unknown,
				id?: string,
			): Eto.Widget;

			/** Finds a control in the parent hierarchy with the specified `id` */
			FindParent(id: string): Eto.Widget;

			/**
			 * Unbinds any bindings in the {@link Eto.Forms.BindableWidget.Bindings} collection and
			 * removes the bindings
			 *
			 * When you implement {@link Eto.Forms.IBindableWidgetContainer}, this will also unbind
			 * any of its children.
			 */
			Unbind(): void;

			/**
			 * Updates all bindings in this widget
			 *
			 * When you implement {@link Eto.Forms.IBindableWidgetContainer}, this will also update
			 * bindings for all of its children.
			 */
			UpdateBindings(mode?: Eto.Forms.BindingUpdateMode): void;

			/** Disposes of this widget, supressing the finalizer */
			dispose(): void;

			/** Gets a string that represents the current object with its ID if specified. */
			ToString(): string;
		}
	}

	export namespace Eto.Forms.RichTextArea {
		export interface IHandler extends
			Eto.Forms.TextArea.IHandler,
			Eto.Forms.TextControl.IHandler,
			Eto.Forms.CommonControl.IHandler,
			Eto.Forms.Control.IHandler,
			Eto.Widget.IHandler {
			SelectionBold: boolean;

			SelectionItalic: boolean;

			SelectionUnderline: boolean;

			SelectionStrikethrough: boolean;

			SelectionFont: Eto.Drawing.Font;

			SelectionForeground: Eto.Drawing.Color;

			SelectionBackground: Eto.Drawing.Color;

			readonly Buffer: Eto.Forms.ITextBuffer;

			SelectionFamily: Eto.Drawing.FontFamily;

			SelectionTypeface: Eto.Drawing.FontTypeface;
		}
	}

	export namespace Eto.Forms {
		/** Event arguments for {@link Eto.Forms.Scrollable.Scroll} events */
		export class ScrollEventArgs {
			/** Initializes a new instance of the {@link Eto.Forms.ScrollEventArgs} class. */
			constructor(scrollPosition: Eto.Drawing.Point);

			/** Gets the scroll position of the Scrollable */
			ScrollPosition: Eto.Drawing.Point;
		}
	}

	export namespace Eto.Forms {
		/** Border types */
		export enum BorderType {
			/** Shows a bezel, if that is the default border for controls */
			Bezel = 0,

			/** Shows a single line border */
			Line = 1,

			/** Show no border */
			None = 2,
		}
	}

	export namespace Eto.Forms {
		/** Control to show content in a scrollable container */
		export class Scrollable implements
			Eto.IHandlerSource,
			Eto.Forms.IBindable,
			Eto.Forms.IMouseInputSource,
			Eto.Forms.IKeyboardInputSource {
			constructor();

			/** Gets or sets the scroll position from the top-left origin */
			ScrollPosition: Eto.Drawing.Point;

			/**
			 * Gets or sets the size of the scrollable region manually
			 *
			 * Typically you do not need to set the scroll size manually, as the content will be used
			 * to determine the size automatically.
			 */
			ScrollSize: Eto.Drawing.Size;

			/** Gets or sets the border type */
			Border: Eto.Forms.BorderType;

			/** Gets the coordinates of the rectangle that is visible to the user */
			readonly VisibleRect: Eto.Drawing.Rectangle;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Forms.Scrollable} expands
			 * content to the width of the control
			 *
			 * This controls whether content that is smaller than the size of the control will be
			 * expanded to fill the available space. Content that is larger than the available space
			 * will make the horizontal scrollbar appear, regardless of this setting.
			 */
			ExpandContentWidth: boolean;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Forms.Scrollable} expands
			 * content to the height of the control
			 *
			 * This controls whether content that is smaller than the size of the control will be
			 * expanded to fill the available space. Content that is larger than the available space
			 * will make the vertical scrollbar appear, regardless of this setting.
			 */
			ExpandContentHeight: boolean;

			/**
			 * Hint to get or set the minimum zoom of the scrollable region, if the platform supports
			 * it
			 */
			MinimumZoom: number;

			/**
			 * Hint to get or set the maximum zoom of the scrollable region, if the platform supports
			 * it
			 */
			MaximumZoom: number;

			/** Hint to set the zoom level of the scrollable region, if the platform supports it */
			Zoom: number;

			/** Gets an enumeration of controls that are directly contained by this container */
			readonly Controls: Iterable<Eto.Forms.Control>;

			/** Gets or sets the padding around the {@link Eto.Forms.Panel.Content} of the panel. */
			Padding: Eto.Drawing.Padding;

			/** Gets or sets the minimum size of the panel. */
			MinimumSize: Eto.Drawing.Size;

			/**
			 * Gets or sets the context menu for the panel.
			 *
			 * The context menu is usually shown when the user right clicks the control, or in mobile
			 * platforms when the user taps and holds their finger down on the control.
			 */
			ContextMenu: Eto.Forms.ContextMenu;

			/**
			 * Gets or sets the main content of the panel.
			 *
			 * The main content will be offset by the {@link Eto.Forms.Panel.Padding} value
			 * specified, and will take up the entire content area of the control. Some controls may
			 * have decorations that will surround the content, such as a {@link Eto.Forms.GroupBox},
			 * {@link Eto.Forms.TabControl}, or {@link Eto.Forms.Window}
			 */
			Content: Eto.Forms.Control;

			/**
			 * Gets or sets the size for the client area of the control
			 *
			 * The client size differs from the {@link Eto.Forms.Control.Size} in that it excludes
			 * the decorations of the container, such as the title bar and border around a
			 * {@link Eto.Forms.Window}, or the title and line  around a {@link Eto.Forms.GroupBox}.
			 */
			ClientSize: Eto.Drawing.Size;

			/**
			 * Gets an enumeration of all contained child controls, including controls within child
			 * containers
			 */
			readonly Children: Iterable<Eto.Forms.Control>;

			/**
			 * Gets an enumeration of all contained child controls in the visual tree, including
			 * controls within child containers.
			 */
			readonly VisualChildren: Iterable<Eto.Forms.Control>;

			/**
			 * Gets or sets the style provider for this container.
			 *
			 * The style provider is used to style this container and its children.
			 */
			StyleProvider: Eto.IStyleProvider;

			/**
			 * Gets the default style provider for this container.
			 *
			 * Use this to apply styles to any child controls of this container. By default, styles
			 * will apply to all children, including children of children unless
			 * {@link Eto.DefaultStyleProvider.Inherit} is set to false .  Typically, you would set
			 * Inherit to false when creating composite controls that already have all their styles
			 * applied and you don't want any other styles to be inherited.
			 */
			readonly Styles: Eto.DefaultStyleProvider;

			/**
			 * Gets a value indicating that the control is loaded onto a form, that is it has been
			 * created, added to a parent, and shown
			 *
			 * The {@link Eto.Forms.Control.OnLoad(System.EventArgs)} method sets this value to true
			 * after cascading to all children (for a {@link Eto.Forms.Container} ) and calling the
			 * platform handler's implementation.  It is called after adding to a loaded form, or
			 * when showing a new form.  The {@link Eto.Forms.Control.OnUnLoad(System.EventArgs)}
			 * method will set this value to false when the control is removed from its parent
			 */
			readonly Loaded: boolean;

			/**
			 * Gets an enumeration of controls that are in the visual tree.
			 *
			 * This is used to specify which controls are contained by this instance that are part of
			 * the visual tree. This should include all controls including non-logical Eto controls
			 * used for layout.
			 */
			readonly VisualControls: Iterable<Eto.Forms.Control>;

			/**
			 * Gets or sets a user-defined object that contains data about the control
			 *
			 * A common use of the tag property is to store data that is associated with the control
			 * that you can later retrieve.
			 */
			Tag: unknown;

			/**
			 * Gets the logical parent control.
			 *
			 * When the control is part of the visual tree (
				 * {@link Eto.Forms.Control.IsVisualControl} is true), this returns the logical parent
				 * that contains this control. Otherwise this is the same as
				 * {@link Eto.Forms.Control.Parent}.
				 */
				readonly LogicalParent: Eto.Forms.Container;

			/** Gets a value indicating this {@link Eto.Forms.Control} is part of the visual tree. */
			IsVisualControl: boolean;

			/**
			 * Gets or sets the size of the control. Use -1 to specify auto sizing for either the
			 * width and/or height.
			 *
			 * Setting the size of controls is entirely optional as most controls will size
			 * themselves appropriately. When specifying a size, it will be used as the desired size
			 * of the control.  The container will reposition and resize the control depending on the
			 * available size.  For a {@link Eto.Forms.Window}, it is preferred to set the
			 * {@link Eto.Forms.Container.ClientSize} instead, as various platforms have different
			 * sizes of window decorations, toolbars, etc.
			 */
			Size: Eto.Drawing.Size;

			/**
			 * Gets a value indicating this control currently has mouse capture
			 *
			 * Mouse capture can happen during a handled MouseDown event until MouseUp, or it can be
			 * captured explicitly via {@link Eto.Forms.Control.CaptureMouse}.
			 */
			readonly IsMouseCaptured: boolean;

			/** Gets or sets the width of the control size. */
			Width: number;

			/** Gets or sets the height of the control size. */
			Height: number;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Forms.Control} (or its
			 * children) are enabled and accept user input.
			 *
			 * Typically when a control is disabled, the user cannot do anything with the control or
			 * any of its children. Including for example, selecting text in a text control. Certain
			 * controls can have a 'Read Only' mode, such as {@link Eto.Forms.TextBox.ReadOnly} which
			 * allow the user to  select text, but not change its contents.
			 */
			Enabled: boolean;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Forms.Control} is visible to
			 * the user.
			 *
			 * When the visibility of a control is set to false, it will not occupy space in the
			 * layout.
			 */
			Visible: boolean;

			/** Gets the container which this control has been added to, if any */
			readonly Parent: Eto.Forms.Container;

			/**
			 * Gets the visual container of this control, if any.
			 *
			 * Some containers may use other Eto controls to layout its children, such as the
			 * {@link Eto.Forms.StackLayout}. This will return the parent control that visually
			 * contains this control as opposed to {@link Eto.Forms.Control.Parent} which will return
			 * the logical parent.
			 */
			VisualParent: Eto.Forms.Container;

			/** Gets a value indicating this control has been attached to a native container */
			readonly IsAttached: boolean;

			/**
			 * Gets or sets the color for the background of the control
			 *
			 * Note that on some platforms (e.g. Mac), setting the background color of a control can
			 * change the performance characteristics of the control and its children, since it must
			 * enable layers to do so.
			 */
			BackgroundColor: Eto.Drawing.Color;

			/** Gets a value indicating whether this instance has the keyboard input focus. */
			readonly HasFocus: boolean;

			/** Gets a value indicating whether the layout of child controls is suspended. */
			readonly IsSuspended: boolean;

			/** Gets the window this control is contained in */
			readonly ParentWindow: Eto.Forms.Window;

			/**
			 * Gets the supported platform commands that can be used to hook up system functions to
			 * user defined logic
			 *
			 * This lists all available commands that can be mapped using the
			 * {@link Eto.Forms.Control.MapPlatformCommand(System.String,Eto.Forms.Command)} method
			 * of the control.
			 */
			readonly SupportedPlatformCommands: Iterable<string>;

			/** Gets the bounding rectangle of this control relative to its container */
			readonly Bounds: Eto.Drawing.Rectangle;

			/**
			 * Gets the location of the control as positioned by the container
			 *
			 * A control's location is set by the container. This can be used to determine where the
			 * control is for overlaying floating windows, menus, etc.
			 */
			readonly Location: Eto.Drawing.Point;

			/** Gets or sets the type of cursor to use when the mouse is hovering over the control */
			Cursor: Eto.Forms.Cursor;

			/** Gets or sets the tool tip to show when the mouse is hovered over the control */
			ToolTip: string;

			/**
			 * Gets or sets the tab index order for this control within its container.
			 *
			 * This sets the order when using the tab key to cycle through controls  Note that some
			 * platforms (Gtk and WinForms) may not support setting the context of the tab order to
			 * StackLayout  or DynamicLayout containers and may not behave exactly as expected. Use
			 * the {@link Eto.PlatformFeatures.TabIndexWithCustomContainers} flag to determine if it
			 * is supported.
			 */
			TabIndex: number;

			/** Gets or sets a value indicating whether this control can serve as drop target. */
			AllowDrop: boolean;

			/**
			 * Gets or sets the parent widget which this widget has been added to, if any
			 *
			 * When implementing child widgets that can participate in the context based binding
			 * (MVVM), You can set this to the parent widget when it is added or removed to it
			 * (usually via a collection).  Note that you should typically provide a public new
			 * [ParentWidget] Parent { get; } property  so that consumers of your API cannot set the
			 * parent to an invalid value.
			 */
			Parent: Eto.Widget;

			/**
			 * Gets an enumeration of all parent widgets in the heirarchy by traversing the
			 * {@link Eto.Forms.BindableWidget.Parent} property.
			 */
			readonly Parents: Iterable<Eto.Widget>;

			/**
			 * Gets or sets the data context for this widget for binding
			 *
			 * Subclasses may override the standard behaviour so that hierarchy of widgets can be
			 * taken into account.  For example, a Control may return the data context of a parent,
			 * if it is not set explicitly.
			 */
			DataContext: unknown;

			/** Gets the collection of bindings that are attached to this widget */
			readonly Bindings: Eto.Forms.BindingCollection;

			/**
			 * Gets a value indicating that the {@link Eto.Forms.BindableWidget.DataContext} property
			 * is changing.
			 *
			 * This can be used to determine when to allow certain logic during the update of the
			 * data context.  It is used to disable binding setters on the model when the data
			 * context changes so that a binding does not cause the view model to be updated when the
			 * state hasn't been fully set yet.
			 */
			IsDataContextChanging: boolean;

			/**
			 * Gets the platform that was used to create the {@link Eto.Widget.Handler} for this
			 * widget
			 *
			 * This gets set to the current {@link Eto.Platform.Instance} during the construction of
			 * the object
			 */
			readonly Platform: Eto.Platform;

			/** Gets the platform-specific handler for this widget */
			Handler: unknown;

			/** Gets the native platform-specific handle for integration purposes */
			readonly NativeHandle: unknown;

			/** Gets the dictionary of properties for this widget */
			readonly Properties: Eto.PropertyStore;

			/** Gets or sets the ID of this widget */
			ID: string;

			/**
			 * Gets or sets the style of this widget
			 *
			 * Styles allow you to attach custom platform-specific logic to a widget. In your
			 * platform-specific assembly, use {@link Style.Add{H}(string, StyleHandler{H})} to add
			 * the style logic with the same id.
			 */
			Style: string;

			/**
			 * Gets the instance of the platform-specific object
			 *
			 * This can sometimes be useful to get the platform-specific object. Some handlers may
			 * not have any backing object for its functionality, so this may be null.  It is more
			 * preferred to use the {@link Eto.Widget.Handler} and cast that to the platform-specific
			 * handler class which can give you additional methods and helpers to do common tasks.
			 * For example, the {@link Eto.Forms.Application} object's handler for OS X has a
			 * AddFullScreenMenuItem property to specify if you want full screen support in your app.
			 */
			readonly ControlObject: unknown;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Widget} has been disposed.
			 *
			 * When the widget is disposed, it can no longer be used.
			 */
			IsDisposed: boolean;

			/**
			 * Manually updates the scroll sizes based on the content
			 *
			 * This should not typically be necessary as it should be done automatically
			 */
			UpdateScrollSizes(): void;

			/** Removes the specified child from the container */
			Remove(child: Eto.Forms.Control): void;

			/** Remove the specified `controls` from this container */
			Remove(controls: Iterable<Eto.Forms.Control>): void;

			/** Removes all controls from this container */
			RemoveAll(): void;

			/**
			 * Finds a child control in this container or any of its child containers with the
			 * specified `id`
			 */
			FindChild<T>(id?: string): T;

			/**
			 * Finds a child control in this container or any of its child containers with the
			 * specified `type`
			 */
			FindChild(
				type: unknown,
				id?: string,
			): Eto.Forms.Control;

			/**
			 * Finds a child control in this container or any of its child containers with the
			 * specified `id`.
			 */
			FindChild(id: string): Eto.Forms.Control;

			/**
			 * Queues a repaint of the entire control on the screen and any of its children.
			 *
			 * This is only useful when the control is visible.
			 */
			Invalidate(): void;

			/**
			 * Queues a repaint of the entire control on the screen
			 *
			 * This is only useful when the control is visible.
			 */
			Invalidate(invalidateChildren: boolean): void;

			/**
			 * Queues a repaint of the specified `rect` of the control and any children.
			 *
			 * This is only useful when the control is visible.
			 */
			Invalidate(rect: Eto.Drawing.Rectangle): void;

			/**
			 * Queues a repaint of the specified `rect` of the control
			 *
			 * This is only useful when the control is visible.
			 */
			Invalidate(
				rect: Eto.Drawing.Rectangle,
				invalidateChildren: boolean,
			): void;

			/**
			 * Updates the layout of this control if necessary.
			 *
			 * This will ensure the control has had all of its layout applied so you can use its
			 * position and size right after this call. Most platforms (except WinForms) use a
			 * deferred layout system so that after adding your control to the form dynamically it
			 * won't get laid out until the next idle loop. This is useful when you need to know the
			 * dimensions of the control immediately. Note that this can be an expensive operation,
			 * so it is recommended to only call this method when necessary and after all of the
			 * controls have been added/updated.
			 */
			UpdateLayout(): void;

			/** Gets the preferred size of this control given infinite space available. */
			GetPreferredSize(): Eto.Drawing.SizeF;

			/** Gets the preferred size of this control given the specified `availableSize`. */
			GetPreferredSize(availableSize: Eto.Drawing.SizeF): Eto.Drawing.SizeF;

			/**
			 * Captures all mouse events to this control.
			 *
			 * This captures all mouse events until {@link Eto.Forms.Control.ReleaseMouseCapture} is
			 * called.  Note that not all platforms will allow a mouse capture unless the mouse is
			 * currently down.
			 */
			CaptureMouse(): boolean;

			/** Releases the mouse capture after a call to {@link Eto.Forms.Control.CaptureMouse}. */
			ReleaseMouseCapture(): void;

			/**
			 * Finds a control in the parent hierarchy with the specified type and
			 * {@link Eto.Widget.ID} if specified
			 */
			FindParent(
				type: unknown,
				id?: string,
			): Eto.Forms.Container;

			/** Finds a control in the parent hierarchy with the specified `id` */
			FindParent(id: string): Eto.Forms.Container;

			/**
			 * Detaches the control by removing it from its parent
			 *
			 * This is essentially a shortcut to myControl.Parent.Remove(myControl);
			 */
			Detach(): void;

			/**
			 * Attaches the control for direct use in a native application
			 *
			 * Use this to use a control directly in a native application.  Note that the native
			 * application must be running the same framework as the current platform.  E.g. a
			 * WinForms application can use an Eto.Forms control when using the Eto.WinForms
			 * platform.  This prepares the control by firing the {@link Eto.Forms.Control.PreLoad},
			 * {@link Eto.Forms.Control.Load}, etc. events.
			 */
			AttachNative(): void;

			/**
			 * Detaches the control when it is used in a native application, when you want to reuse
			 * the control.
			 *
			 * This should only be called after {@link Eto.Forms.Control.AttachNative} has been
			 * called, which is usually done by calling to ToNative(true) .
			 */
			DetachNative(): void;

			/**
			 * Attempts to set the keyboard input focus to this control, or the first child that
			 * accepts focus. For Windows, this will bring it to front and activate it.
			 */
			Focus(): void;

			/**
			 * Suspends the layout of child controls
			 *
			 * This can be used to optimize some platforms while adding, removing, or changing many
			 * child controls at once. It disables the calculation of control positioning until
			 * {@link Eto.Forms.Control.ResumeLayout} is called. Each call to SuspendLayout() must be
			 * balanced with a call to {@link Eto.Forms.Control.ResumeLayout}.
			 */
			SuspendLayout(): void;

			/**
			 * Resumes the layout after it has been suspended, and performs a layout
			 *
			 * This can be used to optimize some platforms while adding, removing, or changing many
			 * child controls at once. Each call to ResumeLayout() must be balanced with a call to
			 * {@link Eto.Forms.Control.SuspendLayout} before it.
			 */
			ResumeLayout(): void;

			/**
			 * Specifies a command to execute for a platform-specific command
			 *
			 * Some platforms have specific system-defined commands that can be associated with a
			 * control. For example, the Mac platform's cut/copy/paste functionality is defined by
			 * the system, and if you want to hook into it, you can use this to map it to your own
			 * defined logic. The valid values of the `systemCommand` parameter are defined by each
			 * platform, and a list can be retrieved using
			 * {@link Eto.Forms.Control.SupportedPlatformCommands}
			 */
			MapPlatformCommand(
				systemCommand: string,
				command: Eto.Forms.Command,
			): void;

			/** Converts a point from screen space to control space. */
			PointFromScreen(point: Eto.Drawing.PointF): Eto.Drawing.PointF;

			/** Converts a point from control space to screen space */
			PointToScreen(point: Eto.Drawing.PointF): Eto.Drawing.PointF;

			/** Converts a rectangle from screen space to control space. */
			RectangleToScreen(rect: Eto.Drawing.RectangleF): Eto.Drawing.RectangleF;

			/** Converts a rectangle from control space to screen space */
			RectangleFromScreen(rect: Eto.Drawing.RectangleF): Eto.Drawing.RectangleF;

			/**
			 * Starts drag operation using this control as drag source.
			 *
			 * This method can be blocking on some platforms (Wpf, WinForms), and non-blocking on
			 * others (Mac, Gtk). Use the {@link Eto.Forms.Control.DragEnd} event to determine when
			 * the drag operation is completed and get its resulting DragEffects.
			 */
			DoDragDrop(
				data: Eto.Forms.DataObject,
				allowedEffects: Eto.Forms.DragEffects,
			): void;

			/**
			 * Starts drag operation using this control as drag source.
			 *
			 * This method can be blocking on some platforms (Wpf, WinForms), and non-blocking on
			 * others (Mac, Gtk). Use the {@link Eto.Forms.Control.DragEnd} event to determine when
			 * the drag operation is completed and get its resulting DragEffects.
			 */
			DoDragDrop(
				data: Eto.Forms.DataObject,
				allowedEffects: Eto.Forms.DragEffects,
				image: Eto.Drawing.Image,
				cursorOffset: Eto.Drawing.PointF,
			): void;

			/**
			 * Triggers the StyleChanged event and re-applies the styles to this control and its
			 * children.
			 */
			TriggerStyleChanged(): void;

			/** Shows a print dialog to print the specified control */
			Print(): void;

			/**
			 * Finds a control in the parent hierarchy with the specified type and
			 * {@link Eto.Widget.ID} if specified
			 */
			FindParent<T>(id?: string): T;

			/**
			 * Finds a control in the parent hierarchy with the specified type and
			 * {@link Eto.Widget.ID} if specified
			 */
			FindParent(
				type: unknown,
				id?: string,
			): Eto.Widget;

			/** Finds a control in the parent hierarchy with the specified `id` */
			FindParent(id: string): Eto.Widget;

			/**
			 * Unbinds any bindings in the {@link Eto.Forms.BindableWidget.Bindings} collection and
			 * removes the bindings
			 *
			 * When you implement {@link Eto.Forms.IBindableWidgetContainer}, this will also unbind
			 * any of its children.
			 */
			Unbind(): void;

			/**
			 * Updates all bindings in this widget
			 *
			 * When you implement {@link Eto.Forms.IBindableWidgetContainer}, this will also update
			 * bindings for all of its children.
			 */
			UpdateBindings(mode?: Eto.Forms.BindingUpdateMode): void;

			/** Disposes of this widget, supressing the finalizer */
			dispose(): void;

			/** Gets a string that represents the current object with its ID if specified. */
			ToString(): string;
		}
	}

	export namespace Eto.Forms.Scrollable {
		export interface ICallback extends
			Eto.Forms.Control.ICallback,
			Eto.Widget.ICallback {
			OnScroll(
				widget: Eto.Forms.Scrollable,
				e: Eto.Forms.ScrollEventArgs,
			): void;
		}
	}

	export namespace Eto.Forms.Scrollable {
		export interface IHandler extends
			Eto.Forms.Panel.IHandler,
			Eto.Forms.Container.IHandler,
			Eto.Forms.Control.IHandler,
			Eto.Widget.IHandler,
			Eto.Forms.IContextMenuHost {
			ScrollPosition: Eto.Drawing.Point;

			ScrollSize: Eto.Drawing.Size;

			Border: Eto.Forms.BorderType;

			readonly VisibleRect: Eto.Drawing.Rectangle;

			ExpandContentWidth: boolean;

			ExpandContentHeight: boolean;

			MinimumZoom: number;

			MaximumZoom: number;

			Zoom: number;

			UpdateScrollSizes(): void;
		}
	}

	export namespace Eto.Forms {
		/**
		 * Search box control
		 *
		 * The search box control is similar to a plain text box, but provides platform-specific
		 * styling.
		 */
		export class SearchBox implements
			Eto.IHandlerSource,
			Eto.Forms.IBindable,
			Eto.Forms.IMouseInputSource,
			Eto.Forms.IKeyboardInputSource {
			constructor();

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Forms.TextBox} is read only.
			 *
			 * A user can selected and copied text when the read only, however the user will not be
			 * able to change any of the text. This differs from the
			 * {@link Eto.Forms.Control.Enabled} property, which disables all user interaction.
			 */
			ReadOnly: boolean;

			/**
			 * Gets or sets the maximum length of the text that can be entered in the control, 0 for
			 * no limit.
			 *
			 * This typically does not affect the value set using {@link Eto.Forms.TextControl.Text},
			 * only the limit of what the user can  enter into the control.
			 */
			MaxLength: number;

			/**
			 * Gets or sets the placeholder text to show as a hint of what the user should enter.
			 *
			 * Typically this will be shown when the control is blank, and will dissappear when the
			 * user enters text or if it has an existing value.
			 */
			PlaceholderText: string;

			/**
			 * Gets or sets a value indicating whether to show the control's border.
			 *
			 * This is a hint to omit the border of the control and show it as plainly as possible.
			 * Typically used when you want to show the control within a cell of the
			 * {@link Eto.Forms.GridView}.
			 */
			ShowBorder: boolean;

			/** Gets or sets the alignment of the text in the entry box. */
			TextAlignment: Eto.Forms.TextAlignment;

			/**
			 * Gets or sets the index of the current insertion point.
			 *
			 * When there is selected text, this is usually the start of the selection.
			 */
			CaretIndex: number;

			/** Gets or sets the current text selection. */
			Selection: Eto.Forms.Range$1<number>;

			/** Gets or sets the selected text. */
			SelectedText: string;

			/** Gets or sets the auto selection mode. */
			AutoSelectMode: Eto.Forms.AutoSelectMode;

			/**
			 * Gets or sets the text of the control.
			 *
			 * Usually, the caret and selection will be set to the end of the string after its set.
			 */
			Text: string;

			/**
			 * Gets or sets the color of the text.
			 *
			 * By default, the text will get a color based on the user's theme. However, this is
			 * usually black.
			 */
			TextColor: Eto.Drawing.Color;

			/** Gets the binding for the {@link Eto.Forms.TextControl.Text} property. */
			readonly TextBinding: Eto.Forms.BindableBinding$2<Eto.Forms.TextControl, string>;

			/** Gets or sets the font for the text of the control */
			Font: Eto.Drawing.Font;

			/**
			 * Gets a value indicating that the control is loaded onto a form, that is it has been
			 * created, added to a parent, and shown
			 *
			 * The {@link Eto.Forms.Control.OnLoad(System.EventArgs)} method sets this value to true
			 * after cascading to all children (for a {@link Eto.Forms.Container} ) and calling the
			 * platform handler's implementation.  It is called after adding to a loaded form, or
			 * when showing a new form.  The {@link Eto.Forms.Control.OnUnLoad(System.EventArgs)}
			 * method will set this value to false when the control is removed from its parent
			 */
			readonly Loaded: boolean;

			/**
			 * Gets an enumeration of controls that are in the visual tree.
			 *
			 * This is used to specify which controls are contained by this instance that are part of
			 * the visual tree. This should include all controls including non-logical Eto controls
			 * used for layout.
			 */
			readonly VisualControls: Iterable<Eto.Forms.Control>;

			/**
			 * Gets or sets a user-defined object that contains data about the control
			 *
			 * A common use of the tag property is to store data that is associated with the control
			 * that you can later retrieve.
			 */
			Tag: unknown;

			/**
			 * Gets the logical parent control.
			 *
			 * When the control is part of the visual tree (
				 * {@link Eto.Forms.Control.IsVisualControl} is true), this returns the logical parent
				 * that contains this control. Otherwise this is the same as
				 * {@link Eto.Forms.Control.Parent}.
				 */
				readonly LogicalParent: Eto.Forms.Container;

			/** Gets a value indicating this {@link Eto.Forms.Control} is part of the visual tree. */
			IsVisualControl: boolean;

			/**
			 * Gets or sets the size of the control. Use -1 to specify auto sizing for either the
			 * width and/or height.
			 *
			 * Setting the size of controls is entirely optional as most controls will size
			 * themselves appropriately. When specifying a size, it will be used as the desired size
			 * of the control.  The container will reposition and resize the control depending on the
			 * available size.  For a {@link Eto.Forms.Window}, it is preferred to set the
			 * {@link Eto.Forms.Container.ClientSize} instead, as various platforms have different
			 * sizes of window decorations, toolbars, etc.
			 */
			Size: Eto.Drawing.Size;

			/**
			 * Gets a value indicating this control currently has mouse capture
			 *
			 * Mouse capture can happen during a handled MouseDown event until MouseUp, or it can be
			 * captured explicitly via {@link Eto.Forms.Control.CaptureMouse}.
			 */
			readonly IsMouseCaptured: boolean;

			/** Gets or sets the width of the control size. */
			Width: number;

			/** Gets or sets the height of the control size. */
			Height: number;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Forms.Control} (or its
			 * children) are enabled and accept user input.
			 *
			 * Typically when a control is disabled, the user cannot do anything with the control or
			 * any of its children. Including for example, selecting text in a text control. Certain
			 * controls can have a 'Read Only' mode, such as {@link Eto.Forms.TextBox.ReadOnly} which
			 * allow the user to  select text, but not change its contents.
			 */
			Enabled: boolean;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Forms.Control} is visible to
			 * the user.
			 *
			 * When the visibility of a control is set to false, it will not occupy space in the
			 * layout.
			 */
			Visible: boolean;

			/** Gets the container which this control has been added to, if any */
			readonly Parent: Eto.Forms.Container;

			/**
			 * Gets the visual container of this control, if any.
			 *
			 * Some containers may use other Eto controls to layout its children, such as the
			 * {@link Eto.Forms.StackLayout}. This will return the parent control that visually
			 * contains this control as opposed to {@link Eto.Forms.Control.Parent} which will return
			 * the logical parent.
			 */
			VisualParent: Eto.Forms.Container;

			/** Gets a value indicating this control has been attached to a native container */
			readonly IsAttached: boolean;

			/**
			 * Gets or sets the color for the background of the control
			 *
			 * Note that on some platforms (e.g. Mac), setting the background color of a control can
			 * change the performance characteristics of the control and its children, since it must
			 * enable layers to do so.
			 */
			BackgroundColor: Eto.Drawing.Color;

			/** Gets a value indicating whether this instance has the keyboard input focus. */
			readonly HasFocus: boolean;

			/** Gets a value indicating whether the layout of child controls is suspended. */
			readonly IsSuspended: boolean;

			/** Gets the window this control is contained in */
			readonly ParentWindow: Eto.Forms.Window;

			/**
			 * Gets the supported platform commands that can be used to hook up system functions to
			 * user defined logic
			 *
			 * This lists all available commands that can be mapped using the
			 * {@link Eto.Forms.Control.MapPlatformCommand(System.String,Eto.Forms.Command)} method
			 * of the control.
			 */
			readonly SupportedPlatformCommands: Iterable<string>;

			/** Gets the bounding rectangle of this control relative to its container */
			readonly Bounds: Eto.Drawing.Rectangle;

			/**
			 * Gets the location of the control as positioned by the container
			 *
			 * A control's location is set by the container. This can be used to determine where the
			 * control is for overlaying floating windows, menus, etc.
			 */
			readonly Location: Eto.Drawing.Point;

			/** Gets or sets the type of cursor to use when the mouse is hovering over the control */
			Cursor: Eto.Forms.Cursor;

			/** Gets or sets the tool tip to show when the mouse is hovered over the control */
			ToolTip: string;

			/**
			 * Gets or sets the tab index order for this control within its container.
			 *
			 * This sets the order when using the tab key to cycle through controls  Note that some
			 * platforms (Gtk and WinForms) may not support setting the context of the tab order to
			 * StackLayout  or DynamicLayout containers and may not behave exactly as expected. Use
			 * the {@link Eto.PlatformFeatures.TabIndexWithCustomContainers} flag to determine if it
			 * is supported.
			 */
			TabIndex: number;

			/** Gets or sets a value indicating whether this control can serve as drop target. */
			AllowDrop: boolean;

			/**
			 * Gets or sets the parent widget which this widget has been added to, if any
			 *
			 * When implementing child widgets that can participate in the context based binding
			 * (MVVM), You can set this to the parent widget when it is added or removed to it
			 * (usually via a collection).  Note that you should typically provide a public new
			 * [ParentWidget] Parent { get; } property  so that consumers of your API cannot set the
			 * parent to an invalid value.
			 */
			Parent: Eto.Widget;

			/**
			 * Gets an enumeration of all parent widgets in the heirarchy by traversing the
			 * {@link Eto.Forms.BindableWidget.Parent} property.
			 */
			readonly Parents: Iterable<Eto.Widget>;

			/**
			 * Gets or sets the data context for this widget for binding
			 *
			 * Subclasses may override the standard behaviour so that hierarchy of widgets can be
			 * taken into account.  For example, a Control may return the data context of a parent,
			 * if it is not set explicitly.
			 */
			DataContext: unknown;

			/** Gets the collection of bindings that are attached to this widget */
			readonly Bindings: Eto.Forms.BindingCollection;

			/**
			 * Gets a value indicating that the {@link Eto.Forms.BindableWidget.DataContext} property
			 * is changing.
			 *
			 * This can be used to determine when to allow certain logic during the update of the
			 * data context.  It is used to disable binding setters on the model when the data
			 * context changes so that a binding does not cause the view model to be updated when the
			 * state hasn't been fully set yet.
			 */
			IsDataContextChanging: boolean;

			/**
			 * Gets the platform that was used to create the {@link Eto.Widget.Handler} for this
			 * widget
			 *
			 * This gets set to the current {@link Eto.Platform.Instance} during the construction of
			 * the object
			 */
			readonly Platform: Eto.Platform;

			/** Gets the platform-specific handler for this widget */
			Handler: unknown;

			/** Gets the native platform-specific handle for integration purposes */
			readonly NativeHandle: unknown;

			/** Gets the dictionary of properties for this widget */
			readonly Properties: Eto.PropertyStore;

			/** Gets or sets the ID of this widget */
			ID: string;

			/**
			 * Gets or sets the style of this widget
			 *
			 * Styles allow you to attach custom platform-specific logic to a widget. In your
			 * platform-specific assembly, use {@link Style.Add{H}(string, StyleHandler{H})} to add
			 * the style logic with the same id.
			 */
			Style: string;

			/**
			 * Gets the instance of the platform-specific object
			 *
			 * This can sometimes be useful to get the platform-specific object. Some handlers may
			 * not have any backing object for its functionality, so this may be null.  It is more
			 * preferred to use the {@link Eto.Widget.Handler} and cast that to the platform-specific
			 * handler class which can give you additional methods and helpers to do common tasks.
			 * For example, the {@link Eto.Forms.Application} object's handler for OS X has a
			 * AddFullScreenMenuItem property to specify if you want full screen support in your app.
			 */
			readonly ControlObject: unknown;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Widget} has been disposed.
			 *
			 * When the widget is disposed, it can no longer be used.
			 */
			IsDisposed: boolean;

			/**
			 * Selects all of the text in the control.
			 *
			 * When setting the selection, the control will be focussed and the associated keyboard
			 * may appear on mobile platforms.
			 */
			SelectAll(): void;

			/**
			 * Queues a repaint of the entire control on the screen and any of its children.
			 *
			 * This is only useful when the control is visible.
			 */
			Invalidate(): void;

			/**
			 * Queues a repaint of the entire control on the screen
			 *
			 * This is only useful when the control is visible.
			 */
			Invalidate(invalidateChildren: boolean): void;

			/**
			 * Queues a repaint of the specified `rect` of the control and any children.
			 *
			 * This is only useful when the control is visible.
			 */
			Invalidate(rect: Eto.Drawing.Rectangle): void;

			/**
			 * Queues a repaint of the specified `rect` of the control
			 *
			 * This is only useful when the control is visible.
			 */
			Invalidate(
				rect: Eto.Drawing.Rectangle,
				invalidateChildren: boolean,
			): void;

			/**
			 * Updates the layout of this control if necessary.
			 *
			 * This will ensure the control has had all of its layout applied so you can use its
			 * position and size right after this call. Most platforms (except WinForms) use a
			 * deferred layout system so that after adding your control to the form dynamically it
			 * won't get laid out until the next idle loop. This is useful when you need to know the
			 * dimensions of the control immediately. Note that this can be an expensive operation,
			 * so it is recommended to only call this method when necessary and after all of the
			 * controls have been added/updated.
			 */
			UpdateLayout(): void;

			/** Gets the preferred size of this control given infinite space available. */
			GetPreferredSize(): Eto.Drawing.SizeF;

			/** Gets the preferred size of this control given the specified `availableSize`. */
			GetPreferredSize(availableSize: Eto.Drawing.SizeF): Eto.Drawing.SizeF;

			/**
			 * Captures all mouse events to this control.
			 *
			 * This captures all mouse events until {@link Eto.Forms.Control.ReleaseMouseCapture} is
			 * called.  Note that not all platforms will allow a mouse capture unless the mouse is
			 * currently down.
			 */
			CaptureMouse(): boolean;

			/** Releases the mouse capture after a call to {@link Eto.Forms.Control.CaptureMouse}. */
			ReleaseMouseCapture(): void;

			/**
			 * Finds a control in the parent hierarchy with the specified type and
			 * {@link Eto.Widget.ID} if specified
			 */
			FindParent(
				type: unknown,
				id?: string,
			): Eto.Forms.Container;

			/** Finds a control in the parent hierarchy with the specified `id` */
			FindParent(id: string): Eto.Forms.Container;

			/**
			 * Detaches the control by removing it from its parent
			 *
			 * This is essentially a shortcut to myControl.Parent.Remove(myControl);
			 */
			Detach(): void;

			/**
			 * Attaches the control for direct use in a native application
			 *
			 * Use this to use a control directly in a native application.  Note that the native
			 * application must be running the same framework as the current platform.  E.g. a
			 * WinForms application can use an Eto.Forms control when using the Eto.WinForms
			 * platform.  This prepares the control by firing the {@link Eto.Forms.Control.PreLoad},
			 * {@link Eto.Forms.Control.Load}, etc. events.
			 */
			AttachNative(): void;

			/**
			 * Detaches the control when it is used in a native application, when you want to reuse
			 * the control.
			 *
			 * This should only be called after {@link Eto.Forms.Control.AttachNative} has been
			 * called, which is usually done by calling to ToNative(true) .
			 */
			DetachNative(): void;

			/**
			 * Attempts to set the keyboard input focus to this control, or the first child that
			 * accepts focus. For Windows, this will bring it to front and activate it.
			 */
			Focus(): void;

			/**
			 * Suspends the layout of child controls
			 *
			 * This can be used to optimize some platforms while adding, removing, or changing many
			 * child controls at once. It disables the calculation of control positioning until
			 * {@link Eto.Forms.Control.ResumeLayout} is called. Each call to SuspendLayout() must be
			 * balanced with a call to {@link Eto.Forms.Control.ResumeLayout}.
			 */
			SuspendLayout(): void;

			/**
			 * Resumes the layout after it has been suspended, and performs a layout
			 *
			 * This can be used to optimize some platforms while adding, removing, or changing many
			 * child controls at once. Each call to ResumeLayout() must be balanced with a call to
			 * {@link Eto.Forms.Control.SuspendLayout} before it.
			 */
			ResumeLayout(): void;

			/**
			 * Specifies a command to execute for a platform-specific command
			 *
			 * Some platforms have specific system-defined commands that can be associated with a
			 * control. For example, the Mac platform's cut/copy/paste functionality is defined by
			 * the system, and if you want to hook into it, you can use this to map it to your own
			 * defined logic. The valid values of the `systemCommand` parameter are defined by each
			 * platform, and a list can be retrieved using
			 * {@link Eto.Forms.Control.SupportedPlatformCommands}
			 */
			MapPlatformCommand(
				systemCommand: string,
				command: Eto.Forms.Command,
			): void;

			/** Converts a point from screen space to control space. */
			PointFromScreen(point: Eto.Drawing.PointF): Eto.Drawing.PointF;

			/** Converts a point from control space to screen space */
			PointToScreen(point: Eto.Drawing.PointF): Eto.Drawing.PointF;

			/** Converts a rectangle from screen space to control space. */
			RectangleToScreen(rect: Eto.Drawing.RectangleF): Eto.Drawing.RectangleF;

			/** Converts a rectangle from control space to screen space */
			RectangleFromScreen(rect: Eto.Drawing.RectangleF): Eto.Drawing.RectangleF;

			/**
			 * Starts drag operation using this control as drag source.
			 *
			 * This method can be blocking on some platforms (Wpf, WinForms), and non-blocking on
			 * others (Mac, Gtk). Use the {@link Eto.Forms.Control.DragEnd} event to determine when
			 * the drag operation is completed and get its resulting DragEffects.
			 */
			DoDragDrop(
				data: Eto.Forms.DataObject,
				allowedEffects: Eto.Forms.DragEffects,
			): void;

			/**
			 * Starts drag operation using this control as drag source.
			 *
			 * This method can be blocking on some platforms (Wpf, WinForms), and non-blocking on
			 * others (Mac, Gtk). Use the {@link Eto.Forms.Control.DragEnd} event to determine when
			 * the drag operation is completed and get its resulting DragEffects.
			 */
			DoDragDrop(
				data: Eto.Forms.DataObject,
				allowedEffects: Eto.Forms.DragEffects,
				image: Eto.Drawing.Image,
				cursorOffset: Eto.Drawing.PointF,
			): void;

			/**
			 * Triggers the StyleChanged event and re-applies the styles to this control and its
			 * children.
			 */
			TriggerStyleChanged(): void;

			/** Shows a print dialog to print the specified control */
			Print(): void;

			/**
			 * Finds a control in the parent hierarchy with the specified type and
			 * {@link Eto.Widget.ID} if specified
			 */
			FindParent<T>(id?: string): T;

			/**
			 * Finds a control in the parent hierarchy with the specified type and
			 * {@link Eto.Widget.ID} if specified
			 */
			FindParent(
				type: unknown,
				id?: string,
			): Eto.Widget;

			/** Finds a control in the parent hierarchy with the specified `id` */
			FindParent(id: string): Eto.Widget;

			/**
			 * Unbinds any bindings in the {@link Eto.Forms.BindableWidget.Bindings} collection and
			 * removes the bindings
			 *
			 * When you implement {@link Eto.Forms.IBindableWidgetContainer}, this will also unbind
			 * any of its children.
			 */
			Unbind(): void;

			/**
			 * Updates all bindings in this widget
			 *
			 * When you implement {@link Eto.Forms.IBindableWidgetContainer}, this will also update
			 * bindings for all of its children.
			 */
			UpdateBindings(mode?: Eto.Forms.BindingUpdateMode): void;

			/** Disposes of this widget, supressing the finalizer */
			dispose(): void;

			/** Gets a string that represents the current object with its ID if specified. */
			ToString(): string;
		}
	}

	export namespace Eto.Forms.SearchBox {
		export interface IHandler extends
			Eto.Forms.TextBox.IHandler,
			Eto.Forms.TextControl.IHandler,
			Eto.Forms.CommonControl.IHandler,
			Eto.Forms.Control.IHandler,
			Eto.Widget.IHandler {
		}
	}

	export namespace Eto.Forms {
		/**
		 * Control with a knob the user can slide up/down or left/right to select a numeric
		 * range.
		 */
		export class Slider implements
			Eto.IHandlerSource,
			Eto.Forms.IBindable,
			Eto.Forms.IMouseInputSource,
			Eto.Forms.IKeyboardInputSource {
			constructor();

			/**
			 * Gets or sets the hint for numeric value between each visual tick.
			 *
			 * This is for visual representation only, unless the {@link Eto.Forms.Slider.SnapToTick}
			 * is set to true.
			 */
			TickFrequency: number;

			/**
			 * Gets or sets a value indicating whether the slider will snap to each tick.
			 *
			 * This will restrict the user's input to only values at each
			 * {@link Eto.Forms.Slider.TickFrequency} interval between the
			 * {@link Eto.Forms.Slider.MinValue} and {@link Eto.Forms.Slider.MaxValue}.
			 */
			SnapToTick: boolean;

			/** Gets or sets the maximum value that can be set by the user. */
			MaxValue: number;

			/** Gets or sets the minimum value that can be set by the user. */
			MinValue: number;

			/** Gets or sets the current slider value. */
			Value: number;

			/** Gets the binding for the {@link Eto.Forms.Slider.Value} property. */
			readonly ValueBinding: Eto.Forms.BindableBinding$2<Eto.Forms.Slider, number>;

			/** Gets or sets the orientation of the slider. */
			Orientation: Eto.Forms.Orientation;

			/**
			 * Gets a value indicating that the control is loaded onto a form, that is it has been
			 * created, added to a parent, and shown
			 *
			 * The {@link Eto.Forms.Control.OnLoad(System.EventArgs)} method sets this value to true
			 * after cascading to all children (for a {@link Eto.Forms.Container} ) and calling the
			 * platform handler's implementation.  It is called after adding to a loaded form, or
			 * when showing a new form.  The {@link Eto.Forms.Control.OnUnLoad(System.EventArgs)}
			 * method will set this value to false when the control is removed from its parent
			 */
			readonly Loaded: boolean;

			/**
			 * Gets an enumeration of controls that are in the visual tree.
			 *
			 * This is used to specify which controls are contained by this instance that are part of
			 * the visual tree. This should include all controls including non-logical Eto controls
			 * used for layout.
			 */
			readonly VisualControls: Iterable<Eto.Forms.Control>;

			/**
			 * Gets or sets a user-defined object that contains data about the control
			 *
			 * A common use of the tag property is to store data that is associated with the control
			 * that you can later retrieve.
			 */
			Tag: unknown;

			/**
			 * Gets the logical parent control.
			 *
			 * When the control is part of the visual tree (
				 * {@link Eto.Forms.Control.IsVisualControl} is true), this returns the logical parent
				 * that contains this control. Otherwise this is the same as
				 * {@link Eto.Forms.Control.Parent}.
				 */
				readonly LogicalParent: Eto.Forms.Container;

			/** Gets a value indicating this {@link Eto.Forms.Control} is part of the visual tree. */
			IsVisualControl: boolean;

			/**
			 * Gets or sets the size of the control. Use -1 to specify auto sizing for either the
			 * width and/or height.
			 *
			 * Setting the size of controls is entirely optional as most controls will size
			 * themselves appropriately. When specifying a size, it will be used as the desired size
			 * of the control.  The container will reposition and resize the control depending on the
			 * available size.  For a {@link Eto.Forms.Window}, it is preferred to set the
			 * {@link Eto.Forms.Container.ClientSize} instead, as various platforms have different
			 * sizes of window decorations, toolbars, etc.
			 */
			Size: Eto.Drawing.Size;

			/**
			 * Gets a value indicating this control currently has mouse capture
			 *
			 * Mouse capture can happen during a handled MouseDown event until MouseUp, or it can be
			 * captured explicitly via {@link Eto.Forms.Control.CaptureMouse}.
			 */
			readonly IsMouseCaptured: boolean;

			/** Gets or sets the width of the control size. */
			Width: number;

			/** Gets or sets the height of the control size. */
			Height: number;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Forms.Control} (or its
			 * children) are enabled and accept user input.
			 *
			 * Typically when a control is disabled, the user cannot do anything with the control or
			 * any of its children. Including for example, selecting text in a text control. Certain
			 * controls can have a 'Read Only' mode, such as {@link Eto.Forms.TextBox.ReadOnly} which
			 * allow the user to  select text, but not change its contents.
			 */
			Enabled: boolean;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Forms.Control} is visible to
			 * the user.
			 *
			 * When the visibility of a control is set to false, it will not occupy space in the
			 * layout.
			 */
			Visible: boolean;

			/** Gets the container which this control has been added to, if any */
			readonly Parent: Eto.Forms.Container;

			/**
			 * Gets the visual container of this control, if any.
			 *
			 * Some containers may use other Eto controls to layout its children, such as the
			 * {@link Eto.Forms.StackLayout}. This will return the parent control that visually
			 * contains this control as opposed to {@link Eto.Forms.Control.Parent} which will return
			 * the logical parent.
			 */
			VisualParent: Eto.Forms.Container;

			/** Gets a value indicating this control has been attached to a native container */
			readonly IsAttached: boolean;

			/**
			 * Gets or sets the color for the background of the control
			 *
			 * Note that on some platforms (e.g. Mac), setting the background color of a control can
			 * change the performance characteristics of the control and its children, since it must
			 * enable layers to do so.
			 */
			BackgroundColor: Eto.Drawing.Color;

			/** Gets a value indicating whether this instance has the keyboard input focus. */
			readonly HasFocus: boolean;

			/** Gets a value indicating whether the layout of child controls is suspended. */
			readonly IsSuspended: boolean;

			/** Gets the window this control is contained in */
			readonly ParentWindow: Eto.Forms.Window;

			/**
			 * Gets the supported platform commands that can be used to hook up system functions to
			 * user defined logic
			 *
			 * This lists all available commands that can be mapped using the
			 * {@link Eto.Forms.Control.MapPlatformCommand(System.String,Eto.Forms.Command)} method
			 * of the control.
			 */
			readonly SupportedPlatformCommands: Iterable<string>;

			/** Gets the bounding rectangle of this control relative to its container */
			readonly Bounds: Eto.Drawing.Rectangle;

			/**
			 * Gets the location of the control as positioned by the container
			 *
			 * A control's location is set by the container. This can be used to determine where the
			 * control is for overlaying floating windows, menus, etc.
			 */
			readonly Location: Eto.Drawing.Point;

			/** Gets or sets the type of cursor to use when the mouse is hovering over the control */
			Cursor: Eto.Forms.Cursor;

			/** Gets or sets the tool tip to show when the mouse is hovered over the control */
			ToolTip: string;

			/**
			 * Gets or sets the tab index order for this control within its container.
			 *
			 * This sets the order when using the tab key to cycle through controls  Note that some
			 * platforms (Gtk and WinForms) may not support setting the context of the tab order to
			 * StackLayout  or DynamicLayout containers and may not behave exactly as expected. Use
			 * the {@link Eto.PlatformFeatures.TabIndexWithCustomContainers} flag to determine if it
			 * is supported.
			 */
			TabIndex: number;

			/** Gets or sets a value indicating whether this control can serve as drop target. */
			AllowDrop: boolean;

			/**
			 * Gets or sets the parent widget which this widget has been added to, if any
			 *
			 * When implementing child widgets that can participate in the context based binding
			 * (MVVM), You can set this to the parent widget when it is added or removed to it
			 * (usually via a collection).  Note that you should typically provide a public new
			 * [ParentWidget] Parent { get; } property  so that consumers of your API cannot set the
			 * parent to an invalid value.
			 */
			Parent: Eto.Widget;

			/**
			 * Gets an enumeration of all parent widgets in the heirarchy by traversing the
			 * {@link Eto.Forms.BindableWidget.Parent} property.
			 */
			readonly Parents: Iterable<Eto.Widget>;

			/**
			 * Gets or sets the data context for this widget for binding
			 *
			 * Subclasses may override the standard behaviour so that hierarchy of widgets can be
			 * taken into account.  For example, a Control may return the data context of a parent,
			 * if it is not set explicitly.
			 */
			DataContext: unknown;

			/** Gets the collection of bindings that are attached to this widget */
			readonly Bindings: Eto.Forms.BindingCollection;

			/**
			 * Gets a value indicating that the {@link Eto.Forms.BindableWidget.DataContext} property
			 * is changing.
			 *
			 * This can be used to determine when to allow certain logic during the update of the
			 * data context.  It is used to disable binding setters on the model when the data
			 * context changes so that a binding does not cause the view model to be updated when the
			 * state hasn't been fully set yet.
			 */
			IsDataContextChanging: boolean;

			/**
			 * Gets the platform that was used to create the {@link Eto.Widget.Handler} for this
			 * widget
			 *
			 * This gets set to the current {@link Eto.Platform.Instance} during the construction of
			 * the object
			 */
			readonly Platform: Eto.Platform;

			/** Gets the platform-specific handler for this widget */
			Handler: unknown;

			/** Gets the native platform-specific handle for integration purposes */
			readonly NativeHandle: unknown;

			/** Gets the dictionary of properties for this widget */
			readonly Properties: Eto.PropertyStore;

			/** Gets or sets the ID of this widget */
			ID: string;

			/**
			 * Gets or sets the style of this widget
			 *
			 * Styles allow you to attach custom platform-specific logic to a widget. In your
			 * platform-specific assembly, use {@link Style.Add{H}(string, StyleHandler{H})} to add
			 * the style logic with the same id.
			 */
			Style: string;

			/**
			 * Gets the instance of the platform-specific object
			 *
			 * This can sometimes be useful to get the platform-specific object. Some handlers may
			 * not have any backing object for its functionality, so this may be null.  It is more
			 * preferred to use the {@link Eto.Widget.Handler} and cast that to the platform-specific
			 * handler class which can give you additional methods and helpers to do common tasks.
			 * For example, the {@link Eto.Forms.Application} object's handler for OS X has a
			 * AddFullScreenMenuItem property to specify if you want full screen support in your app.
			 */
			readonly ControlObject: unknown;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Widget} has been disposed.
			 *
			 * When the widget is disposed, it can no longer be used.
			 */
			IsDisposed: boolean;

			/**
			 * Queues a repaint of the entire control on the screen and any of its children.
			 *
			 * This is only useful when the control is visible.
			 */
			Invalidate(): void;

			/**
			 * Queues a repaint of the entire control on the screen
			 *
			 * This is only useful when the control is visible.
			 */
			Invalidate(invalidateChildren: boolean): void;

			/**
			 * Queues a repaint of the specified `rect` of the control and any children.
			 *
			 * This is only useful when the control is visible.
			 */
			Invalidate(rect: Eto.Drawing.Rectangle): void;

			/**
			 * Queues a repaint of the specified `rect` of the control
			 *
			 * This is only useful when the control is visible.
			 */
			Invalidate(
				rect: Eto.Drawing.Rectangle,
				invalidateChildren: boolean,
			): void;

			/**
			 * Updates the layout of this control if necessary.
			 *
			 * This will ensure the control has had all of its layout applied so you can use its
			 * position and size right after this call. Most platforms (except WinForms) use a
			 * deferred layout system so that after adding your control to the form dynamically it
			 * won't get laid out until the next idle loop. This is useful when you need to know the
			 * dimensions of the control immediately. Note that this can be an expensive operation,
			 * so it is recommended to only call this method when necessary and after all of the
			 * controls have been added/updated.
			 */
			UpdateLayout(): void;

			/** Gets the preferred size of this control given infinite space available. */
			GetPreferredSize(): Eto.Drawing.SizeF;

			/** Gets the preferred size of this control given the specified `availableSize`. */
			GetPreferredSize(availableSize: Eto.Drawing.SizeF): Eto.Drawing.SizeF;

			/**
			 * Captures all mouse events to this control.
			 *
			 * This captures all mouse events until {@link Eto.Forms.Control.ReleaseMouseCapture} is
			 * called.  Note that not all platforms will allow a mouse capture unless the mouse is
			 * currently down.
			 */
			CaptureMouse(): boolean;

			/** Releases the mouse capture after a call to {@link Eto.Forms.Control.CaptureMouse}. */
			ReleaseMouseCapture(): void;

			/**
			 * Finds a control in the parent hierarchy with the specified type and
			 * {@link Eto.Widget.ID} if specified
			 */
			FindParent(
				type: unknown,
				id?: string,
			): Eto.Forms.Container;

			/** Finds a control in the parent hierarchy with the specified `id` */
			FindParent(id: string): Eto.Forms.Container;

			/**
			 * Detaches the control by removing it from its parent
			 *
			 * This is essentially a shortcut to myControl.Parent.Remove(myControl);
			 */
			Detach(): void;

			/**
			 * Attaches the control for direct use in a native application
			 *
			 * Use this to use a control directly in a native application.  Note that the native
			 * application must be running the same framework as the current platform.  E.g. a
			 * WinForms application can use an Eto.Forms control when using the Eto.WinForms
			 * platform.  This prepares the control by firing the {@link Eto.Forms.Control.PreLoad},
			 * {@link Eto.Forms.Control.Load}, etc. events.
			 */
			AttachNative(): void;

			/**
			 * Detaches the control when it is used in a native application, when you want to reuse
			 * the control.
			 *
			 * This should only be called after {@link Eto.Forms.Control.AttachNative} has been
			 * called, which is usually done by calling to ToNative(true) .
			 */
			DetachNative(): void;

			/**
			 * Attempts to set the keyboard input focus to this control, or the first child that
			 * accepts focus. For Windows, this will bring it to front and activate it.
			 */
			Focus(): void;

			/**
			 * Suspends the layout of child controls
			 *
			 * This can be used to optimize some platforms while adding, removing, or changing many
			 * child controls at once. It disables the calculation of control positioning until
			 * {@link Eto.Forms.Control.ResumeLayout} is called. Each call to SuspendLayout() must be
			 * balanced with a call to {@link Eto.Forms.Control.ResumeLayout}.
			 */
			SuspendLayout(): void;

			/**
			 * Resumes the layout after it has been suspended, and performs a layout
			 *
			 * This can be used to optimize some platforms while adding, removing, or changing many
			 * child controls at once. Each call to ResumeLayout() must be balanced with a call to
			 * {@link Eto.Forms.Control.SuspendLayout} before it.
			 */
			ResumeLayout(): void;

			/**
			 * Specifies a command to execute for a platform-specific command
			 *
			 * Some platforms have specific system-defined commands that can be associated with a
			 * control. For example, the Mac platform's cut/copy/paste functionality is defined by
			 * the system, and if you want to hook into it, you can use this to map it to your own
			 * defined logic. The valid values of the `systemCommand` parameter are defined by each
			 * platform, and a list can be retrieved using
			 * {@link Eto.Forms.Control.SupportedPlatformCommands}
			 */
			MapPlatformCommand(
				systemCommand: string,
				command: Eto.Forms.Command,
			): void;

			/** Converts a point from screen space to control space. */
			PointFromScreen(point: Eto.Drawing.PointF): Eto.Drawing.PointF;

			/** Converts a point from control space to screen space */
			PointToScreen(point: Eto.Drawing.PointF): Eto.Drawing.PointF;

			/** Converts a rectangle from screen space to control space. */
			RectangleToScreen(rect: Eto.Drawing.RectangleF): Eto.Drawing.RectangleF;

			/** Converts a rectangle from control space to screen space */
			RectangleFromScreen(rect: Eto.Drawing.RectangleF): Eto.Drawing.RectangleF;

			/**
			 * Starts drag operation using this control as drag source.
			 *
			 * This method can be blocking on some platforms (Wpf, WinForms), and non-blocking on
			 * others (Mac, Gtk). Use the {@link Eto.Forms.Control.DragEnd} event to determine when
			 * the drag operation is completed and get its resulting DragEffects.
			 */
			DoDragDrop(
				data: Eto.Forms.DataObject,
				allowedEffects: Eto.Forms.DragEffects,
			): void;

			/**
			 * Starts drag operation using this control as drag source.
			 *
			 * This method can be blocking on some platforms (Wpf, WinForms), and non-blocking on
			 * others (Mac, Gtk). Use the {@link Eto.Forms.Control.DragEnd} event to determine when
			 * the drag operation is completed and get its resulting DragEffects.
			 */
			DoDragDrop(
				data: Eto.Forms.DataObject,
				allowedEffects: Eto.Forms.DragEffects,
				image: Eto.Drawing.Image,
				cursorOffset: Eto.Drawing.PointF,
			): void;

			/**
			 * Triggers the StyleChanged event and re-applies the styles to this control and its
			 * children.
			 */
			TriggerStyleChanged(): void;

			/** Shows a print dialog to print the specified control */
			Print(): void;

			/**
			 * Finds a control in the parent hierarchy with the specified type and
			 * {@link Eto.Widget.ID} if specified
			 */
			FindParent<T>(id?: string): T;

			/**
			 * Finds a control in the parent hierarchy with the specified type and
			 * {@link Eto.Widget.ID} if specified
			 */
			FindParent(
				type: unknown,
				id?: string,
			): Eto.Widget;

			/** Finds a control in the parent hierarchy with the specified `id` */
			FindParent(id: string): Eto.Widget;

			/**
			 * Unbinds any bindings in the {@link Eto.Forms.BindableWidget.Bindings} collection and
			 * removes the bindings
			 *
			 * When you implement {@link Eto.Forms.IBindableWidgetContainer}, this will also unbind
			 * any of its children.
			 */
			Unbind(): void;

			/**
			 * Updates all bindings in this widget
			 *
			 * When you implement {@link Eto.Forms.IBindableWidgetContainer}, this will also update
			 * bindings for all of its children.
			 */
			UpdateBindings(mode?: Eto.Forms.BindingUpdateMode): void;

			/** Disposes of this widget, supressing the finalizer */
			dispose(): void;

			/** Gets a string that represents the current object with its ID if specified. */
			ToString(): string;
		}
	}

	export namespace Eto.Forms.Slider {
		export interface ICallback extends
			Eto.Forms.Control.ICallback,
			Eto.Widget.ICallback {
			OnValueChanged(
				widget: Eto.Forms.Slider,
				e: unknown,
			): void;
		}
	}

	export namespace Eto.Forms.Slider {
		export interface IHandler extends
			Eto.Forms.Control.IHandler,
			Eto.Widget.IHandler {
			MaxValue: number;

			MinValue: number;

			Value: number;

			TickFrequency: number;

			SnapToTick: boolean;

			Orientation: Eto.Forms.Orientation;
		}
	}

	export namespace Eto.Forms {
		/** Enumeration of the orientations available for the {@link Eto.Forms.Slider} control */
		export class SliderOrientation {
			/** Slider should be shown in a horizontal orientation */
			static readonly Horizontal: Eto.Forms.SliderOrientation;

			/** Slider should be shown in a vertical orientation */
			static readonly Vertical: Eto.Forms.SliderOrientation;

			/**
			 * Determines whether the specified {@link System.Object} is equal to the current
			 * {@link Eto.Forms.SliderOrientation}.
			 */
			Equals(obj: unknown): boolean;

			/** Serves as a hash function for a {@link Eto.Forms.SliderOrientation} object. */
			GetHashCode(): number;
		}
	}

	export namespace Eto.Forms {
		/**
		 * Presents a spinning indeterminate progress spinner wheel
		 *
		 * Use the {@link Eto.Forms.Control.Enabled} property to control whether the spinner is
		 * active or not.
		 */
		export class Spinner implements
			Eto.IHandlerSource,
			Eto.Forms.IBindable,
			Eto.Forms.IMouseInputSource,
			Eto.Forms.IKeyboardInputSource {
			constructor();

			/** Gets or sets a value indicating whether the Spinner is spinning, default is false. */
			Enabled: boolean;

			/**
			 * Gets a value indicating that the control is loaded onto a form, that is it has been
			 * created, added to a parent, and shown
			 *
			 * The {@link Eto.Forms.Control.OnLoad(System.EventArgs)} method sets this value to true
			 * after cascading to all children (for a {@link Eto.Forms.Container} ) and calling the
			 * platform handler's implementation.  It is called after adding to a loaded form, or
			 * when showing a new form.  The {@link Eto.Forms.Control.OnUnLoad(System.EventArgs)}
			 * method will set this value to false when the control is removed from its parent
			 */
			readonly Loaded: boolean;

			/**
			 * Gets an enumeration of controls that are in the visual tree.
			 *
			 * This is used to specify which controls are contained by this instance that are part of
			 * the visual tree. This should include all controls including non-logical Eto controls
			 * used for layout.
			 */
			readonly VisualControls: Iterable<Eto.Forms.Control>;

			/**
			 * Gets or sets a user-defined object that contains data about the control
			 *
			 * A common use of the tag property is to store data that is associated with the control
			 * that you can later retrieve.
			 */
			Tag: unknown;

			/**
			 * Gets the logical parent control.
			 *
			 * When the control is part of the visual tree (
				 * {@link Eto.Forms.Control.IsVisualControl} is true), this returns the logical parent
				 * that contains this control. Otherwise this is the same as
				 * {@link Eto.Forms.Control.Parent}.
				 */
				readonly LogicalParent: Eto.Forms.Container;

			/** Gets a value indicating this {@link Eto.Forms.Control} is part of the visual tree. */
			IsVisualControl: boolean;

			/**
			 * Gets or sets the size of the control. Use -1 to specify auto sizing for either the
			 * width and/or height.
			 *
			 * Setting the size of controls is entirely optional as most controls will size
			 * themselves appropriately. When specifying a size, it will be used as the desired size
			 * of the control.  The container will reposition and resize the control depending on the
			 * available size.  For a {@link Eto.Forms.Window}, it is preferred to set the
			 * {@link Eto.Forms.Container.ClientSize} instead, as various platforms have different
			 * sizes of window decorations, toolbars, etc.
			 */
			Size: Eto.Drawing.Size;

			/**
			 * Gets a value indicating this control currently has mouse capture
			 *
			 * Mouse capture can happen during a handled MouseDown event until MouseUp, or it can be
			 * captured explicitly via {@link Eto.Forms.Control.CaptureMouse}.
			 */
			readonly IsMouseCaptured: boolean;

			/** Gets or sets the width of the control size. */
			Width: number;

			/** Gets or sets the height of the control size. */
			Height: number;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Forms.Control} is visible to
			 * the user.
			 *
			 * When the visibility of a control is set to false, it will not occupy space in the
			 * layout.
			 */
			Visible: boolean;

			/** Gets the container which this control has been added to, if any */
			readonly Parent: Eto.Forms.Container;

			/**
			 * Gets the visual container of this control, if any.
			 *
			 * Some containers may use other Eto controls to layout its children, such as the
			 * {@link Eto.Forms.StackLayout}. This will return the parent control that visually
			 * contains this control as opposed to {@link Eto.Forms.Control.Parent} which will return
			 * the logical parent.
			 */
			VisualParent: Eto.Forms.Container;

			/** Gets a value indicating this control has been attached to a native container */
			readonly IsAttached: boolean;

			/**
			 * Gets or sets the color for the background of the control
			 *
			 * Note that on some platforms (e.g. Mac), setting the background color of a control can
			 * change the performance characteristics of the control and its children, since it must
			 * enable layers to do so.
			 */
			BackgroundColor: Eto.Drawing.Color;

			/** Gets a value indicating whether this instance has the keyboard input focus. */
			readonly HasFocus: boolean;

			/** Gets a value indicating whether the layout of child controls is suspended. */
			readonly IsSuspended: boolean;

			/** Gets the window this control is contained in */
			readonly ParentWindow: Eto.Forms.Window;

			/**
			 * Gets the supported platform commands that can be used to hook up system functions to
			 * user defined logic
			 *
			 * This lists all available commands that can be mapped using the
			 * {@link Eto.Forms.Control.MapPlatformCommand(System.String,Eto.Forms.Command)} method
			 * of the control.
			 */
			readonly SupportedPlatformCommands: Iterable<string>;

			/** Gets the bounding rectangle of this control relative to its container */
			readonly Bounds: Eto.Drawing.Rectangle;

			/**
			 * Gets the location of the control as positioned by the container
			 *
			 * A control's location is set by the container. This can be used to determine where the
			 * control is for overlaying floating windows, menus, etc.
			 */
			readonly Location: Eto.Drawing.Point;

			/** Gets or sets the type of cursor to use when the mouse is hovering over the control */
			Cursor: Eto.Forms.Cursor;

			/** Gets or sets the tool tip to show when the mouse is hovered over the control */
			ToolTip: string;

			/**
			 * Gets or sets the tab index order for this control within its container.
			 *
			 * This sets the order when using the tab key to cycle through controls  Note that some
			 * platforms (Gtk and WinForms) may not support setting the context of the tab order to
			 * StackLayout  or DynamicLayout containers and may not behave exactly as expected. Use
			 * the {@link Eto.PlatformFeatures.TabIndexWithCustomContainers} flag to determine if it
			 * is supported.
			 */
			TabIndex: number;

			/** Gets or sets a value indicating whether this control can serve as drop target. */
			AllowDrop: boolean;

			/**
			 * Gets or sets the parent widget which this widget has been added to, if any
			 *
			 * When implementing child widgets that can participate in the context based binding
			 * (MVVM), You can set this to the parent widget when it is added or removed to it
			 * (usually via a collection).  Note that you should typically provide a public new
			 * [ParentWidget] Parent { get; } property  so that consumers of your API cannot set the
			 * parent to an invalid value.
			 */
			Parent: Eto.Widget;

			/**
			 * Gets an enumeration of all parent widgets in the heirarchy by traversing the
			 * {@link Eto.Forms.BindableWidget.Parent} property.
			 */
			readonly Parents: Iterable<Eto.Widget>;

			/**
			 * Gets or sets the data context for this widget for binding
			 *
			 * Subclasses may override the standard behaviour so that hierarchy of widgets can be
			 * taken into account.  For example, a Control may return the data context of a parent,
			 * if it is not set explicitly.
			 */
			DataContext: unknown;

			/** Gets the collection of bindings that are attached to this widget */
			readonly Bindings: Eto.Forms.BindingCollection;

			/**
			 * Gets a value indicating that the {@link Eto.Forms.BindableWidget.DataContext} property
			 * is changing.
			 *
			 * This can be used to determine when to allow certain logic during the update of the
			 * data context.  It is used to disable binding setters on the model when the data
			 * context changes so that a binding does not cause the view model to be updated when the
			 * state hasn't been fully set yet.
			 */
			IsDataContextChanging: boolean;

			/**
			 * Gets the platform that was used to create the {@link Eto.Widget.Handler} for this
			 * widget
			 *
			 * This gets set to the current {@link Eto.Platform.Instance} during the construction of
			 * the object
			 */
			readonly Platform: Eto.Platform;

			/** Gets the platform-specific handler for this widget */
			Handler: unknown;

			/** Gets the native platform-specific handle for integration purposes */
			readonly NativeHandle: unknown;

			/** Gets the dictionary of properties for this widget */
			readonly Properties: Eto.PropertyStore;

			/** Gets or sets the ID of this widget */
			ID: string;

			/**
			 * Gets or sets the style of this widget
			 *
			 * Styles allow you to attach custom platform-specific logic to a widget. In your
			 * platform-specific assembly, use {@link Style.Add{H}(string, StyleHandler{H})} to add
			 * the style logic with the same id.
			 */
			Style: string;

			/**
			 * Gets the instance of the platform-specific object
			 *
			 * This can sometimes be useful to get the platform-specific object. Some handlers may
			 * not have any backing object for its functionality, so this may be null.  It is more
			 * preferred to use the {@link Eto.Widget.Handler} and cast that to the platform-specific
			 * handler class which can give you additional methods and helpers to do common tasks.
			 * For example, the {@link Eto.Forms.Application} object's handler for OS X has a
			 * AddFullScreenMenuItem property to specify if you want full screen support in your app.
			 */
			readonly ControlObject: unknown;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Widget} has been disposed.
			 *
			 * When the widget is disposed, it can no longer be used.
			 */
			IsDisposed: boolean;

			/**
			 * Queues a repaint of the entire control on the screen and any of its children.
			 *
			 * This is only useful when the control is visible.
			 */
			Invalidate(): void;

			/**
			 * Queues a repaint of the entire control on the screen
			 *
			 * This is only useful when the control is visible.
			 */
			Invalidate(invalidateChildren: boolean): void;

			/**
			 * Queues a repaint of the specified `rect` of the control and any children.
			 *
			 * This is only useful when the control is visible.
			 */
			Invalidate(rect: Eto.Drawing.Rectangle): void;

			/**
			 * Queues a repaint of the specified `rect` of the control
			 *
			 * This is only useful when the control is visible.
			 */
			Invalidate(
				rect: Eto.Drawing.Rectangle,
				invalidateChildren: boolean,
			): void;

			/**
			 * Updates the layout of this control if necessary.
			 *
			 * This will ensure the control has had all of its layout applied so you can use its
			 * position and size right after this call. Most platforms (except WinForms) use a
			 * deferred layout system so that after adding your control to the form dynamically it
			 * won't get laid out until the next idle loop. This is useful when you need to know the
			 * dimensions of the control immediately. Note that this can be an expensive operation,
			 * so it is recommended to only call this method when necessary and after all of the
			 * controls have been added/updated.
			 */
			UpdateLayout(): void;

			/** Gets the preferred size of this control given infinite space available. */
			GetPreferredSize(): Eto.Drawing.SizeF;

			/** Gets the preferred size of this control given the specified `availableSize`. */
			GetPreferredSize(availableSize: Eto.Drawing.SizeF): Eto.Drawing.SizeF;

			/**
			 * Captures all mouse events to this control.
			 *
			 * This captures all mouse events until {@link Eto.Forms.Control.ReleaseMouseCapture} is
			 * called.  Note that not all platforms will allow a mouse capture unless the mouse is
			 * currently down.
			 */
			CaptureMouse(): boolean;

			/** Releases the mouse capture after a call to {@link Eto.Forms.Control.CaptureMouse}. */
			ReleaseMouseCapture(): void;

			/**
			 * Finds a control in the parent hierarchy with the specified type and
			 * {@link Eto.Widget.ID} if specified
			 */
			FindParent(
				type: unknown,
				id?: string,
			): Eto.Forms.Container;

			/** Finds a control in the parent hierarchy with the specified `id` */
			FindParent(id: string): Eto.Forms.Container;

			/**
			 * Detaches the control by removing it from its parent
			 *
			 * This is essentially a shortcut to myControl.Parent.Remove(myControl);
			 */
			Detach(): void;

			/**
			 * Attaches the control for direct use in a native application
			 *
			 * Use this to use a control directly in a native application.  Note that the native
			 * application must be running the same framework as the current platform.  E.g. a
			 * WinForms application can use an Eto.Forms control when using the Eto.WinForms
			 * platform.  This prepares the control by firing the {@link Eto.Forms.Control.PreLoad},
			 * {@link Eto.Forms.Control.Load}, etc. events.
			 */
			AttachNative(): void;

			/**
			 * Detaches the control when it is used in a native application, when you want to reuse
			 * the control.
			 *
			 * This should only be called after {@link Eto.Forms.Control.AttachNative} has been
			 * called, which is usually done by calling to ToNative(true) .
			 */
			DetachNative(): void;

			/**
			 * Attempts to set the keyboard input focus to this control, or the first child that
			 * accepts focus. For Windows, this will bring it to front and activate it.
			 */
			Focus(): void;

			/**
			 * Suspends the layout of child controls
			 *
			 * This can be used to optimize some platforms while adding, removing, or changing many
			 * child controls at once. It disables the calculation of control positioning until
			 * {@link Eto.Forms.Control.ResumeLayout} is called. Each call to SuspendLayout() must be
			 * balanced with a call to {@link Eto.Forms.Control.ResumeLayout}.
			 */
			SuspendLayout(): void;

			/**
			 * Resumes the layout after it has been suspended, and performs a layout
			 *
			 * This can be used to optimize some platforms while adding, removing, or changing many
			 * child controls at once. Each call to ResumeLayout() must be balanced with a call to
			 * {@link Eto.Forms.Control.SuspendLayout} before it.
			 */
			ResumeLayout(): void;

			/**
			 * Specifies a command to execute for a platform-specific command
			 *
			 * Some platforms have specific system-defined commands that can be associated with a
			 * control. For example, the Mac platform's cut/copy/paste functionality is defined by
			 * the system, and if you want to hook into it, you can use this to map it to your own
			 * defined logic. The valid values of the `systemCommand` parameter are defined by each
			 * platform, and a list can be retrieved using
			 * {@link Eto.Forms.Control.SupportedPlatformCommands}
			 */
			MapPlatformCommand(
				systemCommand: string,
				command: Eto.Forms.Command,
			): void;

			/** Converts a point from screen space to control space. */
			PointFromScreen(point: Eto.Drawing.PointF): Eto.Drawing.PointF;

			/** Converts a point from control space to screen space */
			PointToScreen(point: Eto.Drawing.PointF): Eto.Drawing.PointF;

			/** Converts a rectangle from screen space to control space. */
			RectangleToScreen(rect: Eto.Drawing.RectangleF): Eto.Drawing.RectangleF;

			/** Converts a rectangle from control space to screen space */
			RectangleFromScreen(rect: Eto.Drawing.RectangleF): Eto.Drawing.RectangleF;

			/**
			 * Starts drag operation using this control as drag source.
			 *
			 * This method can be blocking on some platforms (Wpf, WinForms), and non-blocking on
			 * others (Mac, Gtk). Use the {@link Eto.Forms.Control.DragEnd} event to determine when
			 * the drag operation is completed and get its resulting DragEffects.
			 */
			DoDragDrop(
				data: Eto.Forms.DataObject,
				allowedEffects: Eto.Forms.DragEffects,
			): void;

			/**
			 * Starts drag operation using this control as drag source.
			 *
			 * This method can be blocking on some platforms (Wpf, WinForms), and non-blocking on
			 * others (Mac, Gtk). Use the {@link Eto.Forms.Control.DragEnd} event to determine when
			 * the drag operation is completed and get its resulting DragEffects.
			 */
			DoDragDrop(
				data: Eto.Forms.DataObject,
				allowedEffects: Eto.Forms.DragEffects,
				image: Eto.Drawing.Image,
				cursorOffset: Eto.Drawing.PointF,
			): void;

			/**
			 * Triggers the StyleChanged event and re-applies the styles to this control and its
			 * children.
			 */
			TriggerStyleChanged(): void;

			/** Shows a print dialog to print the specified control */
			Print(): void;

			/**
			 * Finds a control in the parent hierarchy with the specified type and
			 * {@link Eto.Widget.ID} if specified
			 */
			FindParent<T>(id?: string): T;

			/**
			 * Finds a control in the parent hierarchy with the specified type and
			 * {@link Eto.Widget.ID} if specified
			 */
			FindParent(
				type: unknown,
				id?: string,
			): Eto.Widget;

			/** Finds a control in the parent hierarchy with the specified `id` */
			FindParent(id: string): Eto.Widget;

			/**
			 * Unbinds any bindings in the {@link Eto.Forms.BindableWidget.Bindings} collection and
			 * removes the bindings
			 *
			 * When you implement {@link Eto.Forms.IBindableWidgetContainer}, this will also unbind
			 * any of its children.
			 */
			Unbind(): void;

			/**
			 * Updates all bindings in this widget
			 *
			 * When you implement {@link Eto.Forms.IBindableWidgetContainer}, this will also update
			 * bindings for all of its children.
			 */
			UpdateBindings(mode?: Eto.Forms.BindingUpdateMode): void;

			/** Disposes of this widget, supressing the finalizer */
			dispose(): void;

			/** Gets a string that represents the current object with its ID if specified. */
			ToString(): string;
		}
	}

	export namespace Eto.Forms.Spinner {
		export interface IHandler extends
			Eto.Forms.Control.IHandler,
			Eto.Widget.IHandler {
		}
	}

	export namespace Eto.Forms {
		/** Specifies which panel has a fixed size the parent container is resized. */
		export enum SplitterFixedPanel {
			/**
			 * The first panel will be fixed size, where the second will resize along with the
			 * splitter's container.
			 */
			Panel1 = 0,

			/**
			 * The second panel will be fixed size, where the first will resize along with the
			 * splitter's container.
			 */
			Panel2 = 1,

			/** Both panels will resize along with the splitter's container. */
			None = 2,
		}
	}

	export namespace Eto.Forms {
		/** Event arguments for the {@link Eto.Forms.Splitter.PositionChanging} event. */
		export class SplitterPositionChangingEventArgs {
			/** Initializes a new instance of the SplitterPositionChangingEventArgs class */
			constructor(newPosition: number);

			/** The new position for the splitter */
			readonly NewPosition: number;
		}
	}

	export namespace Eto.Forms {
		/**
		 * Control to show two panels separated by a splitter
		 *
		 * Most desktop platforms allow the user to modify the position of the splitter, though
		 * some (notibly iOS) do not. The {@link Eto.Forms.Splitter.Orientation} of the splitter
		 * determines how the controls are laid out, either horizontally or vertically.
		 */
		export class Splitter implements
			Eto.IHandlerSource,
			Eto.Forms.IBindable,
			Eto.Forms.IMouseInputSource,
			Eto.Forms.IKeyboardInputSource {
			constructor();

			/** Gets an enumeration of controls that are directly contained by this container */
			readonly Controls: Iterable<Eto.Forms.Control>;

			/**
			 * Gets a value indicating the {@link Eto.Forms.Splitter} is supported in the platform
			 */
			static readonly IsSupported: boolean;

			/**
			 * Gets or sets the orientation of the panels in the splitter.
			 *
			 * This defines the orientation of the panels, with a splitter of the opposite
			 * orientation between them. For example, when set to {@link Orientation.Horizontal},
			 * Panel1 and Panel2 will be horizontal to  eachother with a vertical splitter/gutter
			 * between them.
			 */
			Orientation: Eto.Forms.Orientation;

			/**
			 * Gets or sets the panel with fixed size.
			 *
			 * This specifies which panel will not change its size when the splitter's container is
			 * resized. If {@link Eto.Forms.SplitterFixedPanel.None}, both panels will resize.
			 */
			FixedPanel: Eto.Forms.SplitterFixedPanel;

			/** Gets or sets the position of the splitter from the left or top, in pixels. */
			Position: number;

			/**
			 * Gets or sets the relative position of the splitter which is based on
			 * {@link Eto.Forms.Splitter.FixedPanel}.
			 *
			 * Same as {@link Eto.Forms.Splitter.Position} with SplitterFixedPanel.Panel1,
			 * width/height of second panel with SplitterFixedPanel.Panel2 and ratio of width/height
			 * of first panel against available size with SplitterFixedPanel.None.
			 */
			RelativePosition: number;

			/** Gets or sets size of the splitter/gutter */
			SplitterWidth: number;

			/** Gets or sets the top or left panel of the splitter. */
			Panel1: Eto.Forms.Control;

			/** Gets or sets the minimal size of the first panel. */
			Panel1MinimumSize: number;

			/** Gets or sets the bottom or right panel of the splitter. */
			Panel2: Eto.Forms.Control;

			/** Gets or sets the minimal size of the second panel. */
			Panel2MinimumSize: number;

			/**
			 * Gets or sets the size for the client area of the control
			 *
			 * The client size differs from the {@link Eto.Forms.Control.Size} in that it excludes
			 * the decorations of the container, such as the title bar and border around a
			 * {@link Eto.Forms.Window}, or the title and line  around a {@link Eto.Forms.GroupBox}.
			 */
			ClientSize: Eto.Drawing.Size;

			/**
			 * Gets an enumeration of all contained child controls, including controls within child
			 * containers
			 */
			readonly Children: Iterable<Eto.Forms.Control>;

			/**
			 * Gets an enumeration of all contained child controls in the visual tree, including
			 * controls within child containers.
			 */
			readonly VisualChildren: Iterable<Eto.Forms.Control>;

			/**
			 * Gets or sets the style provider for this container.
			 *
			 * The style provider is used to style this container and its children.
			 */
			StyleProvider: Eto.IStyleProvider;

			/**
			 * Gets the default style provider for this container.
			 *
			 * Use this to apply styles to any child controls of this container. By default, styles
			 * will apply to all children, including children of children unless
			 * {@link Eto.DefaultStyleProvider.Inherit} is set to false .  Typically, you would set
			 * Inherit to false when creating composite controls that already have all their styles
			 * applied and you don't want any other styles to be inherited.
			 */
			readonly Styles: Eto.DefaultStyleProvider;

			/**
			 * Gets a value indicating that the control is loaded onto a form, that is it has been
			 * created, added to a parent, and shown
			 *
			 * The {@link Eto.Forms.Control.OnLoad(System.EventArgs)} method sets this value to true
			 * after cascading to all children (for a {@link Eto.Forms.Container} ) and calling the
			 * platform handler's implementation.  It is called after adding to a loaded form, or
			 * when showing a new form.  The {@link Eto.Forms.Control.OnUnLoad(System.EventArgs)}
			 * method will set this value to false when the control is removed from its parent
			 */
			readonly Loaded: boolean;

			/**
			 * Gets an enumeration of controls that are in the visual tree.
			 *
			 * This is used to specify which controls are contained by this instance that are part of
			 * the visual tree. This should include all controls including non-logical Eto controls
			 * used for layout.
			 */
			readonly VisualControls: Iterable<Eto.Forms.Control>;

			/**
			 * Gets or sets a user-defined object that contains data about the control
			 *
			 * A common use of the tag property is to store data that is associated with the control
			 * that you can later retrieve.
			 */
			Tag: unknown;

			/**
			 * Gets the logical parent control.
			 *
			 * When the control is part of the visual tree (
				 * {@link Eto.Forms.Control.IsVisualControl} is true), this returns the logical parent
				 * that contains this control. Otherwise this is the same as
				 * {@link Eto.Forms.Control.Parent}.
				 */
				readonly LogicalParent: Eto.Forms.Container;

			/** Gets a value indicating this {@link Eto.Forms.Control} is part of the visual tree. */
			IsVisualControl: boolean;

			/**
			 * Gets or sets the size of the control. Use -1 to specify auto sizing for either the
			 * width and/or height.
			 *
			 * Setting the size of controls is entirely optional as most controls will size
			 * themselves appropriately. When specifying a size, it will be used as the desired size
			 * of the control.  The container will reposition and resize the control depending on the
			 * available size.  For a {@link Eto.Forms.Window}, it is preferred to set the
			 * {@link Eto.Forms.Container.ClientSize} instead, as various platforms have different
			 * sizes of window decorations, toolbars, etc.
			 */
			Size: Eto.Drawing.Size;

			/**
			 * Gets a value indicating this control currently has mouse capture
			 *
			 * Mouse capture can happen during a handled MouseDown event until MouseUp, or it can be
			 * captured explicitly via {@link Eto.Forms.Control.CaptureMouse}.
			 */
			readonly IsMouseCaptured: boolean;

			/** Gets or sets the width of the control size. */
			Width: number;

			/** Gets or sets the height of the control size. */
			Height: number;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Forms.Control} (or its
			 * children) are enabled and accept user input.
			 *
			 * Typically when a control is disabled, the user cannot do anything with the control or
			 * any of its children. Including for example, selecting text in a text control. Certain
			 * controls can have a 'Read Only' mode, such as {@link Eto.Forms.TextBox.ReadOnly} which
			 * allow the user to  select text, but not change its contents.
			 */
			Enabled: boolean;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Forms.Control} is visible to
			 * the user.
			 *
			 * When the visibility of a control is set to false, it will not occupy space in the
			 * layout.
			 */
			Visible: boolean;

			/** Gets the container which this control has been added to, if any */
			readonly Parent: Eto.Forms.Container;

			/**
			 * Gets the visual container of this control, if any.
			 *
			 * Some containers may use other Eto controls to layout its children, such as the
			 * {@link Eto.Forms.StackLayout}. This will return the parent control that visually
			 * contains this control as opposed to {@link Eto.Forms.Control.Parent} which will return
			 * the logical parent.
			 */
			VisualParent: Eto.Forms.Container;

			/** Gets a value indicating this control has been attached to a native container */
			readonly IsAttached: boolean;

			/**
			 * Gets or sets the color for the background of the control
			 *
			 * Note that on some platforms (e.g. Mac), setting the background color of a control can
			 * change the performance characteristics of the control and its children, since it must
			 * enable layers to do so.
			 */
			BackgroundColor: Eto.Drawing.Color;

			/** Gets a value indicating whether this instance has the keyboard input focus. */
			readonly HasFocus: boolean;

			/** Gets a value indicating whether the layout of child controls is suspended. */
			readonly IsSuspended: boolean;

			/** Gets the window this control is contained in */
			readonly ParentWindow: Eto.Forms.Window;

			/**
			 * Gets the supported platform commands that can be used to hook up system functions to
			 * user defined logic
			 *
			 * This lists all available commands that can be mapped using the
			 * {@link Eto.Forms.Control.MapPlatformCommand(System.String,Eto.Forms.Command)} method
			 * of the control.
			 */
			readonly SupportedPlatformCommands: Iterable<string>;

			/** Gets the bounding rectangle of this control relative to its container */
			readonly Bounds: Eto.Drawing.Rectangle;

			/**
			 * Gets the location of the control as positioned by the container
			 *
			 * A control's location is set by the container. This can be used to determine where the
			 * control is for overlaying floating windows, menus, etc.
			 */
			readonly Location: Eto.Drawing.Point;

			/** Gets or sets the type of cursor to use when the mouse is hovering over the control */
			Cursor: Eto.Forms.Cursor;

			/** Gets or sets the tool tip to show when the mouse is hovered over the control */
			ToolTip: string;

			/**
			 * Gets or sets the tab index order for this control within its container.
			 *
			 * This sets the order when using the tab key to cycle through controls  Note that some
			 * platforms (Gtk and WinForms) may not support setting the context of the tab order to
			 * StackLayout  or DynamicLayout containers and may not behave exactly as expected. Use
			 * the {@link Eto.PlatformFeatures.TabIndexWithCustomContainers} flag to determine if it
			 * is supported.
			 */
			TabIndex: number;

			/** Gets or sets a value indicating whether this control can serve as drop target. */
			AllowDrop: boolean;

			/**
			 * Gets or sets the parent widget which this widget has been added to, if any
			 *
			 * When implementing child widgets that can participate in the context based binding
			 * (MVVM), You can set this to the parent widget when it is added or removed to it
			 * (usually via a collection).  Note that you should typically provide a public new
			 * [ParentWidget] Parent { get; } property  so that consumers of your API cannot set the
			 * parent to an invalid value.
			 */
			Parent: Eto.Widget;

			/**
			 * Gets an enumeration of all parent widgets in the heirarchy by traversing the
			 * {@link Eto.Forms.BindableWidget.Parent} property.
			 */
			readonly Parents: Iterable<Eto.Widget>;

			/**
			 * Gets or sets the data context for this widget for binding
			 *
			 * Subclasses may override the standard behaviour so that hierarchy of widgets can be
			 * taken into account.  For example, a Control may return the data context of a parent,
			 * if it is not set explicitly.
			 */
			DataContext: unknown;

			/** Gets the collection of bindings that are attached to this widget */
			readonly Bindings: Eto.Forms.BindingCollection;

			/**
			 * Gets a value indicating that the {@link Eto.Forms.BindableWidget.DataContext} property
			 * is changing.
			 *
			 * This can be used to determine when to allow certain logic during the update of the
			 * data context.  It is used to disable binding setters on the model when the data
			 * context changes so that a binding does not cause the view model to be updated when the
			 * state hasn't been fully set yet.
			 */
			IsDataContextChanging: boolean;

			/**
			 * Gets the platform that was used to create the {@link Eto.Widget.Handler} for this
			 * widget
			 *
			 * This gets set to the current {@link Eto.Platform.Instance} during the construction of
			 * the object
			 */
			readonly Platform: Eto.Platform;

			/** Gets the platform-specific handler for this widget */
			Handler: unknown;

			/** Gets the native platform-specific handle for integration purposes */
			readonly NativeHandle: unknown;

			/** Gets the dictionary of properties for this widget */
			readonly Properties: Eto.PropertyStore;

			/** Gets or sets the ID of this widget */
			ID: string;

			/**
			 * Gets or sets the style of this widget
			 *
			 * Styles allow you to attach custom platform-specific logic to a widget. In your
			 * platform-specific assembly, use {@link Style.Add{H}(string, StyleHandler{H})} to add
			 * the style logic with the same id.
			 */
			Style: string;

			/**
			 * Gets the instance of the platform-specific object
			 *
			 * This can sometimes be useful to get the platform-specific object. Some handlers may
			 * not have any backing object for its functionality, so this may be null.  It is more
			 * preferred to use the {@link Eto.Widget.Handler} and cast that to the platform-specific
			 * handler class which can give you additional methods and helpers to do common tasks.
			 * For example, the {@link Eto.Forms.Application} object's handler for OS X has a
			 * AddFullScreenMenuItem property to specify if you want full screen support in your app.
			 */
			readonly ControlObject: unknown;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Widget} has been disposed.
			 *
			 * When the widget is disposed, it can no longer be used.
			 */
			IsDisposed: boolean;

			/** Removes the specified child from the container. */
			Remove(child: Eto.Forms.Control): void;

			/** Remove the specified `controls` from this container */
			Remove(controls: Iterable<Eto.Forms.Control>): void;

			/** Removes all controls from this container */
			RemoveAll(): void;

			/**
			 * Finds a child control in this container or any of its child containers with the
			 * specified `id`
			 */
			FindChild<T>(id?: string): T;

			/**
			 * Finds a child control in this container or any of its child containers with the
			 * specified `type`
			 */
			FindChild(
				type: unknown,
				id?: string,
			): Eto.Forms.Control;

			/**
			 * Finds a child control in this container or any of its child containers with the
			 * specified `id`.
			 */
			FindChild(id: string): Eto.Forms.Control;

			/**
			 * Queues a repaint of the entire control on the screen and any of its children.
			 *
			 * This is only useful when the control is visible.
			 */
			Invalidate(): void;

			/**
			 * Queues a repaint of the entire control on the screen
			 *
			 * This is only useful when the control is visible.
			 */
			Invalidate(invalidateChildren: boolean): void;

			/**
			 * Queues a repaint of the specified `rect` of the control and any children.
			 *
			 * This is only useful when the control is visible.
			 */
			Invalidate(rect: Eto.Drawing.Rectangle): void;

			/**
			 * Queues a repaint of the specified `rect` of the control
			 *
			 * This is only useful when the control is visible.
			 */
			Invalidate(
				rect: Eto.Drawing.Rectangle,
				invalidateChildren: boolean,
			): void;

			/**
			 * Updates the layout of this control if necessary.
			 *
			 * This will ensure the control has had all of its layout applied so you can use its
			 * position and size right after this call. Most platforms (except WinForms) use a
			 * deferred layout system so that after adding your control to the form dynamically it
			 * won't get laid out until the next idle loop. This is useful when you need to know the
			 * dimensions of the control immediately. Note that this can be an expensive operation,
			 * so it is recommended to only call this method when necessary and after all of the
			 * controls have been added/updated.
			 */
			UpdateLayout(): void;

			/** Gets the preferred size of this control given infinite space available. */
			GetPreferredSize(): Eto.Drawing.SizeF;

			/** Gets the preferred size of this control given the specified `availableSize`. */
			GetPreferredSize(availableSize: Eto.Drawing.SizeF): Eto.Drawing.SizeF;

			/**
			 * Captures all mouse events to this control.
			 *
			 * This captures all mouse events until {@link Eto.Forms.Control.ReleaseMouseCapture} is
			 * called.  Note that not all platforms will allow a mouse capture unless the mouse is
			 * currently down.
			 */
			CaptureMouse(): boolean;

			/** Releases the mouse capture after a call to {@link Eto.Forms.Control.CaptureMouse}. */
			ReleaseMouseCapture(): void;

			/**
			 * Finds a control in the parent hierarchy with the specified type and
			 * {@link Eto.Widget.ID} if specified
			 */
			FindParent(
				type: unknown,
				id?: string,
			): Eto.Forms.Container;

			/** Finds a control in the parent hierarchy with the specified `id` */
			FindParent(id: string): Eto.Forms.Container;

			/**
			 * Detaches the control by removing it from its parent
			 *
			 * This is essentially a shortcut to myControl.Parent.Remove(myControl);
			 */
			Detach(): void;

			/**
			 * Attaches the control for direct use in a native application
			 *
			 * Use this to use a control directly in a native application.  Note that the native
			 * application must be running the same framework as the current platform.  E.g. a
			 * WinForms application can use an Eto.Forms control when using the Eto.WinForms
			 * platform.  This prepares the control by firing the {@link Eto.Forms.Control.PreLoad},
			 * {@link Eto.Forms.Control.Load}, etc. events.
			 */
			AttachNative(): void;

			/**
			 * Detaches the control when it is used in a native application, when you want to reuse
			 * the control.
			 *
			 * This should only be called after {@link Eto.Forms.Control.AttachNative} has been
			 * called, which is usually done by calling to ToNative(true) .
			 */
			DetachNative(): void;

			/**
			 * Attempts to set the keyboard input focus to this control, or the first child that
			 * accepts focus. For Windows, this will bring it to front and activate it.
			 */
			Focus(): void;

			/**
			 * Suspends the layout of child controls
			 *
			 * This can be used to optimize some platforms while adding, removing, or changing many
			 * child controls at once. It disables the calculation of control positioning until
			 * {@link Eto.Forms.Control.ResumeLayout} is called. Each call to SuspendLayout() must be
			 * balanced with a call to {@link Eto.Forms.Control.ResumeLayout}.
			 */
			SuspendLayout(): void;

			/**
			 * Resumes the layout after it has been suspended, and performs a layout
			 *
			 * This can be used to optimize some platforms while adding, removing, or changing many
			 * child controls at once. Each call to ResumeLayout() must be balanced with a call to
			 * {@link Eto.Forms.Control.SuspendLayout} before it.
			 */
			ResumeLayout(): void;

			/**
			 * Specifies a command to execute for a platform-specific command
			 *
			 * Some platforms have specific system-defined commands that can be associated with a
			 * control. For example, the Mac platform's cut/copy/paste functionality is defined by
			 * the system, and if you want to hook into it, you can use this to map it to your own
			 * defined logic. The valid values of the `systemCommand` parameter are defined by each
			 * platform, and a list can be retrieved using
			 * {@link Eto.Forms.Control.SupportedPlatformCommands}
			 */
			MapPlatformCommand(
				systemCommand: string,
				command: Eto.Forms.Command,
			): void;

			/** Converts a point from screen space to control space. */
			PointFromScreen(point: Eto.Drawing.PointF): Eto.Drawing.PointF;

			/** Converts a point from control space to screen space */
			PointToScreen(point: Eto.Drawing.PointF): Eto.Drawing.PointF;

			/** Converts a rectangle from screen space to control space. */
			RectangleToScreen(rect: Eto.Drawing.RectangleF): Eto.Drawing.RectangleF;

			/** Converts a rectangle from control space to screen space */
			RectangleFromScreen(rect: Eto.Drawing.RectangleF): Eto.Drawing.RectangleF;

			/**
			 * Starts drag operation using this control as drag source.
			 *
			 * This method can be blocking on some platforms (Wpf, WinForms), and non-blocking on
			 * others (Mac, Gtk). Use the {@link Eto.Forms.Control.DragEnd} event to determine when
			 * the drag operation is completed and get its resulting DragEffects.
			 */
			DoDragDrop(
				data: Eto.Forms.DataObject,
				allowedEffects: Eto.Forms.DragEffects,
			): void;

			/**
			 * Starts drag operation using this control as drag source.
			 *
			 * This method can be blocking on some platforms (Wpf, WinForms), and non-blocking on
			 * others (Mac, Gtk). Use the {@link Eto.Forms.Control.DragEnd} event to determine when
			 * the drag operation is completed and get its resulting DragEffects.
			 */
			DoDragDrop(
				data: Eto.Forms.DataObject,
				allowedEffects: Eto.Forms.DragEffects,
				image: Eto.Drawing.Image,
				cursorOffset: Eto.Drawing.PointF,
			): void;

			/**
			 * Triggers the StyleChanged event and re-applies the styles to this control and its
			 * children.
			 */
			TriggerStyleChanged(): void;

			/** Shows a print dialog to print the specified control */
			Print(): void;

			/**
			 * Finds a control in the parent hierarchy with the specified type and
			 * {@link Eto.Widget.ID} if specified
			 */
			FindParent<T>(id?: string): T;

			/**
			 * Finds a control in the parent hierarchy with the specified type and
			 * {@link Eto.Widget.ID} if specified
			 */
			FindParent(
				type: unknown,
				id?: string,
			): Eto.Widget;

			/** Finds a control in the parent hierarchy with the specified `id` */
			FindParent(id: string): Eto.Widget;

			/**
			 * Unbinds any bindings in the {@link Eto.Forms.BindableWidget.Bindings} collection and
			 * removes the bindings
			 *
			 * When you implement {@link Eto.Forms.IBindableWidgetContainer}, this will also unbind
			 * any of its children.
			 */
			Unbind(): void;

			/**
			 * Updates all bindings in this widget
			 *
			 * When you implement {@link Eto.Forms.IBindableWidgetContainer}, this will also update
			 * bindings for all of its children.
			 */
			UpdateBindings(mode?: Eto.Forms.BindingUpdateMode): void;

			/** Disposes of this widget, supressing the finalizer */
			dispose(): void;

			/** Gets a string that represents the current object with its ID if specified. */
			ToString(): string;
		}
	}

	export namespace Eto.Forms.Splitter {
		export interface ICallback extends
			Eto.Forms.Control.ICallback,
			Eto.Widget.ICallback {
			OnPositionChanged(
				widget: Eto.Forms.Splitter,
				e: unknown,
			): void;

			OnPositionChanging(
				widget: Eto.Forms.Splitter,
				e: Eto.Forms.SplitterPositionChangingEventArgs,
			): void;

			OnPositionChangeStarted(
				widget: Eto.Forms.Splitter,
				e: unknown,
			): void;

			OnPositionChangeCompleted(
				widget: Eto.Forms.Splitter,
				e: unknown,
			): void;
		}
	}

	export namespace Eto.Forms.Splitter {
		export interface IHandler extends
			Eto.Forms.Container.IHandler,
			Eto.Forms.Control.IHandler,
			Eto.Widget.IHandler {
			Orientation: Eto.Forms.Orientation;

			FixedPanel: Eto.Forms.SplitterFixedPanel;

			Position: number;

			RelativePosition: number;

			SplitterWidth: number;

			Panel1: Eto.Forms.Control;

			Panel2: Eto.Forms.Control;

			Panel1MinimumSize: number;

			Panel2MinimumSize: number;
		}
	}

	export namespace Eto.Forms {
		/** Orientation of a {@link Eto.Forms.Splitter} control. */
		export class SplitterOrientation {
			/** Controls are in horizontal orientation, with a vertical divider between them. */
			static readonly Horizontal: Eto.Forms.SplitterOrientation;

			/** Controls are in vertical orientation, with a horizontal divider betwen them. */
			static readonly Vertical: Eto.Forms.SplitterOrientation;

			/**
			 * Determines whether the specified {@link System.Object} is equal to the current
			 * {@link Eto.Forms.SplitterOrientation}.
			 */
			Equals(obj: unknown): boolean;

			/** Serves as a hash function for a {@link Eto.Forms.SplitterOrientation} object. */
			GetHashCode(): number;
		}
	}

	export namespace Eto.Forms {
		/** Direction of the stepper when it has been clicked */
		export enum StepperDirection {
			/** The Up direction, which usually increases the value */
			Up = 0,

			/** The Down direction, which usually decreases the value */
			Down = 1,
		}
	}

	export namespace Eto.Forms {
		/**
		 * Valid stepper directions for the (typically) up/down buttons
		 *
		 * Note that some platforms do not actually disable the up or down buttons, but just
		 * won't trigger the {@link Eto.Forms.Stepper.Step} event when it is not valid.
		 */
		export enum StepperValidDirections {
			/** Neither the up or down buttons are valid */
			None = 0,

			/** Specifies that the up/increase button is a valid direction for the stepper */
			Up = 1,

			/** Specifies that the down/decrease button is a valid direction for the stepper */
			Down = 2,

			/**
			 * Combines both the {@link Eto.Forms.StepperValidDirections.Up} and
			 * {@link Eto.Forms.StepperValidDirections.Down} flags.
			 */
			Both = 3,
		}
	}

	export namespace Eto.Forms {
		/**
		 * Arguments for the {@link Eto.Forms.Stepper} and {@link Eto.Forms.TextStepper} to give
		 * you the direction of the step.
		 */
		export class StepperEventArgs {
			/** Initializes a new instance of the {@link Eto.Forms.StepperEventArgs} class. */
			constructor(direction: Eto.Forms.StepperDirection);

			/** Gets the step direction, either up/increase, or down/decrease. */
			readonly Direction: Eto.Forms.StepperDirection;
		}
	}

	export namespace Eto.Forms {
		/**
		 * Control that allows you to "step" through values, usually presented by two buttons
		 * arranged vertically with up and down arrows.
		 */
		export class Stepper implements
			Eto.IHandlerSource,
			Eto.Forms.IBindable,
			Eto.Forms.IMouseInputSource,
			Eto.Forms.IKeyboardInputSource {
			constructor();

			/**
			 * Gets or sets the valid directions the stepper will allow the user to click.
			 *
			 * On some platforms, the up and/or down buttons will not appear disabled, but will not
			 * trigger any events when they are  not set as a valid direction.
			 */
			ValidDirection: Eto.Forms.StepperValidDirections;

			/**
			 * Gets a value indicating that the control is loaded onto a form, that is it has been
			 * created, added to a parent, and shown
			 *
			 * The {@link Eto.Forms.Control.OnLoad(System.EventArgs)} method sets this value to true
			 * after cascading to all children (for a {@link Eto.Forms.Container} ) and calling the
			 * platform handler's implementation.  It is called after adding to a loaded form, or
			 * when showing a new form.  The {@link Eto.Forms.Control.OnUnLoad(System.EventArgs)}
			 * method will set this value to false when the control is removed from its parent
			 */
			readonly Loaded: boolean;

			/**
			 * Gets an enumeration of controls that are in the visual tree.
			 *
			 * This is used to specify which controls are contained by this instance that are part of
			 * the visual tree. This should include all controls including non-logical Eto controls
			 * used for layout.
			 */
			readonly VisualControls: Iterable<Eto.Forms.Control>;

			/**
			 * Gets or sets a user-defined object that contains data about the control
			 *
			 * A common use of the tag property is to store data that is associated with the control
			 * that you can later retrieve.
			 */
			Tag: unknown;

			/**
			 * Gets the logical parent control.
			 *
			 * When the control is part of the visual tree (
				 * {@link Eto.Forms.Control.IsVisualControl} is true), this returns the logical parent
				 * that contains this control. Otherwise this is the same as
				 * {@link Eto.Forms.Control.Parent}.
				 */
				readonly LogicalParent: Eto.Forms.Container;

			/** Gets a value indicating this {@link Eto.Forms.Control} is part of the visual tree. */
			IsVisualControl: boolean;

			/**
			 * Gets or sets the size of the control. Use -1 to specify auto sizing for either the
			 * width and/or height.
			 *
			 * Setting the size of controls is entirely optional as most controls will size
			 * themselves appropriately. When specifying a size, it will be used as the desired size
			 * of the control.  The container will reposition and resize the control depending on the
			 * available size.  For a {@link Eto.Forms.Window}, it is preferred to set the
			 * {@link Eto.Forms.Container.ClientSize} instead, as various platforms have different
			 * sizes of window decorations, toolbars, etc.
			 */
			Size: Eto.Drawing.Size;

			/**
			 * Gets a value indicating this control currently has mouse capture
			 *
			 * Mouse capture can happen during a handled MouseDown event until MouseUp, or it can be
			 * captured explicitly via {@link Eto.Forms.Control.CaptureMouse}.
			 */
			readonly IsMouseCaptured: boolean;

			/** Gets or sets the width of the control size. */
			Width: number;

			/** Gets or sets the height of the control size. */
			Height: number;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Forms.Control} (or its
			 * children) are enabled and accept user input.
			 *
			 * Typically when a control is disabled, the user cannot do anything with the control or
			 * any of its children. Including for example, selecting text in a text control. Certain
			 * controls can have a 'Read Only' mode, such as {@link Eto.Forms.TextBox.ReadOnly} which
			 * allow the user to  select text, but not change its contents.
			 */
			Enabled: boolean;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Forms.Control} is visible to
			 * the user.
			 *
			 * When the visibility of a control is set to false, it will not occupy space in the
			 * layout.
			 */
			Visible: boolean;

			/** Gets the container which this control has been added to, if any */
			readonly Parent: Eto.Forms.Container;

			/**
			 * Gets the visual container of this control, if any.
			 *
			 * Some containers may use other Eto controls to layout its children, such as the
			 * {@link Eto.Forms.StackLayout}. This will return the parent control that visually
			 * contains this control as opposed to {@link Eto.Forms.Control.Parent} which will return
			 * the logical parent.
			 */
			VisualParent: Eto.Forms.Container;

			/** Gets a value indicating this control has been attached to a native container */
			readonly IsAttached: boolean;

			/**
			 * Gets or sets the color for the background of the control
			 *
			 * Note that on some platforms (e.g. Mac), setting the background color of a control can
			 * change the performance characteristics of the control and its children, since it must
			 * enable layers to do so.
			 */
			BackgroundColor: Eto.Drawing.Color;

			/** Gets a value indicating whether this instance has the keyboard input focus. */
			readonly HasFocus: boolean;

			/** Gets a value indicating whether the layout of child controls is suspended. */
			readonly IsSuspended: boolean;

			/** Gets the window this control is contained in */
			readonly ParentWindow: Eto.Forms.Window;

			/**
			 * Gets the supported platform commands that can be used to hook up system functions to
			 * user defined logic
			 *
			 * This lists all available commands that can be mapped using the
			 * {@link Eto.Forms.Control.MapPlatformCommand(System.String,Eto.Forms.Command)} method
			 * of the control.
			 */
			readonly SupportedPlatformCommands: Iterable<string>;

			/** Gets the bounding rectangle of this control relative to its container */
			readonly Bounds: Eto.Drawing.Rectangle;

			/**
			 * Gets the location of the control as positioned by the container
			 *
			 * A control's location is set by the container. This can be used to determine where the
			 * control is for overlaying floating windows, menus, etc.
			 */
			readonly Location: Eto.Drawing.Point;

			/** Gets or sets the type of cursor to use when the mouse is hovering over the control */
			Cursor: Eto.Forms.Cursor;

			/** Gets or sets the tool tip to show when the mouse is hovered over the control */
			ToolTip: string;

			/**
			 * Gets or sets the tab index order for this control within its container.
			 *
			 * This sets the order when using the tab key to cycle through controls  Note that some
			 * platforms (Gtk and WinForms) may not support setting the context of the tab order to
			 * StackLayout  or DynamicLayout containers and may not behave exactly as expected. Use
			 * the {@link Eto.PlatformFeatures.TabIndexWithCustomContainers} flag to determine if it
			 * is supported.
			 */
			TabIndex: number;

			/** Gets or sets a value indicating whether this control can serve as drop target. */
			AllowDrop: boolean;

			/**
			 * Gets or sets the parent widget which this widget has been added to, if any
			 *
			 * When implementing child widgets that can participate in the context based binding
			 * (MVVM), You can set this to the parent widget when it is added or removed to it
			 * (usually via a collection).  Note that you should typically provide a public new
			 * [ParentWidget] Parent { get; } property  so that consumers of your API cannot set the
			 * parent to an invalid value.
			 */
			Parent: Eto.Widget;

			/**
			 * Gets an enumeration of all parent widgets in the heirarchy by traversing the
			 * {@link Eto.Forms.BindableWidget.Parent} property.
			 */
			readonly Parents: Iterable<Eto.Widget>;

			/**
			 * Gets or sets the data context for this widget for binding
			 *
			 * Subclasses may override the standard behaviour so that hierarchy of widgets can be
			 * taken into account.  For example, a Control may return the data context of a parent,
			 * if it is not set explicitly.
			 */
			DataContext: unknown;

			/** Gets the collection of bindings that are attached to this widget */
			readonly Bindings: Eto.Forms.BindingCollection;

			/**
			 * Gets a value indicating that the {@link Eto.Forms.BindableWidget.DataContext} property
			 * is changing.
			 *
			 * This can be used to determine when to allow certain logic during the update of the
			 * data context.  It is used to disable binding setters on the model when the data
			 * context changes so that a binding does not cause the view model to be updated when the
			 * state hasn't been fully set yet.
			 */
			IsDataContextChanging: boolean;

			/**
			 * Gets the platform that was used to create the {@link Eto.Widget.Handler} for this
			 * widget
			 *
			 * This gets set to the current {@link Eto.Platform.Instance} during the construction of
			 * the object
			 */
			readonly Platform: Eto.Platform;

			/** Gets the platform-specific handler for this widget */
			Handler: unknown;

			/** Gets the native platform-specific handle for integration purposes */
			readonly NativeHandle: unknown;

			/** Gets the dictionary of properties for this widget */
			readonly Properties: Eto.PropertyStore;

			/** Gets or sets the ID of this widget */
			ID: string;

			/**
			 * Gets or sets the style of this widget
			 *
			 * Styles allow you to attach custom platform-specific logic to a widget. In your
			 * platform-specific assembly, use {@link Style.Add{H}(string, StyleHandler{H})} to add
			 * the style logic with the same id.
			 */
			Style: string;

			/**
			 * Gets the instance of the platform-specific object
			 *
			 * This can sometimes be useful to get the platform-specific object. Some handlers may
			 * not have any backing object for its functionality, so this may be null.  It is more
			 * preferred to use the {@link Eto.Widget.Handler} and cast that to the platform-specific
			 * handler class which can give you additional methods and helpers to do common tasks.
			 * For example, the {@link Eto.Forms.Application} object's handler for OS X has a
			 * AddFullScreenMenuItem property to specify if you want full screen support in your app.
			 */
			readonly ControlObject: unknown;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Widget} has been disposed.
			 *
			 * When the widget is disposed, it can no longer be used.
			 */
			IsDisposed: boolean;

			/**
			 * Queues a repaint of the entire control on the screen and any of its children.
			 *
			 * This is only useful when the control is visible.
			 */
			Invalidate(): void;

			/**
			 * Queues a repaint of the entire control on the screen
			 *
			 * This is only useful when the control is visible.
			 */
			Invalidate(invalidateChildren: boolean): void;

			/**
			 * Queues a repaint of the specified `rect` of the control and any children.
			 *
			 * This is only useful when the control is visible.
			 */
			Invalidate(rect: Eto.Drawing.Rectangle): void;

			/**
			 * Queues a repaint of the specified `rect` of the control
			 *
			 * This is only useful when the control is visible.
			 */
			Invalidate(
				rect: Eto.Drawing.Rectangle,
				invalidateChildren: boolean,
			): void;

			/**
			 * Updates the layout of this control if necessary.
			 *
			 * This will ensure the control has had all of its layout applied so you can use its
			 * position and size right after this call. Most platforms (except WinForms) use a
			 * deferred layout system so that after adding your control to the form dynamically it
			 * won't get laid out until the next idle loop. This is useful when you need to know the
			 * dimensions of the control immediately. Note that this can be an expensive operation,
			 * so it is recommended to only call this method when necessary and after all of the
			 * controls have been added/updated.
			 */
			UpdateLayout(): void;

			/** Gets the preferred size of this control given infinite space available. */
			GetPreferredSize(): Eto.Drawing.SizeF;

			/** Gets the preferred size of this control given the specified `availableSize`. */
			GetPreferredSize(availableSize: Eto.Drawing.SizeF): Eto.Drawing.SizeF;

			/**
			 * Captures all mouse events to this control.
			 *
			 * This captures all mouse events until {@link Eto.Forms.Control.ReleaseMouseCapture} is
			 * called.  Note that not all platforms will allow a mouse capture unless the mouse is
			 * currently down.
			 */
			CaptureMouse(): boolean;

			/** Releases the mouse capture after a call to {@link Eto.Forms.Control.CaptureMouse}. */
			ReleaseMouseCapture(): void;

			/**
			 * Finds a control in the parent hierarchy with the specified type and
			 * {@link Eto.Widget.ID} if specified
			 */
			FindParent(
				type: unknown,
				id?: string,
			): Eto.Forms.Container;

			/** Finds a control in the parent hierarchy with the specified `id` */
			FindParent(id: string): Eto.Forms.Container;

			/**
			 * Detaches the control by removing it from its parent
			 *
			 * This is essentially a shortcut to myControl.Parent.Remove(myControl);
			 */
			Detach(): void;

			/**
			 * Attaches the control for direct use in a native application
			 *
			 * Use this to use a control directly in a native application.  Note that the native
			 * application must be running the same framework as the current platform.  E.g. a
			 * WinForms application can use an Eto.Forms control when using the Eto.WinForms
			 * platform.  This prepares the control by firing the {@link Eto.Forms.Control.PreLoad},
			 * {@link Eto.Forms.Control.Load}, etc. events.
			 */
			AttachNative(): void;

			/**
			 * Detaches the control when it is used in a native application, when you want to reuse
			 * the control.
			 *
			 * This should only be called after {@link Eto.Forms.Control.AttachNative} has been
			 * called, which is usually done by calling to ToNative(true) .
			 */
			DetachNative(): void;

			/**
			 * Attempts to set the keyboard input focus to this control, or the first child that
			 * accepts focus. For Windows, this will bring it to front and activate it.
			 */
			Focus(): void;

			/**
			 * Suspends the layout of child controls
			 *
			 * This can be used to optimize some platforms while adding, removing, or changing many
			 * child controls at once. It disables the calculation of control positioning until
			 * {@link Eto.Forms.Control.ResumeLayout} is called. Each call to SuspendLayout() must be
			 * balanced with a call to {@link Eto.Forms.Control.ResumeLayout}.
			 */
			SuspendLayout(): void;

			/**
			 * Resumes the layout after it has been suspended, and performs a layout
			 *
			 * This can be used to optimize some platforms while adding, removing, or changing many
			 * child controls at once. Each call to ResumeLayout() must be balanced with a call to
			 * {@link Eto.Forms.Control.SuspendLayout} before it.
			 */
			ResumeLayout(): void;

			/**
			 * Specifies a command to execute for a platform-specific command
			 *
			 * Some platforms have specific system-defined commands that can be associated with a
			 * control. For example, the Mac platform's cut/copy/paste functionality is defined by
			 * the system, and if you want to hook into it, you can use this to map it to your own
			 * defined logic. The valid values of the `systemCommand` parameter are defined by each
			 * platform, and a list can be retrieved using
			 * {@link Eto.Forms.Control.SupportedPlatformCommands}
			 */
			MapPlatformCommand(
				systemCommand: string,
				command: Eto.Forms.Command,
			): void;

			/** Converts a point from screen space to control space. */
			PointFromScreen(point: Eto.Drawing.PointF): Eto.Drawing.PointF;

			/** Converts a point from control space to screen space */
			PointToScreen(point: Eto.Drawing.PointF): Eto.Drawing.PointF;

			/** Converts a rectangle from screen space to control space. */
			RectangleToScreen(rect: Eto.Drawing.RectangleF): Eto.Drawing.RectangleF;

			/** Converts a rectangle from control space to screen space */
			RectangleFromScreen(rect: Eto.Drawing.RectangleF): Eto.Drawing.RectangleF;

			/**
			 * Starts drag operation using this control as drag source.
			 *
			 * This method can be blocking on some platforms (Wpf, WinForms), and non-blocking on
			 * others (Mac, Gtk). Use the {@link Eto.Forms.Control.DragEnd} event to determine when
			 * the drag operation is completed and get its resulting DragEffects.
			 */
			DoDragDrop(
				data: Eto.Forms.DataObject,
				allowedEffects: Eto.Forms.DragEffects,
			): void;

			/**
			 * Starts drag operation using this control as drag source.
			 *
			 * This method can be blocking on some platforms (Wpf, WinForms), and non-blocking on
			 * others (Mac, Gtk). Use the {@link Eto.Forms.Control.DragEnd} event to determine when
			 * the drag operation is completed and get its resulting DragEffects.
			 */
			DoDragDrop(
				data: Eto.Forms.DataObject,
				allowedEffects: Eto.Forms.DragEffects,
				image: Eto.Drawing.Image,
				cursorOffset: Eto.Drawing.PointF,
			): void;

			/**
			 * Triggers the StyleChanged event and re-applies the styles to this control and its
			 * children.
			 */
			TriggerStyleChanged(): void;

			/** Shows a print dialog to print the specified control */
			Print(): void;

			/**
			 * Finds a control in the parent hierarchy with the specified type and
			 * {@link Eto.Widget.ID} if specified
			 */
			FindParent<T>(id?: string): T;

			/**
			 * Finds a control in the parent hierarchy with the specified type and
			 * {@link Eto.Widget.ID} if specified
			 */
			FindParent(
				type: unknown,
				id?: string,
			): Eto.Widget;

			/** Finds a control in the parent hierarchy with the specified `id` */
			FindParent(id: string): Eto.Widget;

			/**
			 * Unbinds any bindings in the {@link Eto.Forms.BindableWidget.Bindings} collection and
			 * removes the bindings
			 *
			 * When you implement {@link Eto.Forms.IBindableWidgetContainer}, this will also unbind
			 * any of its children.
			 */
			Unbind(): void;

			/**
			 * Updates all bindings in this widget
			 *
			 * When you implement {@link Eto.Forms.IBindableWidgetContainer}, this will also update
			 * bindings for all of its children.
			 */
			UpdateBindings(mode?: Eto.Forms.BindingUpdateMode): void;

			/** Disposes of this widget, supressing the finalizer */
			dispose(): void;

			/** Gets a string that represents the current object with its ID if specified. */
			ToString(): string;
		}
	}

	export namespace Eto.Forms.Stepper {
		export interface ICallback extends
			Eto.Forms.Control.ICallback,
			Eto.Widget.ICallback {
			OnStep(
				widget: Eto.Forms.Stepper,
				e: Eto.Forms.StepperEventArgs,
			): void;
		}
	}

	export namespace Eto.Forms.Stepper {
		export interface IHandler extends
			Eto.Forms.Control.IHandler,
			Eto.Widget.IHandler {
			ValidDirection: Eto.Forms.StepperValidDirections;
		}
	}

	export namespace Eto.Forms {
		/**
		 * Control to present multiple pages with a tab selection
		 *
		 * Some platforms (e.g. OS X) have limitations on how many tabs are visible. It is
		 * advised to utilize different methods (e.g. a listbox or combo box) to switch between
		 * many sections if there are too many tabs.
		 */
		export class TabControl implements
			Eto.IHandlerSource,
			Eto.Forms.IBindable,
			Eto.Forms.IMouseInputSource,
			Eto.Forms.IKeyboardInputSource {
			/** Initializes a new instance of the {@link Eto.Forms.TabControl} class. */
			constructor();

			/** Gets an enumeration of controls that are directly contained by this container */
			readonly Controls: Iterable<Eto.Forms.Control>;

			/** Gets or sets the index of the selected tab. */
			SelectedIndex: number;

			/** Gets or sets the currently selected page. */
			SelectedPage: Eto.Forms.TabPage;

			/** Gets the collection of tab pages. */
			readonly Pages: unknown;

			/**
			 * Gets or sets the position of the tabs relative to the content.
			 *
			 * Note that on some platforms the text is rotated when using Left or Right (e.g. OS X).
			 * This means that is is not suitable when you have a lot of tabs. Some platforms
			 * (mobile) may ignore this hint and display the tabs according to the platform.
			 */
			TabPosition: Eto.Forms.DockPosition;

			/** Gets the binding for the {@link Eto.Forms.TabControl.SelectedIndex} property. */
			readonly SelectedIndexBinding: Eto.Forms.BindableBinding$2<Eto.Forms.TabControl, number>;

			/**
			 * Gets or sets the size for the client area of the control
			 *
			 * The client size differs from the {@link Eto.Forms.Control.Size} in that it excludes
			 * the decorations of the container, such as the title bar and border around a
			 * {@link Eto.Forms.Window}, or the title and line  around a {@link Eto.Forms.GroupBox}.
			 */
			ClientSize: Eto.Drawing.Size;

			/**
			 * Gets an enumeration of all contained child controls, including controls within child
			 * containers
			 */
			readonly Children: Iterable<Eto.Forms.Control>;

			/**
			 * Gets an enumeration of all contained child controls in the visual tree, including
			 * controls within child containers.
			 */
			readonly VisualChildren: Iterable<Eto.Forms.Control>;

			/**
			 * Gets or sets the style provider for this container.
			 *
			 * The style provider is used to style this container and its children.
			 */
			StyleProvider: Eto.IStyleProvider;

			/**
			 * Gets the default style provider for this container.
			 *
			 * Use this to apply styles to any child controls of this container. By default, styles
			 * will apply to all children, including children of children unless
			 * {@link Eto.DefaultStyleProvider.Inherit} is set to false .  Typically, you would set
			 * Inherit to false when creating composite controls that already have all their styles
			 * applied and you don't want any other styles to be inherited.
			 */
			readonly Styles: Eto.DefaultStyleProvider;

			/**
			 * Gets a value indicating that the control is loaded onto a form, that is it has been
			 * created, added to a parent, and shown
			 *
			 * The {@link Eto.Forms.Control.OnLoad(System.EventArgs)} method sets this value to true
			 * after cascading to all children (for a {@link Eto.Forms.Container} ) and calling the
			 * platform handler's implementation.  It is called after adding to a loaded form, or
			 * when showing a new form.  The {@link Eto.Forms.Control.OnUnLoad(System.EventArgs)}
			 * method will set this value to false when the control is removed from its parent
			 */
			readonly Loaded: boolean;

			/**
			 * Gets an enumeration of controls that are in the visual tree.
			 *
			 * This is used to specify which controls are contained by this instance that are part of
			 * the visual tree. This should include all controls including non-logical Eto controls
			 * used for layout.
			 */
			readonly VisualControls: Iterable<Eto.Forms.Control>;

			/**
			 * Gets or sets a user-defined object that contains data about the control
			 *
			 * A common use of the tag property is to store data that is associated with the control
			 * that you can later retrieve.
			 */
			Tag: unknown;

			/**
			 * Gets the logical parent control.
			 *
			 * When the control is part of the visual tree (
				 * {@link Eto.Forms.Control.IsVisualControl} is true), this returns the logical parent
				 * that contains this control. Otherwise this is the same as
				 * {@link Eto.Forms.Control.Parent}.
				 */
				readonly LogicalParent: Eto.Forms.Container;

			/** Gets a value indicating this {@link Eto.Forms.Control} is part of the visual tree. */
			IsVisualControl: boolean;

			/**
			 * Gets or sets the size of the control. Use -1 to specify auto sizing for either the
			 * width and/or height.
			 *
			 * Setting the size of controls is entirely optional as most controls will size
			 * themselves appropriately. When specifying a size, it will be used as the desired size
			 * of the control.  The container will reposition and resize the control depending on the
			 * available size.  For a {@link Eto.Forms.Window}, it is preferred to set the
			 * {@link Eto.Forms.Container.ClientSize} instead, as various platforms have different
			 * sizes of window decorations, toolbars, etc.
			 */
			Size: Eto.Drawing.Size;

			/**
			 * Gets a value indicating this control currently has mouse capture
			 *
			 * Mouse capture can happen during a handled MouseDown event until MouseUp, or it can be
			 * captured explicitly via {@link Eto.Forms.Control.CaptureMouse}.
			 */
			readonly IsMouseCaptured: boolean;

			/** Gets or sets the width of the control size. */
			Width: number;

			/** Gets or sets the height of the control size. */
			Height: number;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Forms.Control} (or its
			 * children) are enabled and accept user input.
			 *
			 * Typically when a control is disabled, the user cannot do anything with the control or
			 * any of its children. Including for example, selecting text in a text control. Certain
			 * controls can have a 'Read Only' mode, such as {@link Eto.Forms.TextBox.ReadOnly} which
			 * allow the user to  select text, but not change its contents.
			 */
			Enabled: boolean;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Forms.Control} is visible to
			 * the user.
			 *
			 * When the visibility of a control is set to false, it will not occupy space in the
			 * layout.
			 */
			Visible: boolean;

			/** Gets the container which this control has been added to, if any */
			readonly Parent: Eto.Forms.Container;

			/**
			 * Gets the visual container of this control, if any.
			 *
			 * Some containers may use other Eto controls to layout its children, such as the
			 * {@link Eto.Forms.StackLayout}. This will return the parent control that visually
			 * contains this control as opposed to {@link Eto.Forms.Control.Parent} which will return
			 * the logical parent.
			 */
			VisualParent: Eto.Forms.Container;

			/** Gets a value indicating this control has been attached to a native container */
			readonly IsAttached: boolean;

			/**
			 * Gets or sets the color for the background of the control
			 *
			 * Note that on some platforms (e.g. Mac), setting the background color of a control can
			 * change the performance characteristics of the control and its children, since it must
			 * enable layers to do so.
			 */
			BackgroundColor: Eto.Drawing.Color;

			/** Gets a value indicating whether this instance has the keyboard input focus. */
			readonly HasFocus: boolean;

			/** Gets a value indicating whether the layout of child controls is suspended. */
			readonly IsSuspended: boolean;

			/** Gets the window this control is contained in */
			readonly ParentWindow: Eto.Forms.Window;

			/**
			 * Gets the supported platform commands that can be used to hook up system functions to
			 * user defined logic
			 *
			 * This lists all available commands that can be mapped using the
			 * {@link Eto.Forms.Control.MapPlatformCommand(System.String,Eto.Forms.Command)} method
			 * of the control.
			 */
			readonly SupportedPlatformCommands: Iterable<string>;

			/** Gets the bounding rectangle of this control relative to its container */
			readonly Bounds: Eto.Drawing.Rectangle;

			/**
			 * Gets the location of the control as positioned by the container
			 *
			 * A control's location is set by the container. This can be used to determine where the
			 * control is for overlaying floating windows, menus, etc.
			 */
			readonly Location: Eto.Drawing.Point;

			/** Gets or sets the type of cursor to use when the mouse is hovering over the control */
			Cursor: Eto.Forms.Cursor;

			/** Gets or sets the tool tip to show when the mouse is hovered over the control */
			ToolTip: string;

			/**
			 * Gets or sets the tab index order for this control within its container.
			 *
			 * This sets the order when using the tab key to cycle through controls  Note that some
			 * platforms (Gtk and WinForms) may not support setting the context of the tab order to
			 * StackLayout  or DynamicLayout containers and may not behave exactly as expected. Use
			 * the {@link Eto.PlatformFeatures.TabIndexWithCustomContainers} flag to determine if it
			 * is supported.
			 */
			TabIndex: number;

			/** Gets or sets a value indicating whether this control can serve as drop target. */
			AllowDrop: boolean;

			/**
			 * Gets or sets the parent widget which this widget has been added to, if any
			 *
			 * When implementing child widgets that can participate in the context based binding
			 * (MVVM), You can set this to the parent widget when it is added or removed to it
			 * (usually via a collection).  Note that you should typically provide a public new
			 * [ParentWidget] Parent { get; } property  so that consumers of your API cannot set the
			 * parent to an invalid value.
			 */
			Parent: Eto.Widget;

			/**
			 * Gets an enumeration of all parent widgets in the heirarchy by traversing the
			 * {@link Eto.Forms.BindableWidget.Parent} property.
			 */
			readonly Parents: Iterable<Eto.Widget>;

			/**
			 * Gets or sets the data context for this widget for binding
			 *
			 * Subclasses may override the standard behaviour so that hierarchy of widgets can be
			 * taken into account.  For example, a Control may return the data context of a parent,
			 * if it is not set explicitly.
			 */
			DataContext: unknown;

			/** Gets the collection of bindings that are attached to this widget */
			readonly Bindings: Eto.Forms.BindingCollection;

			/**
			 * Gets a value indicating that the {@link Eto.Forms.BindableWidget.DataContext} property
			 * is changing.
			 *
			 * This can be used to determine when to allow certain logic during the update of the
			 * data context.  It is used to disable binding setters on the model when the data
			 * context changes so that a binding does not cause the view model to be updated when the
			 * state hasn't been fully set yet.
			 */
			IsDataContextChanging: boolean;

			/**
			 * Gets the platform that was used to create the {@link Eto.Widget.Handler} for this
			 * widget
			 *
			 * This gets set to the current {@link Eto.Platform.Instance} during the construction of
			 * the object
			 */
			readonly Platform: Eto.Platform;

			/** Gets the platform-specific handler for this widget */
			Handler: unknown;

			/** Gets the native platform-specific handle for integration purposes */
			readonly NativeHandle: unknown;

			/** Gets the dictionary of properties for this widget */
			readonly Properties: Eto.PropertyStore;

			/** Gets or sets the ID of this widget */
			ID: string;

			/**
			 * Gets or sets the style of this widget
			 *
			 * Styles allow you to attach custom platform-specific logic to a widget. In your
			 * platform-specific assembly, use {@link Style.Add{H}(string, StyleHandler{H})} to add
			 * the style logic with the same id.
			 */
			Style: string;

			/**
			 * Gets the instance of the platform-specific object
			 *
			 * This can sometimes be useful to get the platform-specific object. Some handlers may
			 * not have any backing object for its functionality, so this may be null.  It is more
			 * preferred to use the {@link Eto.Widget.Handler} and cast that to the platform-specific
			 * handler class which can give you additional methods and helpers to do common tasks.
			 * For example, the {@link Eto.Forms.Application} object's handler for OS X has a
			 * AddFullScreenMenuItem property to specify if you want full screen support in your app.
			 */
			readonly ControlObject: unknown;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Widget} has been disposed.
			 *
			 * When the widget is disposed, it can no longer be used.
			 */
			IsDisposed: boolean;

			/** Remove the specified child from the container. */
			Remove(child: Eto.Forms.Control): void;

			/** Remove the specified `controls` from this container */
			Remove(controls: Iterable<Eto.Forms.Control>): void;

			/** Removes all controls from this container */
			RemoveAll(): void;

			/**
			 * Finds a child control in this container or any of its child containers with the
			 * specified `id`
			 */
			FindChild<T>(id?: string): T;

			/**
			 * Finds a child control in this container or any of its child containers with the
			 * specified `type`
			 */
			FindChild(
				type: unknown,
				id?: string,
			): Eto.Forms.Control;

			/**
			 * Finds a child control in this container or any of its child containers with the
			 * specified `id`.
			 */
			FindChild(id: string): Eto.Forms.Control;

			/**
			 * Queues a repaint of the entire control on the screen and any of its children.
			 *
			 * This is only useful when the control is visible.
			 */
			Invalidate(): void;

			/**
			 * Queues a repaint of the entire control on the screen
			 *
			 * This is only useful when the control is visible.
			 */
			Invalidate(invalidateChildren: boolean): void;

			/**
			 * Queues a repaint of the specified `rect` of the control and any children.
			 *
			 * This is only useful when the control is visible.
			 */
			Invalidate(rect: Eto.Drawing.Rectangle): void;

			/**
			 * Queues a repaint of the specified `rect` of the control
			 *
			 * This is only useful when the control is visible.
			 */
			Invalidate(
				rect: Eto.Drawing.Rectangle,
				invalidateChildren: boolean,
			): void;

			/**
			 * Updates the layout of this control if necessary.
			 *
			 * This will ensure the control has had all of its layout applied so you can use its
			 * position and size right after this call. Most platforms (except WinForms) use a
			 * deferred layout system so that after adding your control to the form dynamically it
			 * won't get laid out until the next idle loop. This is useful when you need to know the
			 * dimensions of the control immediately. Note that this can be an expensive operation,
			 * so it is recommended to only call this method when necessary and after all of the
			 * controls have been added/updated.
			 */
			UpdateLayout(): void;

			/** Gets the preferred size of this control given infinite space available. */
			GetPreferredSize(): Eto.Drawing.SizeF;

			/** Gets the preferred size of this control given the specified `availableSize`. */
			GetPreferredSize(availableSize: Eto.Drawing.SizeF): Eto.Drawing.SizeF;

			/**
			 * Captures all mouse events to this control.
			 *
			 * This captures all mouse events until {@link Eto.Forms.Control.ReleaseMouseCapture} is
			 * called.  Note that not all platforms will allow a mouse capture unless the mouse is
			 * currently down.
			 */
			CaptureMouse(): boolean;

			/** Releases the mouse capture after a call to {@link Eto.Forms.Control.CaptureMouse}. */
			ReleaseMouseCapture(): void;

			/**
			 * Finds a control in the parent hierarchy with the specified type and
			 * {@link Eto.Widget.ID} if specified
			 */
			FindParent(
				type: unknown,
				id?: string,
			): Eto.Forms.Container;

			/** Finds a control in the parent hierarchy with the specified `id` */
			FindParent(id: string): Eto.Forms.Container;

			/**
			 * Detaches the control by removing it from its parent
			 *
			 * This is essentially a shortcut to myControl.Parent.Remove(myControl);
			 */
			Detach(): void;

			/**
			 * Attaches the control for direct use in a native application
			 *
			 * Use this to use a control directly in a native application.  Note that the native
			 * application must be running the same framework as the current platform.  E.g. a
			 * WinForms application can use an Eto.Forms control when using the Eto.WinForms
			 * platform.  This prepares the control by firing the {@link Eto.Forms.Control.PreLoad},
			 * {@link Eto.Forms.Control.Load}, etc. events.
			 */
			AttachNative(): void;

			/**
			 * Detaches the control when it is used in a native application, when you want to reuse
			 * the control.
			 *
			 * This should only be called after {@link Eto.Forms.Control.AttachNative} has been
			 * called, which is usually done by calling to ToNative(true) .
			 */
			DetachNative(): void;

			/**
			 * Attempts to set the keyboard input focus to this control, or the first child that
			 * accepts focus. For Windows, this will bring it to front and activate it.
			 */
			Focus(): void;

			/**
			 * Suspends the layout of child controls
			 *
			 * This can be used to optimize some platforms while adding, removing, or changing many
			 * child controls at once. It disables the calculation of control positioning until
			 * {@link Eto.Forms.Control.ResumeLayout} is called. Each call to SuspendLayout() must be
			 * balanced with a call to {@link Eto.Forms.Control.ResumeLayout}.
			 */
			SuspendLayout(): void;

			/**
			 * Resumes the layout after it has been suspended, and performs a layout
			 *
			 * This can be used to optimize some platforms while adding, removing, or changing many
			 * child controls at once. Each call to ResumeLayout() must be balanced with a call to
			 * {@link Eto.Forms.Control.SuspendLayout} before it.
			 */
			ResumeLayout(): void;

			/**
			 * Specifies a command to execute for a platform-specific command
			 *
			 * Some platforms have specific system-defined commands that can be associated with a
			 * control. For example, the Mac platform's cut/copy/paste functionality is defined by
			 * the system, and if you want to hook into it, you can use this to map it to your own
			 * defined logic. The valid values of the `systemCommand` parameter are defined by each
			 * platform, and a list can be retrieved using
			 * {@link Eto.Forms.Control.SupportedPlatformCommands}
			 */
			MapPlatformCommand(
				systemCommand: string,
				command: Eto.Forms.Command,
			): void;

			/** Converts a point from screen space to control space. */
			PointFromScreen(point: Eto.Drawing.PointF): Eto.Drawing.PointF;

			/** Converts a point from control space to screen space */
			PointToScreen(point: Eto.Drawing.PointF): Eto.Drawing.PointF;

			/** Converts a rectangle from screen space to control space. */
			RectangleToScreen(rect: Eto.Drawing.RectangleF): Eto.Drawing.RectangleF;

			/** Converts a rectangle from control space to screen space */
			RectangleFromScreen(rect: Eto.Drawing.RectangleF): Eto.Drawing.RectangleF;

			/**
			 * Starts drag operation using this control as drag source.
			 *
			 * This method can be blocking on some platforms (Wpf, WinForms), and non-blocking on
			 * others (Mac, Gtk). Use the {@link Eto.Forms.Control.DragEnd} event to determine when
			 * the drag operation is completed and get its resulting DragEffects.
			 */
			DoDragDrop(
				data: Eto.Forms.DataObject,
				allowedEffects: Eto.Forms.DragEffects,
			): void;

			/**
			 * Starts drag operation using this control as drag source.
			 *
			 * This method can be blocking on some platforms (Wpf, WinForms), and non-blocking on
			 * others (Mac, Gtk). Use the {@link Eto.Forms.Control.DragEnd} event to determine when
			 * the drag operation is completed and get its resulting DragEffects.
			 */
			DoDragDrop(
				data: Eto.Forms.DataObject,
				allowedEffects: Eto.Forms.DragEffects,
				image: Eto.Drawing.Image,
				cursorOffset: Eto.Drawing.PointF,
			): void;

			/**
			 * Triggers the StyleChanged event and re-applies the styles to this control and its
			 * children.
			 */
			TriggerStyleChanged(): void;

			/** Shows a print dialog to print the specified control */
			Print(): void;

			/**
			 * Finds a control in the parent hierarchy with the specified type and
			 * {@link Eto.Widget.ID} if specified
			 */
			FindParent<T>(id?: string): T;

			/**
			 * Finds a control in the parent hierarchy with the specified type and
			 * {@link Eto.Widget.ID} if specified
			 */
			FindParent(
				type: unknown,
				id?: string,
			): Eto.Widget;

			/** Finds a control in the parent hierarchy with the specified `id` */
			FindParent(id: string): Eto.Widget;

			/**
			 * Unbinds any bindings in the {@link Eto.Forms.BindableWidget.Bindings} collection and
			 * removes the bindings
			 *
			 * When you implement {@link Eto.Forms.IBindableWidgetContainer}, this will also unbind
			 * any of its children.
			 */
			Unbind(): void;

			/**
			 * Updates all bindings in this widget
			 *
			 * When you implement {@link Eto.Forms.IBindableWidgetContainer}, this will also update
			 * bindings for all of its children.
			 */
			UpdateBindings(mode?: Eto.Forms.BindingUpdateMode): void;

			/** Disposes of this widget, supressing the finalizer */
			dispose(): void;

			/** Gets a string that represents the current object with its ID if specified. */
			ToString(): string;
		}
	}

	export namespace Eto.Forms.TabControl {
		export interface ICallback extends
			Eto.Forms.Control.ICallback,
			Eto.Widget.ICallback {
			OnSelectedIndexChanged(
				widget: Eto.Forms.TabControl,
				e: unknown,
			): void;
		}
	}

	export namespace Eto.Forms.TabControl {
		export interface IHandler extends
			Eto.Forms.Container.IHandler,
			Eto.Forms.Control.IHandler,
			Eto.Widget.IHandler {
			SelectedIndex: number;

			TabPosition: Eto.Forms.DockPosition;

			InsertTab(
				index: number,
				page: Eto.Forms.TabPage,
			): void;

			ClearTabs(): void;

			RemoveTab(
				index: number,
				page: Eto.Forms.TabPage,
			): void;
		}
	}

	export namespace Eto.Forms {
		/** Control for a page in a {@link Eto.Forms.TabControl} */
		export class TabPage implements
			Eto.IHandlerSource,
			Eto.Forms.IBindable,
			Eto.Forms.IMouseInputSource,
			Eto.Forms.IKeyboardInputSource {
			/** Initializes a new instance of the {@link Eto.Forms.TabPage} class. */
			constructor(
				control: Eto.Forms.Control,
				padding?: Eto.Drawing.Padding,
			);

			/** Initializes a new instance of the {@link Eto.Forms.TabPage} class. */
			constructor();

			/** Gets or sets the title text of the page. */
			Text: string;

			/**
			 * Gets or sets the image of the page.
			 *
			 * It is usally good to use an {@link Eto.Drawing.Icon} for the image with multiple
			 * sizes, so that scaling won't be needed to fit the image in the space. Usually you'd
			 * need 16x16 (desktop), 32x32 (iOS), and 64x64 (iOS Retina) variations.
			 */
			Image: Eto.Drawing.Image;

			/** Gets an enumeration of controls that are directly contained by this container */
			readonly Controls: Iterable<Eto.Forms.Control>;

			/** Gets or sets the padding around the {@link Eto.Forms.Panel.Content} of the panel. */
			Padding: Eto.Drawing.Padding;

			/** Gets or sets the minimum size of the panel. */
			MinimumSize: Eto.Drawing.Size;

			/**
			 * Gets or sets the context menu for the panel.
			 *
			 * The context menu is usually shown when the user right clicks the control, or in mobile
			 * platforms when the user taps and holds their finger down on the control.
			 */
			ContextMenu: Eto.Forms.ContextMenu;

			/**
			 * Gets or sets the main content of the panel.
			 *
			 * The main content will be offset by the {@link Eto.Forms.Panel.Padding} value
			 * specified, and will take up the entire content area of the control. Some controls may
			 * have decorations that will surround the content, such as a {@link Eto.Forms.GroupBox},
			 * {@link Eto.Forms.TabControl}, or {@link Eto.Forms.Window}
			 */
			Content: Eto.Forms.Control;

			/**
			 * Gets or sets the size for the client area of the control
			 *
			 * The client size differs from the {@link Eto.Forms.Control.Size} in that it excludes
			 * the decorations of the container, such as the title bar and border around a
			 * {@link Eto.Forms.Window}, or the title and line  around a {@link Eto.Forms.GroupBox}.
			 */
			ClientSize: Eto.Drawing.Size;

			/**
			 * Gets an enumeration of all contained child controls, including controls within child
			 * containers
			 */
			readonly Children: Iterable<Eto.Forms.Control>;

			/**
			 * Gets an enumeration of all contained child controls in the visual tree, including
			 * controls within child containers.
			 */
			readonly VisualChildren: Iterable<Eto.Forms.Control>;

			/**
			 * Gets or sets the style provider for this container.
			 *
			 * The style provider is used to style this container and its children.
			 */
			StyleProvider: Eto.IStyleProvider;

			/**
			 * Gets the default style provider for this container.
			 *
			 * Use this to apply styles to any child controls of this container. By default, styles
			 * will apply to all children, including children of children unless
			 * {@link Eto.DefaultStyleProvider.Inherit} is set to false .  Typically, you would set
			 * Inherit to false when creating composite controls that already have all their styles
			 * applied and you don't want any other styles to be inherited.
			 */
			readonly Styles: Eto.DefaultStyleProvider;

			/**
			 * Gets a value indicating that the control is loaded onto a form, that is it has been
			 * created, added to a parent, and shown
			 *
			 * The {@link Eto.Forms.Control.OnLoad(System.EventArgs)} method sets this value to true
			 * after cascading to all children (for a {@link Eto.Forms.Container} ) and calling the
			 * platform handler's implementation.  It is called after adding to a loaded form, or
			 * when showing a new form.  The {@link Eto.Forms.Control.OnUnLoad(System.EventArgs)}
			 * method will set this value to false when the control is removed from its parent
			 */
			readonly Loaded: boolean;

			/**
			 * Gets an enumeration of controls that are in the visual tree.
			 *
			 * This is used to specify which controls are contained by this instance that are part of
			 * the visual tree. This should include all controls including non-logical Eto controls
			 * used for layout.
			 */
			readonly VisualControls: Iterable<Eto.Forms.Control>;

			/**
			 * Gets or sets a user-defined object that contains data about the control
			 *
			 * A common use of the tag property is to store data that is associated with the control
			 * that you can later retrieve.
			 */
			Tag: unknown;

			/**
			 * Gets the logical parent control.
			 *
			 * When the control is part of the visual tree (
				 * {@link Eto.Forms.Control.IsVisualControl} is true), this returns the logical parent
				 * that contains this control. Otherwise this is the same as
				 * {@link Eto.Forms.Control.Parent}.
				 */
				readonly LogicalParent: Eto.Forms.Container;

			/** Gets a value indicating this {@link Eto.Forms.Control} is part of the visual tree. */
			IsVisualControl: boolean;

			/**
			 * Gets or sets the size of the control. Use -1 to specify auto sizing for either the
			 * width and/or height.
			 *
			 * Setting the size of controls is entirely optional as most controls will size
			 * themselves appropriately. When specifying a size, it will be used as the desired size
			 * of the control.  The container will reposition and resize the control depending on the
			 * available size.  For a {@link Eto.Forms.Window}, it is preferred to set the
			 * {@link Eto.Forms.Container.ClientSize} instead, as various platforms have different
			 * sizes of window decorations, toolbars, etc.
			 */
			Size: Eto.Drawing.Size;

			/**
			 * Gets a value indicating this control currently has mouse capture
			 *
			 * Mouse capture can happen during a handled MouseDown event until MouseUp, or it can be
			 * captured explicitly via {@link Eto.Forms.Control.CaptureMouse}.
			 */
			readonly IsMouseCaptured: boolean;

			/** Gets or sets the width of the control size. */
			Width: number;

			/** Gets or sets the height of the control size. */
			Height: number;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Forms.Control} (or its
			 * children) are enabled and accept user input.
			 *
			 * Typically when a control is disabled, the user cannot do anything with the control or
			 * any of its children. Including for example, selecting text in a text control. Certain
			 * controls can have a 'Read Only' mode, such as {@link Eto.Forms.TextBox.ReadOnly} which
			 * allow the user to  select text, but not change its contents.
			 */
			Enabled: boolean;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Forms.Control} is visible to
			 * the user.
			 *
			 * When the visibility of a control is set to false, it will not occupy space in the
			 * layout.
			 */
			Visible: boolean;

			/** Gets the container which this control has been added to, if any */
			readonly Parent: Eto.Forms.Container;

			/**
			 * Gets the visual container of this control, if any.
			 *
			 * Some containers may use other Eto controls to layout its children, such as the
			 * {@link Eto.Forms.StackLayout}. This will return the parent control that visually
			 * contains this control as opposed to {@link Eto.Forms.Control.Parent} which will return
			 * the logical parent.
			 */
			VisualParent: Eto.Forms.Container;

			/** Gets a value indicating this control has been attached to a native container */
			readonly IsAttached: boolean;

			/**
			 * Gets or sets the color for the background of the control
			 *
			 * Note that on some platforms (e.g. Mac), setting the background color of a control can
			 * change the performance characteristics of the control and its children, since it must
			 * enable layers to do so.
			 */
			BackgroundColor: Eto.Drawing.Color;

			/** Gets a value indicating whether this instance has the keyboard input focus. */
			readonly HasFocus: boolean;

			/** Gets a value indicating whether the layout of child controls is suspended. */
			readonly IsSuspended: boolean;

			/** Gets the window this control is contained in */
			readonly ParentWindow: Eto.Forms.Window;

			/**
			 * Gets the supported platform commands that can be used to hook up system functions to
			 * user defined logic
			 *
			 * This lists all available commands that can be mapped using the
			 * {@link Eto.Forms.Control.MapPlatformCommand(System.String,Eto.Forms.Command)} method
			 * of the control.
			 */
			readonly SupportedPlatformCommands: Iterable<string>;

			/** Gets the bounding rectangle of this control relative to its container */
			readonly Bounds: Eto.Drawing.Rectangle;

			/**
			 * Gets the location of the control as positioned by the container
			 *
			 * A control's location is set by the container. This can be used to determine where the
			 * control is for overlaying floating windows, menus, etc.
			 */
			readonly Location: Eto.Drawing.Point;

			/** Gets or sets the type of cursor to use when the mouse is hovering over the control */
			Cursor: Eto.Forms.Cursor;

			/** Gets or sets the tool tip to show when the mouse is hovered over the control */
			ToolTip: string;

			/**
			 * Gets or sets the tab index order for this control within its container.
			 *
			 * This sets the order when using the tab key to cycle through controls  Note that some
			 * platforms (Gtk and WinForms) may not support setting the context of the tab order to
			 * StackLayout  or DynamicLayout containers and may not behave exactly as expected. Use
			 * the {@link Eto.PlatformFeatures.TabIndexWithCustomContainers} flag to determine if it
			 * is supported.
			 */
			TabIndex: number;

			/** Gets or sets a value indicating whether this control can serve as drop target. */
			AllowDrop: boolean;

			/**
			 * Gets or sets the parent widget which this widget has been added to, if any
			 *
			 * When implementing child widgets that can participate in the context based binding
			 * (MVVM), You can set this to the parent widget when it is added or removed to it
			 * (usually via a collection).  Note that you should typically provide a public new
			 * [ParentWidget] Parent { get; } property  so that consumers of your API cannot set the
			 * parent to an invalid value.
			 */
			Parent: Eto.Widget;

			/**
			 * Gets an enumeration of all parent widgets in the heirarchy by traversing the
			 * {@link Eto.Forms.BindableWidget.Parent} property.
			 */
			readonly Parents: Iterable<Eto.Widget>;

			/**
			 * Gets or sets the data context for this widget for binding
			 *
			 * Subclasses may override the standard behaviour so that hierarchy of widgets can be
			 * taken into account.  For example, a Control may return the data context of a parent,
			 * if it is not set explicitly.
			 */
			DataContext: unknown;

			/** Gets the collection of bindings that are attached to this widget */
			readonly Bindings: Eto.Forms.BindingCollection;

			/**
			 * Gets a value indicating that the {@link Eto.Forms.BindableWidget.DataContext} property
			 * is changing.
			 *
			 * This can be used to determine when to allow certain logic during the update of the
			 * data context.  It is used to disable binding setters on the model when the data
			 * context changes so that a binding does not cause the view model to be updated when the
			 * state hasn't been fully set yet.
			 */
			IsDataContextChanging: boolean;

			/**
			 * Gets the platform that was used to create the {@link Eto.Widget.Handler} for this
			 * widget
			 *
			 * This gets set to the current {@link Eto.Platform.Instance} during the construction of
			 * the object
			 */
			readonly Platform: Eto.Platform;

			/** Gets the platform-specific handler for this widget */
			Handler: unknown;

			/** Gets the native platform-specific handle for integration purposes */
			readonly NativeHandle: unknown;

			/** Gets the dictionary of properties for this widget */
			readonly Properties: Eto.PropertyStore;

			/** Gets or sets the ID of this widget */
			ID: string;

			/**
			 * Gets or sets the style of this widget
			 *
			 * Styles allow you to attach custom platform-specific logic to a widget. In your
			 * platform-specific assembly, use {@link Style.Add{H}(string, StyleHandler{H})} to add
			 * the style logic with the same id.
			 */
			Style: string;

			/**
			 * Gets the instance of the platform-specific object
			 *
			 * This can sometimes be useful to get the platform-specific object. Some handlers may
			 * not have any backing object for its functionality, so this may be null.  It is more
			 * preferred to use the {@link Eto.Widget.Handler} and cast that to the platform-specific
			 * handler class which can give you additional methods and helpers to do common tasks.
			 * For example, the {@link Eto.Forms.Application} object's handler for OS X has a
			 * AddFullScreenMenuItem property to specify if you want full screen support in your app.
			 */
			readonly ControlObject: unknown;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Widget} has been disposed.
			 *
			 * When the widget is disposed, it can no longer be used.
			 */
			IsDisposed: boolean;

			/** Removes the specified child from the container */
			Remove(child: Eto.Forms.Control): void;

			/** Remove the specified `controls` from this container */
			Remove(controls: Iterable<Eto.Forms.Control>): void;

			/** Removes all controls from this container */
			RemoveAll(): void;

			/**
			 * Finds a child control in this container or any of its child containers with the
			 * specified `id`
			 */
			FindChild<T>(id?: string): T;

			/**
			 * Finds a child control in this container or any of its child containers with the
			 * specified `type`
			 */
			FindChild(
				type: unknown,
				id?: string,
			): Eto.Forms.Control;

			/**
			 * Finds a child control in this container or any of its child containers with the
			 * specified `id`.
			 */
			FindChild(id: string): Eto.Forms.Control;

			/**
			 * Queues a repaint of the entire control on the screen and any of its children.
			 *
			 * This is only useful when the control is visible.
			 */
			Invalidate(): void;

			/**
			 * Queues a repaint of the entire control on the screen
			 *
			 * This is only useful when the control is visible.
			 */
			Invalidate(invalidateChildren: boolean): void;

			/**
			 * Queues a repaint of the specified `rect` of the control and any children.
			 *
			 * This is only useful when the control is visible.
			 */
			Invalidate(rect: Eto.Drawing.Rectangle): void;

			/**
			 * Queues a repaint of the specified `rect` of the control
			 *
			 * This is only useful when the control is visible.
			 */
			Invalidate(
				rect: Eto.Drawing.Rectangle,
				invalidateChildren: boolean,
			): void;

			/**
			 * Updates the layout of this control if necessary.
			 *
			 * This will ensure the control has had all of its layout applied so you can use its
			 * position and size right after this call. Most platforms (except WinForms) use a
			 * deferred layout system so that after adding your control to the form dynamically it
			 * won't get laid out until the next idle loop. This is useful when you need to know the
			 * dimensions of the control immediately. Note that this can be an expensive operation,
			 * so it is recommended to only call this method when necessary and after all of the
			 * controls have been added/updated.
			 */
			UpdateLayout(): void;

			/** Gets the preferred size of this control given infinite space available. */
			GetPreferredSize(): Eto.Drawing.SizeF;

			/** Gets the preferred size of this control given the specified `availableSize`. */
			GetPreferredSize(availableSize: Eto.Drawing.SizeF): Eto.Drawing.SizeF;

			/**
			 * Captures all mouse events to this control.
			 *
			 * This captures all mouse events until {@link Eto.Forms.Control.ReleaseMouseCapture} is
			 * called.  Note that not all platforms will allow a mouse capture unless the mouse is
			 * currently down.
			 */
			CaptureMouse(): boolean;

			/** Releases the mouse capture after a call to {@link Eto.Forms.Control.CaptureMouse}. */
			ReleaseMouseCapture(): void;

			/**
			 * Finds a control in the parent hierarchy with the specified type and
			 * {@link Eto.Widget.ID} if specified
			 */
			FindParent(
				type: unknown,
				id?: string,
			): Eto.Forms.Container;

			/** Finds a control in the parent hierarchy with the specified `id` */
			FindParent(id: string): Eto.Forms.Container;

			/**
			 * Detaches the control by removing it from its parent
			 *
			 * This is essentially a shortcut to myControl.Parent.Remove(myControl);
			 */
			Detach(): void;

			/**
			 * Attaches the control for direct use in a native application
			 *
			 * Use this to use a control directly in a native application.  Note that the native
			 * application must be running the same framework as the current platform.  E.g. a
			 * WinForms application can use an Eto.Forms control when using the Eto.WinForms
			 * platform.  This prepares the control by firing the {@link Eto.Forms.Control.PreLoad},
			 * {@link Eto.Forms.Control.Load}, etc. events.
			 */
			AttachNative(): void;

			/**
			 * Detaches the control when it is used in a native application, when you want to reuse
			 * the control.
			 *
			 * This should only be called after {@link Eto.Forms.Control.AttachNative} has been
			 * called, which is usually done by calling to ToNative(true) .
			 */
			DetachNative(): void;

			/**
			 * Attempts to set the keyboard input focus to this control, or the first child that
			 * accepts focus. For Windows, this will bring it to front and activate it.
			 */
			Focus(): void;

			/**
			 * Suspends the layout of child controls
			 *
			 * This can be used to optimize some platforms while adding, removing, or changing many
			 * child controls at once. It disables the calculation of control positioning until
			 * {@link Eto.Forms.Control.ResumeLayout} is called. Each call to SuspendLayout() must be
			 * balanced with a call to {@link Eto.Forms.Control.ResumeLayout}.
			 */
			SuspendLayout(): void;

			/**
			 * Resumes the layout after it has been suspended, and performs a layout
			 *
			 * This can be used to optimize some platforms while adding, removing, or changing many
			 * child controls at once. Each call to ResumeLayout() must be balanced with a call to
			 * {@link Eto.Forms.Control.SuspendLayout} before it.
			 */
			ResumeLayout(): void;

			/**
			 * Specifies a command to execute for a platform-specific command
			 *
			 * Some platforms have specific system-defined commands that can be associated with a
			 * control. For example, the Mac platform's cut/copy/paste functionality is defined by
			 * the system, and if you want to hook into it, you can use this to map it to your own
			 * defined logic. The valid values of the `systemCommand` parameter are defined by each
			 * platform, and a list can be retrieved using
			 * {@link Eto.Forms.Control.SupportedPlatformCommands}
			 */
			MapPlatformCommand(
				systemCommand: string,
				command: Eto.Forms.Command,
			): void;

			/** Converts a point from screen space to control space. */
			PointFromScreen(point: Eto.Drawing.PointF): Eto.Drawing.PointF;

			/** Converts a point from control space to screen space */
			PointToScreen(point: Eto.Drawing.PointF): Eto.Drawing.PointF;

			/** Converts a rectangle from screen space to control space. */
			RectangleToScreen(rect: Eto.Drawing.RectangleF): Eto.Drawing.RectangleF;

			/** Converts a rectangle from control space to screen space */
			RectangleFromScreen(rect: Eto.Drawing.RectangleF): Eto.Drawing.RectangleF;

			/**
			 * Starts drag operation using this control as drag source.
			 *
			 * This method can be blocking on some platforms (Wpf, WinForms), and non-blocking on
			 * others (Mac, Gtk). Use the {@link Eto.Forms.Control.DragEnd} event to determine when
			 * the drag operation is completed and get its resulting DragEffects.
			 */
			DoDragDrop(
				data: Eto.Forms.DataObject,
				allowedEffects: Eto.Forms.DragEffects,
			): void;

			/**
			 * Starts drag operation using this control as drag source.
			 *
			 * This method can be blocking on some platforms (Wpf, WinForms), and non-blocking on
			 * others (Mac, Gtk). Use the {@link Eto.Forms.Control.DragEnd} event to determine when
			 * the drag operation is completed and get its resulting DragEffects.
			 */
			DoDragDrop(
				data: Eto.Forms.DataObject,
				allowedEffects: Eto.Forms.DragEffects,
				image: Eto.Drawing.Image,
				cursorOffset: Eto.Drawing.PointF,
			): void;

			/**
			 * Triggers the StyleChanged event and re-applies the styles to this control and its
			 * children.
			 */
			TriggerStyleChanged(): void;

			/** Shows a print dialog to print the specified control */
			Print(): void;

			/**
			 * Finds a control in the parent hierarchy with the specified type and
			 * {@link Eto.Widget.ID} if specified
			 */
			FindParent<T>(id?: string): T;

			/**
			 * Finds a control in the parent hierarchy with the specified type and
			 * {@link Eto.Widget.ID} if specified
			 */
			FindParent(
				type: unknown,
				id?: string,
			): Eto.Widget;

			/** Finds a control in the parent hierarchy with the specified `id` */
			FindParent(id: string): Eto.Widget;

			/**
			 * Unbinds any bindings in the {@link Eto.Forms.BindableWidget.Bindings} collection and
			 * removes the bindings
			 *
			 * When you implement {@link Eto.Forms.IBindableWidgetContainer}, this will also unbind
			 * any of its children.
			 */
			Unbind(): void;

			/**
			 * Updates all bindings in this widget
			 *
			 * When you implement {@link Eto.Forms.IBindableWidgetContainer}, this will also update
			 * bindings for all of its children.
			 */
			UpdateBindings(mode?: Eto.Forms.BindingUpdateMode): void;

			/** Disposes of this widget, supressing the finalizer */
			dispose(): void;

			/** Gets a string that represents the current object with its ID if specified. */
			ToString(): string;
		}
	}

	export namespace Eto.Forms.TabPage {
		export interface IHandler extends
			Eto.Forms.Panel.IHandler,
			Eto.Forms.Container.IHandler,
			Eto.Forms.Control.IHandler,
			Eto.Widget.IHandler,
			Eto.Forms.IContextMenuHost {
			Text: string;

			Image: Eto.Drawing.Image;
		}
	}

	export namespace Eto.Forms {
		/** Text replacement options when entering text */
		export enum TextReplacements {
			/** Do not perform any automatic replacements based on user input */
			None = 0,

			/** Perform text replacements, such as shortcuts */
			Text = 1,

			/** Perform replacements of straight quotes to 'curly' quotes */
			Quote = 2,

			/**
			 * Perform replacements of dashes '-' to em dash '—'.
			 *
			 * Note that some platforms may do this automatically with a single dash, some may
			 * require the user to enter  double dashes.
			 */
			Dash = 4,

			/** Perform automatic spelling correction */
			Spelling = 8,

			/** All replacements enabled. */
			All = 15,
		}
	}

	export namespace Eto.Forms {
		/**
		 * Control for multi-line text
		 *
		 * This differs from the {@link Eto.Forms.TextBox} in that it is used for multi-line text
		 * entry and can accept {@link Eto.Forms.Keys.Tab} and {@link Eto.Forms.Keys.Enter}
		 * input.
		 */
		export class TextArea implements
			Eto.IHandlerSource,
			Eto.Forms.IBindable,
			Eto.Forms.IMouseInputSource,
			Eto.Forms.IKeyboardInputSource {
			constructor();

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Forms.TextArea} is read only.
			 *
			 * A read only text box can be scrolled, text can be selected and copied, etc. However,
			 * the user will not be able to change any of the text. This differs from the
			 * {@link Eto.Forms.Control.Enabled} property, which disables all user interaction.
			 */
			ReadOnly: boolean;

			/**
			 * Gets or sets a value indicating whether text will wrap if lines are longer than the
			 * width of the control.
			 *
			 * Typically, a platform will word wrap the text.
			 */
			Wrap: boolean;

			/**
			 * Gets or sets the selected text.
			 *
			 * When setting the selected text, the text within the
			 * {@link Eto.Forms.TextArea.Selection} range will be replaced with the new value.
			 */
			SelectedText: string;

			/**
			 * Gets or sets the range of selected text.
			 *
			 * When setting the selection, the control will be focussed and the associated keyboard
			 * may appear on mobile platforms.
			 */
			Selection: Eto.Forms.Range$1<number>;

			/**
			 * Gets or sets the index of the insertion caret.
			 *
			 * When setting the caret, the control will be focussed and the associated keyboard may
			 * appear on mobile platforms.
			 */
			CaretIndex: number;

			/**
			 * Gets or sets a value indicating whether the tab key is inserted into the text area, or
			 * if it should be ignored by this control and used for navigating to the next control.
			 */
			AcceptsTab: boolean;

			/**
			 * Gets or sets a value indicating whether the return key is inserted into the text area,
			 * or if it should be ignored by this control.
			 */
			AcceptsReturn: boolean;

			/** Gets or sets the horizontal alignment of the text. */
			TextAlignment: Eto.Forms.TextAlignment;

			/** Gets or sets the horizontal alignment of the text. */
			HorizontalAlign: Eto.Forms.HorizontalAlign;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Forms.TextArea} will perform
			 * spell checking.
			 *
			 * When true , platforms will typically show misspelled or unknown words with a red
			 * underline. This is a hint, and is only supported by the platform when
			 * {@link Eto.Forms.TextArea.SpellCheckIsSupported} is true. When not supported, setting
			 * this property will do nothing.
			 */
			SpellCheck: boolean;

			/**
			 * Gets a value indicating whether the {@link Eto.Forms.TextArea.SpellCheck} property is
			 * supported on the control's platform.
			 */
			readonly SpellCheckIsSupported: boolean;

			/**
			 * Gets or sets a hint value indicating whether this {@link Eto.Forms.TextArea} will
			 * automatically correct text.
			 *
			 * On some platforms, autocorrection or text replacements such as quotes, etc may be
			 * default. Set this to {@link Eto.Forms.TextReplacements.None} to disable any text
			 * replacement.  Note this is only supported on OS X currently, all other platforms will
			 * be ignored.
			 */
			TextReplacements: Eto.Forms.TextReplacements;

			/**
			 * Gets the text replacements that this control supports on the current platform.
			 *
			 * You can use this to determine which flags in the
			 * {@link Eto.Forms.TextArea.TextReplacements} will take effect.
			 */
			readonly SupportedTextReplacements: Eto.Forms.TextReplacements;

			/** Gets or sets the border type */
			Border: Eto.Forms.BorderType;

			/**
			 * Gets the current length of the text
			 *
			 * When there is lots of text, this can be more performant than using Text.Length.
			 */
			readonly TextLength: number;

			/**
			 * Gets or sets the text of the control.
			 *
			 * Usually, the caret and selection will be set to the end of the string after its set.
			 */
			Text: string;

			/**
			 * Gets or sets the color of the text.
			 *
			 * By default, the text will get a color based on the user's theme. However, this is
			 * usually black.
			 */
			TextColor: Eto.Drawing.Color;

			/** Gets the binding for the {@link Eto.Forms.TextControl.Text} property. */
			readonly TextBinding: Eto.Forms.BindableBinding$2<Eto.Forms.TextControl, string>;

			/** Gets or sets the font for the text of the control */
			Font: Eto.Drawing.Font;

			/**
			 * Gets a value indicating that the control is loaded onto a form, that is it has been
			 * created, added to a parent, and shown
			 *
			 * The {@link Eto.Forms.Control.OnLoad(System.EventArgs)} method sets this value to true
			 * after cascading to all children (for a {@link Eto.Forms.Container} ) and calling the
			 * platform handler's implementation.  It is called after adding to a loaded form, or
			 * when showing a new form.  The {@link Eto.Forms.Control.OnUnLoad(System.EventArgs)}
			 * method will set this value to false when the control is removed from its parent
			 */
			readonly Loaded: boolean;

			/**
			 * Gets an enumeration of controls that are in the visual tree.
			 *
			 * This is used to specify which controls are contained by this instance that are part of
			 * the visual tree. This should include all controls including non-logical Eto controls
			 * used for layout.
			 */
			readonly VisualControls: Iterable<Eto.Forms.Control>;

			/**
			 * Gets or sets a user-defined object that contains data about the control
			 *
			 * A common use of the tag property is to store data that is associated with the control
			 * that you can later retrieve.
			 */
			Tag: unknown;

			/**
			 * Gets the logical parent control.
			 *
			 * When the control is part of the visual tree (
				 * {@link Eto.Forms.Control.IsVisualControl} is true), this returns the logical parent
				 * that contains this control. Otherwise this is the same as
				 * {@link Eto.Forms.Control.Parent}.
				 */
				readonly LogicalParent: Eto.Forms.Container;

			/** Gets a value indicating this {@link Eto.Forms.Control} is part of the visual tree. */
			IsVisualControl: boolean;

			/**
			 * Gets or sets the size of the control. Use -1 to specify auto sizing for either the
			 * width and/or height.
			 *
			 * Setting the size of controls is entirely optional as most controls will size
			 * themselves appropriately. When specifying a size, it will be used as the desired size
			 * of the control.  The container will reposition and resize the control depending on the
			 * available size.  For a {@link Eto.Forms.Window}, it is preferred to set the
			 * {@link Eto.Forms.Container.ClientSize} instead, as various platforms have different
			 * sizes of window decorations, toolbars, etc.
			 */
			Size: Eto.Drawing.Size;

			/**
			 * Gets a value indicating this control currently has mouse capture
			 *
			 * Mouse capture can happen during a handled MouseDown event until MouseUp, or it can be
			 * captured explicitly via {@link Eto.Forms.Control.CaptureMouse}.
			 */
			readonly IsMouseCaptured: boolean;

			/** Gets or sets the width of the control size. */
			Width: number;

			/** Gets or sets the height of the control size. */
			Height: number;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Forms.Control} (or its
			 * children) are enabled and accept user input.
			 *
			 * Typically when a control is disabled, the user cannot do anything with the control or
			 * any of its children. Including for example, selecting text in a text control. Certain
			 * controls can have a 'Read Only' mode, such as {@link Eto.Forms.TextBox.ReadOnly} which
			 * allow the user to  select text, but not change its contents.
			 */
			Enabled: boolean;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Forms.Control} is visible to
			 * the user.
			 *
			 * When the visibility of a control is set to false, it will not occupy space in the
			 * layout.
			 */
			Visible: boolean;

			/** Gets the container which this control has been added to, if any */
			readonly Parent: Eto.Forms.Container;

			/**
			 * Gets the visual container of this control, if any.
			 *
			 * Some containers may use other Eto controls to layout its children, such as the
			 * {@link Eto.Forms.StackLayout}. This will return the parent control that visually
			 * contains this control as opposed to {@link Eto.Forms.Control.Parent} which will return
			 * the logical parent.
			 */
			VisualParent: Eto.Forms.Container;

			/** Gets a value indicating this control has been attached to a native container */
			readonly IsAttached: boolean;

			/**
			 * Gets or sets the color for the background of the control
			 *
			 * Note that on some platforms (e.g. Mac), setting the background color of a control can
			 * change the performance characteristics of the control and its children, since it must
			 * enable layers to do so.
			 */
			BackgroundColor: Eto.Drawing.Color;

			/** Gets a value indicating whether this instance has the keyboard input focus. */
			readonly HasFocus: boolean;

			/** Gets a value indicating whether the layout of child controls is suspended. */
			readonly IsSuspended: boolean;

			/** Gets the window this control is contained in */
			readonly ParentWindow: Eto.Forms.Window;

			/**
			 * Gets the supported platform commands that can be used to hook up system functions to
			 * user defined logic
			 *
			 * This lists all available commands that can be mapped using the
			 * {@link Eto.Forms.Control.MapPlatformCommand(System.String,Eto.Forms.Command)} method
			 * of the control.
			 */
			readonly SupportedPlatformCommands: Iterable<string>;

			/** Gets the bounding rectangle of this control relative to its container */
			readonly Bounds: Eto.Drawing.Rectangle;

			/**
			 * Gets the location of the control as positioned by the container
			 *
			 * A control's location is set by the container. This can be used to determine where the
			 * control is for overlaying floating windows, menus, etc.
			 */
			readonly Location: Eto.Drawing.Point;

			/** Gets or sets the type of cursor to use when the mouse is hovering over the control */
			Cursor: Eto.Forms.Cursor;

			/** Gets or sets the tool tip to show when the mouse is hovered over the control */
			ToolTip: string;

			/**
			 * Gets or sets the tab index order for this control within its container.
			 *
			 * This sets the order when using the tab key to cycle through controls  Note that some
			 * platforms (Gtk and WinForms) may not support setting the context of the tab order to
			 * StackLayout  or DynamicLayout containers and may not behave exactly as expected. Use
			 * the {@link Eto.PlatformFeatures.TabIndexWithCustomContainers} flag to determine if it
			 * is supported.
			 */
			TabIndex: number;

			/** Gets or sets a value indicating whether this control can serve as drop target. */
			AllowDrop: boolean;

			/**
			 * Gets or sets the parent widget which this widget has been added to, if any
			 *
			 * When implementing child widgets that can participate in the context based binding
			 * (MVVM), You can set this to the parent widget when it is added or removed to it
			 * (usually via a collection).  Note that you should typically provide a public new
			 * [ParentWidget] Parent { get; } property  so that consumers of your API cannot set the
			 * parent to an invalid value.
			 */
			Parent: Eto.Widget;

			/**
			 * Gets an enumeration of all parent widgets in the heirarchy by traversing the
			 * {@link Eto.Forms.BindableWidget.Parent} property.
			 */
			readonly Parents: Iterable<Eto.Widget>;

			/**
			 * Gets or sets the data context for this widget for binding
			 *
			 * Subclasses may override the standard behaviour so that hierarchy of widgets can be
			 * taken into account.  For example, a Control may return the data context of a parent,
			 * if it is not set explicitly.
			 */
			DataContext: unknown;

			/** Gets the collection of bindings that are attached to this widget */
			readonly Bindings: Eto.Forms.BindingCollection;

			/**
			 * Gets a value indicating that the {@link Eto.Forms.BindableWidget.DataContext} property
			 * is changing.
			 *
			 * This can be used to determine when to allow certain logic during the update of the
			 * data context.  It is used to disable binding setters on the model when the data
			 * context changes so that a binding does not cause the view model to be updated when the
			 * state hasn't been fully set yet.
			 */
			IsDataContextChanging: boolean;

			/**
			 * Gets the platform that was used to create the {@link Eto.Widget.Handler} for this
			 * widget
			 *
			 * This gets set to the current {@link Eto.Platform.Instance} during the construction of
			 * the object
			 */
			readonly Platform: Eto.Platform;

			/** Gets the platform-specific handler for this widget */
			Handler: unknown;

			/** Gets the native platform-specific handle for integration purposes */
			readonly NativeHandle: unknown;

			/** Gets the dictionary of properties for this widget */
			readonly Properties: Eto.PropertyStore;

			/** Gets or sets the ID of this widget */
			ID: string;

			/**
			 * Gets or sets the style of this widget
			 *
			 * Styles allow you to attach custom platform-specific logic to a widget. In your
			 * platform-specific assembly, use {@link Style.Add{H}(string, StyleHandler{H})} to add
			 * the style logic with the same id.
			 */
			Style: string;

			/**
			 * Gets the instance of the platform-specific object
			 *
			 * This can sometimes be useful to get the platform-specific object. Some handlers may
			 * not have any backing object for its functionality, so this may be null.  It is more
			 * preferred to use the {@link Eto.Widget.Handler} and cast that to the platform-specific
			 * handler class which can give you additional methods and helpers to do common tasks.
			 * For example, the {@link Eto.Forms.Application} object's handler for OS X has a
			 * AddFullScreenMenuItem property to specify if you want full screen support in your app.
			 */
			readonly ControlObject: unknown;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Widget} has been disposed.
			 *
			 * When the widget is disposed, it can no longer be used.
			 */
			IsDisposed: boolean;

			/**
			 * Selects all text.
			 *
			 * When setting the selection, the control will be focussed and the associated keyboard
			 * may appear on mobile platforms.
			 */
			SelectAll(): void;

			/**
			 * Append the specified text to the control and optionally scrolls to make the inserted
			 * text visible.
			 *
			 * This is an optimized way of inserting text into a TextArea when its content gets
			 * large.
			 */
			Append(
				text: string,
				scrollToCursor?: boolean,
			): void;

			/**
			 * Scrolls the specified range into view.
			 *
			 * On some platforms, this may just scroll to the end of the range.
			 */
			ScrollTo(range: Eto.Forms.Range$1<number>): void;

			/** Scrolls to the start of the text in the text area. */
			ScrollToStart(): void;

			/** Scrolls to the end of the text in the text area. */
			ScrollToEnd(): void;

			/**
			 * Queues a repaint of the entire control on the screen and any of its children.
			 *
			 * This is only useful when the control is visible.
			 */
			Invalidate(): void;

			/**
			 * Queues a repaint of the entire control on the screen
			 *
			 * This is only useful when the control is visible.
			 */
			Invalidate(invalidateChildren: boolean): void;

			/**
			 * Queues a repaint of the specified `rect` of the control and any children.
			 *
			 * This is only useful when the control is visible.
			 */
			Invalidate(rect: Eto.Drawing.Rectangle): void;

			/**
			 * Queues a repaint of the specified `rect` of the control
			 *
			 * This is only useful when the control is visible.
			 */
			Invalidate(
				rect: Eto.Drawing.Rectangle,
				invalidateChildren: boolean,
			): void;

			/**
			 * Updates the layout of this control if necessary.
			 *
			 * This will ensure the control has had all of its layout applied so you can use its
			 * position and size right after this call. Most platforms (except WinForms) use a
			 * deferred layout system so that after adding your control to the form dynamically it
			 * won't get laid out until the next idle loop. This is useful when you need to know the
			 * dimensions of the control immediately. Note that this can be an expensive operation,
			 * so it is recommended to only call this method when necessary and after all of the
			 * controls have been added/updated.
			 */
			UpdateLayout(): void;

			/** Gets the preferred size of this control given infinite space available. */
			GetPreferredSize(): Eto.Drawing.SizeF;

			/** Gets the preferred size of this control given the specified `availableSize`. */
			GetPreferredSize(availableSize: Eto.Drawing.SizeF): Eto.Drawing.SizeF;

			/**
			 * Captures all mouse events to this control.
			 *
			 * This captures all mouse events until {@link Eto.Forms.Control.ReleaseMouseCapture} is
			 * called.  Note that not all platforms will allow a mouse capture unless the mouse is
			 * currently down.
			 */
			CaptureMouse(): boolean;

			/** Releases the mouse capture after a call to {@link Eto.Forms.Control.CaptureMouse}. */
			ReleaseMouseCapture(): void;

			/**
			 * Finds a control in the parent hierarchy with the specified type and
			 * {@link Eto.Widget.ID} if specified
			 */
			FindParent(
				type: unknown,
				id?: string,
			): Eto.Forms.Container;

			/** Finds a control in the parent hierarchy with the specified `id` */
			FindParent(id: string): Eto.Forms.Container;

			/**
			 * Detaches the control by removing it from its parent
			 *
			 * This is essentially a shortcut to myControl.Parent.Remove(myControl);
			 */
			Detach(): void;

			/**
			 * Attaches the control for direct use in a native application
			 *
			 * Use this to use a control directly in a native application.  Note that the native
			 * application must be running the same framework as the current platform.  E.g. a
			 * WinForms application can use an Eto.Forms control when using the Eto.WinForms
			 * platform.  This prepares the control by firing the {@link Eto.Forms.Control.PreLoad},
			 * {@link Eto.Forms.Control.Load}, etc. events.
			 */
			AttachNative(): void;

			/**
			 * Detaches the control when it is used in a native application, when you want to reuse
			 * the control.
			 *
			 * This should only be called after {@link Eto.Forms.Control.AttachNative} has been
			 * called, which is usually done by calling to ToNative(true) .
			 */
			DetachNative(): void;

			/**
			 * Attempts to set the keyboard input focus to this control, or the first child that
			 * accepts focus. For Windows, this will bring it to front and activate it.
			 */
			Focus(): void;

			/**
			 * Suspends the layout of child controls
			 *
			 * This can be used to optimize some platforms while adding, removing, or changing many
			 * child controls at once. It disables the calculation of control positioning until
			 * {@link Eto.Forms.Control.ResumeLayout} is called. Each call to SuspendLayout() must be
			 * balanced with a call to {@link Eto.Forms.Control.ResumeLayout}.
			 */
			SuspendLayout(): void;

			/**
			 * Resumes the layout after it has been suspended, and performs a layout
			 *
			 * This can be used to optimize some platforms while adding, removing, or changing many
			 * child controls at once. Each call to ResumeLayout() must be balanced with a call to
			 * {@link Eto.Forms.Control.SuspendLayout} before it.
			 */
			ResumeLayout(): void;

			/**
			 * Specifies a command to execute for a platform-specific command
			 *
			 * Some platforms have specific system-defined commands that can be associated with a
			 * control. For example, the Mac platform's cut/copy/paste functionality is defined by
			 * the system, and if you want to hook into it, you can use this to map it to your own
			 * defined logic. The valid values of the `systemCommand` parameter are defined by each
			 * platform, and a list can be retrieved using
			 * {@link Eto.Forms.Control.SupportedPlatformCommands}
			 */
			MapPlatformCommand(
				systemCommand: string,
				command: Eto.Forms.Command,
			): void;

			/** Converts a point from screen space to control space. */
			PointFromScreen(point: Eto.Drawing.PointF): Eto.Drawing.PointF;

			/** Converts a point from control space to screen space */
			PointToScreen(point: Eto.Drawing.PointF): Eto.Drawing.PointF;

			/** Converts a rectangle from screen space to control space. */
			RectangleToScreen(rect: Eto.Drawing.RectangleF): Eto.Drawing.RectangleF;

			/** Converts a rectangle from control space to screen space */
			RectangleFromScreen(rect: Eto.Drawing.RectangleF): Eto.Drawing.RectangleF;

			/**
			 * Starts drag operation using this control as drag source.
			 *
			 * This method can be blocking on some platforms (Wpf, WinForms), and non-blocking on
			 * others (Mac, Gtk). Use the {@link Eto.Forms.Control.DragEnd} event to determine when
			 * the drag operation is completed and get its resulting DragEffects.
			 */
			DoDragDrop(
				data: Eto.Forms.DataObject,
				allowedEffects: Eto.Forms.DragEffects,
			): void;

			/**
			 * Starts drag operation using this control as drag source.
			 *
			 * This method can be blocking on some platforms (Wpf, WinForms), and non-blocking on
			 * others (Mac, Gtk). Use the {@link Eto.Forms.Control.DragEnd} event to determine when
			 * the drag operation is completed and get its resulting DragEffects.
			 */
			DoDragDrop(
				data: Eto.Forms.DataObject,
				allowedEffects: Eto.Forms.DragEffects,
				image: Eto.Drawing.Image,
				cursorOffset: Eto.Drawing.PointF,
			): void;

			/**
			 * Triggers the StyleChanged event and re-applies the styles to this control and its
			 * children.
			 */
			TriggerStyleChanged(): void;

			/** Shows a print dialog to print the specified control */
			Print(): void;

			/**
			 * Finds a control in the parent hierarchy with the specified type and
			 * {@link Eto.Widget.ID} if specified
			 */
			FindParent<T>(id?: string): T;

			/**
			 * Finds a control in the parent hierarchy with the specified type and
			 * {@link Eto.Widget.ID} if specified
			 */
			FindParent(
				type: unknown,
				id?: string,
			): Eto.Widget;

			/** Finds a control in the parent hierarchy with the specified `id` */
			FindParent(id: string): Eto.Widget;

			/**
			 * Unbinds any bindings in the {@link Eto.Forms.BindableWidget.Bindings} collection and
			 * removes the bindings
			 *
			 * When you implement {@link Eto.Forms.IBindableWidgetContainer}, this will also unbind
			 * any of its children.
			 */
			Unbind(): void;

			/**
			 * Updates all bindings in this widget
			 *
			 * When you implement {@link Eto.Forms.IBindableWidgetContainer}, this will also update
			 * bindings for all of its children.
			 */
			UpdateBindings(mode?: Eto.Forms.BindingUpdateMode): void;

			/** Disposes of this widget, supressing the finalizer */
			dispose(): void;

			/** Gets a string that represents the current object with its ID if specified. */
			ToString(): string;
		}
	}

	export namespace Eto.Forms.TextArea {
		export interface ICallback extends
			Eto.Forms.TextControl.ICallback,
			Eto.Forms.Control.ICallback,
			Eto.Widget.ICallback {
			OnSelectionChanged(
				widget: Eto.Forms.TextArea,
				e: unknown,
			): void;

			OnCaretIndexChanged(
				widget: Eto.Forms.TextArea,
				e: unknown,
			): void;
		}
	}

	export namespace Eto.Forms.TextArea {
		export interface IHandler extends
			Eto.Forms.TextControl.IHandler,
			Eto.Forms.CommonControl.IHandler,
			Eto.Forms.Control.IHandler,
			Eto.Widget.IHandler {
			ReadOnly: boolean;

			Wrap: boolean;

			SelectedText: string;

			Selection: Eto.Forms.Range$1<number>;

			CaretIndex: number;

			AcceptsTab: boolean;

			AcceptsReturn: boolean;

			TextReplacements: Eto.Forms.TextReplacements;

			readonly SupportedTextReplacements: Eto.Forms.TextReplacements;

			TextAlignment: Eto.Forms.TextAlignment;

			SpellCheck: boolean;

			readonly SpellCheckIsSupported: boolean;

			Border: Eto.Forms.BorderType;

			readonly TextLength: number;

			Append(
				text: string,
				scrollToCursor: boolean,
			): void;

			SelectAll(): void;

			ScrollTo(range: Eto.Forms.Range$1<number>): void;

			ScrollToStart(): void;

			ScrollToEnd(): void;
		}
	}

	export namespace Eto.Forms {
		/** Enumeration of the modes for auto selecting text. */
		export enum AutoSelectMode {
			/**
			 * Selects the text when the control recieves focus, unless the user clicks at a point in
			 * the text with the I beam cursor.
			 */
			OnFocus = 0,

			/**
			 * The text is never automatically selected.  When the text of the control is set to a
			 * different value, the cursor usually will be at the end of the text input.  The last
			 * selection of the control is also usually kept in this mode.
			 */
			Never = 1,

			/**
			 * Selects the text when the control recieves focus regardless of whether the user
			 * clicked at a point in the text, or the last selection.  On macOS, if the user clicks
			 * and drags to select some text it will not select all text.
			 */
			Always = 2,
		}
	}

	export namespace Eto.Forms {
		/** Single line text box control */
		export class TextBox implements
			Eto.IHandlerSource,
			Eto.Forms.IBindable,
			Eto.Forms.IMouseInputSource,
			Eto.Forms.IKeyboardInputSource {
			constructor();

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Forms.TextBox} is read only.
			 *
			 * A user can selected and copied text when the read only, however the user will not be
			 * able to change any of the text. This differs from the
			 * {@link Eto.Forms.Control.Enabled} property, which disables all user interaction.
			 */
			ReadOnly: boolean;

			/**
			 * Gets or sets the maximum length of the text that can be entered in the control, 0 for
			 * no limit.
			 *
			 * This typically does not affect the value set using {@link Eto.Forms.TextControl.Text},
			 * only the limit of what the user can  enter into the control.
			 */
			MaxLength: number;

			/**
			 * Gets or sets the placeholder text to show as a hint of what the user should enter.
			 *
			 * Typically this will be shown when the control is blank, and will dissappear when the
			 * user enters text or if it has an existing value.
			 */
			PlaceholderText: string;

			/**
			 * Gets or sets a value indicating whether to show the control's border.
			 *
			 * This is a hint to omit the border of the control and show it as plainly as possible.
			 * Typically used when you want to show the control within a cell of the
			 * {@link Eto.Forms.GridView}.
			 */
			ShowBorder: boolean;

			/** Gets or sets the alignment of the text in the entry box. */
			TextAlignment: Eto.Forms.TextAlignment;

			/**
			 * Gets or sets the index of the current insertion point.
			 *
			 * When there is selected text, this is usually the start of the selection.
			 */
			CaretIndex: number;

			/** Gets or sets the current text selection. */
			Selection: Eto.Forms.Range$1<number>;

			/** Gets or sets the selected text. */
			SelectedText: string;

			/** Gets or sets the auto selection mode. */
			AutoSelectMode: Eto.Forms.AutoSelectMode;

			/**
			 * Gets or sets the text of the control.
			 *
			 * Usually, the caret and selection will be set to the end of the string after its set.
			 */
			Text: string;

			/**
			 * Gets or sets the color of the text.
			 *
			 * By default, the text will get a color based on the user's theme. However, this is
			 * usually black.
			 */
			TextColor: Eto.Drawing.Color;

			/** Gets the binding for the {@link Eto.Forms.TextControl.Text} property. */
			readonly TextBinding: Eto.Forms.BindableBinding$2<Eto.Forms.TextControl, string>;

			/** Gets or sets the font for the text of the control */
			Font: Eto.Drawing.Font;

			/**
			 * Gets a value indicating that the control is loaded onto a form, that is it has been
			 * created, added to a parent, and shown
			 *
			 * The {@link Eto.Forms.Control.OnLoad(System.EventArgs)} method sets this value to true
			 * after cascading to all children (for a {@link Eto.Forms.Container} ) and calling the
			 * platform handler's implementation.  It is called after adding to a loaded form, or
			 * when showing a new form.  The {@link Eto.Forms.Control.OnUnLoad(System.EventArgs)}
			 * method will set this value to false when the control is removed from its parent
			 */
			readonly Loaded: boolean;

			/**
			 * Gets an enumeration of controls that are in the visual tree.
			 *
			 * This is used to specify which controls are contained by this instance that are part of
			 * the visual tree. This should include all controls including non-logical Eto controls
			 * used for layout.
			 */
			readonly VisualControls: Iterable<Eto.Forms.Control>;

			/**
			 * Gets or sets a user-defined object that contains data about the control
			 *
			 * A common use of the tag property is to store data that is associated with the control
			 * that you can later retrieve.
			 */
			Tag: unknown;

			/**
			 * Gets the logical parent control.
			 *
			 * When the control is part of the visual tree (
				 * {@link Eto.Forms.Control.IsVisualControl} is true), this returns the logical parent
				 * that contains this control. Otherwise this is the same as
				 * {@link Eto.Forms.Control.Parent}.
				 */
				readonly LogicalParent: Eto.Forms.Container;

			/** Gets a value indicating this {@link Eto.Forms.Control} is part of the visual tree. */
			IsVisualControl: boolean;

			/**
			 * Gets or sets the size of the control. Use -1 to specify auto sizing for either the
			 * width and/or height.
			 *
			 * Setting the size of controls is entirely optional as most controls will size
			 * themselves appropriately. When specifying a size, it will be used as the desired size
			 * of the control.  The container will reposition and resize the control depending on the
			 * available size.  For a {@link Eto.Forms.Window}, it is preferred to set the
			 * {@link Eto.Forms.Container.ClientSize} instead, as various platforms have different
			 * sizes of window decorations, toolbars, etc.
			 */
			Size: Eto.Drawing.Size;

			/**
			 * Gets a value indicating this control currently has mouse capture
			 *
			 * Mouse capture can happen during a handled MouseDown event until MouseUp, or it can be
			 * captured explicitly via {@link Eto.Forms.Control.CaptureMouse}.
			 */
			readonly IsMouseCaptured: boolean;

			/** Gets or sets the width of the control size. */
			Width: number;

			/** Gets or sets the height of the control size. */
			Height: number;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Forms.Control} (or its
			 * children) are enabled and accept user input.
			 *
			 * Typically when a control is disabled, the user cannot do anything with the control or
			 * any of its children. Including for example, selecting text in a text control. Certain
			 * controls can have a 'Read Only' mode, such as {@link Eto.Forms.TextBox.ReadOnly} which
			 * allow the user to  select text, but not change its contents.
			 */
			Enabled: boolean;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Forms.Control} is visible to
			 * the user.
			 *
			 * When the visibility of a control is set to false, it will not occupy space in the
			 * layout.
			 */
			Visible: boolean;

			/** Gets the container which this control has been added to, if any */
			readonly Parent: Eto.Forms.Container;

			/**
			 * Gets the visual container of this control, if any.
			 *
			 * Some containers may use other Eto controls to layout its children, such as the
			 * {@link Eto.Forms.StackLayout}. This will return the parent control that visually
			 * contains this control as opposed to {@link Eto.Forms.Control.Parent} which will return
			 * the logical parent.
			 */
			VisualParent: Eto.Forms.Container;

			/** Gets a value indicating this control has been attached to a native container */
			readonly IsAttached: boolean;

			/**
			 * Gets or sets the color for the background of the control
			 *
			 * Note that on some platforms (e.g. Mac), setting the background color of a control can
			 * change the performance characteristics of the control and its children, since it must
			 * enable layers to do so.
			 */
			BackgroundColor: Eto.Drawing.Color;

			/** Gets a value indicating whether this instance has the keyboard input focus. */
			readonly HasFocus: boolean;

			/** Gets a value indicating whether the layout of child controls is suspended. */
			readonly IsSuspended: boolean;

			/** Gets the window this control is contained in */
			readonly ParentWindow: Eto.Forms.Window;

			/**
			 * Gets the supported platform commands that can be used to hook up system functions to
			 * user defined logic
			 *
			 * This lists all available commands that can be mapped using the
			 * {@link Eto.Forms.Control.MapPlatformCommand(System.String,Eto.Forms.Command)} method
			 * of the control.
			 */
			readonly SupportedPlatformCommands: Iterable<string>;

			/** Gets the bounding rectangle of this control relative to its container */
			readonly Bounds: Eto.Drawing.Rectangle;

			/**
			 * Gets the location of the control as positioned by the container
			 *
			 * A control's location is set by the container. This can be used to determine where the
			 * control is for overlaying floating windows, menus, etc.
			 */
			readonly Location: Eto.Drawing.Point;

			/** Gets or sets the type of cursor to use when the mouse is hovering over the control */
			Cursor: Eto.Forms.Cursor;

			/** Gets or sets the tool tip to show when the mouse is hovered over the control */
			ToolTip: string;

			/**
			 * Gets or sets the tab index order for this control within its container.
			 *
			 * This sets the order when using the tab key to cycle through controls  Note that some
			 * platforms (Gtk and WinForms) may not support setting the context of the tab order to
			 * StackLayout  or DynamicLayout containers and may not behave exactly as expected. Use
			 * the {@link Eto.PlatformFeatures.TabIndexWithCustomContainers} flag to determine if it
			 * is supported.
			 */
			TabIndex: number;

			/** Gets or sets a value indicating whether this control can serve as drop target. */
			AllowDrop: boolean;

			/**
			 * Gets or sets the parent widget which this widget has been added to, if any
			 *
			 * When implementing child widgets that can participate in the context based binding
			 * (MVVM), You can set this to the parent widget when it is added or removed to it
			 * (usually via a collection).  Note that you should typically provide a public new
			 * [ParentWidget] Parent { get; } property  so that consumers of your API cannot set the
			 * parent to an invalid value.
			 */
			Parent: Eto.Widget;

			/**
			 * Gets an enumeration of all parent widgets in the heirarchy by traversing the
			 * {@link Eto.Forms.BindableWidget.Parent} property.
			 */
			readonly Parents: Iterable<Eto.Widget>;

			/**
			 * Gets or sets the data context for this widget for binding
			 *
			 * Subclasses may override the standard behaviour so that hierarchy of widgets can be
			 * taken into account.  For example, a Control may return the data context of a parent,
			 * if it is not set explicitly.
			 */
			DataContext: unknown;

			/** Gets the collection of bindings that are attached to this widget */
			readonly Bindings: Eto.Forms.BindingCollection;

			/**
			 * Gets a value indicating that the {@link Eto.Forms.BindableWidget.DataContext} property
			 * is changing.
			 *
			 * This can be used to determine when to allow certain logic during the update of the
			 * data context.  It is used to disable binding setters on the model when the data
			 * context changes so that a binding does not cause the view model to be updated when the
			 * state hasn't been fully set yet.
			 */
			IsDataContextChanging: boolean;

			/**
			 * Gets the platform that was used to create the {@link Eto.Widget.Handler} for this
			 * widget
			 *
			 * This gets set to the current {@link Eto.Platform.Instance} during the construction of
			 * the object
			 */
			readonly Platform: Eto.Platform;

			/** Gets the platform-specific handler for this widget */
			Handler: unknown;

			/** Gets the native platform-specific handle for integration purposes */
			readonly NativeHandle: unknown;

			/** Gets the dictionary of properties for this widget */
			readonly Properties: Eto.PropertyStore;

			/** Gets or sets the ID of this widget */
			ID: string;

			/**
			 * Gets or sets the style of this widget
			 *
			 * Styles allow you to attach custom platform-specific logic to a widget. In your
			 * platform-specific assembly, use {@link Style.Add{H}(string, StyleHandler{H})} to add
			 * the style logic with the same id.
			 */
			Style: string;

			/**
			 * Gets the instance of the platform-specific object
			 *
			 * This can sometimes be useful to get the platform-specific object. Some handlers may
			 * not have any backing object for its functionality, so this may be null.  It is more
			 * preferred to use the {@link Eto.Widget.Handler} and cast that to the platform-specific
			 * handler class which can give you additional methods and helpers to do common tasks.
			 * For example, the {@link Eto.Forms.Application} object's handler for OS X has a
			 * AddFullScreenMenuItem property to specify if you want full screen support in your app.
			 */
			readonly ControlObject: unknown;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Widget} has been disposed.
			 *
			 * When the widget is disposed, it can no longer be used.
			 */
			IsDisposed: boolean;

			/**
			 * Selects all of the text in the control.
			 *
			 * When setting the selection, the control will be focussed and the associated keyboard
			 * may appear on mobile platforms.
			 */
			SelectAll(): void;

			/**
			 * Queues a repaint of the entire control on the screen and any of its children.
			 *
			 * This is only useful when the control is visible.
			 */
			Invalidate(): void;

			/**
			 * Queues a repaint of the entire control on the screen
			 *
			 * This is only useful when the control is visible.
			 */
			Invalidate(invalidateChildren: boolean): void;

			/**
			 * Queues a repaint of the specified `rect` of the control and any children.
			 *
			 * This is only useful when the control is visible.
			 */
			Invalidate(rect: Eto.Drawing.Rectangle): void;

			/**
			 * Queues a repaint of the specified `rect` of the control
			 *
			 * This is only useful when the control is visible.
			 */
			Invalidate(
				rect: Eto.Drawing.Rectangle,
				invalidateChildren: boolean,
			): void;

			/**
			 * Updates the layout of this control if necessary.
			 *
			 * This will ensure the control has had all of its layout applied so you can use its
			 * position and size right after this call. Most platforms (except WinForms) use a
			 * deferred layout system so that after adding your control to the form dynamically it
			 * won't get laid out until the next idle loop. This is useful when you need to know the
			 * dimensions of the control immediately. Note that this can be an expensive operation,
			 * so it is recommended to only call this method when necessary and after all of the
			 * controls have been added/updated.
			 */
			UpdateLayout(): void;

			/** Gets the preferred size of this control given infinite space available. */
			GetPreferredSize(): Eto.Drawing.SizeF;

			/** Gets the preferred size of this control given the specified `availableSize`. */
			GetPreferredSize(availableSize: Eto.Drawing.SizeF): Eto.Drawing.SizeF;

			/**
			 * Captures all mouse events to this control.
			 *
			 * This captures all mouse events until {@link Eto.Forms.Control.ReleaseMouseCapture} is
			 * called.  Note that not all platforms will allow a mouse capture unless the mouse is
			 * currently down.
			 */
			CaptureMouse(): boolean;

			/** Releases the mouse capture after a call to {@link Eto.Forms.Control.CaptureMouse}. */
			ReleaseMouseCapture(): void;

			/**
			 * Finds a control in the parent hierarchy with the specified type and
			 * {@link Eto.Widget.ID} if specified
			 */
			FindParent(
				type: unknown,
				id?: string,
			): Eto.Forms.Container;

			/** Finds a control in the parent hierarchy with the specified `id` */
			FindParent(id: string): Eto.Forms.Container;

			/**
			 * Detaches the control by removing it from its parent
			 *
			 * This is essentially a shortcut to myControl.Parent.Remove(myControl);
			 */
			Detach(): void;

			/**
			 * Attaches the control for direct use in a native application
			 *
			 * Use this to use a control directly in a native application.  Note that the native
			 * application must be running the same framework as the current platform.  E.g. a
			 * WinForms application can use an Eto.Forms control when using the Eto.WinForms
			 * platform.  This prepares the control by firing the {@link Eto.Forms.Control.PreLoad},
			 * {@link Eto.Forms.Control.Load}, etc. events.
			 */
			AttachNative(): void;

			/**
			 * Detaches the control when it is used in a native application, when you want to reuse
			 * the control.
			 *
			 * This should only be called after {@link Eto.Forms.Control.AttachNative} has been
			 * called, which is usually done by calling to ToNative(true) .
			 */
			DetachNative(): void;

			/**
			 * Attempts to set the keyboard input focus to this control, or the first child that
			 * accepts focus. For Windows, this will bring it to front and activate it.
			 */
			Focus(): void;

			/**
			 * Suspends the layout of child controls
			 *
			 * This can be used to optimize some platforms while adding, removing, or changing many
			 * child controls at once. It disables the calculation of control positioning until
			 * {@link Eto.Forms.Control.ResumeLayout} is called. Each call to SuspendLayout() must be
			 * balanced with a call to {@link Eto.Forms.Control.ResumeLayout}.
			 */
			SuspendLayout(): void;

			/**
			 * Resumes the layout after it has been suspended, and performs a layout
			 *
			 * This can be used to optimize some platforms while adding, removing, or changing many
			 * child controls at once. Each call to ResumeLayout() must be balanced with a call to
			 * {@link Eto.Forms.Control.SuspendLayout} before it.
			 */
			ResumeLayout(): void;

			/**
			 * Specifies a command to execute for a platform-specific command
			 *
			 * Some platforms have specific system-defined commands that can be associated with a
			 * control. For example, the Mac platform's cut/copy/paste functionality is defined by
			 * the system, and if you want to hook into it, you can use this to map it to your own
			 * defined logic. The valid values of the `systemCommand` parameter are defined by each
			 * platform, and a list can be retrieved using
			 * {@link Eto.Forms.Control.SupportedPlatformCommands}
			 */
			MapPlatformCommand(
				systemCommand: string,
				command: Eto.Forms.Command,
			): void;

			/** Converts a point from screen space to control space. */
			PointFromScreen(point: Eto.Drawing.PointF): Eto.Drawing.PointF;

			/** Converts a point from control space to screen space */
			PointToScreen(point: Eto.Drawing.PointF): Eto.Drawing.PointF;

			/** Converts a rectangle from screen space to control space. */
			RectangleToScreen(rect: Eto.Drawing.RectangleF): Eto.Drawing.RectangleF;

			/** Converts a rectangle from control space to screen space */
			RectangleFromScreen(rect: Eto.Drawing.RectangleF): Eto.Drawing.RectangleF;

			/**
			 * Starts drag operation using this control as drag source.
			 *
			 * This method can be blocking on some platforms (Wpf, WinForms), and non-blocking on
			 * others (Mac, Gtk). Use the {@link Eto.Forms.Control.DragEnd} event to determine when
			 * the drag operation is completed and get its resulting DragEffects.
			 */
			DoDragDrop(
				data: Eto.Forms.DataObject,
				allowedEffects: Eto.Forms.DragEffects,
			): void;

			/**
			 * Starts drag operation using this control as drag source.
			 *
			 * This method can be blocking on some platforms (Wpf, WinForms), and non-blocking on
			 * others (Mac, Gtk). Use the {@link Eto.Forms.Control.DragEnd} event to determine when
			 * the drag operation is completed and get its resulting DragEffects.
			 */
			DoDragDrop(
				data: Eto.Forms.DataObject,
				allowedEffects: Eto.Forms.DragEffects,
				image: Eto.Drawing.Image,
				cursorOffset: Eto.Drawing.PointF,
			): void;

			/**
			 * Triggers the StyleChanged event and re-applies the styles to this control and its
			 * children.
			 */
			TriggerStyleChanged(): void;

			/** Shows a print dialog to print the specified control */
			Print(): void;

			/**
			 * Finds a control in the parent hierarchy with the specified type and
			 * {@link Eto.Widget.ID} if specified
			 */
			FindParent<T>(id?: string): T;

			/**
			 * Finds a control in the parent hierarchy with the specified type and
			 * {@link Eto.Widget.ID} if specified
			 */
			FindParent(
				type: unknown,
				id?: string,
			): Eto.Widget;

			/** Finds a control in the parent hierarchy with the specified `id` */
			FindParent(id: string): Eto.Widget;

			/**
			 * Unbinds any bindings in the {@link Eto.Forms.BindableWidget.Bindings} collection and
			 * removes the bindings
			 *
			 * When you implement {@link Eto.Forms.IBindableWidgetContainer}, this will also unbind
			 * any of its children.
			 */
			Unbind(): void;

			/**
			 * Updates all bindings in this widget
			 *
			 * When you implement {@link Eto.Forms.IBindableWidgetContainer}, this will also update
			 * bindings for all of its children.
			 */
			UpdateBindings(mode?: Eto.Forms.BindingUpdateMode): void;

			/** Disposes of this widget, supressing the finalizer */
			dispose(): void;

			/** Gets a string that represents the current object with its ID if specified. */
			ToString(): string;
		}
	}

	export namespace Eto.Forms.TextBox {
		export interface IHandler extends
			Eto.Forms.TextControl.IHandler,
			Eto.Forms.CommonControl.IHandler,
			Eto.Forms.Control.IHandler,
			Eto.Widget.IHandler {
			ReadOnly: boolean;

			MaxLength: number;

			PlaceholderText: string;

			CaretIndex: number;

			Selection: Eto.Forms.Range$1<number>;

			ShowBorder: boolean;

			TextAlignment: Eto.Forms.TextAlignment;

			AutoSelectMode: Eto.Forms.AutoSelectMode;

			SelectAll(): void;
		}
	}

	export namespace Eto.Forms.TextBox {
		export interface ICallback extends
			Eto.Forms.TextControl.ICallback,
			Eto.Forms.Control.ICallback,
			Eto.Widget.ICallback {
			OnTextChanging(
				widget: Eto.Forms.TextBox,
				e: Eto.Forms.TextChangingEventArgs,
			): void;
		}
	}

	export namespace Eto.Forms {
		/**
		 * Arguments for events that handle when text is about to change, such as the
		 * {@link Eto.Forms.TextBox.TextChanging} event.
		 *
		 * To cancel the change, set the inherited
		 * {@link System.ComponentModel.CancelEventArgs.Cancel} property to true.
		 */
		export class TextChangingEventArgs {
			/** Initializes a new instance of the {@link Eto.Forms.TextChangingEventArgs} class. */
			constructor(
				text: string,
				range: Eto.Forms.Range$1<number>,
				fromUser: boolean,
			);

			/** Initializes a new instance of the {@link Eto.Forms.TextChangingEventArgs} class. */
			constructor(
				text: string,
				range: Eto.Forms.Range$1<number>,
				oldText: string,
				fromUser: boolean,
			);

			/** Initializes a new instance of the {@link Eto.Forms.TextChangingEventArgs} class. */
			constructor(
				oldText: string,
				newText: string,
				fromUser: boolean,
			);

			/**
			 * Gets the text that is to be inserted at the given
			 * {@link Eto.Forms.TextChangingEventArgs.Range}, or string.Empty if text will be
			 * deleted.
			 */
			readonly Text: string;

			/**
			 * Gets the range that the text will be replaced or deleted.
			 *
			 * When the {@link Eto.Forms.TextChangingEventArgs.Text} is empty, then the specified
			 * range of text will be deleted. Otherwise, the text in the range will be replaced. Note
			 * that the length of the {@link Eto.Forms.TextChangingEventArgs.Text} will not
			 * necessarily match the length of the range.
			 */
			readonly Range: Eto.Forms.Range$1<number>;

			/**
			 * Gets the entire old text for the control.
			 *
			 * This is the same as the {@link Eto.Forms.TextControl.Text} property of the control.
			 */
			readonly OldText: string;

			/** Gets the new text the control will contain after the change. */
			readonly NewText: string;

			/** Gets a value indicating that the change was initiated by the user, false */
			readonly FromUser: boolean;
		}
	}

	export namespace Eto.Forms {
		/**
		 * Base class for controls implementing text and text changing events, when it has a
		 * singular text property.
		 *
		 * If a control has multiple text properties, it is best to implement those specifically
		 * to identify what the property represents more clearly.
		 */
		export class TextControl implements
			Eto.IHandlerSource,
			Eto.Forms.IBindable,
			Eto.Forms.IMouseInputSource,
			Eto.Forms.IKeyboardInputSource {
			/**
			 * Gets or sets the text of the control.
			 *
			 * Usually, the caret and selection will be set to the end of the string after its set.
			 */
			Text: string;

			/**
			 * Gets or sets the color of the text.
			 *
			 * By default, the text will get a color based on the user's theme. However, this is
			 * usually black.
			 */
			TextColor: Eto.Drawing.Color;

			/** Gets the binding for the {@link Eto.Forms.TextControl.Text} property. */
			readonly TextBinding: Eto.Forms.BindableBinding$2<Eto.Forms.TextControl, string>;

			/** Gets or sets the font for the text of the control */
			Font: Eto.Drawing.Font;

			/**
			 * Gets a value indicating that the control is loaded onto a form, that is it has been
			 * created, added to a parent, and shown
			 *
			 * The {@link Eto.Forms.Control.OnLoad(System.EventArgs)} method sets this value to true
			 * after cascading to all children (for a {@link Eto.Forms.Container} ) and calling the
			 * platform handler's implementation.  It is called after adding to a loaded form, or
			 * when showing a new form.  The {@link Eto.Forms.Control.OnUnLoad(System.EventArgs)}
			 * method will set this value to false when the control is removed from its parent
			 */
			readonly Loaded: boolean;

			/**
			 * Gets an enumeration of controls that are in the visual tree.
			 *
			 * This is used to specify which controls are contained by this instance that are part of
			 * the visual tree. This should include all controls including non-logical Eto controls
			 * used for layout.
			 */
			readonly VisualControls: Iterable<Eto.Forms.Control>;

			/**
			 * Gets or sets a user-defined object that contains data about the control
			 *
			 * A common use of the tag property is to store data that is associated with the control
			 * that you can later retrieve.
			 */
			Tag: unknown;

			/**
			 * Gets the logical parent control.
			 *
			 * When the control is part of the visual tree (
				 * {@link Eto.Forms.Control.IsVisualControl} is true), this returns the logical parent
				 * that contains this control. Otherwise this is the same as
				 * {@link Eto.Forms.Control.Parent}.
				 */
				readonly LogicalParent: Eto.Forms.Container;

			/** Gets a value indicating this {@link Eto.Forms.Control} is part of the visual tree. */
			IsVisualControl: boolean;

			/**
			 * Gets or sets the size of the control. Use -1 to specify auto sizing for either the
			 * width and/or height.
			 *
			 * Setting the size of controls is entirely optional as most controls will size
			 * themselves appropriately. When specifying a size, it will be used as the desired size
			 * of the control.  The container will reposition and resize the control depending on the
			 * available size.  For a {@link Eto.Forms.Window}, it is preferred to set the
			 * {@link Eto.Forms.Container.ClientSize} instead, as various platforms have different
			 * sizes of window decorations, toolbars, etc.
			 */
			Size: Eto.Drawing.Size;

			/**
			 * Gets a value indicating this control currently has mouse capture
			 *
			 * Mouse capture can happen during a handled MouseDown event until MouseUp, or it can be
			 * captured explicitly via {@link Eto.Forms.Control.CaptureMouse}.
			 */
			readonly IsMouseCaptured: boolean;

			/** Gets or sets the width of the control size. */
			Width: number;

			/** Gets or sets the height of the control size. */
			Height: number;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Forms.Control} (or its
			 * children) are enabled and accept user input.
			 *
			 * Typically when a control is disabled, the user cannot do anything with the control or
			 * any of its children. Including for example, selecting text in a text control. Certain
			 * controls can have a 'Read Only' mode, such as {@link Eto.Forms.TextBox.ReadOnly} which
			 * allow the user to  select text, but not change its contents.
			 */
			Enabled: boolean;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Forms.Control} is visible to
			 * the user.
			 *
			 * When the visibility of a control is set to false, it will not occupy space in the
			 * layout.
			 */
			Visible: boolean;

			/** Gets the container which this control has been added to, if any */
			readonly Parent: Eto.Forms.Container;

			/**
			 * Gets the visual container of this control, if any.
			 *
			 * Some containers may use other Eto controls to layout its children, such as the
			 * {@link Eto.Forms.StackLayout}. This will return the parent control that visually
			 * contains this control as opposed to {@link Eto.Forms.Control.Parent} which will return
			 * the logical parent.
			 */
			VisualParent: Eto.Forms.Container;

			/** Gets a value indicating this control has been attached to a native container */
			readonly IsAttached: boolean;

			/**
			 * Gets or sets the color for the background of the control
			 *
			 * Note that on some platforms (e.g. Mac), setting the background color of a control can
			 * change the performance characteristics of the control and its children, since it must
			 * enable layers to do so.
			 */
			BackgroundColor: Eto.Drawing.Color;

			/** Gets a value indicating whether this instance has the keyboard input focus. */
			readonly HasFocus: boolean;

			/** Gets a value indicating whether the layout of child controls is suspended. */
			readonly IsSuspended: boolean;

			/** Gets the window this control is contained in */
			readonly ParentWindow: Eto.Forms.Window;

			/**
			 * Gets the supported platform commands that can be used to hook up system functions to
			 * user defined logic
			 *
			 * This lists all available commands that can be mapped using the
			 * {@link Eto.Forms.Control.MapPlatformCommand(System.String,Eto.Forms.Command)} method
			 * of the control.
			 */
			readonly SupportedPlatformCommands: Iterable<string>;

			/** Gets the bounding rectangle of this control relative to its container */
			readonly Bounds: Eto.Drawing.Rectangle;

			/**
			 * Gets the location of the control as positioned by the container
			 *
			 * A control's location is set by the container. This can be used to determine where the
			 * control is for overlaying floating windows, menus, etc.
			 */
			readonly Location: Eto.Drawing.Point;

			/** Gets or sets the type of cursor to use when the mouse is hovering over the control */
			Cursor: Eto.Forms.Cursor;

			/** Gets or sets the tool tip to show when the mouse is hovered over the control */
			ToolTip: string;

			/**
			 * Gets or sets the tab index order for this control within its container.
			 *
			 * This sets the order when using the tab key to cycle through controls  Note that some
			 * platforms (Gtk and WinForms) may not support setting the context of the tab order to
			 * StackLayout  or DynamicLayout containers and may not behave exactly as expected. Use
			 * the {@link Eto.PlatformFeatures.TabIndexWithCustomContainers} flag to determine if it
			 * is supported.
			 */
			TabIndex: number;

			/** Gets or sets a value indicating whether this control can serve as drop target. */
			AllowDrop: boolean;

			/**
			 * Gets or sets the parent widget which this widget has been added to, if any
			 *
			 * When implementing child widgets that can participate in the context based binding
			 * (MVVM), You can set this to the parent widget when it is added or removed to it
			 * (usually via a collection).  Note that you should typically provide a public new
			 * [ParentWidget] Parent { get; } property  so that consumers of your API cannot set the
			 * parent to an invalid value.
			 */
			Parent: Eto.Widget;

			/**
			 * Gets an enumeration of all parent widgets in the heirarchy by traversing the
			 * {@link Eto.Forms.BindableWidget.Parent} property.
			 */
			readonly Parents: Iterable<Eto.Widget>;

			/**
			 * Gets or sets the data context for this widget for binding
			 *
			 * Subclasses may override the standard behaviour so that hierarchy of widgets can be
			 * taken into account.  For example, a Control may return the data context of a parent,
			 * if it is not set explicitly.
			 */
			DataContext: unknown;

			/** Gets the collection of bindings that are attached to this widget */
			readonly Bindings: Eto.Forms.BindingCollection;

			/**
			 * Gets a value indicating that the {@link Eto.Forms.BindableWidget.DataContext} property
			 * is changing.
			 *
			 * This can be used to determine when to allow certain logic during the update of the
			 * data context.  It is used to disable binding setters on the model when the data
			 * context changes so that a binding does not cause the view model to be updated when the
			 * state hasn't been fully set yet.
			 */
			IsDataContextChanging: boolean;

			/**
			 * Gets the platform that was used to create the {@link Eto.Widget.Handler} for this
			 * widget
			 *
			 * This gets set to the current {@link Eto.Platform.Instance} during the construction of
			 * the object
			 */
			readonly Platform: Eto.Platform;

			/** Gets the platform-specific handler for this widget */
			Handler: unknown;

			/** Gets the native platform-specific handle for integration purposes */
			readonly NativeHandle: unknown;

			/** Gets the dictionary of properties for this widget */
			readonly Properties: Eto.PropertyStore;

			/** Gets or sets the ID of this widget */
			ID: string;

			/**
			 * Gets or sets the style of this widget
			 *
			 * Styles allow you to attach custom platform-specific logic to a widget. In your
			 * platform-specific assembly, use {@link Style.Add{H}(string, StyleHandler{H})} to add
			 * the style logic with the same id.
			 */
			Style: string;

			/**
			 * Gets the instance of the platform-specific object
			 *
			 * This can sometimes be useful to get the platform-specific object. Some handlers may
			 * not have any backing object for its functionality, so this may be null.  It is more
			 * preferred to use the {@link Eto.Widget.Handler} and cast that to the platform-specific
			 * handler class which can give you additional methods and helpers to do common tasks.
			 * For example, the {@link Eto.Forms.Application} object's handler for OS X has a
			 * AddFullScreenMenuItem property to specify if you want full screen support in your app.
			 */
			readonly ControlObject: unknown;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Widget} has been disposed.
			 *
			 * When the widget is disposed, it can no longer be used.
			 */
			IsDisposed: boolean;

			/**
			 * Queues a repaint of the entire control on the screen and any of its children.
			 *
			 * This is only useful when the control is visible.
			 */
			Invalidate(): void;

			/**
			 * Queues a repaint of the entire control on the screen
			 *
			 * This is only useful when the control is visible.
			 */
			Invalidate(invalidateChildren: boolean): void;

			/**
			 * Queues a repaint of the specified `rect` of the control and any children.
			 *
			 * This is only useful when the control is visible.
			 */
			Invalidate(rect: Eto.Drawing.Rectangle): void;

			/**
			 * Queues a repaint of the specified `rect` of the control
			 *
			 * This is only useful when the control is visible.
			 */
			Invalidate(
				rect: Eto.Drawing.Rectangle,
				invalidateChildren: boolean,
			): void;

			/**
			 * Updates the layout of this control if necessary.
			 *
			 * This will ensure the control has had all of its layout applied so you can use its
			 * position and size right after this call. Most platforms (except WinForms) use a
			 * deferred layout system so that after adding your control to the form dynamically it
			 * won't get laid out until the next idle loop. This is useful when you need to know the
			 * dimensions of the control immediately. Note that this can be an expensive operation,
			 * so it is recommended to only call this method when necessary and after all of the
			 * controls have been added/updated.
			 */
			UpdateLayout(): void;

			/** Gets the preferred size of this control given infinite space available. */
			GetPreferredSize(): Eto.Drawing.SizeF;

			/** Gets the preferred size of this control given the specified `availableSize`. */
			GetPreferredSize(availableSize: Eto.Drawing.SizeF): Eto.Drawing.SizeF;

			/**
			 * Captures all mouse events to this control.
			 *
			 * This captures all mouse events until {@link Eto.Forms.Control.ReleaseMouseCapture} is
			 * called.  Note that not all platforms will allow a mouse capture unless the mouse is
			 * currently down.
			 */
			CaptureMouse(): boolean;

			/** Releases the mouse capture after a call to {@link Eto.Forms.Control.CaptureMouse}. */
			ReleaseMouseCapture(): void;

			/**
			 * Finds a control in the parent hierarchy with the specified type and
			 * {@link Eto.Widget.ID} if specified
			 */
			FindParent(
				type: unknown,
				id?: string,
			): Eto.Forms.Container;

			/** Finds a control in the parent hierarchy with the specified `id` */
			FindParent(id: string): Eto.Forms.Container;

			/**
			 * Detaches the control by removing it from its parent
			 *
			 * This is essentially a shortcut to myControl.Parent.Remove(myControl);
			 */
			Detach(): void;

			/**
			 * Attaches the control for direct use in a native application
			 *
			 * Use this to use a control directly in a native application.  Note that the native
			 * application must be running the same framework as the current platform.  E.g. a
			 * WinForms application can use an Eto.Forms control when using the Eto.WinForms
			 * platform.  This prepares the control by firing the {@link Eto.Forms.Control.PreLoad},
			 * {@link Eto.Forms.Control.Load}, etc. events.
			 */
			AttachNative(): void;

			/**
			 * Detaches the control when it is used in a native application, when you want to reuse
			 * the control.
			 *
			 * This should only be called after {@link Eto.Forms.Control.AttachNative} has been
			 * called, which is usually done by calling to ToNative(true) .
			 */
			DetachNative(): void;

			/**
			 * Attempts to set the keyboard input focus to this control, or the first child that
			 * accepts focus. For Windows, this will bring it to front and activate it.
			 */
			Focus(): void;

			/**
			 * Suspends the layout of child controls
			 *
			 * This can be used to optimize some platforms while adding, removing, or changing many
			 * child controls at once. It disables the calculation of control positioning until
			 * {@link Eto.Forms.Control.ResumeLayout} is called. Each call to SuspendLayout() must be
			 * balanced with a call to {@link Eto.Forms.Control.ResumeLayout}.
			 */
			SuspendLayout(): void;

			/**
			 * Resumes the layout after it has been suspended, and performs a layout
			 *
			 * This can be used to optimize some platforms while adding, removing, or changing many
			 * child controls at once. Each call to ResumeLayout() must be balanced with a call to
			 * {@link Eto.Forms.Control.SuspendLayout} before it.
			 */
			ResumeLayout(): void;

			/**
			 * Specifies a command to execute for a platform-specific command
			 *
			 * Some platforms have specific system-defined commands that can be associated with a
			 * control. For example, the Mac platform's cut/copy/paste functionality is defined by
			 * the system, and if you want to hook into it, you can use this to map it to your own
			 * defined logic. The valid values of the `systemCommand` parameter are defined by each
			 * platform, and a list can be retrieved using
			 * {@link Eto.Forms.Control.SupportedPlatformCommands}
			 */
			MapPlatformCommand(
				systemCommand: string,
				command: Eto.Forms.Command,
			): void;

			/** Converts a point from screen space to control space. */
			PointFromScreen(point: Eto.Drawing.PointF): Eto.Drawing.PointF;

			/** Converts a point from control space to screen space */
			PointToScreen(point: Eto.Drawing.PointF): Eto.Drawing.PointF;

			/** Converts a rectangle from screen space to control space. */
			RectangleToScreen(rect: Eto.Drawing.RectangleF): Eto.Drawing.RectangleF;

			/** Converts a rectangle from control space to screen space */
			RectangleFromScreen(rect: Eto.Drawing.RectangleF): Eto.Drawing.RectangleF;

			/**
			 * Starts drag operation using this control as drag source.
			 *
			 * This method can be blocking on some platforms (Wpf, WinForms), and non-blocking on
			 * others (Mac, Gtk). Use the {@link Eto.Forms.Control.DragEnd} event to determine when
			 * the drag operation is completed and get its resulting DragEffects.
			 */
			DoDragDrop(
				data: Eto.Forms.DataObject,
				allowedEffects: Eto.Forms.DragEffects,
			): void;

			/**
			 * Starts drag operation using this control as drag source.
			 *
			 * This method can be blocking on some platforms (Wpf, WinForms), and non-blocking on
			 * others (Mac, Gtk). Use the {@link Eto.Forms.Control.DragEnd} event to determine when
			 * the drag operation is completed and get its resulting DragEffects.
			 */
			DoDragDrop(
				data: Eto.Forms.DataObject,
				allowedEffects: Eto.Forms.DragEffects,
				image: Eto.Drawing.Image,
				cursorOffset: Eto.Drawing.PointF,
			): void;

			/**
			 * Triggers the StyleChanged event and re-applies the styles to this control and its
			 * children.
			 */
			TriggerStyleChanged(): void;

			/** Shows a print dialog to print the specified control */
			Print(): void;

			/**
			 * Finds a control in the parent hierarchy with the specified type and
			 * {@link Eto.Widget.ID} if specified
			 */
			FindParent<T>(id?: string): T;

			/**
			 * Finds a control in the parent hierarchy with the specified type and
			 * {@link Eto.Widget.ID} if specified
			 */
			FindParent(
				type: unknown,
				id?: string,
			): Eto.Widget;

			/** Finds a control in the parent hierarchy with the specified `id` */
			FindParent(id: string): Eto.Widget;

			/**
			 * Unbinds any bindings in the {@link Eto.Forms.BindableWidget.Bindings} collection and
			 * removes the bindings
			 *
			 * When you implement {@link Eto.Forms.IBindableWidgetContainer}, this will also unbind
			 * any of its children.
			 */
			Unbind(): void;

			/**
			 * Updates all bindings in this widget
			 *
			 * When you implement {@link Eto.Forms.IBindableWidgetContainer}, this will also update
			 * bindings for all of its children.
			 */
			UpdateBindings(mode?: Eto.Forms.BindingUpdateMode): void;

			/** Disposes of this widget, supressing the finalizer */
			dispose(): void;

			/** Gets a string that represents the current object with its ID if specified. */
			ToString(): string;
		}
	}

	export namespace Eto.Forms.TextControl {
		export interface ICallback extends
			Eto.Forms.Control.ICallback,
			Eto.Widget.ICallback {
			OnTextChanged(
				widget: Eto.Forms.TextControl,
				e: unknown,
			): void;
		}
	}

	export namespace Eto.Forms.TextControl {
		export interface IHandler extends
			Eto.Forms.CommonControl.IHandler,
			Eto.Forms.Control.IHandler,
			Eto.Widget.IHandler {
			Text: string;

			TextColor: Eto.Drawing.Color;
		}
	}

	export namespace Eto.Forms {
		/** Event arguments when handling text input events */
		export class TextInputEventArgs {
			/** Initializes a new instance of the {@link Eto.Forms.TextInputEventArgs} class. */
			constructor(text: string);

			/** The entered text, or null if no text was entered. */
			Text: string;
		}
	}

	export namespace Eto.Forms {
		/**
		 * Stepper with custom text entry field
		 *
		 * This can be used to implement a custom stepper interface that is not entirely
		 * restricted to numeric values like {@link Eto.Forms.NumericStepper}.
		 */
		export class TextStepper implements
			Eto.IHandlerSource,
			Eto.Forms.IBindable,
			Eto.Forms.IMouseInputSource,
			Eto.Forms.IKeyboardInputSource {
			constructor();

			/**
			 * Gets or sets the valid directions the stepper will allow the user to click.
			 *
			 * On some platforms, the up and/or down buttons will not appear disabled, but will not
			 * trigger any events when they are  not set as a valid direction.
			 */
			ValidDirection: Eto.Forms.StepperValidDirections;

			/**
			 * Gets or sets a value indicating whether the Stepper will be shown.
			 *
			 * This is a hint only, some platforms (currently Gtk) may ignore this setting.
			 */
			ShowStepper: boolean;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Forms.TextBox} is read only.
			 *
			 * A user can selected and copied text when the read only, however the user will not be
			 * able to change any of the text. This differs from the
			 * {@link Eto.Forms.Control.Enabled} property, which disables all user interaction.
			 */
			ReadOnly: boolean;

			/**
			 * Gets or sets the maximum length of the text that can be entered in the control, 0 for
			 * no limit.
			 *
			 * This typically does not affect the value set using {@link Eto.Forms.TextControl.Text},
			 * only the limit of what the user can  enter into the control.
			 */
			MaxLength: number;

			/**
			 * Gets or sets the placeholder text to show as a hint of what the user should enter.
			 *
			 * Typically this will be shown when the control is blank, and will dissappear when the
			 * user enters text or if it has an existing value.
			 */
			PlaceholderText: string;

			/**
			 * Gets or sets a value indicating whether to show the control's border.
			 *
			 * This is a hint to omit the border of the control and show it as plainly as possible.
			 * Typically used when you want to show the control within a cell of the
			 * {@link Eto.Forms.GridView}.
			 */
			ShowBorder: boolean;

			/** Gets or sets the alignment of the text in the entry box. */
			TextAlignment: Eto.Forms.TextAlignment;

			/**
			 * Gets or sets the index of the current insertion point.
			 *
			 * When there is selected text, this is usually the start of the selection.
			 */
			CaretIndex: number;

			/** Gets or sets the current text selection. */
			Selection: Eto.Forms.Range$1<number>;

			/** Gets or sets the selected text. */
			SelectedText: string;

			/** Gets or sets the auto selection mode. */
			AutoSelectMode: Eto.Forms.AutoSelectMode;

			/**
			 * Gets or sets the text of the control.
			 *
			 * Usually, the caret and selection will be set to the end of the string after its set.
			 */
			Text: string;

			/**
			 * Gets or sets the color of the text.
			 *
			 * By default, the text will get a color based on the user's theme. However, this is
			 * usually black.
			 */
			TextColor: Eto.Drawing.Color;

			/** Gets the binding for the {@link Eto.Forms.TextControl.Text} property. */
			readonly TextBinding: Eto.Forms.BindableBinding$2<Eto.Forms.TextControl, string>;

			/** Gets or sets the font for the text of the control */
			Font: Eto.Drawing.Font;

			/**
			 * Gets a value indicating that the control is loaded onto a form, that is it has been
			 * created, added to a parent, and shown
			 *
			 * The {@link Eto.Forms.Control.OnLoad(System.EventArgs)} method sets this value to true
			 * after cascading to all children (for a {@link Eto.Forms.Container} ) and calling the
			 * platform handler's implementation.  It is called after adding to a loaded form, or
			 * when showing a new form.  The {@link Eto.Forms.Control.OnUnLoad(System.EventArgs)}
			 * method will set this value to false when the control is removed from its parent
			 */
			readonly Loaded: boolean;

			/**
			 * Gets an enumeration of controls that are in the visual tree.
			 *
			 * This is used to specify which controls are contained by this instance that are part of
			 * the visual tree. This should include all controls including non-logical Eto controls
			 * used for layout.
			 */
			readonly VisualControls: Iterable<Eto.Forms.Control>;

			/**
			 * Gets or sets a user-defined object that contains data about the control
			 *
			 * A common use of the tag property is to store data that is associated with the control
			 * that you can later retrieve.
			 */
			Tag: unknown;

			/**
			 * Gets the logical parent control.
			 *
			 * When the control is part of the visual tree (
				 * {@link Eto.Forms.Control.IsVisualControl} is true), this returns the logical parent
				 * that contains this control. Otherwise this is the same as
				 * {@link Eto.Forms.Control.Parent}.
				 */
				readonly LogicalParent: Eto.Forms.Container;

			/** Gets a value indicating this {@link Eto.Forms.Control} is part of the visual tree. */
			IsVisualControl: boolean;

			/**
			 * Gets or sets the size of the control. Use -1 to specify auto sizing for either the
			 * width and/or height.
			 *
			 * Setting the size of controls is entirely optional as most controls will size
			 * themselves appropriately. When specifying a size, it will be used as the desired size
			 * of the control.  The container will reposition and resize the control depending on the
			 * available size.  For a {@link Eto.Forms.Window}, it is preferred to set the
			 * {@link Eto.Forms.Container.ClientSize} instead, as various platforms have different
			 * sizes of window decorations, toolbars, etc.
			 */
			Size: Eto.Drawing.Size;

			/**
			 * Gets a value indicating this control currently has mouse capture
			 *
			 * Mouse capture can happen during a handled MouseDown event until MouseUp, or it can be
			 * captured explicitly via {@link Eto.Forms.Control.CaptureMouse}.
			 */
			readonly IsMouseCaptured: boolean;

			/** Gets or sets the width of the control size. */
			Width: number;

			/** Gets or sets the height of the control size. */
			Height: number;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Forms.Control} (or its
			 * children) are enabled and accept user input.
			 *
			 * Typically when a control is disabled, the user cannot do anything with the control or
			 * any of its children. Including for example, selecting text in a text control. Certain
			 * controls can have a 'Read Only' mode, such as {@link Eto.Forms.TextBox.ReadOnly} which
			 * allow the user to  select text, but not change its contents.
			 */
			Enabled: boolean;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Forms.Control} is visible to
			 * the user.
			 *
			 * When the visibility of a control is set to false, it will not occupy space in the
			 * layout.
			 */
			Visible: boolean;

			/** Gets the container which this control has been added to, if any */
			readonly Parent: Eto.Forms.Container;

			/**
			 * Gets the visual container of this control, if any.
			 *
			 * Some containers may use other Eto controls to layout its children, such as the
			 * {@link Eto.Forms.StackLayout}. This will return the parent control that visually
			 * contains this control as opposed to {@link Eto.Forms.Control.Parent} which will return
			 * the logical parent.
			 */
			VisualParent: Eto.Forms.Container;

			/** Gets a value indicating this control has been attached to a native container */
			readonly IsAttached: boolean;

			/**
			 * Gets or sets the color for the background of the control
			 *
			 * Note that on some platforms (e.g. Mac), setting the background color of a control can
			 * change the performance characteristics of the control and its children, since it must
			 * enable layers to do so.
			 */
			BackgroundColor: Eto.Drawing.Color;

			/** Gets a value indicating whether this instance has the keyboard input focus. */
			readonly HasFocus: boolean;

			/** Gets a value indicating whether the layout of child controls is suspended. */
			readonly IsSuspended: boolean;

			/** Gets the window this control is contained in */
			readonly ParentWindow: Eto.Forms.Window;

			/**
			 * Gets the supported platform commands that can be used to hook up system functions to
			 * user defined logic
			 *
			 * This lists all available commands that can be mapped using the
			 * {@link Eto.Forms.Control.MapPlatformCommand(System.String,Eto.Forms.Command)} method
			 * of the control.
			 */
			readonly SupportedPlatformCommands: Iterable<string>;

			/** Gets the bounding rectangle of this control relative to its container */
			readonly Bounds: Eto.Drawing.Rectangle;

			/**
			 * Gets the location of the control as positioned by the container
			 *
			 * A control's location is set by the container. This can be used to determine where the
			 * control is for overlaying floating windows, menus, etc.
			 */
			readonly Location: Eto.Drawing.Point;

			/** Gets or sets the type of cursor to use when the mouse is hovering over the control */
			Cursor: Eto.Forms.Cursor;

			/** Gets or sets the tool tip to show when the mouse is hovered over the control */
			ToolTip: string;

			/**
			 * Gets or sets the tab index order for this control within its container.
			 *
			 * This sets the order when using the tab key to cycle through controls  Note that some
			 * platforms (Gtk and WinForms) may not support setting the context of the tab order to
			 * StackLayout  or DynamicLayout containers and may not behave exactly as expected. Use
			 * the {@link Eto.PlatformFeatures.TabIndexWithCustomContainers} flag to determine if it
			 * is supported.
			 */
			TabIndex: number;

			/** Gets or sets a value indicating whether this control can serve as drop target. */
			AllowDrop: boolean;

			/**
			 * Gets or sets the parent widget which this widget has been added to, if any
			 *
			 * When implementing child widgets that can participate in the context based binding
			 * (MVVM), You can set this to the parent widget when it is added or removed to it
			 * (usually via a collection).  Note that you should typically provide a public new
			 * [ParentWidget] Parent { get; } property  so that consumers of your API cannot set the
			 * parent to an invalid value.
			 */
			Parent: Eto.Widget;

			/**
			 * Gets an enumeration of all parent widgets in the heirarchy by traversing the
			 * {@link Eto.Forms.BindableWidget.Parent} property.
			 */
			readonly Parents: Iterable<Eto.Widget>;

			/**
			 * Gets or sets the data context for this widget for binding
			 *
			 * Subclasses may override the standard behaviour so that hierarchy of widgets can be
			 * taken into account.  For example, a Control may return the data context of a parent,
			 * if it is not set explicitly.
			 */
			DataContext: unknown;

			/** Gets the collection of bindings that are attached to this widget */
			readonly Bindings: Eto.Forms.BindingCollection;

			/**
			 * Gets a value indicating that the {@link Eto.Forms.BindableWidget.DataContext} property
			 * is changing.
			 *
			 * This can be used to determine when to allow certain logic during the update of the
			 * data context.  It is used to disable binding setters on the model when the data
			 * context changes so that a binding does not cause the view model to be updated when the
			 * state hasn't been fully set yet.
			 */
			IsDataContextChanging: boolean;

			/**
			 * Gets the platform that was used to create the {@link Eto.Widget.Handler} for this
			 * widget
			 *
			 * This gets set to the current {@link Eto.Platform.Instance} during the construction of
			 * the object
			 */
			readonly Platform: Eto.Platform;

			/** Gets the platform-specific handler for this widget */
			Handler: unknown;

			/** Gets the native platform-specific handle for integration purposes */
			readonly NativeHandle: unknown;

			/** Gets the dictionary of properties for this widget */
			readonly Properties: Eto.PropertyStore;

			/** Gets or sets the ID of this widget */
			ID: string;

			/**
			 * Gets or sets the style of this widget
			 *
			 * Styles allow you to attach custom platform-specific logic to a widget. In your
			 * platform-specific assembly, use {@link Style.Add{H}(string, StyleHandler{H})} to add
			 * the style logic with the same id.
			 */
			Style: string;

			/**
			 * Gets the instance of the platform-specific object
			 *
			 * This can sometimes be useful to get the platform-specific object. Some handlers may
			 * not have any backing object for its functionality, so this may be null.  It is more
			 * preferred to use the {@link Eto.Widget.Handler} and cast that to the platform-specific
			 * handler class which can give you additional methods and helpers to do common tasks.
			 * For example, the {@link Eto.Forms.Application} object's handler for OS X has a
			 * AddFullScreenMenuItem property to specify if you want full screen support in your app.
			 */
			readonly ControlObject: unknown;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Widget} has been disposed.
			 *
			 * When the widget is disposed, it can no longer be used.
			 */
			IsDisposed: boolean;

			/**
			 * Selects all of the text in the control.
			 *
			 * When setting the selection, the control will be focussed and the associated keyboard
			 * may appear on mobile platforms.
			 */
			SelectAll(): void;

			/**
			 * Queues a repaint of the entire control on the screen and any of its children.
			 *
			 * This is only useful when the control is visible.
			 */
			Invalidate(): void;

			/**
			 * Queues a repaint of the entire control on the screen
			 *
			 * This is only useful when the control is visible.
			 */
			Invalidate(invalidateChildren: boolean): void;

			/**
			 * Queues a repaint of the specified `rect` of the control and any children.
			 *
			 * This is only useful when the control is visible.
			 */
			Invalidate(rect: Eto.Drawing.Rectangle): void;

			/**
			 * Queues a repaint of the specified `rect` of the control
			 *
			 * This is only useful when the control is visible.
			 */
			Invalidate(
				rect: Eto.Drawing.Rectangle,
				invalidateChildren: boolean,
			): void;

			/**
			 * Updates the layout of this control if necessary.
			 *
			 * This will ensure the control has had all of its layout applied so you can use its
			 * position and size right after this call. Most platforms (except WinForms) use a
			 * deferred layout system so that after adding your control to the form dynamically it
			 * won't get laid out until the next idle loop. This is useful when you need to know the
			 * dimensions of the control immediately. Note that this can be an expensive operation,
			 * so it is recommended to only call this method when necessary and after all of the
			 * controls have been added/updated.
			 */
			UpdateLayout(): void;

			/** Gets the preferred size of this control given infinite space available. */
			GetPreferredSize(): Eto.Drawing.SizeF;

			/** Gets the preferred size of this control given the specified `availableSize`. */
			GetPreferredSize(availableSize: Eto.Drawing.SizeF): Eto.Drawing.SizeF;

			/**
			 * Captures all mouse events to this control.
			 *
			 * This captures all mouse events until {@link Eto.Forms.Control.ReleaseMouseCapture} is
			 * called.  Note that not all platforms will allow a mouse capture unless the mouse is
			 * currently down.
			 */
			CaptureMouse(): boolean;

			/** Releases the mouse capture after a call to {@link Eto.Forms.Control.CaptureMouse}. */
			ReleaseMouseCapture(): void;

			/**
			 * Finds a control in the parent hierarchy with the specified type and
			 * {@link Eto.Widget.ID} if specified
			 */
			FindParent(
				type: unknown,
				id?: string,
			): Eto.Forms.Container;

			/** Finds a control in the parent hierarchy with the specified `id` */
			FindParent(id: string): Eto.Forms.Container;

			/**
			 * Detaches the control by removing it from its parent
			 *
			 * This is essentially a shortcut to myControl.Parent.Remove(myControl);
			 */
			Detach(): void;

			/**
			 * Attaches the control for direct use in a native application
			 *
			 * Use this to use a control directly in a native application.  Note that the native
			 * application must be running the same framework as the current platform.  E.g. a
			 * WinForms application can use an Eto.Forms control when using the Eto.WinForms
			 * platform.  This prepares the control by firing the {@link Eto.Forms.Control.PreLoad},
			 * {@link Eto.Forms.Control.Load}, etc. events.
			 */
			AttachNative(): void;

			/**
			 * Detaches the control when it is used in a native application, when you want to reuse
			 * the control.
			 *
			 * This should only be called after {@link Eto.Forms.Control.AttachNative} has been
			 * called, which is usually done by calling to ToNative(true) .
			 */
			DetachNative(): void;

			/**
			 * Attempts to set the keyboard input focus to this control, or the first child that
			 * accepts focus. For Windows, this will bring it to front and activate it.
			 */
			Focus(): void;

			/**
			 * Suspends the layout of child controls
			 *
			 * This can be used to optimize some platforms while adding, removing, or changing many
			 * child controls at once. It disables the calculation of control positioning until
			 * {@link Eto.Forms.Control.ResumeLayout} is called. Each call to SuspendLayout() must be
			 * balanced with a call to {@link Eto.Forms.Control.ResumeLayout}.
			 */
			SuspendLayout(): void;

			/**
			 * Resumes the layout after it has been suspended, and performs a layout
			 *
			 * This can be used to optimize some platforms while adding, removing, or changing many
			 * child controls at once. Each call to ResumeLayout() must be balanced with a call to
			 * {@link Eto.Forms.Control.SuspendLayout} before it.
			 */
			ResumeLayout(): void;

			/**
			 * Specifies a command to execute for a platform-specific command
			 *
			 * Some platforms have specific system-defined commands that can be associated with a
			 * control. For example, the Mac platform's cut/copy/paste functionality is defined by
			 * the system, and if you want to hook into it, you can use this to map it to your own
			 * defined logic. The valid values of the `systemCommand` parameter are defined by each
			 * platform, and a list can be retrieved using
			 * {@link Eto.Forms.Control.SupportedPlatformCommands}
			 */
			MapPlatformCommand(
				systemCommand: string,
				command: Eto.Forms.Command,
			): void;

			/** Converts a point from screen space to control space. */
			PointFromScreen(point: Eto.Drawing.PointF): Eto.Drawing.PointF;

			/** Converts a point from control space to screen space */
			PointToScreen(point: Eto.Drawing.PointF): Eto.Drawing.PointF;

			/** Converts a rectangle from screen space to control space. */
			RectangleToScreen(rect: Eto.Drawing.RectangleF): Eto.Drawing.RectangleF;

			/** Converts a rectangle from control space to screen space */
			RectangleFromScreen(rect: Eto.Drawing.RectangleF): Eto.Drawing.RectangleF;

			/**
			 * Starts drag operation using this control as drag source.
			 *
			 * This method can be blocking on some platforms (Wpf, WinForms), and non-blocking on
			 * others (Mac, Gtk). Use the {@link Eto.Forms.Control.DragEnd} event to determine when
			 * the drag operation is completed and get its resulting DragEffects.
			 */
			DoDragDrop(
				data: Eto.Forms.DataObject,
				allowedEffects: Eto.Forms.DragEffects,
			): void;

			/**
			 * Starts drag operation using this control as drag source.
			 *
			 * This method can be blocking on some platforms (Wpf, WinForms), and non-blocking on
			 * others (Mac, Gtk). Use the {@link Eto.Forms.Control.DragEnd} event to determine when
			 * the drag operation is completed and get its resulting DragEffects.
			 */
			DoDragDrop(
				data: Eto.Forms.DataObject,
				allowedEffects: Eto.Forms.DragEffects,
				image: Eto.Drawing.Image,
				cursorOffset: Eto.Drawing.PointF,
			): void;

			/**
			 * Triggers the StyleChanged event and re-applies the styles to this control and its
			 * children.
			 */
			TriggerStyleChanged(): void;

			/** Shows a print dialog to print the specified control */
			Print(): void;

			/**
			 * Finds a control in the parent hierarchy with the specified type and
			 * {@link Eto.Widget.ID} if specified
			 */
			FindParent<T>(id?: string): T;

			/**
			 * Finds a control in the parent hierarchy with the specified type and
			 * {@link Eto.Widget.ID} if specified
			 */
			FindParent(
				type: unknown,
				id?: string,
			): Eto.Widget;

			/** Finds a control in the parent hierarchy with the specified `id` */
			FindParent(id: string): Eto.Widget;

			/**
			 * Unbinds any bindings in the {@link Eto.Forms.BindableWidget.Bindings} collection and
			 * removes the bindings
			 *
			 * When you implement {@link Eto.Forms.IBindableWidgetContainer}, this will also unbind
			 * any of its children.
			 */
			Unbind(): void;

			/**
			 * Updates all bindings in this widget
			 *
			 * When you implement {@link Eto.Forms.IBindableWidgetContainer}, this will also update
			 * bindings for all of its children.
			 */
			UpdateBindings(mode?: Eto.Forms.BindingUpdateMode): void;

			/** Disposes of this widget, supressing the finalizer */
			dispose(): void;

			/** Gets a string that represents the current object with its ID if specified. */
			ToString(): string;
		}
	}

	export namespace Eto.Forms.TextStepper {
		export interface ICallback extends
			Eto.Forms.TextBox.ICallback,
			Eto.Forms.TextControl.ICallback,
			Eto.Forms.Control.ICallback,
			Eto.Widget.ICallback {
			OnStep(
				widget: Eto.Forms.TextStepper,
				e: Eto.Forms.StepperEventArgs,
			): void;
		}
	}

	export namespace Eto.Forms.TextStepper {
		export interface IHandler extends
			Eto.Forms.TextBox.IHandler,
			Eto.Forms.TextControl.IHandler,
			Eto.Forms.CommonControl.IHandler,
			Eto.Forms.Control.IHandler,
			Eto.Widget.IHandler {
			ValidDirection: Eto.Forms.StepperValidDirections;

			ShowStepper: boolean;
		}
	}

	export namespace Eto.Forms {
		/**
		 * [Generic type factory] Base class for implementing Eto Container control handlers
		 * using Eto controls.
		 */
		export function ThemedContainerHandler$(TControl: IType, TWidget: IType, TCallback: IType): typeof ThemedContainerHandler$3<any, any, any>;

		/** Base class for implementing Eto Container control handlers using Eto controls. */
		export class ThemedContainerHandler$3<TControl, TWidget, TCallback> implements
			Eto.Widget.IHandler,
			Eto.Forms.Control.IHandler,
			Eto.Forms.Container.IHandler {
			/** Gets or sets the size of the client. */
			ClientSize: Eto.Drawing.Size;

			/**
			 * Gets a value indicating whether PreLoad/Load/LoadComplete/Unload events are propegated
			 * to the children controls
			 *
			 * This is mainly used when you want to use Eto controls in your handler, such as with
			 * the {@link Eto.Forms.ThemedContainerHandler<,,>}
			 */
			readonly RecurseToChildren: boolean;

			BackgroundColor: Eto.Drawing.Color;

			readonly VisualControls: Iterable<Eto.Forms.Control>;

			readonly PropagateLoadEvents: boolean;

			Size: Eto.Drawing.Size;

			Width: number;

			Height: number;

			Enabled: boolean;

			readonly HasFocus: boolean;

			Visible: boolean;

			readonly SupportedPlatformCommands: Iterable<string>;

			readonly Location: Eto.Drawing.Point;

			ToolTip: string;

			Cursor: Eto.Forms.Cursor;

			readonly ControlObject: unknown;

			TabIndex: number;

			AllowDrop: boolean;

			readonly IsMouseCaptured: boolean;

			readonly Callback: TCallback;

			Control: TControl;

			readonly HasControl: boolean;

			readonly Widget: TWidget;

			ID: string;

			readonly NativeHandle: unknown;

			GetPreferredSize(availableSize: Eto.Drawing.SizeF): Eto.Drawing.SizeF;

			Invalidate(invalidateChildren: boolean): void;

			Invalidate(
				rect: Eto.Drawing.Rectangle,
				invalidateChildren: boolean,
			): void;

			SuspendLayout(): void;

			ResumeLayout(): void;

			Focus(): void;

			OnPreLoad(e: unknown): void;

			OnLoad(e: unknown): void;

			OnLoadComplete(e: unknown): void;

			OnUnLoad(e: unknown): void;

			SetParent(
				oldParent: Eto.Forms.Container,
				newParent: Eto.Forms.Container,
			): void;

			PointFromScreen(point: Eto.Drawing.PointF): Eto.Drawing.PointF;

			PointToScreen(point: Eto.Drawing.PointF): Eto.Drawing.PointF;

			MapPlatformCommand(
				systemAction: string,
				action: Eto.Forms.Command,
			): void;

			DoDragDrop(
				data: Eto.Forms.DataObject,
				allowedAction: Eto.Forms.DragEffects,
				image: Eto.Drawing.Image,
				cursorOffset: Eto.Drawing.PointF,
			): void;

			AttachEvent(id: string): void;

			GetNativeParentWindow(): Eto.Forms.Window;

			Print(): void;

			UpdateLayout(): void;

			CaptureMouse(): boolean;

			ReleaseMouseCapture(): void;

			IsEventHandled(id: string): boolean;

			HandleEvent(
				id: string,
				defaultEvent?: boolean,
			): void;

			dispose(): void;
		}
	}

	export namespace Eto.Forms {
		/**
		 * [Generic type factory] Base class for implementing Eto control handlers using other
		 * Eto controls.
		 *
		 * This allows a single implementation to be used in multiple platforms and is useful in
		 * a couple of scenarios:  a) Creating default implementations of a control on platforms
		 * that do not support the control natively. b) Implementing a control with a non-native
		 * look and feel that is consistent across platforms.
		 */
		export function ThemedControlHandler$(TControl: IType, TWidget: IType, TCallback: IType): typeof ThemedControlHandler$3<any, any, any>;

		/**
		 * Base class for implementing Eto control handlers using other Eto controls.
		 *
		 * This allows a single implementation to be used in multiple platforms and is useful in
		 * a couple of scenarios:  a) Creating default implementations of a control on platforms
		 * that do not support the control natively. b) Implementing a control with a non-native
		 * look and feel that is consistent across platforms.
		 */
		export class ThemedControlHandler$3<TControl, TWidget, TCallback> implements
			Eto.Widget.IHandler,
			Eto.Forms.Control.IHandler {
			new(): ThemedControlHandler$3<TControl, TWidget, TCallback>;

			/**
			 * Gets or sets the color for the background of the control
			 *
			 * Note that on some platforms (e.g. Mac), setting the background color of a control can
			 * change the performance characteristics of the control and its children, since it must
			 * enable layers to do so.
			 */
			BackgroundColor: Eto.Drawing.Color;

			/**
			 * Gets an enumeration of controls that are in the visual tree.
			 *
			 * This is used to specify which controls are contained by this instance that are part of
			 * the visual tree. This should include all controls including non-logical Eto controls
			 * used for layout.
			 */
			readonly VisualControls: Iterable<Eto.Forms.Control>;

			/**
			 * Gets a value indicating whether {@link Eto.Forms.Control.PreLoad} /
			 * {@link Eto.Forms.Control.Load} / {@link Eto.Forms.Control.LoadComplete} /
			 * {@link Eto.Forms.Control.UnLoad} events are propagated to the inner control
			 *
			 * Typically this should be true so that the events are propagated, but when you set the
			 * control hierarchy  manually, such as a {@link Eto.Forms.TabPage} on a
			 * {@link Eto.Forms.TabControl}, you can return false here since the load events will be
			 * handled automatically by the internal eto controls.
			 */
			readonly PropagateLoadEvents: boolean;

			/**
			 * Gets or sets the size of the control. Use -1 to specify auto sizing for either the
			 * width and/or height.
			 */
			Size: Eto.Drawing.Size;

			/** Gets or sets the width of the control size. */
			Width: number;

			/** Gets or sets the height of the control size. */
			Height: number;

			/** Gets or sets a value indicating whether this control is enabled */
			Enabled: boolean;

			/** Gets a value indicating whether this instance has the keyboard input focus. */
			readonly HasFocus: boolean;

			/**
			 * Gets or sets a value indicating whether this control is visible to the user.
			 *
			 * When the visibility of a control is set to false, it will still occupy space in the
			 * layout, but not be shown. The only exception is for controls like the
			 * {@link Eto.Forms.Splitter}, which will hide a pane if the visibility of one of the
			 * panels is changed.
			 */
			Visible: boolean;

			/**
			 * Gets the supported platform commands that can be used to hook up system functions to
			 * user defined logic
			 */
			readonly SupportedPlatformCommands: Iterable<string>;

			/**
			 * Gets the location of the control as positioned by the container
			 *
			 * A control's location is set by the container. This can be used to determine where the
			 * control is for overlaying floating windows, menus, etc.
			 */
			readonly Location: Eto.Drawing.Point;

			/** Gets or sets the tool tip to show when the mouse is hovered over the control */
			ToolTip: string;

			/** Gets or sets the type of cursor to use when the mouse is hovering over the control */
			Cursor: Eto.Forms.Cursor;

			/** Gets the instance of the platform-specific object */
			readonly ControlObject: unknown;

			/**
			 * Gets or sets the tab index order for this control within its container.
			 *
			 * This sets the order when using the tab key to cycle through controls  Note that some
			 * platforms (Gtk and WinForms) may not support setting the context of the tab order to
			 * StackLayout  or DynamicLayout containers and may not behave exactly as expected. Use
			 * the {@link Eto.PlatformFeatures.TabIndexWithCustomContainers} flag to determine if it
			 * is supported.
			 */
			TabIndex: number;

			/** Gets or sets a value indicating whether this control can serve as drop target. */
			AllowDrop: boolean;

			readonly IsMouseCaptured: boolean;

			readonly Callback: TCallback;

			Control: TControl;

			readonly HasControl: boolean;

			readonly Widget: TWidget;

			ID: string;

			readonly NativeHandle: unknown;

			/** Gets the preferred size of this control given the specified `availableSize`. */
			GetPreferredSize(availableSize: Eto.Drawing.SizeF): Eto.Drawing.SizeF;

			/**
			 * Queues a repaint of the entire control on the screen
			 *
			 * This is only useful when the control is visible.
			 */
			Invalidate(invalidateChildren: boolean): void;

			/**
			 * Queues a repaint of the specified `rect` of the control
			 *
			 * This is only useful when the control is visible.
			 */
			Invalidate(
				rect: Eto.Drawing.Rectangle,
				invalidateChildren: boolean,
			): void;

			/**
			 * Suspends the layout of child controls
			 *
			 * This can be used to optimize some platforms while adding, removing, or changing many
			 * child controls at once. It disables the calculation of control positioning until
			 * {@link Eto.Forms.ThemedControlHandler`3.ResumeLayout} is called. Each call to
			 * SuspendLayout() must be balanced with a call to
			 * {@link Eto.Forms.ThemedControlHandler`3.ResumeLayout}.
			 */
			SuspendLayout(): void;

			/**
			 * Resumes the layout after it has been suspended, and performs a layout
			 *
			 * This can be used to optimize some platforms while adding, removing, or changing many
			 * child controls at once. Each call to ResumeLayout() must be balanced with a call to
			 * {@link Eto.Forms.ThemedControlHandler`3.SuspendLayout} before it.
			 */
			ResumeLayout(): void;

			/**
			 * Attempts to set the keyboard input focus to this control, or the first child that
			 * accepts focus
			 */
			Focus(): void;

			/** Called before the control is loaded on a form */
			OnPreLoad(e: unknown): void;

			/** Called when the control is loaded on a form */
			OnLoad(e: unknown): void;

			/** Called after all other controls have been loaded */
			OnLoadComplete(e: unknown): void;

			/**
			 * Called when the control is unloaded, which is when it is not currently on a displayed
			 * window
			 */
			OnUnLoad(e: unknown): void;

			/** Called when the parent of the control has been set */
			SetParent(
				oldParent: Eto.Forms.Container,
				newParent: Eto.Forms.Container,
			): void;

			/** Converts a point from screen space to control space. */
			PointFromScreen(point: Eto.Drawing.PointF): Eto.Drawing.PointF;

			/** Converts a point from control space to screen space */
			PointToScreen(point: Eto.Drawing.PointF): Eto.Drawing.PointF;

			/** Specifies a command to execute for a platform-specific command */
			MapPlatformCommand(
				systemAction: string,
				action: Eto.Forms.Command,
			): void;

			/** Starts drag operation using this control as drag source. */
			DoDragDrop(
				data: Eto.Forms.DataObject,
				allowedAction: Eto.Forms.DragEffects,
				image: Eto.Drawing.Image,
				cursorOffset: Eto.Drawing.PointF,
			): void;

			/**
			 * Attaches the specified event to the platform-specific control
			 *
			 * Implementors should override this method to handle any events that the widget
			 * supports. Ensure to call the base class' implementation if the event is not one the
			 * specific widget supports, so the base class' events can be handled as well.
			 */
			AttachEvent(id: string): void;

			/** Gets the window this control is contained in */
			GetNativeParentWindow(): Eto.Forms.Window;

			Print(): void;

			UpdateLayout(): void;

			CaptureMouse(): boolean;

			ReleaseMouseCapture(): void;

			IsEventHandled(id: string): boolean;

			HandleEvent(
				id: string,
				defaultEvent?: boolean,
			): void;

			dispose(): void;
		}
	}

	export namespace Eto.Forms {
		/**
		 * Specialized Button that can be toggled on or off.
		 *
		 * This is similar to the {@link Eto.Forms.CheckBox} but appears depressed or highlighted
		 * when "checked".
		 */
		export class ToggleButton implements
			Eto.IHandlerSource,
			Eto.Forms.IBindable,
			Eto.Forms.IMouseInputSource,
			Eto.Forms.IKeyboardInputSource {
			constructor();

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Forms.ToggleButton} is
			 * checked.
			 */
			Checked: boolean;

			/**
			 * Gets or sets the command to invoke when the button is pressed.
			 *
			 * This will invoke the specified command when the button is pressed. The
			 * {@link System.Windows.Input.ICommand.CanExecute(System.Object)} will also be used to
			 * set the {@link Eto.Forms.Control.Enabled} state of the button.
			 */
			Command: unknown;

			/**
			 * Gets or sets the parameter to pass to the {@link Eto.Forms.Button.Command} when
			 * executing or determining its
			 * {@link System.Windows.Input.ICommand.CanExecute(System.Object)} state.
			 */
			CommandParameter: unknown;

			/** Gets or sets the image to display on the button. */
			Image: Eto.Drawing.Image;

			/** Gets or sets the position of the image relative to the text. */
			ImagePosition: Eto.Forms.ButtonImagePosition;

			/**
			 * Gets or sets the minimum size for the button.
			 *
			 * Each platform may have a different initial minimum size set for buttons to match their
			 * standard sizes.  Setting this to {@link Eto.Drawing.Size.Empty} is useful when you
			 * want the button to shrink to fit the size of the specified
			 * {@link Eto.Forms.Button.Image} and/or {@link Eto.Forms.TextControl.Text}.
			 */
			MinimumSize: Eto.Drawing.Size;

			/**
			 * Gets or sets the size of the control. Use -1 to specify auto sizing for either the
			 * width and/or height.
			 */
			Size: Eto.Drawing.Size;

			/** Gets or sets the width of the control size. */
			Width: number;

			/** Gets or sets the height of the control size. */
			Height: number;

			/**
			 * Gets or sets the text of the control.
			 *
			 * Usually, the caret and selection will be set to the end of the string after its set.
			 */
			Text: string;

			/**
			 * Gets or sets the color of the text.
			 *
			 * By default, the text will get a color based on the user's theme. However, this is
			 * usually black.
			 */
			TextColor: Eto.Drawing.Color;

			/** Gets the binding for the {@link Eto.Forms.TextControl.Text} property. */
			readonly TextBinding: Eto.Forms.BindableBinding$2<Eto.Forms.TextControl, string>;

			/** Gets or sets the font for the text of the control */
			Font: Eto.Drawing.Font;

			/**
			 * Gets a value indicating that the control is loaded onto a form, that is it has been
			 * created, added to a parent, and shown
			 *
			 * The {@link Eto.Forms.Control.OnLoad(System.EventArgs)} method sets this value to true
			 * after cascading to all children (for a {@link Eto.Forms.Container} ) and calling the
			 * platform handler's implementation.  It is called after adding to a loaded form, or
			 * when showing a new form.  The {@link Eto.Forms.Control.OnUnLoad(System.EventArgs)}
			 * method will set this value to false when the control is removed from its parent
			 */
			readonly Loaded: boolean;

			/**
			 * Gets an enumeration of controls that are in the visual tree.
			 *
			 * This is used to specify which controls are contained by this instance that are part of
			 * the visual tree. This should include all controls including non-logical Eto controls
			 * used for layout.
			 */
			readonly VisualControls: Iterable<Eto.Forms.Control>;

			/**
			 * Gets or sets a user-defined object that contains data about the control
			 *
			 * A common use of the tag property is to store data that is associated with the control
			 * that you can later retrieve.
			 */
			Tag: unknown;

			/**
			 * Gets the logical parent control.
			 *
			 * When the control is part of the visual tree (
				 * {@link Eto.Forms.Control.IsVisualControl} is true), this returns the logical parent
				 * that contains this control. Otherwise this is the same as
				 * {@link Eto.Forms.Control.Parent}.
				 */
				readonly LogicalParent: Eto.Forms.Container;

			/** Gets a value indicating this {@link Eto.Forms.Control} is part of the visual tree. */
			IsVisualControl: boolean;

			/**
			 * Gets a value indicating this control currently has mouse capture
			 *
			 * Mouse capture can happen during a handled MouseDown event until MouseUp, or it can be
			 * captured explicitly via {@link Eto.Forms.Control.CaptureMouse}.
			 */
			readonly IsMouseCaptured: boolean;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Forms.Control} (or its
			 * children) are enabled and accept user input.
			 *
			 * Typically when a control is disabled, the user cannot do anything with the control or
			 * any of its children. Including for example, selecting text in a text control. Certain
			 * controls can have a 'Read Only' mode, such as {@link Eto.Forms.TextBox.ReadOnly} which
			 * allow the user to  select text, but not change its contents.
			 */
			Enabled: boolean;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Forms.Control} is visible to
			 * the user.
			 *
			 * When the visibility of a control is set to false, it will not occupy space in the
			 * layout.
			 */
			Visible: boolean;

			/** Gets the container which this control has been added to, if any */
			readonly Parent: Eto.Forms.Container;

			/**
			 * Gets the visual container of this control, if any.
			 *
			 * Some containers may use other Eto controls to layout its children, such as the
			 * {@link Eto.Forms.StackLayout}. This will return the parent control that visually
			 * contains this control as opposed to {@link Eto.Forms.Control.Parent} which will return
			 * the logical parent.
			 */
			VisualParent: Eto.Forms.Container;

			/** Gets a value indicating this control has been attached to a native container */
			readonly IsAttached: boolean;

			/**
			 * Gets or sets the color for the background of the control
			 *
			 * Note that on some platforms (e.g. Mac), setting the background color of a control can
			 * change the performance characteristics of the control and its children, since it must
			 * enable layers to do so.
			 */
			BackgroundColor: Eto.Drawing.Color;

			/** Gets a value indicating whether this instance has the keyboard input focus. */
			readonly HasFocus: boolean;

			/** Gets a value indicating whether the layout of child controls is suspended. */
			readonly IsSuspended: boolean;

			/** Gets the window this control is contained in */
			readonly ParentWindow: Eto.Forms.Window;

			/**
			 * Gets the supported platform commands that can be used to hook up system functions to
			 * user defined logic
			 *
			 * This lists all available commands that can be mapped using the
			 * {@link Eto.Forms.Control.MapPlatformCommand(System.String,Eto.Forms.Command)} method
			 * of the control.
			 */
			readonly SupportedPlatformCommands: Iterable<string>;

			/** Gets the bounding rectangle of this control relative to its container */
			readonly Bounds: Eto.Drawing.Rectangle;

			/**
			 * Gets the location of the control as positioned by the container
			 *
			 * A control's location is set by the container. This can be used to determine where the
			 * control is for overlaying floating windows, menus, etc.
			 */
			readonly Location: Eto.Drawing.Point;

			/** Gets or sets the type of cursor to use when the mouse is hovering over the control */
			Cursor: Eto.Forms.Cursor;

			/** Gets or sets the tool tip to show when the mouse is hovered over the control */
			ToolTip: string;

			/**
			 * Gets or sets the tab index order for this control within its container.
			 *
			 * This sets the order when using the tab key to cycle through controls  Note that some
			 * platforms (Gtk and WinForms) may not support setting the context of the tab order to
			 * StackLayout  or DynamicLayout containers and may not behave exactly as expected. Use
			 * the {@link Eto.PlatformFeatures.TabIndexWithCustomContainers} flag to determine if it
			 * is supported.
			 */
			TabIndex: number;

			/** Gets or sets a value indicating whether this control can serve as drop target. */
			AllowDrop: boolean;

			/**
			 * Gets or sets the parent widget which this widget has been added to, if any
			 *
			 * When implementing child widgets that can participate in the context based binding
			 * (MVVM), You can set this to the parent widget when it is added or removed to it
			 * (usually via a collection).  Note that you should typically provide a public new
			 * [ParentWidget] Parent { get; } property  so that consumers of your API cannot set the
			 * parent to an invalid value.
			 */
			Parent: Eto.Widget;

			/**
			 * Gets an enumeration of all parent widgets in the heirarchy by traversing the
			 * {@link Eto.Forms.BindableWidget.Parent} property.
			 */
			readonly Parents: Iterable<Eto.Widget>;

			/**
			 * Gets or sets the data context for this widget for binding
			 *
			 * Subclasses may override the standard behaviour so that hierarchy of widgets can be
			 * taken into account.  For example, a Control may return the data context of a parent,
			 * if it is not set explicitly.
			 */
			DataContext: unknown;

			/** Gets the collection of bindings that are attached to this widget */
			readonly Bindings: Eto.Forms.BindingCollection;

			/**
			 * Gets a value indicating that the {@link Eto.Forms.BindableWidget.DataContext} property
			 * is changing.
			 *
			 * This can be used to determine when to allow certain logic during the update of the
			 * data context.  It is used to disable binding setters on the model when the data
			 * context changes so that a binding does not cause the view model to be updated when the
			 * state hasn't been fully set yet.
			 */
			IsDataContextChanging: boolean;

			/**
			 * Gets the platform that was used to create the {@link Eto.Widget.Handler} for this
			 * widget
			 *
			 * This gets set to the current {@link Eto.Platform.Instance} during the construction of
			 * the object
			 */
			readonly Platform: Eto.Platform;

			/** Gets the platform-specific handler for this widget */
			Handler: unknown;

			/** Gets the native platform-specific handle for integration purposes */
			readonly NativeHandle: unknown;

			/** Gets the dictionary of properties for this widget */
			readonly Properties: Eto.PropertyStore;

			/** Gets or sets the ID of this widget */
			ID: string;

			/**
			 * Gets or sets the style of this widget
			 *
			 * Styles allow you to attach custom platform-specific logic to a widget. In your
			 * platform-specific assembly, use {@link Style.Add{H}(string, StyleHandler{H})} to add
			 * the style logic with the same id.
			 */
			Style: string;

			/**
			 * Gets the instance of the platform-specific object
			 *
			 * This can sometimes be useful to get the platform-specific object. Some handlers may
			 * not have any backing object for its functionality, so this may be null.  It is more
			 * preferred to use the {@link Eto.Widget.Handler} and cast that to the platform-specific
			 * handler class which can give you additional methods and helpers to do common tasks.
			 * For example, the {@link Eto.Forms.Application} object's handler for OS X has a
			 * AddFullScreenMenuItem property to specify if you want full screen support in your app.
			 */
			readonly ControlObject: unknown;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Widget} has been disposed.
			 *
			 * When the widget is disposed, it can no longer be used.
			 */
			IsDisposed: boolean;

			/**
			 * Clicks the toggle button programatically, raising the same events and toggling the
			 * Checked state if Enabled and Visible.
			 */
			PerformClick(): void;

			/**
			 * Queues a repaint of the entire control on the screen and any of its children.
			 *
			 * This is only useful when the control is visible.
			 */
			Invalidate(): void;

			/**
			 * Queues a repaint of the entire control on the screen
			 *
			 * This is only useful when the control is visible.
			 */
			Invalidate(invalidateChildren: boolean): void;

			/**
			 * Queues a repaint of the specified `rect` of the control and any children.
			 *
			 * This is only useful when the control is visible.
			 */
			Invalidate(rect: Eto.Drawing.Rectangle): void;

			/**
			 * Queues a repaint of the specified `rect` of the control
			 *
			 * This is only useful when the control is visible.
			 */
			Invalidate(
				rect: Eto.Drawing.Rectangle,
				invalidateChildren: boolean,
			): void;

			/**
			 * Updates the layout of this control if necessary.
			 *
			 * This will ensure the control has had all of its layout applied so you can use its
			 * position and size right after this call. Most platforms (except WinForms) use a
			 * deferred layout system so that after adding your control to the form dynamically it
			 * won't get laid out until the next idle loop. This is useful when you need to know the
			 * dimensions of the control immediately. Note that this can be an expensive operation,
			 * so it is recommended to only call this method when necessary and after all of the
			 * controls have been added/updated.
			 */
			UpdateLayout(): void;

			/** Gets the preferred size of this control given infinite space available. */
			GetPreferredSize(): Eto.Drawing.SizeF;

			/** Gets the preferred size of this control given the specified `availableSize`. */
			GetPreferredSize(availableSize: Eto.Drawing.SizeF): Eto.Drawing.SizeF;

			/**
			 * Captures all mouse events to this control.
			 *
			 * This captures all mouse events until {@link Eto.Forms.Control.ReleaseMouseCapture} is
			 * called.  Note that not all platforms will allow a mouse capture unless the mouse is
			 * currently down.
			 */
			CaptureMouse(): boolean;

			/** Releases the mouse capture after a call to {@link Eto.Forms.Control.CaptureMouse}. */
			ReleaseMouseCapture(): void;

			/**
			 * Finds a control in the parent hierarchy with the specified type and
			 * {@link Eto.Widget.ID} if specified
			 */
			FindParent(
				type: unknown,
				id?: string,
			): Eto.Forms.Container;

			/** Finds a control in the parent hierarchy with the specified `id` */
			FindParent(id: string): Eto.Forms.Container;

			/**
			 * Detaches the control by removing it from its parent
			 *
			 * This is essentially a shortcut to myControl.Parent.Remove(myControl);
			 */
			Detach(): void;

			/**
			 * Attaches the control for direct use in a native application
			 *
			 * Use this to use a control directly in a native application.  Note that the native
			 * application must be running the same framework as the current platform.  E.g. a
			 * WinForms application can use an Eto.Forms control when using the Eto.WinForms
			 * platform.  This prepares the control by firing the {@link Eto.Forms.Control.PreLoad},
			 * {@link Eto.Forms.Control.Load}, etc. events.
			 */
			AttachNative(): void;

			/**
			 * Detaches the control when it is used in a native application, when you want to reuse
			 * the control.
			 *
			 * This should only be called after {@link Eto.Forms.Control.AttachNative} has been
			 * called, which is usually done by calling to ToNative(true) .
			 */
			DetachNative(): void;

			/**
			 * Attempts to set the keyboard input focus to this control, or the first child that
			 * accepts focus. For Windows, this will bring it to front and activate it.
			 */
			Focus(): void;

			/**
			 * Suspends the layout of child controls
			 *
			 * This can be used to optimize some platforms while adding, removing, or changing many
			 * child controls at once. It disables the calculation of control positioning until
			 * {@link Eto.Forms.Control.ResumeLayout} is called. Each call to SuspendLayout() must be
			 * balanced with a call to {@link Eto.Forms.Control.ResumeLayout}.
			 */
			SuspendLayout(): void;

			/**
			 * Resumes the layout after it has been suspended, and performs a layout
			 *
			 * This can be used to optimize some platforms while adding, removing, or changing many
			 * child controls at once. Each call to ResumeLayout() must be balanced with a call to
			 * {@link Eto.Forms.Control.SuspendLayout} before it.
			 */
			ResumeLayout(): void;

			/**
			 * Specifies a command to execute for a platform-specific command
			 *
			 * Some platforms have specific system-defined commands that can be associated with a
			 * control. For example, the Mac platform's cut/copy/paste functionality is defined by
			 * the system, and if you want to hook into it, you can use this to map it to your own
			 * defined logic. The valid values of the `systemCommand` parameter are defined by each
			 * platform, and a list can be retrieved using
			 * {@link Eto.Forms.Control.SupportedPlatformCommands}
			 */
			MapPlatformCommand(
				systemCommand: string,
				command: Eto.Forms.Command,
			): void;

			/** Converts a point from screen space to control space. */
			PointFromScreen(point: Eto.Drawing.PointF): Eto.Drawing.PointF;

			/** Converts a point from control space to screen space */
			PointToScreen(point: Eto.Drawing.PointF): Eto.Drawing.PointF;

			/** Converts a rectangle from screen space to control space. */
			RectangleToScreen(rect: Eto.Drawing.RectangleF): Eto.Drawing.RectangleF;

			/** Converts a rectangle from control space to screen space */
			RectangleFromScreen(rect: Eto.Drawing.RectangleF): Eto.Drawing.RectangleF;

			/**
			 * Starts drag operation using this control as drag source.
			 *
			 * This method can be blocking on some platforms (Wpf, WinForms), and non-blocking on
			 * others (Mac, Gtk). Use the {@link Eto.Forms.Control.DragEnd} event to determine when
			 * the drag operation is completed and get its resulting DragEffects.
			 */
			DoDragDrop(
				data: Eto.Forms.DataObject,
				allowedEffects: Eto.Forms.DragEffects,
			): void;

			/**
			 * Starts drag operation using this control as drag source.
			 *
			 * This method can be blocking on some platforms (Wpf, WinForms), and non-blocking on
			 * others (Mac, Gtk). Use the {@link Eto.Forms.Control.DragEnd} event to determine when
			 * the drag operation is completed and get its resulting DragEffects.
			 */
			DoDragDrop(
				data: Eto.Forms.DataObject,
				allowedEffects: Eto.Forms.DragEffects,
				image: Eto.Drawing.Image,
				cursorOffset: Eto.Drawing.PointF,
			): void;

			/**
			 * Triggers the StyleChanged event and re-applies the styles to this control and its
			 * children.
			 */
			TriggerStyleChanged(): void;

			/** Shows a print dialog to print the specified control */
			Print(): void;

			/**
			 * Finds a control in the parent hierarchy with the specified type and
			 * {@link Eto.Widget.ID} if specified
			 */
			FindParent<T>(id?: string): T;

			/**
			 * Finds a control in the parent hierarchy with the specified type and
			 * {@link Eto.Widget.ID} if specified
			 */
			FindParent(
				type: unknown,
				id?: string,
			): Eto.Widget;

			/** Finds a control in the parent hierarchy with the specified `id` */
			FindParent(id: string): Eto.Widget;

			/**
			 * Unbinds any bindings in the {@link Eto.Forms.BindableWidget.Bindings} collection and
			 * removes the bindings
			 *
			 * When you implement {@link Eto.Forms.IBindableWidgetContainer}, this will also unbind
			 * any of its children.
			 */
			Unbind(): void;

			/**
			 * Updates all bindings in this widget
			 *
			 * When you implement {@link Eto.Forms.IBindableWidgetContainer}, this will also update
			 * bindings for all of its children.
			 */
			UpdateBindings(mode?: Eto.Forms.BindingUpdateMode): void;

			/** Disposes of this widget, supressing the finalizer */
			dispose(): void;

			/** Gets a string that represents the current object with its ID if specified. */
			ToString(): string;
		}
	}

	export namespace Eto.Forms.ToggleButton {
		export interface ICallback extends
			Eto.Forms.Button.ICallback,
			Eto.Forms.TextControl.ICallback,
			Eto.Forms.Control.ICallback,
			Eto.Widget.ICallback {
			OnCheckedChanged(
				widget: Eto.Forms.ToggleButton,
				e: unknown,
			): void;
		}
	}

	export namespace Eto.Forms.ToggleButton {
		export interface IHandler extends
			Eto.Forms.Button.IHandler,
			Eto.Forms.TextControl.IHandler,
			Eto.Forms.CommonControl.IHandler,
			Eto.Forms.Control.IHandler,
			Eto.Widget.IHandler {
			Checked: boolean;
		}
	}

	export namespace Eto.Forms {
		/** [Generic type factory] Base tree item interface */
		export function ITreeItem$(T: IType): IType;

		/** Base tree item interface */
		export interface ITreeItem$1<T> {
			/**
			 * Gets or sets a value indicating whether this {@link Eto.Forms.ITreeItem<>} is
			 * expanded.
			 *
			 * When expanded, the children of the tree item will be shown. This will be set
			 * automatically by the {@link Eto.Forms.TreeGridView} when the item is expanded or
			 * collapsed and keep in in sync with the view.
			 */
			Expanded: boolean;

			/**
			 * Gets a value indicating whether this {@link Eto.Forms.ITreeItem<>} is expandable.
			 *
			 * When true , this will typically show a glyph that can be clicked to expand the item to
			 * show its children. When false , the glyph is not shown and the node is not expandable
			 * by the user.
			 */
			readonly Expandable: boolean;

			/** Gets or sets the parent of this item. */
			Parent: T;
		}
	}

	export namespace Eto.Forms {
		/**
		 * Interface for an item in a {@link Eto.Forms.TreeGridView}.
		 *
		 * This is the base interface for items in a tree grid.  Use this interface if you wish
		 * to use your own class for items in a tree. Otherwise, you can use the standard
		 * {@link Eto.Forms.TreeGridItem}.
		 */
		export interface ITreeGridItem extends Eto.Forms.ITreeItem$1<Eto.Forms.ITreeGridItem> {
		}
	}

	export namespace Eto.Forms {
		/**
		 * [Generic type factory] Interface for an item in a {@link Eto.Forms.TreeGridView} that
		 * implements children
		 */
		export function ITreeGridItem$(T: IType): IType;

		/** Interface for an item in a {@link Eto.Forms.TreeGridView} that implements children */
		export interface ITreeGridItem$1<T> extends
			Eto.Forms.ITreeGridItem,
			Eto.Forms.ITreeItem$1<Eto.Forms.ITreeGridItem>,
			Eto.Forms.ITreeGridStore$1<T>,
			Eto.Forms.IDataStore$1<T> {
		}
	}

	export namespace Eto.Forms {
		/** Collection of {@link Eto.Forms.ITreeGridItem} objects for child nodes of a tree. */
		export class TreeGridItemCollection implements
			Eto.Forms.ITreeGridStore$1<Eto.Forms.ITreeGridItem>,
			Eto.Forms.IDataStore$1<Eto.Forms.ITreeGridItem> {
			/** Initializes a new instance of the {@link Eto.Forms.TreeGridItemCollection} class. */
			constructor();

			/**
			 * Initializes a new instance of the {@link Eto.Forms.TreeGridItemCollection} class with
			 * an enumeration of existing values.
			 */
			constructor(items: Iterable<Eto.Forms.ITreeGridItem>);

			Sort(comparer: unknown): void;

			Sort(comparison: unknown): void;

			AddRange(items: Iterable<Eto.Forms.ITreeGridItem>): void;
		}
	}

	export namespace Eto.Forms {
		/**
		 * Item for a {@link Eto.Forms.TreeGridView} for each node of the tree.
		 *
		 * This is the standard implementation.  You can implement
		 * {@link Eto.Forms.ITreeGridItem} with your own class to use them as nodes in the tree
		 * instead.
		 */
		export class TreeGridItem implements
			Eto.Forms.IColumnItem,
			Eto.Forms.ITreeGridItem,
			Eto.Forms.ITreeItem$1<Eto.Forms.ITreeGridItem>,
			Eto.Forms.ITreeGridStore$1<Eto.Forms.ITreeGridItem>,
			Eto.Forms.IDataStore$1<Eto.Forms.ITreeGridItem> {
			/** Initializes a new instance of the {@link Eto.Forms.TreeGridItem} class. */
			constructor();

			/**
			 * Initializes a new instance of the {@link Eto.Forms.TreeGridItem} class with the
			 * specified `values`.
			 */
			constructor(values: unknown[]);

			/**
			 * Initializes a new instance of the {@link Eto.Forms.TreeGridItem} class with the
			 * specified `children` and `values`.
			 */
			constructor(
				children: Iterable<Eto.Forms.ITreeGridItem>,
				values: unknown[],
			);

			/** Gets the collection of children for this tree grid item. */
			readonly Children: Eto.Forms.TreeGridItemCollection;

			/** Gets or sets the parent of this item. */
			Parent: Eto.Forms.ITreeGridItem;

			/** Gets a value indicating whether this {@link Eto.Forms.TreeGridItem} is expandable. */
			readonly Expandable: boolean;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Forms.TreeGridItem} is
			 * expanded.
			 */
			Expanded: boolean;

			/** Gets the number of child items. */
			readonly Count: number;

			/** Gets or sets a custom value to associate with this item. */
			Tag: unknown;

			/** Gets or sets the values of the row. */
			Values: unknown[];

			/** Gets the value from this item for the specified column/index */
			GetValue(column: number): unknown;

			/** Sets the value of this object for the specified column/index */
			SetValue(
				column: number,
				value: unknown,
			): void;
		}
	}

	export namespace Eto.Forms {
		/** [Generic type factory] Item store for the {@link Eto.Forms.TreeGridView} */
		export function ITreeGridStore$(T: IType): IType;

		/** Item store for the {@link Eto.Forms.TreeGridView} */
		export interface ITreeGridStore$1<T> extends Eto.Forms.IDataStore$1<T> {
		}
	}

	export namespace Eto.Forms {
		/** Event arguments for {@link Eto.Forms.TreeGridView} events */
		export class TreeGridViewItemEventArgs {
			/**
			 * Initializes a new instance of the {@link Eto.Forms.TreeGridViewItemEventArgs} class.
			 */
			constructor(item: Eto.Forms.ITreeGridItem);

			/** Gets the item that triggered the event. */
			Item: Eto.Forms.ITreeGridItem;
		}
	}

	export namespace Eto.Forms {
		/** Event arguments for {@link Eto.Forms.TreeGridView} events that can be cancelled */
		export class TreeGridViewItemCancelEventArgs {
			/**
			 * Initializes a new instance of the {@link Eto.Forms.TreeGridViewItemCancelEventArgs}
			 * class.
			 */
			constructor(item: Eto.Forms.ITreeGridItem);

			/** Gets the item that triggered the event. */
			Item: Eto.Forms.ITreeGridItem;
		}
	}

	export namespace Eto.Forms {
		/** Enumeration of the types of grid cells */
		export enum GridCellType {
			/** Empty part of the grid */
			None = 0,

			/** Cell containing the data, that is when the row and column are a valid value. */
			Data = 1,

			/** Column header */
			ColumnHeader = 2,
		}
	}

	export namespace Eto.Forms {
		/** Information of a cell in the {@link Eto.Forms.TreeGridView} */
		export class TreeGridCell {
			/** Initializes a new instance of the TreeGridCell class */
			constructor(
				column: Eto.Forms.GridColumn,
				columnIndex: number,
				type: Eto.Forms.GridCellType,
				item: unknown,
			);

			/** Gets the item associated with the row of the cell, or null if there is no item. */
			readonly Item: unknown;

			/**
			 * Gets the column of the cell, or null if there is no column at the specified location.
			 */
			readonly Column: Eto.Forms.GridColumn;

			/**
			 * Gets the index of the column, or -1 if there is no column at the specified location.
			 */
			readonly ColumnIndex: number;

			/** Gets the type of the cell */
			readonly Type: Eto.Forms.GridCellType;
		}
	}

	export namespace Eto.Forms {
		/** Enumeration of the drag position relative to a node or item in a Grid. */
		export enum GridDragPosition {
			/** The user is dragging overtop an existing node or item. */
			Over = 0,

			/** The user is dragging to insert before a node or item. */
			Before = 1,

			/** The user is dragging to insert after a node or item. */
			After = 2,
		}
	}

	export namespace Eto.Forms {
		/**
		 * Extra drag information when dragging to a {@link Eto.Forms.TreeGridView}.
		 *
		 * Use this information to determine where the user is dragging to, and also to change
		 * where the drag indicator will be shown by modifying the Item and ChildIndex
		 * properties.
		 */
		export class TreeGridViewDragInfo {
			/** Initializes a new instance of the {@link Eto.Forms.TreeGridDragInfo} class. */
			constructor(
				control: Eto.Forms.TreeGridView,
				parent: unknown,
				item: unknown,
				childIndex: number | undefined,
				position: Eto.Forms.GridDragPosition,
			);

			/**
			 * Gets or sets the parent node of the {@link Eto.Forms.TreeGridViewDragInfo.Item} to
			 * drag to.
			 *
			 * Normally you would only need to set {@link Eto.Forms.TreeGridViewDragInfo.Item} to
			 * specify which node to drag to.  However, in the case of dragging to below the Parent
			 * as inserting a first child you would set Parent to the node,
			 * {@link Eto.Forms.TreeGridViewDragInfo.Item} to null, and
			 * {@link Eto.Forms.TreeGridViewDragInfo.Position} to
			 * {@link Eto.Forms.GridDragPosition.After}.
			 */
			Parent: unknown;

			/**
			 * Gets the index of the {@link Eto.Forms.TreeGridViewDragInfo.Item} relative to the
			 * {@link Eto.Forms.TreeGridViewDragInfo.Parent}.
			 */
			readonly ChildIndex: number;

			/**
			 * Gets or sets the insertion index where the user is dragging to as a child of Item, or
			 * -1 if dragging over the Item.
			 *
			 * This is useful if the user is dragging between existing items, or the beginning or end
			 * of a child list.
			 */
			readonly InsertIndex: number;

			/**
			 * Gets a value indicating whether the drop should insert before, after, or over the
			 * {@link Eto.Forms.TreeGridViewDragInfo.Item}.
			 *
			 * When this is Before or After, you can use the
			 * {@link Eto.Forms.TreeGridViewDragInfo.InsertIndex} to determine what index to insert
			 * the  item as a child of the {@link Eto.Forms.TreeGridViewDragInfo.Parent} node.
			 */
			Position: Eto.Forms.GridDragPosition;

			/** Gets the parent tree control this info is for. */
			readonly Control: Eto.Forms.TreeGridView;

			/**
			 * Gets a value indicating whether this {@link Eto.Forms.TreeGridDragInfo} is changed.
			 *
			 * This will return true if the {@link Eto.Forms.TreeGridViewDragInfo.InsertIndex} or
			 * {@link Eto.Forms.TreeGridViewDragInfo.Parent} have been set. This is useful for
			 * platform implementations to determine if the drop target has been modified.
			 */
			IsChanged: boolean;

			/**
			 * Gets or sets the item to drag to, or null if dragging below the
			 * {@link Eto.Forms.TreeGridViewDragInfo.Parent} node.
			 *
			 * This specifies the target item to drag to.  Note that if
			 * {@link Eto.Forms.TreeGridViewDragInfo.Position} is Before or After, then you should
			 * use {@link Eto.Forms.TreeGridViewDragInfo.InsertIndex} to insert the nodes at that
			 * specified location.  If you do not want to allow inserting, use
			 * {@link Eto.Forms.TreeGridViewDragInfo.RestrictToOver} in the
			 * {@link Eto.Forms.Control.DragOver} event, or you can also use
			 * {@link Eto.Forms.TreeGridViewDragInfo.RestrictToInsert} to only allow inserting items.
			 */
			Item: unknown;

			/** Helper to restrict to drop on top an existing item without allowing any insertion. */
			RestrictToOver(): void;

			/**
			 * Helper to restrict the drop to insert items only without allowing draging over
			 * existing items.
			 */
			RestrictToInsert(): void;

			/** Restricts the drop to an item or a child within the specified number of levels. */
			RestrictToNode(
				item: unknown,
				childLevels?: number,
			): boolean;
		}
	}

	export namespace Eto.Forms {
		/** Presents a tree with multiple columns */
		export class TreeGridView implements
			Eto.IHandlerSource,
			Eto.Forms.IBindable,
			Eto.Forms.IMouseInputSource,
			Eto.Forms.IKeyboardInputSource,
			Eto.Forms.ISelectable$1<unknown> {
			constructor();

			/** Gets or sets the selected item in the tree. */
			SelectedItem: Eto.Forms.ITreeGridItem;

			/**
			 * Gets or sets the data store of tree items.
			 *
			 * Use the {@link Eto.Forms.TreeGridItemCollection} for easy creation of a tree.
			 */
			DataStore: Eto.Forms.ITreeGridStore$1<Eto.Forms.ITreeGridItem>;

			/** Gets an enumeration of the currently selected items */
			readonly SelectedItems: Iterable<unknown>;

			/**
			 * Gets or sets the context menu when right clicking or pressing the menu key on an item.
			 */
			ContextMenu: Eto.Forms.ContextMenu;

			/** Gets the collection of columns to display in the grid */
			readonly Columns: Eto.Forms.GridColumnCollection;

			/** Gets or sets a value indicating that the header should be shown */
			ShowHeader: boolean;

			/** Gets or sets a value indicating whether the user can re-order columns */
			AllowColumnReordering: boolean;

			/** Gets or sets a value indicating whether the user can select multiple rows */
			AllowMultipleSelection: boolean;

			/**
			 * If there is exactly one selected item, returns it, otherwise returns null.
			 *
			 * Typically, you would use {@link Eto.Forms.Grid.SelectedItems} when
			 * {@link Eto.Forms.Grid.AllowMultipleSelection} is true .
			 */
			readonly SelectedItem: unknown;

			/** Gets a binding object to bind to the {@link Eto.Forms.Grid.SelectedItem} property. */
			readonly SelectedItemBinding: Eto.Forms.BindableBinding$2<Eto.Forms.Grid, unknown>;

			/** Gets or sets the selected rows indexes */
			SelectedRows: Iterable<number>;

			/**
			 * Gets or sets the selected row, or -1 for none.
			 *
			 * When {@link Eto.Forms.Grid.AllowMultipleSelection} is true and you want all selected
			 * rows, use {@link Eto.Forms.Grid.SelectedRow}.
			 */
			SelectedRow: number;

			/** Gets or sets the height for each row in the grid */
			RowHeight: number;

			/** Gets or sets the style of grid lines to show between columns and rows */
			GridLines: Eto.Forms.GridLines;

			/** Gets or sets the border type */
			Border: Eto.Forms.BorderType;

			/**
			 * Gets or sets a value indicating that the user can clear the selection.
			 *
			 * When true, the user can deselect the item by cmd/ctrl+click the last selected row, or
			 * by clicking on the empty space in the Grid. Some platforms may have empty space to the
			 * right, and some only have space at the bottom. When false, this setting will make it
			 * so the user cannot deselect the last selected item, and the control will initially
			 * select the first item when setting the DataStore property. This does not affect the
			 * ability to clear the selection programmatically.
			 */
			AllowEmptySelection: boolean;

			/** Gets a value indicating that the current cell is in edit mode. */
			readonly IsEditing: boolean;

			/**
			 * Gets a value indicating that the control is loaded onto a form, that is it has been
			 * created, added to a parent, and shown
			 *
			 * The {@link Eto.Forms.Control.OnLoad(System.EventArgs)} method sets this value to true
			 * after cascading to all children (for a {@link Eto.Forms.Container} ) and calling the
			 * platform handler's implementation.  It is called after adding to a loaded form, or
			 * when showing a new form.  The {@link Eto.Forms.Control.OnUnLoad(System.EventArgs)}
			 * method will set this value to false when the control is removed from its parent
			 */
			readonly Loaded: boolean;

			/**
			 * Gets an enumeration of controls that are in the visual tree.
			 *
			 * This is used to specify which controls are contained by this instance that are part of
			 * the visual tree. This should include all controls including non-logical Eto controls
			 * used for layout.
			 */
			readonly VisualControls: Iterable<Eto.Forms.Control>;

			/**
			 * Gets or sets a user-defined object that contains data about the control
			 *
			 * A common use of the tag property is to store data that is associated with the control
			 * that you can later retrieve.
			 */
			Tag: unknown;

			/**
			 * Gets the logical parent control.
			 *
			 * When the control is part of the visual tree (
				 * {@link Eto.Forms.Control.IsVisualControl} is true), this returns the logical parent
				 * that contains this control. Otherwise this is the same as
				 * {@link Eto.Forms.Control.Parent}.
				 */
				readonly LogicalParent: Eto.Forms.Container;

			/** Gets a value indicating this {@link Eto.Forms.Control} is part of the visual tree. */
			IsVisualControl: boolean;

			/**
			 * Gets or sets the size of the control. Use -1 to specify auto sizing for either the
			 * width and/or height.
			 *
			 * Setting the size of controls is entirely optional as most controls will size
			 * themselves appropriately. When specifying a size, it will be used as the desired size
			 * of the control.  The container will reposition and resize the control depending on the
			 * available size.  For a {@link Eto.Forms.Window}, it is preferred to set the
			 * {@link Eto.Forms.Container.ClientSize} instead, as various platforms have different
			 * sizes of window decorations, toolbars, etc.
			 */
			Size: Eto.Drawing.Size;

			/**
			 * Gets a value indicating this control currently has mouse capture
			 *
			 * Mouse capture can happen during a handled MouseDown event until MouseUp, or it can be
			 * captured explicitly via {@link Eto.Forms.Control.CaptureMouse}.
			 */
			readonly IsMouseCaptured: boolean;

			/** Gets or sets the width of the control size. */
			Width: number;

			/** Gets or sets the height of the control size. */
			Height: number;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Forms.Control} (or its
			 * children) are enabled and accept user input.
			 *
			 * Typically when a control is disabled, the user cannot do anything with the control or
			 * any of its children. Including for example, selecting text in a text control. Certain
			 * controls can have a 'Read Only' mode, such as {@link Eto.Forms.TextBox.ReadOnly} which
			 * allow the user to  select text, but not change its contents.
			 */
			Enabled: boolean;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Forms.Control} is visible to
			 * the user.
			 *
			 * When the visibility of a control is set to false, it will not occupy space in the
			 * layout.
			 */
			Visible: boolean;

			/** Gets the container which this control has been added to, if any */
			readonly Parent: Eto.Forms.Container;

			/**
			 * Gets the visual container of this control, if any.
			 *
			 * Some containers may use other Eto controls to layout its children, such as the
			 * {@link Eto.Forms.StackLayout}. This will return the parent control that visually
			 * contains this control as opposed to {@link Eto.Forms.Control.Parent} which will return
			 * the logical parent.
			 */
			VisualParent: Eto.Forms.Container;

			/** Gets a value indicating this control has been attached to a native container */
			readonly IsAttached: boolean;

			/**
			 * Gets or sets the color for the background of the control
			 *
			 * Note that on some platforms (e.g. Mac), setting the background color of a control can
			 * change the performance characteristics of the control and its children, since it must
			 * enable layers to do so.
			 */
			BackgroundColor: Eto.Drawing.Color;

			/** Gets a value indicating whether this instance has the keyboard input focus. */
			readonly HasFocus: boolean;

			/** Gets a value indicating whether the layout of child controls is suspended. */
			readonly IsSuspended: boolean;

			/** Gets the window this control is contained in */
			readonly ParentWindow: Eto.Forms.Window;

			/**
			 * Gets the supported platform commands that can be used to hook up system functions to
			 * user defined logic
			 *
			 * This lists all available commands that can be mapped using the
			 * {@link Eto.Forms.Control.MapPlatformCommand(System.String,Eto.Forms.Command)} method
			 * of the control.
			 */
			readonly SupportedPlatformCommands: Iterable<string>;

			/** Gets the bounding rectangle of this control relative to its container */
			readonly Bounds: Eto.Drawing.Rectangle;

			/**
			 * Gets the location of the control as positioned by the container
			 *
			 * A control's location is set by the container. This can be used to determine where the
			 * control is for overlaying floating windows, menus, etc.
			 */
			readonly Location: Eto.Drawing.Point;

			/** Gets or sets the type of cursor to use when the mouse is hovering over the control */
			Cursor: Eto.Forms.Cursor;

			/** Gets or sets the tool tip to show when the mouse is hovered over the control */
			ToolTip: string;

			/**
			 * Gets or sets the tab index order for this control within its container.
			 *
			 * This sets the order when using the tab key to cycle through controls  Note that some
			 * platforms (Gtk and WinForms) may not support setting the context of the tab order to
			 * StackLayout  or DynamicLayout containers and may not behave exactly as expected. Use
			 * the {@link Eto.PlatformFeatures.TabIndexWithCustomContainers} flag to determine if it
			 * is supported.
			 */
			TabIndex: number;

			/** Gets or sets a value indicating whether this control can serve as drop target. */
			AllowDrop: boolean;

			/**
			 * Gets or sets the parent widget which this widget has been added to, if any
			 *
			 * When implementing child widgets that can participate in the context based binding
			 * (MVVM), You can set this to the parent widget when it is added or removed to it
			 * (usually via a collection).  Note that you should typically provide a public new
			 * [ParentWidget] Parent { get; } property  so that consumers of your API cannot set the
			 * parent to an invalid value.
			 */
			Parent: Eto.Widget;

			/**
			 * Gets an enumeration of all parent widgets in the heirarchy by traversing the
			 * {@link Eto.Forms.BindableWidget.Parent} property.
			 */
			readonly Parents: Iterable<Eto.Widget>;

			/**
			 * Gets or sets the data context for this widget for binding
			 *
			 * Subclasses may override the standard behaviour so that hierarchy of widgets can be
			 * taken into account.  For example, a Control may return the data context of a parent,
			 * if it is not set explicitly.
			 */
			DataContext: unknown;

			/** Gets the collection of bindings that are attached to this widget */
			readonly Bindings: Eto.Forms.BindingCollection;

			/**
			 * Gets a value indicating that the {@link Eto.Forms.BindableWidget.DataContext} property
			 * is changing.
			 *
			 * This can be used to determine when to allow certain logic during the update of the
			 * data context.  It is used to disable binding setters on the model when the data
			 * context changes so that a binding does not cause the view model to be updated when the
			 * state hasn't been fully set yet.
			 */
			IsDataContextChanging: boolean;

			/**
			 * Gets the platform that was used to create the {@link Eto.Widget.Handler} for this
			 * widget
			 *
			 * This gets set to the current {@link Eto.Platform.Instance} during the construction of
			 * the object
			 */
			readonly Platform: Eto.Platform;

			/** Gets the platform-specific handler for this widget */
			Handler: unknown;

			/** Gets the native platform-specific handle for integration purposes */
			readonly NativeHandle: unknown;

			/** Gets the dictionary of properties for this widget */
			readonly Properties: Eto.PropertyStore;

			/** Gets or sets the ID of this widget */
			ID: string;

			/**
			 * Gets or sets the style of this widget
			 *
			 * Styles allow you to attach custom platform-specific logic to a widget. In your
			 * platform-specific assembly, use {@link Style.Add{H}(string, StyleHandler{H})} to add
			 * the style logic with the same id.
			 */
			Style: string;

			/**
			 * Gets the instance of the platform-specific object
			 *
			 * This can sometimes be useful to get the platform-specific object. Some handlers may
			 * not have any backing object for its functionality, so this may be null.  It is more
			 * preferred to use the {@link Eto.Widget.Handler} and cast that to the platform-specific
			 * handler class which can give you additional methods and helpers to do common tasks.
			 * For example, the {@link Eto.Forms.Application} object's handler for OS X has a
			 * AddFullScreenMenuItem property to specify if you want full screen support in your app.
			 */
			readonly ControlObject: unknown;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Widget} has been disposed.
			 *
			 * When the widget is disposed, it can no longer be used.
			 */
			IsDisposed: boolean;

			/** Refreshes the data, keeping the selection */
			ReloadData(): void;

			/**
			 * Refreshes the specified item and all its children, keeping the selection if not part
			 * of the refreshed nodes
			 */
			ReloadItem(item: Eto.Forms.ITreeGridItem): void;

			/**
			 * Refreshes the specified item and optionally all of its children, keeping the selection
			 * if not part of the refreshed nodes
			 */
			ReloadItem(
				item: Eto.Forms.ITreeGridItem,
				reloadChildren: boolean,
			): void;

			/**
			 * Gets the cell information at a specified location from the origin of the control
			 *
			 * Useful for determining which node is under the mouse cursor.
			 */
			GetCellAt(location: Eto.Drawing.PointF): Eto.Forms.TreeGridCell;

			/**
			 * Gets the tree grid drag info for the specified DragEventArgs.
			 *
			 * Use this to get or set information about where the drop will occur.
			 */
			GetDragInfo(args: Eto.Forms.DragEventArgs): Eto.Forms.TreeGridViewDragInfo;

			/** Selects the row to the specified `row`, clearing other selections */
			SelectRow(row: number): void;

			/** Selects all rows */
			SelectAll(): void;

			/** Unselects the specified `row` */
			UnselectRow(row: number): void;

			/** Clears the selection */
			UnselectAll(): void;

			/** Begin to edit one cell */
			BeginEdit(
				row: number,
				column: number,
			): void;

			/** Commits a current edit operation and sets the current value to the model. */
			CommitEdit(): boolean;

			/**
			 * Cancels the current edit operation and reverts the cell value to the value in the
			 * model.
			 */
			CancelEdit(): boolean;

			/** Scrolls to show the specified row in the view */
			ScrollToRow(row: number): void;

			/**
			 * Queues a repaint of the entire control on the screen and any of its children.
			 *
			 * This is only useful when the control is visible.
			 */
			Invalidate(): void;

			/**
			 * Queues a repaint of the entire control on the screen
			 *
			 * This is only useful when the control is visible.
			 */
			Invalidate(invalidateChildren: boolean): void;

			/**
			 * Queues a repaint of the specified `rect` of the control and any children.
			 *
			 * This is only useful when the control is visible.
			 */
			Invalidate(rect: Eto.Drawing.Rectangle): void;

			/**
			 * Queues a repaint of the specified `rect` of the control
			 *
			 * This is only useful when the control is visible.
			 */
			Invalidate(
				rect: Eto.Drawing.Rectangle,
				invalidateChildren: boolean,
			): void;

			/**
			 * Updates the layout of this control if necessary.
			 *
			 * This will ensure the control has had all of its layout applied so you can use its
			 * position and size right after this call. Most platforms (except WinForms) use a
			 * deferred layout system so that after adding your control to the form dynamically it
			 * won't get laid out until the next idle loop. This is useful when you need to know the
			 * dimensions of the control immediately. Note that this can be an expensive operation,
			 * so it is recommended to only call this method when necessary and after all of the
			 * controls have been added/updated.
			 */
			UpdateLayout(): void;

			/** Gets the preferred size of this control given infinite space available. */
			GetPreferredSize(): Eto.Drawing.SizeF;

			/** Gets the preferred size of this control given the specified `availableSize`. */
			GetPreferredSize(availableSize: Eto.Drawing.SizeF): Eto.Drawing.SizeF;

			/**
			 * Captures all mouse events to this control.
			 *
			 * This captures all mouse events until {@link Eto.Forms.Control.ReleaseMouseCapture} is
			 * called.  Note that not all platforms will allow a mouse capture unless the mouse is
			 * currently down.
			 */
			CaptureMouse(): boolean;

			/** Releases the mouse capture after a call to {@link Eto.Forms.Control.CaptureMouse}. */
			ReleaseMouseCapture(): void;

			/**
			 * Finds a control in the parent hierarchy with the specified type and
			 * {@link Eto.Widget.ID} if specified
			 */
			FindParent(
				type: unknown,
				id?: string,
			): Eto.Forms.Container;

			/** Finds a control in the parent hierarchy with the specified `id` */
			FindParent(id: string): Eto.Forms.Container;

			/**
			 * Detaches the control by removing it from its parent
			 *
			 * This is essentially a shortcut to myControl.Parent.Remove(myControl);
			 */
			Detach(): void;

			/**
			 * Attaches the control for direct use in a native application
			 *
			 * Use this to use a control directly in a native application.  Note that the native
			 * application must be running the same framework as the current platform.  E.g. a
			 * WinForms application can use an Eto.Forms control when using the Eto.WinForms
			 * platform.  This prepares the control by firing the {@link Eto.Forms.Control.PreLoad},
			 * {@link Eto.Forms.Control.Load}, etc. events.
			 */
			AttachNative(): void;

			/**
			 * Detaches the control when it is used in a native application, when you want to reuse
			 * the control.
			 *
			 * This should only be called after {@link Eto.Forms.Control.AttachNative} has been
			 * called, which is usually done by calling to ToNative(true) .
			 */
			DetachNative(): void;

			/**
			 * Attempts to set the keyboard input focus to this control, or the first child that
			 * accepts focus. For Windows, this will bring it to front and activate it.
			 */
			Focus(): void;

			/**
			 * Suspends the layout of child controls
			 *
			 * This can be used to optimize some platforms while adding, removing, or changing many
			 * child controls at once. It disables the calculation of control positioning until
			 * {@link Eto.Forms.Control.ResumeLayout} is called. Each call to SuspendLayout() must be
			 * balanced with a call to {@link Eto.Forms.Control.ResumeLayout}.
			 */
			SuspendLayout(): void;

			/**
			 * Resumes the layout after it has been suspended, and performs a layout
			 *
			 * This can be used to optimize some platforms while adding, removing, or changing many
			 * child controls at once. Each call to ResumeLayout() must be balanced with a call to
			 * {@link Eto.Forms.Control.SuspendLayout} before it.
			 */
			ResumeLayout(): void;

			/**
			 * Specifies a command to execute for a platform-specific command
			 *
			 * Some platforms have specific system-defined commands that can be associated with a
			 * control. For example, the Mac platform's cut/copy/paste functionality is defined by
			 * the system, and if you want to hook into it, you can use this to map it to your own
			 * defined logic. The valid values of the `systemCommand` parameter are defined by each
			 * platform, and a list can be retrieved using
			 * {@link Eto.Forms.Control.SupportedPlatformCommands}
			 */
			MapPlatformCommand(
				systemCommand: string,
				command: Eto.Forms.Command,
			): void;

			/** Converts a point from screen space to control space. */
			PointFromScreen(point: Eto.Drawing.PointF): Eto.Drawing.PointF;

			/** Converts a point from control space to screen space */
			PointToScreen(point: Eto.Drawing.PointF): Eto.Drawing.PointF;

			/** Converts a rectangle from screen space to control space. */
			RectangleToScreen(rect: Eto.Drawing.RectangleF): Eto.Drawing.RectangleF;

			/** Converts a rectangle from control space to screen space */
			RectangleFromScreen(rect: Eto.Drawing.RectangleF): Eto.Drawing.RectangleF;

			/**
			 * Starts drag operation using this control as drag source.
			 *
			 * This method can be blocking on some platforms (Wpf, WinForms), and non-blocking on
			 * others (Mac, Gtk). Use the {@link Eto.Forms.Control.DragEnd} event to determine when
			 * the drag operation is completed and get its resulting DragEffects.
			 */
			DoDragDrop(
				data: Eto.Forms.DataObject,
				allowedEffects: Eto.Forms.DragEffects,
			): void;

			/**
			 * Starts drag operation using this control as drag source.
			 *
			 * This method can be blocking on some platforms (Wpf, WinForms), and non-blocking on
			 * others (Mac, Gtk). Use the {@link Eto.Forms.Control.DragEnd} event to determine when
			 * the drag operation is completed and get its resulting DragEffects.
			 */
			DoDragDrop(
				data: Eto.Forms.DataObject,
				allowedEffects: Eto.Forms.DragEffects,
				image: Eto.Drawing.Image,
				cursorOffset: Eto.Drawing.PointF,
			): void;

			/**
			 * Triggers the StyleChanged event and re-applies the styles to this control and its
			 * children.
			 */
			TriggerStyleChanged(): void;

			/** Shows a print dialog to print the specified control */
			Print(): void;

			/**
			 * Finds a control in the parent hierarchy with the specified type and
			 * {@link Eto.Widget.ID} if specified
			 */
			FindParent<T>(id?: string): T;

			/**
			 * Finds a control in the parent hierarchy with the specified type and
			 * {@link Eto.Widget.ID} if specified
			 */
			FindParent(
				type: unknown,
				id?: string,
			): Eto.Widget;

			/** Finds a control in the parent hierarchy with the specified `id` */
			FindParent(id: string): Eto.Widget;

			/**
			 * Unbinds any bindings in the {@link Eto.Forms.BindableWidget.Bindings} collection and
			 * removes the bindings
			 *
			 * When you implement {@link Eto.Forms.IBindableWidgetContainer}, this will also unbind
			 * any of its children.
			 */
			Unbind(): void;

			/**
			 * Updates all bindings in this widget
			 *
			 * When you implement {@link Eto.Forms.IBindableWidgetContainer}, this will also update
			 * bindings for all of its children.
			 */
			UpdateBindings(mode?: Eto.Forms.BindingUpdateMode): void;

			/** Disposes of this widget, supressing the finalizer */
			dispose(): void;

			/** Gets a string that represents the current object with its ID if specified. */
			ToString(): string;
		}
	}

	export namespace Eto.Forms.TreeGridView {
		export interface ICallback extends
			Eto.Forms.Grid.ICallback,
			Eto.Forms.Control.ICallback,
			Eto.Widget.ICallback {
			OnActivated(
				widget: Eto.Forms.TreeGridView,
				e: Eto.Forms.TreeGridViewItemEventArgs,
			): void;

			OnExpanding(
				widget: Eto.Forms.TreeGridView,
				e: Eto.Forms.TreeGridViewItemCancelEventArgs,
			): void;

			OnExpanded(
				widget: Eto.Forms.TreeGridView,
				e: Eto.Forms.TreeGridViewItemEventArgs,
			): void;

			OnCollapsing(
				widget: Eto.Forms.TreeGridView,
				e: Eto.Forms.TreeGridViewItemCancelEventArgs,
			): void;

			OnCollapsed(
				widget: Eto.Forms.TreeGridView,
				e: Eto.Forms.TreeGridViewItemEventArgs,
			): void;

			OnSelectedItemChanged(
				widget: Eto.Forms.TreeGridView,
				e: unknown,
			): void;
		}
	}

	export namespace Eto.Forms.TreeGridView {
		export interface IHandler extends
			Eto.Forms.Grid.IHandler,
			Eto.Forms.Control.IHandler,
			Eto.Widget.IHandler,
			Eto.Forms.IContextMenuHost {
			DataStore: Eto.Forms.ITreeGridStore$1<Eto.Forms.ITreeGridItem>;

			SelectedItem: Eto.Forms.ITreeGridItem;

			readonly SelectedItems: Iterable<unknown>;

			ReloadData(): void;

			ReloadItem(
				item: Eto.Forms.ITreeGridItem,
				reloadChildren: boolean,
			): void;

			GetCellAt(location: Eto.Drawing.PointF): Eto.Forms.TreeGridCell;

			GetDragInfo(args: Eto.Forms.DragEventArgs): Eto.Forms.TreeGridViewDragInfo;
		}
	}

	export namespace Eto.Forms {
		/**
		 * Interface for an item in a {@link Eto.Forms.TreeView}
		 *
		 * This can be used instead of {@link Eto.Forms.TreeItem} when you want to use your own
		 * class as the item object of a tree.
		 */
		export interface ITreeItem extends
			Eto.Forms.IImageListItem,
			Eto.Forms.IListItem,
			Eto.Forms.ITreeStore,
			Eto.Forms.IDataStore$1<Eto.Forms.ITreeItem>,
			Eto.Forms.ITreeItem$1<Eto.Forms.ITreeItem> {
		}
	}

	export namespace Eto.Forms {
		/** Tree item collection. */
		export class TreeItemCollection implements
			Eto.Forms.ITreeStore,
			Eto.Forms.IDataStore$1<Eto.Forms.ITreeItem> {
			constructor();

			Sort(comparer: unknown): void;

			Sort(comparison: unknown): void;

			AddRange(items: Iterable<Eto.Forms.ITreeItem>): void;
		}
	}

	export namespace Eto.Forms {
		/** Item for a {@link Eto.Forms.TreeView} */
		export class TreeItem implements
			Eto.Forms.IListItem,
			Eto.Forms.IImageListItem,
			Eto.Forms.ITreeItem,
			Eto.Forms.ITreeStore,
			Eto.Forms.IDataStore$1<Eto.Forms.ITreeItem>,
			Eto.Forms.ITreeItem$1<Eto.Forms.ITreeItem> {
			/** Initializes a new instance of the {@link Eto.Forms.TreeItem} class. */
			constructor();

			/**
			 * Initializes a new instance of the {@link Eto.Forms.TreeItem} class with the specified
			 * children
			 */
			constructor(children: Iterable<Eto.Forms.ITreeItem>);

			/**
			 * Initializes a new instance of the {@link Eto.Forms.TreeItem} class with the specified
			 * children
			 */
			constructor(children: Eto.Forms.ITreeItem[]);

			/** Gets the children collection */
			readonly Children: Eto.Forms.TreeItemCollection;

			/** Gets or sets the parent tree item */
			Parent: Eto.Forms.ITreeItem;

			/** Gets a value indicating whether this {@link Eto.Forms.TreeItem} is expandable. */
			readonly Expandable: boolean;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Forms.TreeItem} is expanded.
			 */
			Expanded: boolean;

			/** Gets the count of children of this node */
			readonly Count: number;

			/** Gets or sets the image for this item. */
			Image: Eto.Drawing.Image;

			/** Gets or sets the text of the item. */
			Text: string;

			/**
			 * Gets or sets the unique key of the item.
			 *
			 * The key is typically used to identify each item uniquely.  If no key is specified, the
			 * {@link Eto.Forms.ListItem.Text} is used as the key.
			 */
			Key: string;

			/** Gets or sets custom data for the item. */
			Tag: unknown;

			/** Gets the listItem's string */
			ToString(): string;
		}
	}

	export namespace Eto.Forms {
		/** Base data store for the {@link Eto.Forms.TreeView} */
		export interface ITreeStore extends Eto.Forms.IDataStore$1<Eto.Forms.ITreeItem> {
		}
	}

	export namespace Eto.Forms {
		/** Event arguments for {@link Eto.Forms.TreeView} events relating to an item */
		export class TreeViewItemEventArgs {
			/** Initializes a new instance of the {@link Eto.Forms.TreeViewItemEventArgs} class. */
			constructor(item: Eto.Forms.ITreeItem);

			/** Gets the item that triggered the event */
			Item: Eto.Forms.ITreeItem;
		}
	}

	export namespace Eto.Forms {
		/** Event arguments for {@link Eto.Forms.TreeView} events that can be cancelled */
		export class TreeViewItemCancelEventArgs {
			/**
			 * Initializes a new instance of the {@link Eto.Forms.TreeViewItemCancelEventArgs} class.
			 */
			constructor(item: Eto.Forms.ITreeItem);

			/** Gets the item that triggered the event */
			Item: Eto.Forms.ITreeItem;
		}
	}

	export namespace Eto.Forms {
		/**
		 * Event arguments for {@link Eto.Forms.TreeView} events that can modify the label of the
		 * text
		 */
		export class TreeViewItemEditEventArgs {
			/**
			 * Initializes a new instance of the {@link Eto.Forms.TreeViewItemEditEventArgs} class.
			 */
			constructor(
				item: Eto.Forms.ITreeItem,
				label: string,
			);

			/** Gets or sets the label of the item */
			Label: string;

			/** Gets the item that triggered the event */
			readonly Item: Eto.Forms.ITreeItem;
		}
	}

	export namespace Eto.Forms {
		/**
		 * Standard tree view control with a single column
		 *
		 * This uses the standard tree view controls on windows, so it can sometimes be more
		 * desirable to use to give a more natural feel in that case.  For a tree with multiple
		 * columns, use the {@link Eto.Forms.TreeGridView}.
		 */
		export class TreeView implements
			Eto.IHandlerSource,
			Eto.Forms.IBindable,
			Eto.Forms.IMouseInputSource,
			Eto.Forms.IKeyboardInputSource {
			constructor();

			/** Gets or sets the selected item. */
			SelectedItem: Eto.Forms.ITreeItem;

			/** Gets or sets the data store. */
			DataStore: Eto.Forms.ITreeStore;

			/** Gets or sets the color of the text for all nodes. */
			TextColor: Eto.Drawing.Color;

			/** Gets or sets a value indicating whether users can edit the labels of items */
			LabelEdit: boolean;

			/**
			 * Gets or sets the context menu to show when the user right clicks or presses the menu
			 * key
			 */
			ContextMenu: Eto.Forms.ContextMenu;

			/**
			 * Gets a value indicating that the control is loaded onto a form, that is it has been
			 * created, added to a parent, and shown
			 *
			 * The {@link Eto.Forms.Control.OnLoad(System.EventArgs)} method sets this value to true
			 * after cascading to all children (for a {@link Eto.Forms.Container} ) and calling the
			 * platform handler's implementation.  It is called after adding to a loaded form, or
			 * when showing a new form.  The {@link Eto.Forms.Control.OnUnLoad(System.EventArgs)}
			 * method will set this value to false when the control is removed from its parent
			 */
			readonly Loaded: boolean;

			/**
			 * Gets an enumeration of controls that are in the visual tree.
			 *
			 * This is used to specify which controls are contained by this instance that are part of
			 * the visual tree. This should include all controls including non-logical Eto controls
			 * used for layout.
			 */
			readonly VisualControls: Iterable<Eto.Forms.Control>;

			/**
			 * Gets or sets a user-defined object that contains data about the control
			 *
			 * A common use of the tag property is to store data that is associated with the control
			 * that you can later retrieve.
			 */
			Tag: unknown;

			/**
			 * Gets the logical parent control.
			 *
			 * When the control is part of the visual tree (
				 * {@link Eto.Forms.Control.IsVisualControl} is true), this returns the logical parent
				 * that contains this control. Otherwise this is the same as
				 * {@link Eto.Forms.Control.Parent}.
				 */
				readonly LogicalParent: Eto.Forms.Container;

			/** Gets a value indicating this {@link Eto.Forms.Control} is part of the visual tree. */
			IsVisualControl: boolean;

			/**
			 * Gets or sets the size of the control. Use -1 to specify auto sizing for either the
			 * width and/or height.
			 *
			 * Setting the size of controls is entirely optional as most controls will size
			 * themselves appropriately. When specifying a size, it will be used as the desired size
			 * of the control.  The container will reposition and resize the control depending on the
			 * available size.  For a {@link Eto.Forms.Window}, it is preferred to set the
			 * {@link Eto.Forms.Container.ClientSize} instead, as various platforms have different
			 * sizes of window decorations, toolbars, etc.
			 */
			Size: Eto.Drawing.Size;

			/**
			 * Gets a value indicating this control currently has mouse capture
			 *
			 * Mouse capture can happen during a handled MouseDown event until MouseUp, or it can be
			 * captured explicitly via {@link Eto.Forms.Control.CaptureMouse}.
			 */
			readonly IsMouseCaptured: boolean;

			/** Gets or sets the width of the control size. */
			Width: number;

			/** Gets or sets the height of the control size. */
			Height: number;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Forms.Control} (or its
			 * children) are enabled and accept user input.
			 *
			 * Typically when a control is disabled, the user cannot do anything with the control or
			 * any of its children. Including for example, selecting text in a text control. Certain
			 * controls can have a 'Read Only' mode, such as {@link Eto.Forms.TextBox.ReadOnly} which
			 * allow the user to  select text, but not change its contents.
			 */
			Enabled: boolean;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Forms.Control} is visible to
			 * the user.
			 *
			 * When the visibility of a control is set to false, it will not occupy space in the
			 * layout.
			 */
			Visible: boolean;

			/** Gets the container which this control has been added to, if any */
			readonly Parent: Eto.Forms.Container;

			/**
			 * Gets the visual container of this control, if any.
			 *
			 * Some containers may use other Eto controls to layout its children, such as the
			 * {@link Eto.Forms.StackLayout}. This will return the parent control that visually
			 * contains this control as opposed to {@link Eto.Forms.Control.Parent} which will return
			 * the logical parent.
			 */
			VisualParent: Eto.Forms.Container;

			/** Gets a value indicating this control has been attached to a native container */
			readonly IsAttached: boolean;

			/**
			 * Gets or sets the color for the background of the control
			 *
			 * Note that on some platforms (e.g. Mac), setting the background color of a control can
			 * change the performance characteristics of the control and its children, since it must
			 * enable layers to do so.
			 */
			BackgroundColor: Eto.Drawing.Color;

			/** Gets a value indicating whether this instance has the keyboard input focus. */
			readonly HasFocus: boolean;

			/** Gets a value indicating whether the layout of child controls is suspended. */
			readonly IsSuspended: boolean;

			/** Gets the window this control is contained in */
			readonly ParentWindow: Eto.Forms.Window;

			/**
			 * Gets the supported platform commands that can be used to hook up system functions to
			 * user defined logic
			 *
			 * This lists all available commands that can be mapped using the
			 * {@link Eto.Forms.Control.MapPlatformCommand(System.String,Eto.Forms.Command)} method
			 * of the control.
			 */
			readonly SupportedPlatformCommands: Iterable<string>;

			/** Gets the bounding rectangle of this control relative to its container */
			readonly Bounds: Eto.Drawing.Rectangle;

			/**
			 * Gets the location of the control as positioned by the container
			 *
			 * A control's location is set by the container. This can be used to determine where the
			 * control is for overlaying floating windows, menus, etc.
			 */
			readonly Location: Eto.Drawing.Point;

			/** Gets or sets the type of cursor to use when the mouse is hovering over the control */
			Cursor: Eto.Forms.Cursor;

			/** Gets or sets the tool tip to show when the mouse is hovered over the control */
			ToolTip: string;

			/**
			 * Gets or sets the tab index order for this control within its container.
			 *
			 * This sets the order when using the tab key to cycle through controls  Note that some
			 * platforms (Gtk and WinForms) may not support setting the context of the tab order to
			 * StackLayout  or DynamicLayout containers and may not behave exactly as expected. Use
			 * the {@link Eto.PlatformFeatures.TabIndexWithCustomContainers} flag to determine if it
			 * is supported.
			 */
			TabIndex: number;

			/** Gets or sets a value indicating whether this control can serve as drop target. */
			AllowDrop: boolean;

			/**
			 * Gets or sets the parent widget which this widget has been added to, if any
			 *
			 * When implementing child widgets that can participate in the context based binding
			 * (MVVM), You can set this to the parent widget when it is added or removed to it
			 * (usually via a collection).  Note that you should typically provide a public new
			 * [ParentWidget] Parent { get; } property  so that consumers of your API cannot set the
			 * parent to an invalid value.
			 */
			Parent: Eto.Widget;

			/**
			 * Gets an enumeration of all parent widgets in the heirarchy by traversing the
			 * {@link Eto.Forms.BindableWidget.Parent} property.
			 */
			readonly Parents: Iterable<Eto.Widget>;

			/**
			 * Gets or sets the data context for this widget for binding
			 *
			 * Subclasses may override the standard behaviour so that hierarchy of widgets can be
			 * taken into account.  For example, a Control may return the data context of a parent,
			 * if it is not set explicitly.
			 */
			DataContext: unknown;

			/** Gets the collection of bindings that are attached to this widget */
			readonly Bindings: Eto.Forms.BindingCollection;

			/**
			 * Gets a value indicating that the {@link Eto.Forms.BindableWidget.DataContext} property
			 * is changing.
			 *
			 * This can be used to determine when to allow certain logic during the update of the
			 * data context.  It is used to disable binding setters on the model when the data
			 * context changes so that a binding does not cause the view model to be updated when the
			 * state hasn't been fully set yet.
			 */
			IsDataContextChanging: boolean;

			/**
			 * Gets the platform that was used to create the {@link Eto.Widget.Handler} for this
			 * widget
			 *
			 * This gets set to the current {@link Eto.Platform.Instance} during the construction of
			 * the object
			 */
			readonly Platform: Eto.Platform;

			/** Gets the platform-specific handler for this widget */
			Handler: unknown;

			/** Gets the native platform-specific handle for integration purposes */
			readonly NativeHandle: unknown;

			/** Gets the dictionary of properties for this widget */
			readonly Properties: Eto.PropertyStore;

			/** Gets or sets the ID of this widget */
			ID: string;

			/**
			 * Gets or sets the style of this widget
			 *
			 * Styles allow you to attach custom platform-specific logic to a widget. In your
			 * platform-specific assembly, use {@link Style.Add{H}(string, StyleHandler{H})} to add
			 * the style logic with the same id.
			 */
			Style: string;

			/**
			 * Gets the instance of the platform-specific object
			 *
			 * This can sometimes be useful to get the platform-specific object. Some handlers may
			 * not have any backing object for its functionality, so this may be null.  It is more
			 * preferred to use the {@link Eto.Widget.Handler} and cast that to the platform-specific
			 * handler class which can give you additional methods and helpers to do common tasks.
			 * For example, the {@link Eto.Forms.Application} object's handler for OS X has a
			 * AddFullScreenMenuItem property to specify if you want full screen support in your app.
			 */
			readonly ControlObject: unknown;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Widget} has been disposed.
			 *
			 * When the widget is disposed, it can no longer be used.
			 */
			IsDisposed: boolean;

			/** Refreshes the data, keeping the selection */
			RefreshData(): void;

			/**
			 * Refreshes the specified item and all its children, keeping the selection if not part
			 * of the refreshed nodes
			 */
			RefreshItem(item: Eto.Forms.ITreeItem): void;

			/**
			 * Gets the node at a specified point from the origin of the control
			 *
			 * Useful for determining which node is under the mouse cursor.
			 */
			GetNodeAt(point: Eto.Drawing.PointF): Eto.Forms.ITreeItem;

			/**
			 * Queues a repaint of the entire control on the screen and any of its children.
			 *
			 * This is only useful when the control is visible.
			 */
			Invalidate(): void;

			/**
			 * Queues a repaint of the entire control on the screen
			 *
			 * This is only useful when the control is visible.
			 */
			Invalidate(invalidateChildren: boolean): void;

			/**
			 * Queues a repaint of the specified `rect` of the control and any children.
			 *
			 * This is only useful when the control is visible.
			 */
			Invalidate(rect: Eto.Drawing.Rectangle): void;

			/**
			 * Queues a repaint of the specified `rect` of the control
			 *
			 * This is only useful when the control is visible.
			 */
			Invalidate(
				rect: Eto.Drawing.Rectangle,
				invalidateChildren: boolean,
			): void;

			/**
			 * Updates the layout of this control if necessary.
			 *
			 * This will ensure the control has had all of its layout applied so you can use its
			 * position and size right after this call. Most platforms (except WinForms) use a
			 * deferred layout system so that after adding your control to the form dynamically it
			 * won't get laid out until the next idle loop. This is useful when you need to know the
			 * dimensions of the control immediately. Note that this can be an expensive operation,
			 * so it is recommended to only call this method when necessary and after all of the
			 * controls have been added/updated.
			 */
			UpdateLayout(): void;

			/** Gets the preferred size of this control given infinite space available. */
			GetPreferredSize(): Eto.Drawing.SizeF;

			/** Gets the preferred size of this control given the specified `availableSize`. */
			GetPreferredSize(availableSize: Eto.Drawing.SizeF): Eto.Drawing.SizeF;

			/**
			 * Captures all mouse events to this control.
			 *
			 * This captures all mouse events until {@link Eto.Forms.Control.ReleaseMouseCapture} is
			 * called.  Note that not all platforms will allow a mouse capture unless the mouse is
			 * currently down.
			 */
			CaptureMouse(): boolean;

			/** Releases the mouse capture after a call to {@link Eto.Forms.Control.CaptureMouse}. */
			ReleaseMouseCapture(): void;

			/**
			 * Finds a control in the parent hierarchy with the specified type and
			 * {@link Eto.Widget.ID} if specified
			 */
			FindParent(
				type: unknown,
				id?: string,
			): Eto.Forms.Container;

			/** Finds a control in the parent hierarchy with the specified `id` */
			FindParent(id: string): Eto.Forms.Container;

			/**
			 * Detaches the control by removing it from its parent
			 *
			 * This is essentially a shortcut to myControl.Parent.Remove(myControl);
			 */
			Detach(): void;

			/**
			 * Attaches the control for direct use in a native application
			 *
			 * Use this to use a control directly in a native application.  Note that the native
			 * application must be running the same framework as the current platform.  E.g. a
			 * WinForms application can use an Eto.Forms control when using the Eto.WinForms
			 * platform.  This prepares the control by firing the {@link Eto.Forms.Control.PreLoad},
			 * {@link Eto.Forms.Control.Load}, etc. events.
			 */
			AttachNative(): void;

			/**
			 * Detaches the control when it is used in a native application, when you want to reuse
			 * the control.
			 *
			 * This should only be called after {@link Eto.Forms.Control.AttachNative} has been
			 * called, which is usually done by calling to ToNative(true) .
			 */
			DetachNative(): void;

			/**
			 * Attempts to set the keyboard input focus to this control, or the first child that
			 * accepts focus. For Windows, this will bring it to front and activate it.
			 */
			Focus(): void;

			/**
			 * Suspends the layout of child controls
			 *
			 * This can be used to optimize some platforms while adding, removing, or changing many
			 * child controls at once. It disables the calculation of control positioning until
			 * {@link Eto.Forms.Control.ResumeLayout} is called. Each call to SuspendLayout() must be
			 * balanced with a call to {@link Eto.Forms.Control.ResumeLayout}.
			 */
			SuspendLayout(): void;

			/**
			 * Resumes the layout after it has been suspended, and performs a layout
			 *
			 * This can be used to optimize some platforms while adding, removing, or changing many
			 * child controls at once. Each call to ResumeLayout() must be balanced with a call to
			 * {@link Eto.Forms.Control.SuspendLayout} before it.
			 */
			ResumeLayout(): void;

			/**
			 * Specifies a command to execute for a platform-specific command
			 *
			 * Some platforms have specific system-defined commands that can be associated with a
			 * control. For example, the Mac platform's cut/copy/paste functionality is defined by
			 * the system, and if you want to hook into it, you can use this to map it to your own
			 * defined logic. The valid values of the `systemCommand` parameter are defined by each
			 * platform, and a list can be retrieved using
			 * {@link Eto.Forms.Control.SupportedPlatformCommands}
			 */
			MapPlatformCommand(
				systemCommand: string,
				command: Eto.Forms.Command,
			): void;

			/** Converts a point from screen space to control space. */
			PointFromScreen(point: Eto.Drawing.PointF): Eto.Drawing.PointF;

			/** Converts a point from control space to screen space */
			PointToScreen(point: Eto.Drawing.PointF): Eto.Drawing.PointF;

			/** Converts a rectangle from screen space to control space. */
			RectangleToScreen(rect: Eto.Drawing.RectangleF): Eto.Drawing.RectangleF;

			/** Converts a rectangle from control space to screen space */
			RectangleFromScreen(rect: Eto.Drawing.RectangleF): Eto.Drawing.RectangleF;

			/**
			 * Starts drag operation using this control as drag source.
			 *
			 * This method can be blocking on some platforms (Wpf, WinForms), and non-blocking on
			 * others (Mac, Gtk). Use the {@link Eto.Forms.Control.DragEnd} event to determine when
			 * the drag operation is completed and get its resulting DragEffects.
			 */
			DoDragDrop(
				data: Eto.Forms.DataObject,
				allowedEffects: Eto.Forms.DragEffects,
			): void;

			/**
			 * Starts drag operation using this control as drag source.
			 *
			 * This method can be blocking on some platforms (Wpf, WinForms), and non-blocking on
			 * others (Mac, Gtk). Use the {@link Eto.Forms.Control.DragEnd} event to determine when
			 * the drag operation is completed and get its resulting DragEffects.
			 */
			DoDragDrop(
				data: Eto.Forms.DataObject,
				allowedEffects: Eto.Forms.DragEffects,
				image: Eto.Drawing.Image,
				cursorOffset: Eto.Drawing.PointF,
			): void;

			/**
			 * Triggers the StyleChanged event and re-applies the styles to this control and its
			 * children.
			 */
			TriggerStyleChanged(): void;

			/** Shows a print dialog to print the specified control */
			Print(): void;

			/**
			 * Finds a control in the parent hierarchy with the specified type and
			 * {@link Eto.Widget.ID} if specified
			 */
			FindParent<T>(id?: string): T;

			/**
			 * Finds a control in the parent hierarchy with the specified type and
			 * {@link Eto.Widget.ID} if specified
			 */
			FindParent(
				type: unknown,
				id?: string,
			): Eto.Widget;

			/** Finds a control in the parent hierarchy with the specified `id` */
			FindParent(id: string): Eto.Widget;

			/**
			 * Unbinds any bindings in the {@link Eto.Forms.BindableWidget.Bindings} collection and
			 * removes the bindings
			 *
			 * When you implement {@link Eto.Forms.IBindableWidgetContainer}, this will also unbind
			 * any of its children.
			 */
			Unbind(): void;

			/**
			 * Updates all bindings in this widget
			 *
			 * When you implement {@link Eto.Forms.IBindableWidgetContainer}, this will also update
			 * bindings for all of its children.
			 */
			UpdateBindings(mode?: Eto.Forms.BindingUpdateMode): void;

			/** Disposes of this widget, supressing the finalizer */
			dispose(): void;

			/** Gets a string that represents the current object with its ID if specified. */
			ToString(): string;
		}
	}

	export namespace Eto.Forms.TreeView {
		export interface ICallback extends
			Eto.Forms.Control.ICallback,
			Eto.Widget.ICallback {
			OnActivated(
				widget: Eto.Forms.TreeView,
				e: Eto.Forms.TreeViewItemEventArgs,
			): void;

			OnSelectionChanged(
				widget: Eto.Forms.TreeView,
				e: unknown,
			): void;

			OnExpanding(
				widget: Eto.Forms.TreeView,
				e: Eto.Forms.TreeViewItemCancelEventArgs,
			): void;

			OnExpanded(
				widget: Eto.Forms.TreeView,
				e: Eto.Forms.TreeViewItemEventArgs,
			): void;

			OnCollapsing(
				widget: Eto.Forms.TreeView,
				e: Eto.Forms.TreeViewItemCancelEventArgs,
			): void;

			OnCollapsed(
				widget: Eto.Forms.TreeView,
				e: Eto.Forms.TreeViewItemEventArgs,
			): void;

			OnLabelEdited(
				widget: Eto.Forms.TreeView,
				e: Eto.Forms.TreeViewItemEditEventArgs,
			): void;

			OnLabelEditing(
				widget: Eto.Forms.TreeView,
				e: Eto.Forms.TreeViewItemCancelEventArgs,
			): void;

			OnNodeMouseClick(
				widget: Eto.Forms.TreeView,
				e: Eto.Forms.TreeViewItemEventArgs,
			): void;
		}
	}

	export namespace Eto.Forms.TreeView {
		export interface IHandler extends
			Eto.Forms.Control.IHandler,
			Eto.Widget.IHandler,
			Eto.Forms.IContextMenuHost {
			DataStore: Eto.Forms.ITreeStore;

			SelectedItem: Eto.Forms.ITreeItem;

			LabelEdit: boolean;

			TextColor: Eto.Drawing.Color;

			RefreshData(): void;

			RefreshItem(item: Eto.Forms.ITreeItem): void;

			GetNodeAt(point: Eto.Drawing.PointF): Eto.Forms.ITreeItem;
		}
	}

	export namespace Eto.Forms {
		/** Event arguments when the {@link Eto.Forms.WebView} has finished loaded a uri */
		export class WebViewLoadedEventArgs {
			/** Initializes a new instance of the {@link Eto.Forms.WebViewLoadedEventArgs} class. */
			constructor(uri: unknown);

			/** Gets the URI of the page that was loaded. */
			Uri: unknown;
		}
	}

	export namespace Eto.Forms {
		/** Event arguments when the {@link Eto.Forms.WebView} is loading a new uri. */
		export class WebViewLoadingEventArgs {
			/** Initializes a new instance of the {@link Eto.Forms.WebViewLoadingEventArgs} class. */
			constructor(
				uri: unknown,
				isMainFrame: boolean,
			);

			/** Gets or sets a value indicating whether to cancel the load. */
			Cancel: boolean;

			/**
			 * Gets or sets a value indicating whether the main frame is loading, or a child frame.
			 */
			IsMainFrame: boolean;

			/** Gets the URI of the page that was loaded. */
			readonly Uri: unknown;
		}
	}

	export namespace Eto.Forms {
		/** Event arguments for when the {@link Eto.Forms.WebView} changes its title */
		export class WebViewTitleEventArgs {
			/** Initializes a new instance of the {@link Eto.Forms.WebViewTitleEventArgs} class. */
			constructor(title: string);

			/** Gets the new title for the page. */
			Title: string;
		}
	}

	export namespace Eto.Forms {
		/**
		 * Event arguments for when the {@link Eto.Forms.WebView} prompts to open a new window.
		 */
		export class WebViewNewWindowEventArgs {
			/**
			 * Initializes a new instance of the {@link Eto.Forms.WebViewNewWindowEventArgs} class.
			 */
			constructor(
				uri: unknown,
				newWindowName: string,
			);

			/** Gets the name of the new window. */
			NewWindowName: string;

			/** Gets or sets a value indicating whether to cancel the load. */
			Cancel: boolean;

			/**
			 * Gets or sets a value indicating whether the main frame is loading, or a child frame.
			 */
			IsMainFrame: boolean;

			/** Gets the URI of the page that was loaded. */
			readonly Uri: unknown;
		}
	}

	export namespace Eto.Forms {
		/**
		 * Control to show a browser control that can display html and execute javascript.
		 *
		 * Most platforms have built-in support for a browser control, which by default this will
		 * use.  There are other browser implementations available, such as Chromium, etc.  You
		 * can create your own handler for the web view if you want to use a different browser
		 * control.
		 */
		export class WebView implements
			Eto.IHandlerSource,
			Eto.Forms.IBindable,
			Eto.Forms.IMouseInputSource,
			Eto.Forms.IKeyboardInputSource {
			constructor();

			/**
			 * Gets a value indicating whether the browser can go back to the previous page in
			 * history.
			 */
			readonly CanGoBack: boolean;

			/** Gets a value indicating whether the browser can go forward to the next page. */
			readonly CanGoForward: boolean;

			/**
			 * Gets or sets the URL of the currently navigated page.
			 *
			 * Setting this will cause the current page to stop loading (if not already loaded), and
			 * begin loading another page. Loading the new page can be cancelled by the
			 * {@link Eto.Forms.WebView.DocumentLoading} event.
			 */
			Url: unknown;

			/** Gets the document title of the current page. */
			readonly DocumentTitle: string;

			/**
			 * Gets or sets a value indicating whether the user can click to show the context menu.
			 *
			 * This is useful when using a browser control with content that should not be changed.
			 * The context menu can show navigation items which may cause the page to reload so
			 * setting this value to false will ensure the user can only interact with the page as
			 * is.
			 */
			BrowserContextMenuEnabled: boolean;

			/**
			 * Gets a value indicating that the control is loaded onto a form, that is it has been
			 * created, added to a parent, and shown
			 *
			 * The {@link Eto.Forms.Control.OnLoad(System.EventArgs)} method sets this value to true
			 * after cascading to all children (for a {@link Eto.Forms.Container} ) and calling the
			 * platform handler's implementation.  It is called after adding to a loaded form, or
			 * when showing a new form.  The {@link Eto.Forms.Control.OnUnLoad(System.EventArgs)}
			 * method will set this value to false when the control is removed from its parent
			 */
			readonly Loaded: boolean;

			/**
			 * Gets an enumeration of controls that are in the visual tree.
			 *
			 * This is used to specify which controls are contained by this instance that are part of
			 * the visual tree. This should include all controls including non-logical Eto controls
			 * used for layout.
			 */
			readonly VisualControls: Iterable<Eto.Forms.Control>;

			/**
			 * Gets or sets a user-defined object that contains data about the control
			 *
			 * A common use of the tag property is to store data that is associated with the control
			 * that you can later retrieve.
			 */
			Tag: unknown;

			/**
			 * Gets the logical parent control.
			 *
			 * When the control is part of the visual tree (
				 * {@link Eto.Forms.Control.IsVisualControl} is true), this returns the logical parent
				 * that contains this control. Otherwise this is the same as
				 * {@link Eto.Forms.Control.Parent}.
				 */
				readonly LogicalParent: Eto.Forms.Container;

			/** Gets a value indicating this {@link Eto.Forms.Control} is part of the visual tree. */
			IsVisualControl: boolean;

			/**
			 * Gets or sets the size of the control. Use -1 to specify auto sizing for either the
			 * width and/or height.
			 *
			 * Setting the size of controls is entirely optional as most controls will size
			 * themselves appropriately. When specifying a size, it will be used as the desired size
			 * of the control.  The container will reposition and resize the control depending on the
			 * available size.  For a {@link Eto.Forms.Window}, it is preferred to set the
			 * {@link Eto.Forms.Container.ClientSize} instead, as various platforms have different
			 * sizes of window decorations, toolbars, etc.
			 */
			Size: Eto.Drawing.Size;

			/**
			 * Gets a value indicating this control currently has mouse capture
			 *
			 * Mouse capture can happen during a handled MouseDown event until MouseUp, or it can be
			 * captured explicitly via {@link Eto.Forms.Control.CaptureMouse}.
			 */
			readonly IsMouseCaptured: boolean;

			/** Gets or sets the width of the control size. */
			Width: number;

			/** Gets or sets the height of the control size. */
			Height: number;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Forms.Control} (or its
			 * children) are enabled and accept user input.
			 *
			 * Typically when a control is disabled, the user cannot do anything with the control or
			 * any of its children. Including for example, selecting text in a text control. Certain
			 * controls can have a 'Read Only' mode, such as {@link Eto.Forms.TextBox.ReadOnly} which
			 * allow the user to  select text, but not change its contents.
			 */
			Enabled: boolean;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Forms.Control} is visible to
			 * the user.
			 *
			 * When the visibility of a control is set to false, it will not occupy space in the
			 * layout.
			 */
			Visible: boolean;

			/** Gets the container which this control has been added to, if any */
			readonly Parent: Eto.Forms.Container;

			/**
			 * Gets the visual container of this control, if any.
			 *
			 * Some containers may use other Eto controls to layout its children, such as the
			 * {@link Eto.Forms.StackLayout}. This will return the parent control that visually
			 * contains this control as opposed to {@link Eto.Forms.Control.Parent} which will return
			 * the logical parent.
			 */
			VisualParent: Eto.Forms.Container;

			/** Gets a value indicating this control has been attached to a native container */
			readonly IsAttached: boolean;

			/**
			 * Gets or sets the color for the background of the control
			 *
			 * Note that on some platforms (e.g. Mac), setting the background color of a control can
			 * change the performance characteristics of the control and its children, since it must
			 * enable layers to do so.
			 */
			BackgroundColor: Eto.Drawing.Color;

			/** Gets a value indicating whether this instance has the keyboard input focus. */
			readonly HasFocus: boolean;

			/** Gets a value indicating whether the layout of child controls is suspended. */
			readonly IsSuspended: boolean;

			/** Gets the window this control is contained in */
			readonly ParentWindow: Eto.Forms.Window;

			/**
			 * Gets the supported platform commands that can be used to hook up system functions to
			 * user defined logic
			 *
			 * This lists all available commands that can be mapped using the
			 * {@link Eto.Forms.Control.MapPlatformCommand(System.String,Eto.Forms.Command)} method
			 * of the control.
			 */
			readonly SupportedPlatformCommands: Iterable<string>;

			/** Gets the bounding rectangle of this control relative to its container */
			readonly Bounds: Eto.Drawing.Rectangle;

			/**
			 * Gets the location of the control as positioned by the container
			 *
			 * A control's location is set by the container. This can be used to determine where the
			 * control is for overlaying floating windows, menus, etc.
			 */
			readonly Location: Eto.Drawing.Point;

			/** Gets or sets the type of cursor to use when the mouse is hovering over the control */
			Cursor: Eto.Forms.Cursor;

			/** Gets or sets the tool tip to show when the mouse is hovered over the control */
			ToolTip: string;

			/**
			 * Gets or sets the tab index order for this control within its container.
			 *
			 * This sets the order when using the tab key to cycle through controls  Note that some
			 * platforms (Gtk and WinForms) may not support setting the context of the tab order to
			 * StackLayout  or DynamicLayout containers and may not behave exactly as expected. Use
			 * the {@link Eto.PlatformFeatures.TabIndexWithCustomContainers} flag to determine if it
			 * is supported.
			 */
			TabIndex: number;

			/** Gets or sets a value indicating whether this control can serve as drop target. */
			AllowDrop: boolean;

			/**
			 * Gets or sets the parent widget which this widget has been added to, if any
			 *
			 * When implementing child widgets that can participate in the context based binding
			 * (MVVM), You can set this to the parent widget when it is added or removed to it
			 * (usually via a collection).  Note that you should typically provide a public new
			 * [ParentWidget] Parent { get; } property  so that consumers of your API cannot set the
			 * parent to an invalid value.
			 */
			Parent: Eto.Widget;

			/**
			 * Gets an enumeration of all parent widgets in the heirarchy by traversing the
			 * {@link Eto.Forms.BindableWidget.Parent} property.
			 */
			readonly Parents: Iterable<Eto.Widget>;

			/**
			 * Gets or sets the data context for this widget for binding
			 *
			 * Subclasses may override the standard behaviour so that hierarchy of widgets can be
			 * taken into account.  For example, a Control may return the data context of a parent,
			 * if it is not set explicitly.
			 */
			DataContext: unknown;

			/** Gets the collection of bindings that are attached to this widget */
			readonly Bindings: Eto.Forms.BindingCollection;

			/**
			 * Gets a value indicating that the {@link Eto.Forms.BindableWidget.DataContext} property
			 * is changing.
			 *
			 * This can be used to determine when to allow certain logic during the update of the
			 * data context.  It is used to disable binding setters on the model when the data
			 * context changes so that a binding does not cause the view model to be updated when the
			 * state hasn't been fully set yet.
			 */
			IsDataContextChanging: boolean;

			/**
			 * Gets the platform that was used to create the {@link Eto.Widget.Handler} for this
			 * widget
			 *
			 * This gets set to the current {@link Eto.Platform.Instance} during the construction of
			 * the object
			 */
			readonly Platform: Eto.Platform;

			/** Gets the platform-specific handler for this widget */
			Handler: unknown;

			/** Gets the native platform-specific handle for integration purposes */
			readonly NativeHandle: unknown;

			/** Gets the dictionary of properties for this widget */
			readonly Properties: Eto.PropertyStore;

			/** Gets or sets the ID of this widget */
			ID: string;

			/**
			 * Gets or sets the style of this widget
			 *
			 * Styles allow you to attach custom platform-specific logic to a widget. In your
			 * platform-specific assembly, use {@link Style.Add{H}(string, StyleHandler{H})} to add
			 * the style logic with the same id.
			 */
			Style: string;

			/**
			 * Gets the instance of the platform-specific object
			 *
			 * This can sometimes be useful to get the platform-specific object. Some handlers may
			 * not have any backing object for its functionality, so this may be null.  It is more
			 * preferred to use the {@link Eto.Widget.Handler} and cast that to the platform-specific
			 * handler class which can give you additional methods and helpers to do common tasks.
			 * For example, the {@link Eto.Forms.Application} object's handler for OS X has a
			 * AddFullScreenMenuItem property to specify if you want full screen support in your app.
			 */
			readonly ControlObject: unknown;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Widget} has been disposed.
			 *
			 * When the widget is disposed, it can no longer be used.
			 */
			IsDisposed: boolean;

			/** Navigates the browser back to the previous page in history, if there is one. */
			GoBack(): void;

			/** Navigates the browser forward to the next page in history, if there is one. */
			GoForward(): void;

			/**
			 * Stops loading the current page.
			 *
			 * You can determine if the page is finished loading by the
			 * {@link Eto.Forms.WebView.DocumentLoaded} event.
			 */
			Stop(): void;

			/** Reloads the current page */
			Reload(): void;

			/**
			 * Executes the specified javascript in the context of the current page, returning its
			 * result.
			 */
			ExecuteScript(script: string): string;

			/**
			 * Executes the specified javascript in the context of the current page asynchronously,
			 * returning its result.
			 *
			 * Note that not all platforms support asynchronous execution of javascript and may run
			 * synchronously.
			 */
			ExecuteScriptAsync(script: string): Promise<string>;

			/** Loads the specified stream as html into the control. */
			LoadHtml(
				stream: Duplex,
				baseUri?: unknown,
			): void;

			/** Loads the specified html string. */
			LoadHtml(
				html: string,
				baseUri?: unknown,
			): void;

			/**
			 * Shows the print dialog for the current page.
			 *
			 * This prompts the browser to print its contents.
			 */
			ShowPrintDialog(): void;

			/**
			 * Queues a repaint of the entire control on the screen and any of its children.
			 *
			 * This is only useful when the control is visible.
			 */
			Invalidate(): void;

			/**
			 * Queues a repaint of the entire control on the screen
			 *
			 * This is only useful when the control is visible.
			 */
			Invalidate(invalidateChildren: boolean): void;

			/**
			 * Queues a repaint of the specified `rect` of the control and any children.
			 *
			 * This is only useful when the control is visible.
			 */
			Invalidate(rect: Eto.Drawing.Rectangle): void;

			/**
			 * Queues a repaint of the specified `rect` of the control
			 *
			 * This is only useful when the control is visible.
			 */
			Invalidate(
				rect: Eto.Drawing.Rectangle,
				invalidateChildren: boolean,
			): void;

			/**
			 * Updates the layout of this control if necessary.
			 *
			 * This will ensure the control has had all of its layout applied so you can use its
			 * position and size right after this call. Most platforms (except WinForms) use a
			 * deferred layout system so that after adding your control to the form dynamically it
			 * won't get laid out until the next idle loop. This is useful when you need to know the
			 * dimensions of the control immediately. Note that this can be an expensive operation,
			 * so it is recommended to only call this method when necessary and after all of the
			 * controls have been added/updated.
			 */
			UpdateLayout(): void;

			/** Gets the preferred size of this control given infinite space available. */
			GetPreferredSize(): Eto.Drawing.SizeF;

			/** Gets the preferred size of this control given the specified `availableSize`. */
			GetPreferredSize(availableSize: Eto.Drawing.SizeF): Eto.Drawing.SizeF;

			/**
			 * Captures all mouse events to this control.
			 *
			 * This captures all mouse events until {@link Eto.Forms.Control.ReleaseMouseCapture} is
			 * called.  Note that not all platforms will allow a mouse capture unless the mouse is
			 * currently down.
			 */
			CaptureMouse(): boolean;

			/** Releases the mouse capture after a call to {@link Eto.Forms.Control.CaptureMouse}. */
			ReleaseMouseCapture(): void;

			/**
			 * Finds a control in the parent hierarchy with the specified type and
			 * {@link Eto.Widget.ID} if specified
			 */
			FindParent(
				type: unknown,
				id?: string,
			): Eto.Forms.Container;

			/** Finds a control in the parent hierarchy with the specified `id` */
			FindParent(id: string): Eto.Forms.Container;

			/**
			 * Detaches the control by removing it from its parent
			 *
			 * This is essentially a shortcut to myControl.Parent.Remove(myControl);
			 */
			Detach(): void;

			/**
			 * Attaches the control for direct use in a native application
			 *
			 * Use this to use a control directly in a native application.  Note that the native
			 * application must be running the same framework as the current platform.  E.g. a
			 * WinForms application can use an Eto.Forms control when using the Eto.WinForms
			 * platform.  This prepares the control by firing the {@link Eto.Forms.Control.PreLoad},
			 * {@link Eto.Forms.Control.Load}, etc. events.
			 */
			AttachNative(): void;

			/**
			 * Detaches the control when it is used in a native application, when you want to reuse
			 * the control.
			 *
			 * This should only be called after {@link Eto.Forms.Control.AttachNative} has been
			 * called, which is usually done by calling to ToNative(true) .
			 */
			DetachNative(): void;

			/**
			 * Attempts to set the keyboard input focus to this control, or the first child that
			 * accepts focus. For Windows, this will bring it to front and activate it.
			 */
			Focus(): void;

			/**
			 * Suspends the layout of child controls
			 *
			 * This can be used to optimize some platforms while adding, removing, or changing many
			 * child controls at once. It disables the calculation of control positioning until
			 * {@link Eto.Forms.Control.ResumeLayout} is called. Each call to SuspendLayout() must be
			 * balanced with a call to {@link Eto.Forms.Control.ResumeLayout}.
			 */
			SuspendLayout(): void;

			/**
			 * Resumes the layout after it has been suspended, and performs a layout
			 *
			 * This can be used to optimize some platforms while adding, removing, or changing many
			 * child controls at once. Each call to ResumeLayout() must be balanced with a call to
			 * {@link Eto.Forms.Control.SuspendLayout} before it.
			 */
			ResumeLayout(): void;

			/**
			 * Specifies a command to execute for a platform-specific command
			 *
			 * Some platforms have specific system-defined commands that can be associated with a
			 * control. For example, the Mac platform's cut/copy/paste functionality is defined by
			 * the system, and if you want to hook into it, you can use this to map it to your own
			 * defined logic. The valid values of the `systemCommand` parameter are defined by each
			 * platform, and a list can be retrieved using
			 * {@link Eto.Forms.Control.SupportedPlatformCommands}
			 */
			MapPlatformCommand(
				systemCommand: string,
				command: Eto.Forms.Command,
			): void;

			/** Converts a point from screen space to control space. */
			PointFromScreen(point: Eto.Drawing.PointF): Eto.Drawing.PointF;

			/** Converts a point from control space to screen space */
			PointToScreen(point: Eto.Drawing.PointF): Eto.Drawing.PointF;

			/** Converts a rectangle from screen space to control space. */
			RectangleToScreen(rect: Eto.Drawing.RectangleF): Eto.Drawing.RectangleF;

			/** Converts a rectangle from control space to screen space */
			RectangleFromScreen(rect: Eto.Drawing.RectangleF): Eto.Drawing.RectangleF;

			/**
			 * Starts drag operation using this control as drag source.
			 *
			 * This method can be blocking on some platforms (Wpf, WinForms), and non-blocking on
			 * others (Mac, Gtk). Use the {@link Eto.Forms.Control.DragEnd} event to determine when
			 * the drag operation is completed and get its resulting DragEffects.
			 */
			DoDragDrop(
				data: Eto.Forms.DataObject,
				allowedEffects: Eto.Forms.DragEffects,
			): void;

			/**
			 * Starts drag operation using this control as drag source.
			 *
			 * This method can be blocking on some platforms (Wpf, WinForms), and non-blocking on
			 * others (Mac, Gtk). Use the {@link Eto.Forms.Control.DragEnd} event to determine when
			 * the drag operation is completed and get its resulting DragEffects.
			 */
			DoDragDrop(
				data: Eto.Forms.DataObject,
				allowedEffects: Eto.Forms.DragEffects,
				image: Eto.Drawing.Image,
				cursorOffset: Eto.Drawing.PointF,
			): void;

			/**
			 * Triggers the StyleChanged event and re-applies the styles to this control and its
			 * children.
			 */
			TriggerStyleChanged(): void;

			/** Shows a print dialog to print the specified control */
			Print(): void;

			/**
			 * Finds a control in the parent hierarchy with the specified type and
			 * {@link Eto.Widget.ID} if specified
			 */
			FindParent<T>(id?: string): T;

			/**
			 * Finds a control in the parent hierarchy with the specified type and
			 * {@link Eto.Widget.ID} if specified
			 */
			FindParent(
				type: unknown,
				id?: string,
			): Eto.Widget;

			/** Finds a control in the parent hierarchy with the specified `id` */
			FindParent(id: string): Eto.Widget;

			/**
			 * Unbinds any bindings in the {@link Eto.Forms.BindableWidget.Bindings} collection and
			 * removes the bindings
			 *
			 * When you implement {@link Eto.Forms.IBindableWidgetContainer}, this will also unbind
			 * any of its children.
			 */
			Unbind(): void;

			/**
			 * Updates all bindings in this widget
			 *
			 * When you implement {@link Eto.Forms.IBindableWidgetContainer}, this will also update
			 * bindings for all of its children.
			 */
			UpdateBindings(mode?: Eto.Forms.BindingUpdateMode): void;

			/** Disposes of this widget, supressing the finalizer */
			dispose(): void;

			/** Gets a string that represents the current object with its ID if specified. */
			ToString(): string;
		}
	}

	export namespace Eto.Forms.WebView {
		export interface ICallback extends
			Eto.Forms.Control.ICallback,
			Eto.Widget.ICallback {
			OnNavigated(
				widget: Eto.Forms.WebView,
				e: Eto.Forms.WebViewLoadedEventArgs,
			): void;

			OnDocumentLoaded(
				widget: Eto.Forms.WebView,
				e: Eto.Forms.WebViewLoadedEventArgs,
			): void;

			OnDocumentLoading(
				widget: Eto.Forms.WebView,
				e: Eto.Forms.WebViewLoadingEventArgs,
			): void;

			OnOpenNewWindow(
				widget: Eto.Forms.WebView,
				e: Eto.Forms.WebViewNewWindowEventArgs,
			): void;

			OnDocumentTitleChanged(
				widget: Eto.Forms.WebView,
				e: Eto.Forms.WebViewTitleEventArgs,
			): void;
		}
	}

	export namespace Eto.Forms.WebView {
		export interface IHandler extends
			Eto.Forms.Control.IHandler,
			Eto.Widget.IHandler {
			Url: unknown;

			readonly CanGoBack: boolean;

			readonly CanGoForward: boolean;

			readonly DocumentTitle: string;

			BrowserContextMenuEnabled: boolean;

			LoadHtml(
				html: string,
				baseUri: unknown,
			): void;

			GoBack(): void;

			GoForward(): void;

			Stop(): void;

			Reload(): void;

			ExecuteScript(script: string): string;

			ExecuteScriptAsync(script: string): Promise<string>;

			ShowPrintDialog(): void;
		}
	}

	export namespace Eto.Forms {
		/** Enumeration of the cursor types supported by the {@link Eto.Forms.Cursor} object */
		export enum CursorType {
			/**
			 * Default cursor, which is usually an arrow but may be different depending on the
			 * control
			 */
			Default = 0,

			/** Standard arrow cursor */
			Arrow = 1,

			/** Cursor with a cross hair */
			Crosshair = 2,

			/** Pointer cursor, which is usually a hand */
			Pointer = 3,

			/** All direction move cursor */
			Move = 4,

			/** I-beam cursor for selecting text or placing the text cursor */
			IBeam = 5,

			/** Vertical sizing cursor */
			VerticalSplit = 6,

			/** Horizontal sizing cursor */
			HorizontalSplit = 7,

			/** All direction sizing cursor */
			SizeAll = 8,

			/**
			 * Left side sizing cursor, which on some platforms is the same as
			 * {@link Eto.Forms.CursorType.SizeRight}
			 */
			SizeLeft = 9,

			/**
			 * Top side sizing cursor, which on some platforms is the same as
			 * {@link Eto.Forms.CursorType.SizeBottom}
			 */
			SizeTop = 10,

			/**
			 * Right side sizing cursor, which on some platforms is the same as
			 * {@link Eto.Forms.CursorType.SizeLeft}
			 */
			SizeRight = 11,

			/**
			 * Bottom side sizing cursor, which on some platforms is the same as
			 * {@link Eto.Forms.CursorType.SizeTop}
			 */
			SizeBottom = 12,

			/**
			 * Top-left corner sizing cursor, which on some platforms is the same as
			 * {@link Eto.Forms.CursorType.SizeBottomRight}
			 */
			SizeTopLeft = 13,

			/**
			 * Top-right corner sizing cursor, which on some platforms is the same as
			 * {@link Eto.Forms.CursorType.SizeBottomLeft}
			 */
			SizeTopRight = 14,

			/**
			 * Bottom-left corner sizing cursor, which on some platforms is the same as
			 * {@link Eto.Forms.CursorType.SizeTopRight}
			 */
			SizeBottomLeft = 15,

			/**
			 * Bottom-right corner sizing cursor, which on some platforms is the same as
			 * {@link Eto.Forms.CursorType.SizeTopLeft}
			 */
			SizeBottomRight = 16,
		}
	}

	export namespace Eto.Forms {
		/**
		 * Class for a particular Mouse cursor type
		 *
		 * This can be used to specify a cursor for a particular control using
		 * {@link Eto.Forms.Control.Cursor}
		 */
		export class Cursor implements
			Eto.IHandlerSource {
			/**
			 * Initializes a new instance of the {@link Eto.Forms.Cursor} class with the specified
			 * `type`.
			 */
			constructor(type: Eto.Forms.CursorType);

			/**
			 * Initializes a new instance of the Cursor class by loading the specified .cur
			 * `fileName`
			 */
			constructor(fileName: string);

			/**
			 * Initializes a new instance of the Cursor class by loading a cursor from the specified
			 * `stream`
			 */
			constructor(stream: Duplex);

			/** Initializes a new instance of the Cursor with the specified `image` and `hotspot`. */
			constructor(
				image: Eto.Drawing.Bitmap,
				hotspot: Eto.Drawing.PointF,
			);

			/** Initializes a new instance of the Cursor with the specified `image` and `hotspot`. */
			constructor(
				image: Eto.Drawing.Icon,
				hotspot: Eto.Drawing.PointF,
			);

			constructor(handler: Eto.Forms.Cursor.IHandler);

			/**
			 * Gets the platform that was used to create the {@link Eto.Widget.Handler} for this
			 * widget
			 *
			 * This gets set to the current {@link Eto.Platform.Instance} during the construction of
			 * the object
			 */
			readonly Platform: Eto.Platform;

			/** Gets the platform-specific handler for this widget */
			Handler: unknown;

			/** Gets the native platform-specific handle for integration purposes */
			readonly NativeHandle: unknown;

			/** Gets the dictionary of properties for this widget */
			readonly Properties: Eto.PropertyStore;

			/** Gets or sets the ID of this widget */
			ID: string;

			/**
			 * Gets or sets the style of this widget
			 *
			 * Styles allow you to attach custom platform-specific logic to a widget. In your
			 * platform-specific assembly, use {@link Style.Add{H}(string, StyleHandler{H})} to add
			 * the style logic with the same id.
			 */
			Style: string;

			/**
			 * Gets the instance of the platform-specific object
			 *
			 * This can sometimes be useful to get the platform-specific object. Some handlers may
			 * not have any backing object for its functionality, so this may be null.  It is more
			 * preferred to use the {@link Eto.Widget.Handler} and cast that to the platform-specific
			 * handler class which can give you additional methods and helpers to do common tasks.
			 * For example, the {@link Eto.Forms.Application} object's handler for OS X has a
			 * AddFullScreenMenuItem property to specify if you want full screen support in your app.
			 */
			readonly ControlObject: unknown;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Widget} has been disposed.
			 *
			 * When the widget is disposed, it can no longer be used.
			 */
			IsDisposed: boolean;

			/** Loads a cursor from the resource in the specified or caller's `assembly` */
			static FromResource(
				resourceName: string,
				assembly?: unknown,
			): Eto.Forms.Cursor;

			/** Loads a bitmap from a resource in the same assembly as the specified `type` */
			static FromResource(
				resourceName: string,
				type: unknown,
			): Eto.Forms.Cursor;

			/** Disposes of this widget, supressing the finalizer */
			dispose(): void;

			/** Gets a string that represents the current object with its ID if specified. */
			ToString(): string;
		}
	}

	export namespace Eto.Forms.Cursor {
		export interface IHandler extends Eto.Widget.IHandler {
			Create(type: Eto.Forms.CursorType): void;

			Create(
				image: Eto.Drawing.Image,
				hotspot: Eto.Drawing.PointF,
			): void;

			Create(fileName: string): void;

			Create(stream: Duplex): void;
		}
	}

	export namespace Eto.Forms {
		/**
		 * Provides direct access to a cached set of cursors for use within your application
		 *
		 * This provides a preferred method of getting cursors as opposed to creating new
		 * instances directly via {@link Eto.Forms.Cursor}, as it will cache the cursors and only
		 * create one shared instance.
		 */
		export namespace Cursors {
			/**
			 * Default cursor, which is usually an arrow but may be different depending on the
			 * control
			 */
			export const Default: Eto.Forms.Cursor;

			/** Standard arrow cursor */
			export const Arrow: Eto.Forms.Cursor;

			/** Cursor with a cross hair */
			export const Crosshair: Eto.Forms.Cursor;

			/** Pointer cursor, which is usually a hand */
			export const Pointer: Eto.Forms.Cursor;

			/** All direction move cursor */
			export const Move: Eto.Forms.Cursor;

			/** I-beam cursor for selecting text or placing the text cursor */
			export const IBeam: Eto.Forms.Cursor;

			/** Vertical sizing cursor */
			export const VerticalSplit: Eto.Forms.Cursor;

			/** Horizontal sizing cursor */
			export const HorizontalSplit: Eto.Forms.Cursor;

			/** All direction sizing cursor */
			export const SizeAll: Eto.Forms.Cursor;

			/**
			 * Left side sizing cursor, which on some platforms is the same as
			 * {@link Eto.Forms.Cursors.SizeRight}
			 */
			export const SizeLeft: Eto.Forms.Cursor;

			/**
			 * Top side sizing cursor, which on some platforms is the same as
			 * {@link Eto.Forms.Cursors.SizeBottom}
			 */
			export const SizeTop: Eto.Forms.Cursor;

			/**
			 * Right side sizing cursor, which on some platforms is the same as
			 * {@link Eto.Forms.Cursors.SizeLeft}
			 */
			export const SizeRight: Eto.Forms.Cursor;

			/**
			 * Bottom side sizing cursor, which on some platforms is the same as
			 * {@link Eto.Forms.Cursors.SizeTop}
			 */
			export const SizeBottom: Eto.Forms.Cursor;

			/**
			 * Top-left corner sizing cursor, which on some platforms is the same as
			 * {@link Eto.Forms.Cursors.SizeBottomRight}
			 */
			export const SizeTopLeft: Eto.Forms.Cursor;

			/**
			 * Top-right corner sizing cursor, which on some platforms is the same as
			 * {@link Eto.Forms.Cursors.SizeBottomLeft}
			 */
			export const SizeTopRight: Eto.Forms.Cursor;

			/**
			 * Bottom-left corner sizing cursor, which on some platforms is the same as
			 * {@link Eto.Forms.Cursors.SizeTopRight}
			 */
			export const SizeBottomLeft: Eto.Forms.Cursor;

			/**
			 * Bottom-right corner sizing cursor, which on some platforms is the same as
			 * {@link Eto.Forms.Cursors.SizeTopLeft}
			 */
			export const SizeBottomRight: Eto.Forms.Cursor;

			/** Gets a cached cursor with the specified `type` */
			export function Cached(type: Eto.Forms.CursorType): Eto.Forms.Cursor;

			/**
			 * Clears the cursor cache
			 *
			 * This is useful if you are using the
			 * {@link Eto.Forms.Cursors.Cached(Eto.Forms.CursorType)} method to cache pens and want
			 * to clear it to conserve memory or resources.
			 */
			export function ClearCache(): void;
		}
	}

	export namespace Eto.Forms {
		/** Provides access to common data formats in a {@link Eto.Forms.DataObject}. */
		export namespace DataFormats {
			/** Gets the data format used for plain text */
			export const Text: string;

			/** Gets the data format used for html */
			export const Html: string;

			/** Gets the data format used for a color object */
			export const Color: string;
		}
	}

	export namespace Eto.Forms.DataFormats {
		export interface IHandler {
			readonly Text: string;

			readonly Html: string;

			readonly Color: string;
		}
	}

	export namespace Eto.Forms {
		/**
		 * Interface to allow you to share common code with {@link Eto.Forms.Clipboard} and
		 * {@link Eto.Forms.DataObject}.
		 */
		export interface IDataObject {
			/** Gets the type id's for each type of data in the data object. */
			readonly Types: string[];

			/**
			 * Gets a value indicating whether this {@link Eto.Forms.IDataObject} contains a value
			 * for {@link Eto.Forms.IDataObject.Text}.
			 */
			readonly ContainsText: boolean;

			/**
			 * Gets a value indicating whether this {@link Eto.Forms.IDataObject} contains a value
			 * for {@link Eto.Forms.IDataObject.Html}.
			 */
			readonly ContainsHtml: boolean;

			/**
			 * Gets a value indicating whether this {@link Eto.Forms.IDataObject} contains a value
			 * for {@link Eto.Forms.IDataObject.Image}.
			 */
			readonly ContainsImage: boolean;

			/**
			 * Gets a value indicating whether this {@link Eto.Forms.IDataObject} contains a value
			 * for {@link Eto.Forms.IDataObject.Uris}.
			 *
			 * This can be a mix of both URL and File objects.  You can use {@link System.Uri.IsFile}
			 * to test for that. On some platforms, (e.g. windows), only a single URL can be
			 * retrieved or set.
			 */
			readonly ContainsUris: boolean;

			/** Gets or sets the plain text in the data object. */
			Text: string;

			/** Gets or sets html text in the data object. */
			Html: string;

			/** Gets or sets an image in the data object. */
			Image: Eto.Drawing.Image;

			/**
			 * Gets or sets the Uri's of the files in the data object.
			 *
			 * This can be a mix of both URL and File objects.  You can use {@link System.Uri.IsFile}
			 * to test for that. On some platforms, (e.g. windows), only a single URL can be
			 * retrieved or set.
			 */
			Uris: unknown[];

			/**
			 * Sets a string into the data object with the specified type identifier.
			 *
			 * This is useful when setting alternate string values into the data object that are not
			 * plain text. If you are storing plain text, use the {@link Eto.Forms.IDataObject.Text}
			 * property instead.
			 */
			SetString(
				value: string,
				type: string,
			): void;

			/** sets a data array into the data object with the specified type identifier. */
			SetData(
				value: number[],
				type: string,
			): void;

			/** Gets a string from the data object with the specified type identifier. */
			GetString(type: string): string;

			/**
			 * Gets a value indicating that data with the specified type is contained in the data
			 * object.
			 */
			Contains(type: string): boolean;

			/** Gets a data array from the data object with the specified type identifier. */
			GetData(type: string): number[];

			/** Clears the data object completely of all values */
			Clear(): void;

			/**
			 * Sets the `value` into the data object with the specified `type` using serialization or
			 * type converter
			 *
			 * The object specified must be serializable or have a type converter to convert to a
			 * string.
			 */
			SetObject(
				value: unknown,
				type: string,
			): void;

			/**
			 * Gets an object from the data object with the specified type
			 *
			 * This is useful when you know the type of object, and it is serializable or has a type
			 * converter to convert from string. If it cannot be converted it will return the default
			 * value.
			 */
			GetObject<T>(type: string): T;

			/** Gets a serialized value with the specified `type` identifier. */
			GetObject(type: string): unknown;

			/**
			 * Gets an object from the data object with the specified type
			 *
			 * This is useful when you know the type of object, and it is serializable or has a type
			 * converter to convert from string. If it cannot be converted it will return the default
			 * value.
			 */
			GetObject(
				type: string,
				objectType: unknown,
			): unknown;
		}
	}

	export namespace Eto.Forms {
		/** Drag/Drop action data. */
		export class DataObject implements
			Eto.IHandlerSource,
			Eto.Forms.IDataObject {
			/** Initializes a new instance of the {@link Eto.Forms.DataObject} class. */
			constructor();

			constructor(handler: Eto.Forms.DataObject.IHandler);

			/**
			 * Gets the types of data in the data object to be used with
			 * {@link Eto.Forms.DataObject.GetString(System.String)} and
			 * {@link Eto.Forms.DataObject.GetData(System.String)}
			 */
			readonly Types: string[];

			/**
			 * Gets a value indicating whether this {@link Eto.Forms.DataObject} contains a value for
			 * {@link Eto.Forms.DataObject.Text}.
			 */
			readonly ContainsText: boolean;

			/**
			 * Gets a value indicating whether this {@link Eto.Forms.DataObject} contains a value for
			 * {@link Eto.Forms.DataObject.Html}.
			 */
			readonly ContainsHtml: boolean;

			/**
			 * Gets a value indicating whether this {@link Eto.Forms.DataObject} contains a value for
			 * {@link Eto.Forms.DataObject.Image}.
			 */
			readonly ContainsImage: boolean;

			/**
			 * Gets a value indicating whether this {@link Eto.Forms.DataObject} contains a value for
			 * {@link Eto.Forms.DataObject.Uris}.
			 *
			 * This can be a mix of both URL and File objects.  You can use {@link System.Uri.IsFile}
			 * to test for that. On some platforms, (e.g. windows), only a single URL can be
			 * retrieved or set.
			 */
			readonly ContainsUris: boolean;

			/** Gets or sets the plain text in the data object. */
			Text: string;

			/** Gets or sets html text in the data object. */
			Html: string;

			/** Gets or sets an image in the data object. */
			Image: Eto.Drawing.Image;

			/** Gets or sets the Uri's of the files in the data object */
			Uris: unknown[];

			/**
			 * Gets the platform that was used to create the {@link Eto.Widget.Handler} for this
			 * widget
			 *
			 * This gets set to the current {@link Eto.Platform.Instance} during the construction of
			 * the object
			 */
			readonly Platform: Eto.Platform;

			/** Gets the platform-specific handler for this widget */
			Handler: unknown;

			/** Gets the native platform-specific handle for integration purposes */
			readonly NativeHandle: unknown;

			/** Gets the dictionary of properties for this widget */
			readonly Properties: Eto.PropertyStore;

			/** Gets or sets the ID of this widget */
			ID: string;

			/**
			 * Gets or sets the style of this widget
			 *
			 * Styles allow you to attach custom platform-specific logic to a widget. In your
			 * platform-specific assembly, use {@link Style.Add{H}(string, StyleHandler{H})} to add
			 * the style logic with the same id.
			 */
			Style: string;

			/**
			 * Gets the instance of the platform-specific object
			 *
			 * This can sometimes be useful to get the platform-specific object. Some handlers may
			 * not have any backing object for its functionality, so this may be null.  It is more
			 * preferred to use the {@link Eto.Widget.Handler} and cast that to the platform-specific
			 * handler class which can give you additional methods and helpers to do common tasks.
			 * For example, the {@link Eto.Forms.Application} object's handler for OS X has a
			 * AddFullScreenMenuItem property to specify if you want full screen support in your app.
			 */
			readonly ControlObject: unknown;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Widget} has been disposed.
			 *
			 * When the widget is disposed, it can no longer be used.
			 */
			IsDisposed: boolean;

			/** Sets a string into the data object with the specified custom type. */
			SetString(
				value: string,
				type: string,
			): void;

			/** Sets a data stream into the clipboard with the specified type identifier. */
			SetDataStream(
				stream: Duplex,
				type: string,
			): void;

			/**
			 * Sets the `value` into the data object with the specified `type` using serialization or
			 * type converter
			 *
			 * The object specified must be serializable or have a type converter to convert to a
			 * string.
			 */
			SetObject(
				value: unknown,
				type: string,
			): void;

			/**
			 * Gets an object from the data object with the specified type
			 *
			 * This is useful when you know the type of object, and it is serializable or has a type
			 * converter to convert from string. If it cannot be converted it will return the default
			 * value.
			 */
			GetObject<T>(type: string): T;

			/** Gets a serialized value with the specified `type` identifier. */
			GetObject(type: string): unknown;

			/**
			 * Gets an object from the data object with the specified type
			 *
			 * This is useful when you know the type of object, and it is serializable or has a type
			 * converter to convert from string. If it cannot be converted it will return the default
			 * value.
			 */
			GetObject(
				type: string,
				objectType: unknown,
			): unknown;

			/** Sets a data array for the specified type identifier. */
			SetData(
				value: number[],
				type: string,
			): void;

			/**
			 * Gets a value indicating that data with the specified type is contained in the data
			 * object.
			 */
			Contains(type: string): boolean;

			/** Gets a string from the data object with the specified type identifier. */
			GetString(type: string): string;

			/** Gets the data stream with the specified type identifier. */
			GetDataStream(type: string): Duplex;

			/** Gets a byte array from the data object with the specified type identifier. */
			GetData(type: string): number[];

			/** Clears the data object */
			Clear(): void;

			/** Disposes of this widget, supressing the finalizer */
			dispose(): void;

			/** Gets a string that represents the current object with its ID if specified. */
			ToString(): string;
		}
	}

	export namespace Eto.Forms.DataObject {
		export interface IHandler extends
			Eto.Widget.IHandler,
			Eto.Forms.IDataObject {
			TrySetObject(
				value: unknown,
				type: string,
			): boolean;

			TryGetObject(
				type: string,
				objectType: unknown,
			): unknown | undefined;
		}
	}

	export namespace Eto.Forms {
		/**
		 * [Generic type factory] Translates an {@link Eto.Forms.IDataStore<>} to a read-only
		 * {@link System.Collections.Generic.IList<>}
		 *
		 * This is typically used to pass the data store to controls that require a standard
		 * collection
		 */
		export function DataStoreVirtualCollection$(T: IType): typeof DataStoreVirtualCollection$1<any>;

		/**
		 * Translates an {@link Eto.Forms.IDataStore<>} to a read-only
		 * {@link System.Collections.Generic.IList<>}
		 *
		 * This is typically used to pass the data store to controls that require a standard
		 * collection
		 */
		export class DataStoreVirtualCollection$1<T> {
			/**
			 * Initializes a new instance of the {@link Eto.Forms.DataStoreVirtualCollection<>}
			 * class.
			 */
			new(store: Eto.Forms.IDataStore$1<T>): DataStoreVirtualCollection$1<T>;

			/** Gets the count of items in this collection */
			readonly Count: number;

			/** Gets a value indicating whether this instance is read only. */
			readonly IsReadOnly: boolean;

			/** Gets a value indicating whether this instance is fixed size. */
			readonly IsFixedSize: boolean;

			/** Gets a value indicating whether this instance is synchronized. */
			readonly IsSynchronized: boolean;

			/** Gets the sync root. */
			readonly SyncRoot: unknown;

			/** Determines the index of a specific item in the collection. */
			IndexOf(item: T): number;

			/**
			 * Inserts an item at the specified index. This collection is read-only so this throws an
			 * exception.
			 */
			Insert(
				index: number,
				item: T,
			): void;

			/**
			 * Removes the item at the specified index. This collection is read-only so this throws
			 * an exception.
			 */
			RemoveAt(index: number): void;

			/**
			 * Adds an item to the current collection. This collection is read-only so this throws an
			 * exception.
			 */
			Add(item: T): void;

			/**
			 * Clears all items from the collection. This collection is read-only so this throws an
			 * exception.
			 */
			Clear(): void;

			/** Determines whether the current collection contains a specific value. */
			Contains(item: T): boolean;

			CopyTo(
				array: T[],
				arrayIndex: number,
			): void;

			/**
			 * Remove the specified item. This collection is read-only so this throws an exception.
			 */
			Remove(item: T): boolean;

			/** Gets the enumerator for the collection */
			GetEnumerator(): unknown;

			/** Adds an item to the current collection. */
			Add(value: unknown): number;

			/** Determines whether the current collection contains a specific value. */
			Contains(value: unknown): boolean;

			/** Determines the index of a specific item in the current instance. */
			IndexOf(value: unknown): number;

			/** Insert a value into the collection with the specified index */
			Insert(
				index: number,
				value: unknown,
			): void;

			/** Removes the first occurrence of an item from the current collection. */
			Remove(value: unknown): void;

			/**
			 * Copies the contents of the collection to the specified array starting at the specified
			 * index
			 */
			CopyTo(
				array: unknown,
				index: number,
			): void;
		}
	}

	export namespace Eto.Forms {
		/**
		 * Hint to tell the platform how to display the dialog
		 *
		 * This tells the platform how you prefer to display the dialog.  Each platform may
		 * support only certain modes and will choose the appropriate mode based on the hint
		 * given.
		 */
		export enum DialogDisplayMode {
			/**
			 * The default display mode for modal dialogs in the platform
			 *
			 * This uses the ideal display mode given the state of the application and the owner
			 * window that is passed in
			 */
			Default = 0,

			/** Display the dialog attached to the owner window, if supported (e.g. OS X) */
			Attached = 1,

			/**
			 * Display the dialog as a separate window (e.g. Windows/Linux only supports this mode)
			 */
			Separate = 2,

			/** Display in navigation if available */
			Navigation = 4,
		}
	}

	export namespace Eto.Forms {
		/**
		 * [Generic type factory] Custom modal dialog with a specified result type
		 *
		 * This provides a way to show a modal dialog with custom contents to the user. A dialog
		 * will block user input from the owner form until the dialog is closed.
		 */
		export function Dialog$(T: IType): typeof Dialog$1<any>;

		/**
		 * Custom modal dialog with a specified result type
		 *
		 * This provides a way to show a modal dialog with custom contents to the user. A dialog
		 * will block user input from the owner form until the dialog is closed.
		 */
		export class Dialog$1<T> implements
			Eto.IHandlerSource,
			Eto.Forms.IBindable,
			Eto.Forms.IMouseInputSource,
			Eto.Forms.IKeyboardInputSource {
			new(): Dialog$1<T>;

			/** Gets or sets the result of the dialog */
			Result: T;

			/** Gets or sets the display mode hint */
			DisplayMode: Eto.Forms.DialogDisplayMode;

			/**
			 * Gets or sets the abort button.
			 *
			 * On some platforms, the abort button would be called automatically if the user presses
			 * the escape key
			 */
			AbortButton: Eto.Forms.Button;

			/**
			 * Gets or sets the default button.
			 *
			 * On some platforms, the abort button would be called automatically if the user presses
			 * the return key on the form
			 */
			DefaultButton: Eto.Forms.Button;

			/**
			 * Gets the positive buttons list, these buttons are automatically added to the dialog.
			 *
			 * Depending on the platform these buttons can be added on the left side or the right
			 * side. The lower the index the closer the button is to the edge.
			 */
			readonly PositiveButtons: unknown;

			/**
			 * Gets the negative buttons list, these buttons are automatically added to the dialog.
			 *
			 * Depending on the platform these buttons can be added on the left side or the right
			 * side. The lower the index the closer the button is to the edge.
			 */
			readonly NegativeButtons: unknown;

			/**
			 * Gets or sets the title of the window
			 *
			 * The title of the window is displayed to the user usually at the top of the window, but
			 * in cases where you show a window in a mobile environment, this may be the title shown
			 * in a navigation controller.
			 */
			Title: string;

			/**
			 * Gets or sets the location of the window
			 *
			 * Note that in multi-monitor setups, the origin of the location is at the upper-left of
			 * {@link Eto.Forms.Screen.PrimaryScreen}.  Also note, that on Linux systems running GTK
			 * via Wayland, this will always point to 0, 0 , and setting it to different values will
			 * have no effect.
			 */
			Location: Eto.Drawing.Point;

			/** Gets or sets the size and location of the window */
			Bounds: Eto.Drawing.Rectangle;

			/**
			 * Gets or sets the tool bar for the window.
			 *
			 * Note that each window can only have a single tool bar
			 */
			ToolBar: Eto.Forms.ToolBar;

			/** Gets or sets the opacity of the window */
			Opacity: number;

			/**
			 * Gets or sets the owner of this window.
			 *
			 * This sets the parent window that has ownership over this window. For a
			 * {@link Eto.Forms.Dialog}, this will be the window that will be disabled while the
			 * modal dialog is shown. With a {@link Eto.Forms.Form}, the specified owner will always
			 * be below the current window when shown, and will  still be responsive to user input.
			 * Typically, but not always, the window will move along with the owner.
			 */
			Owner: Eto.Forms.Window;

			/**
			 * Gets the screen this window is mostly contained in. Typically defined by the screen
			 * center of the window is visible.
			 */
			readonly Screen: Eto.Forms.Screen;

			/**
			 * Gets or sets the menu bar for this window
			 *
			 * Some platforms have a global menu bar (e.g. Ubuntu, OS X). When the window is in
			 * focus, the global menu bar will be changed to reflect the menu assigned.
			 */
			Menu: Eto.Forms.MenuBar;

			/**
			 * Gets or sets the icon for the window to show in the menu bar.
			 *
			 * The icon should have many variations, such as 16x16, 24x24, 32x32, 48x48, 64x64, etc.
			 * This ensures that the many places it is used (title bar, task bar, switch window, etc)
			 * all have optimized icon sizes.  For OS X, the application icon is specified in the
			 * .app bundle, not by this value.
			 */
			Icon: Eto.Drawing.Icon;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Forms.Window} is resizable.
			 */
			Resizable: boolean;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Forms.Window} can be
			 * maximized.
			 *
			 * This may hide or disable the minimize button on the title bar.
			 */
			Maximizable: boolean;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Forms.Window} can be
			 * minimized.
			 *
			 * This may hide or disable the maximize button on the title bar.
			 */
			Minimizable: boolean;

			/**
			 * Gets or sets a value indicating whether the close button should be shown. Defaults to
			 * true
			 *
			 * Note that on some platforms (e.g. Windows) this also hides the system menu and
			 * minimize/maximize buttons. Note that this does not prevent the window from being
			 * closed, to do that use the {@link Eto.Forms.Window.Closing} event.
			 */
			Closeable: boolean;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Forms.Window} will show in the
			 * taskbar.
			 *
			 * Some platforms, e.g. macOS do not show a separate icon for each running window.  You
			 * may also have to add  the LSUIElement key to your app's Info.plist to make your app
			 * hidden in the dock.   See
			 * https://developer.apple.com/library/archive/documentation/General/Reference/InfoPlistKeyReference/Articles/LaunchServicesKeys.html#//apple_ref/doc/uid/TP40009250-108256-TPXREF136
			 */
			ShowInTaskbar: boolean;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Forms.Window} is above all
			 * other windows.
			 *
			 * The window should be above all other windows when this is true.  In some platforms,
			 * this will show above all other windows only when the application has focus.
			 */
			Topmost: boolean;

			/** Gets or sets the state of the window. */
			WindowState: Eto.Forms.WindowState;

			/**
			 * Gets the bounds of the window before it was minimized or maximized, or the current
			 * bounds if {@link Eto.Forms.Window.WindowState} is Normal.
			 *
			 * This is useful to retrieve the desired size and position of the window even though it
			 * is currently maximized or minimized.
			 */
			readonly RestoreBounds: Eto.Drawing.Rectangle;

			/** Gets or sets the style of this window. */
			WindowStyle: Eto.Forms.WindowStyle;

			/**
			 * Gets the number of pixels per logical pixel when on a high DPI display.
			 *
			 * This indicates the number of pixels per logical pixel.   All units in Eto.Forms such
			 * as control size, drawing operations, etc are in logical pixels. When not in high DPI,
			 * this will be 1.0;  Retina displays in OS X will return 2; and in windows this matches
			 * the scale set in the monitor settings.  Use the
			 * {@link Eto.Forms.Window.LogicalPixelSizeChanged} to detect when the window is moved to
			 *  a display with a different DPI.
			 */
			readonly LogicalPixelSize: number;

			/**
			 * Gets or sets a value indicating that the window can be moved by click+dragging the
			 * window background
			 */
			MovableByWindowBackground: boolean;

			/**
			 * Gets or sets a value indicating that the window will automatically resize when its
			 * content changes
			 *
			 * Note that if you set both dimensions of the {@link Eto.Drawing.Size} and/or
			 * {@link Eto.Forms.Container.ClientSize}, this will be set to false.
			 */
			AutoSize: boolean;

			/** Gets an enumeration of controls that are directly contained by this container */
			readonly Controls: Iterable<Eto.Forms.Control>;

			/** Gets or sets the padding around the {@link Eto.Forms.Panel.Content} of the panel. */
			Padding: Eto.Drawing.Padding;

			/** Gets or sets the minimum size of the panel. */
			MinimumSize: Eto.Drawing.Size;

			/**
			 * Gets or sets the context menu for the panel.
			 *
			 * The context menu is usually shown when the user right clicks the control, or in mobile
			 * platforms when the user taps and holds their finger down on the control.
			 */
			ContextMenu: Eto.Forms.ContextMenu;

			/**
			 * Gets or sets the main content of the panel.
			 *
			 * The main content will be offset by the {@link Eto.Forms.Panel.Padding} value
			 * specified, and will take up the entire content area of the control. Some controls may
			 * have decorations that will surround the content, such as a {@link Eto.Forms.GroupBox},
			 * {@link Eto.Forms.TabControl}, or {@link Eto.Forms.Window}
			 */
			Content: Eto.Forms.Control;

			/**
			 * Gets or sets the size for the client area of the control
			 *
			 * The client size differs from the {@link Eto.Forms.Control.Size} in that it excludes
			 * the decorations of the container, such as the title bar and border around a
			 * {@link Eto.Forms.Window}, or the title and line  around a {@link Eto.Forms.GroupBox}.
			 */
			ClientSize: Eto.Drawing.Size;

			/**
			 * Gets an enumeration of all contained child controls, including controls within child
			 * containers
			 */
			readonly Children: Iterable<Eto.Forms.Control>;

			/**
			 * Gets an enumeration of all contained child controls in the visual tree, including
			 * controls within child containers.
			 */
			readonly VisualChildren: Iterable<Eto.Forms.Control>;

			/**
			 * Gets or sets the style provider for this container.
			 *
			 * The style provider is used to style this container and its children.
			 */
			StyleProvider: Eto.IStyleProvider;

			/**
			 * Gets the default style provider for this container.
			 *
			 * Use this to apply styles to any child controls of this container. By default, styles
			 * will apply to all children, including children of children unless
			 * {@link Eto.DefaultStyleProvider.Inherit} is set to false .  Typically, you would set
			 * Inherit to false when creating composite controls that already have all their styles
			 * applied and you don't want any other styles to be inherited.
			 */
			readonly Styles: Eto.DefaultStyleProvider;

			/**
			 * Gets a value indicating that the control is loaded onto a form, that is it has been
			 * created, added to a parent, and shown
			 *
			 * The {@link Eto.Forms.Control.OnLoad(System.EventArgs)} method sets this value to true
			 * after cascading to all children (for a {@link Eto.Forms.Container} ) and calling the
			 * platform handler's implementation.  It is called after adding to a loaded form, or
			 * when showing a new form.  The {@link Eto.Forms.Control.OnUnLoad(System.EventArgs)}
			 * method will set this value to false when the control is removed from its parent
			 */
			readonly Loaded: boolean;

			/**
			 * Gets an enumeration of controls that are in the visual tree.
			 *
			 * This is used to specify which controls are contained by this instance that are part of
			 * the visual tree. This should include all controls including non-logical Eto controls
			 * used for layout.
			 */
			readonly VisualControls: Iterable<Eto.Forms.Control>;

			/**
			 * Gets or sets a user-defined object that contains data about the control
			 *
			 * A common use of the tag property is to store data that is associated with the control
			 * that you can later retrieve.
			 */
			Tag: unknown;

			/**
			 * Gets the logical parent control.
			 *
			 * When the control is part of the visual tree (
				 * {@link Eto.Forms.Control.IsVisualControl} is true), this returns the logical parent
				 * that contains this control. Otherwise this is the same as
				 * {@link Eto.Forms.Control.Parent}.
				 */
				readonly LogicalParent: Eto.Forms.Container;

			/** Gets a value indicating this {@link Eto.Forms.Control} is part of the visual tree. */
			IsVisualControl: boolean;

			/**
			 * Gets or sets the size of the control. Use -1 to specify auto sizing for either the
			 * width and/or height.
			 *
			 * Setting the size of controls is entirely optional as most controls will size
			 * themselves appropriately. When specifying a size, it will be used as the desired size
			 * of the control.  The container will reposition and resize the control depending on the
			 * available size.  For a {@link Eto.Forms.Window}, it is preferred to set the
			 * {@link Eto.Forms.Container.ClientSize} instead, as various platforms have different
			 * sizes of window decorations, toolbars, etc.
			 */
			Size: Eto.Drawing.Size;

			/**
			 * Gets a value indicating this control currently has mouse capture
			 *
			 * Mouse capture can happen during a handled MouseDown event until MouseUp, or it can be
			 * captured explicitly via {@link Eto.Forms.Control.CaptureMouse}.
			 */
			readonly IsMouseCaptured: boolean;

			/** Gets or sets the width of the control size. */
			Width: number;

			/** Gets or sets the height of the control size. */
			Height: number;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Forms.Control} (or its
			 * children) are enabled and accept user input.
			 *
			 * Typically when a control is disabled, the user cannot do anything with the control or
			 * any of its children. Including for example, selecting text in a text control. Certain
			 * controls can have a 'Read Only' mode, such as {@link Eto.Forms.TextBox.ReadOnly} which
			 * allow the user to  select text, but not change its contents.
			 */
			Enabled: boolean;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Forms.Control} is visible to
			 * the user.
			 *
			 * When the visibility of a control is set to false, it will not occupy space in the
			 * layout.
			 */
			Visible: boolean;

			/** Gets the container which this control has been added to, if any */
			readonly Parent: Eto.Forms.Container;

			/**
			 * Gets the visual container of this control, if any.
			 *
			 * Some containers may use other Eto controls to layout its children, such as the
			 * {@link Eto.Forms.StackLayout}. This will return the parent control that visually
			 * contains this control as opposed to {@link Eto.Forms.Control.Parent} which will return
			 * the logical parent.
			 */
			VisualParent: Eto.Forms.Container;

			/** Gets a value indicating this control has been attached to a native container */
			readonly IsAttached: boolean;

			/**
			 * Gets or sets the color for the background of the control
			 *
			 * Note that on some platforms (e.g. Mac), setting the background color of a control can
			 * change the performance characteristics of the control and its children, since it must
			 * enable layers to do so.
			 */
			BackgroundColor: Eto.Drawing.Color;

			/** Gets a value indicating whether this instance has the keyboard input focus. */
			readonly HasFocus: boolean;

			/** Gets a value indicating whether the layout of child controls is suspended. */
			readonly IsSuspended: boolean;

			/** Gets the window this control is contained in */
			readonly ParentWindow: Eto.Forms.Window;

			/**
			 * Gets the supported platform commands that can be used to hook up system functions to
			 * user defined logic
			 *
			 * This lists all available commands that can be mapped using the
			 * {@link Eto.Forms.Control.MapPlatformCommand(System.String,Eto.Forms.Command)} method
			 * of the control.
			 */
			readonly SupportedPlatformCommands: Iterable<string>;

			/** Gets or sets the type of cursor to use when the mouse is hovering over the control */
			Cursor: Eto.Forms.Cursor;

			/** Gets or sets the tool tip to show when the mouse is hovered over the control */
			ToolTip: string;

			/**
			 * Gets or sets the tab index order for this control within its container.
			 *
			 * This sets the order when using the tab key to cycle through controls  Note that some
			 * platforms (Gtk and WinForms) may not support setting the context of the tab order to
			 * StackLayout  or DynamicLayout containers and may not behave exactly as expected. Use
			 * the {@link Eto.PlatformFeatures.TabIndexWithCustomContainers} flag to determine if it
			 * is supported.
			 */
			TabIndex: number;

			/** Gets or sets a value indicating whether this control can serve as drop target. */
			AllowDrop: boolean;

			/**
			 * Gets or sets the parent widget which this widget has been added to, if any
			 *
			 * When implementing child widgets that can participate in the context based binding
			 * (MVVM), You can set this to the parent widget when it is added or removed to it
			 * (usually via a collection).  Note that you should typically provide a public new
			 * [ParentWidget] Parent { get; } property  so that consumers of your API cannot set the
			 * parent to an invalid value.
			 */
			Parent: Eto.Widget;

			/**
			 * Gets an enumeration of all parent widgets in the heirarchy by traversing the
			 * {@link Eto.Forms.BindableWidget.Parent} property.
			 */
			readonly Parents: Iterable<Eto.Widget>;

			/**
			 * Gets or sets the data context for this widget for binding
			 *
			 * Subclasses may override the standard behaviour so that hierarchy of widgets can be
			 * taken into account.  For example, a Control may return the data context of a parent,
			 * if it is not set explicitly.
			 */
			DataContext: unknown;

			/** Gets the collection of bindings that are attached to this widget */
			readonly Bindings: Eto.Forms.BindingCollection;

			/**
			 * Gets a value indicating that the {@link Eto.Forms.BindableWidget.DataContext} property
			 * is changing.
			 *
			 * This can be used to determine when to allow certain logic during the update of the
			 * data context.  It is used to disable binding setters on the model when the data
			 * context changes so that a binding does not cause the view model to be updated when the
			 * state hasn't been fully set yet.
			 */
			IsDataContextChanging: boolean;

			/**
			 * Gets the platform that was used to create the {@link Eto.Widget.Handler} for this
			 * widget
			 *
			 * This gets set to the current {@link Eto.Platform.Instance} during the construction of
			 * the object
			 */
			readonly Platform: Eto.Platform;

			/** Gets the platform-specific handler for this widget */
			Handler: unknown;

			/** Gets the native platform-specific handle for integration purposes */
			readonly NativeHandle: unknown;

			/** Gets the dictionary of properties for this widget */
			readonly Properties: Eto.PropertyStore;

			/** Gets or sets the ID of this widget */
			ID: string;

			/**
			 * Gets or sets the style of this widget
			 *
			 * Styles allow you to attach custom platform-specific logic to a widget. In your
			 * platform-specific assembly, use {@link Style.Add{H}(string, StyleHandler{H})} to add
			 * the style logic with the same id.
			 */
			Style: string;

			/**
			 * Gets the instance of the platform-specific object
			 *
			 * This can sometimes be useful to get the platform-specific object. Some handlers may
			 * not have any backing object for its functionality, so this may be null.  It is more
			 * preferred to use the {@link Eto.Widget.Handler} and cast that to the platform-specific
			 * handler class which can give you additional methods and helpers to do common tasks.
			 * For example, the {@link Eto.Forms.Application} object's handler for OS X has a
			 * AddFullScreenMenuItem property to specify if you want full screen support in your app.
			 */
			readonly ControlObject: unknown;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Widget} has been disposed.
			 *
			 * When the widget is disposed, it can no longer be used.
			 */
			IsDisposed: boolean;

			/** Shows the dialog and blocks until the user closes the dialog */
			ShowModal(): T;

			/** Shows the dialog modally asynchronously */
			ShowModalAsync(): Promise<T>;

			/**
			 * Shows the dialog and blocks until the user closes the dialog
			 *
			 * The `owner` specifies the control on the window that will be blocked from user input
			 * until the dialog is closed.
			 */
			ShowModal(owner: Eto.Forms.Control): T;

			/**
			 * Shows the dialog modally asynchronously
			 *
			 * The `owner` specifies the control on the window that will be blocked from user input
			 * until the dialog is closed.
			 */
			ShowModalAsync(owner: Eto.Forms.Control): Promise<T>;

			/** Close the dialog with the specified result */
			Close(result: T): void;

			/**
			 * Shows the dialog modally, blocking the current thread until it is closed.
			 *
			 * The `owner` specifies the control on the window that will be blocked from user input
			 * until the dialog is closed. Calling this method is identical to setting the
			 * {@link Eto.Forms.Window.Owner} property and calling
			 * {@link Eto.Forms.Dialog.ShowModal}.
			 */
			ShowModal(owner: Eto.Forms.Control): void;

			/** Shows the dialog modally, blocking the current thread until it is closed. */
			ShowModal(): void;

			/**
			 * Shows the dialog modally asynchronously
			 *
			 * The `owner` specifies the control on the window that will be blocked from user input
			 * until the dialog is closed. Calling this method is identical to setting the
			 * {@link Eto.Forms.Window.Owner} property and calling
			 * {@link Eto.Forms.Dialog.ShowModalAsync}.
			 */
			ShowModalAsync(owner: Eto.Forms.Control): Promise<void>;

			/** Shows the dialog modally asynchronously */
			ShowModalAsync(): Promise<void>;

			/**
			 * Closes the window
			 *
			 * Note that once a window is closed, it cannot be shown again in most platforms.
			 */
			Close(): void;

			/**
			 * Sets {@link Eto.Forms.Window.WindowState} to {@link Eto.Forms.WindowState.Minimized}
			 */
			Minimize(): void;

			/**
			 * Sets {@link Eto.Forms.Window.WindowState} to {@link Eto.Forms.WindowState.Maximized}
			 */
			Maximize(): void;

			/**
			 * Brings the window in front of all other windows in the z-order.  This should not
			 * activate/focus the window.
			 */
			BringToFront(): void;

			/**
			 * Sends the window behind all other windows in the z-order, and will remain active if it
			 * has focus.
			 */
			SendToBack(): void;

			/** Removes the specified child from the container */
			Remove(child: Eto.Forms.Control): void;

			/** Remove the specified `controls` from this container */
			Remove(controls: Iterable<Eto.Forms.Control>): void;

			/** Removes all controls from this container */
			RemoveAll(): void;

			/**
			 * Finds a child control in this container or any of its child containers with the
			 * specified `id`
			 */
			FindChild<T>(id?: string): T;

			/**
			 * Finds a child control in this container or any of its child containers with the
			 * specified `type`
			 */
			FindChild(
				type: unknown,
				id?: string,
			): Eto.Forms.Control;

			/**
			 * Finds a child control in this container or any of its child containers with the
			 * specified `id`.
			 */
			FindChild(id: string): Eto.Forms.Control;

			/**
			 * Queues a repaint of the entire control on the screen and any of its children.
			 *
			 * This is only useful when the control is visible.
			 */
			Invalidate(): void;

			/**
			 * Queues a repaint of the entire control on the screen
			 *
			 * This is only useful when the control is visible.
			 */
			Invalidate(invalidateChildren: boolean): void;

			/**
			 * Queues a repaint of the specified `rect` of the control and any children.
			 *
			 * This is only useful when the control is visible.
			 */
			Invalidate(rect: Eto.Drawing.Rectangle): void;

			/**
			 * Queues a repaint of the specified `rect` of the control
			 *
			 * This is only useful when the control is visible.
			 */
			Invalidate(
				rect: Eto.Drawing.Rectangle,
				invalidateChildren: boolean,
			): void;

			/**
			 * Updates the layout of this control if necessary.
			 *
			 * This will ensure the control has had all of its layout applied so you can use its
			 * position and size right after this call. Most platforms (except WinForms) use a
			 * deferred layout system so that after adding your control to the form dynamically it
			 * won't get laid out until the next idle loop. This is useful when you need to know the
			 * dimensions of the control immediately. Note that this can be an expensive operation,
			 * so it is recommended to only call this method when necessary and after all of the
			 * controls have been added/updated.
			 */
			UpdateLayout(): void;

			/** Gets the preferred size of this control given infinite space available. */
			GetPreferredSize(): Eto.Drawing.SizeF;

			/** Gets the preferred size of this control given the specified `availableSize`. */
			GetPreferredSize(availableSize: Eto.Drawing.SizeF): Eto.Drawing.SizeF;

			/**
			 * Captures all mouse events to this control.
			 *
			 * This captures all mouse events until {@link Eto.Forms.Control.ReleaseMouseCapture} is
			 * called.  Note that not all platforms will allow a mouse capture unless the mouse is
			 * currently down.
			 */
			CaptureMouse(): boolean;

			/** Releases the mouse capture after a call to {@link Eto.Forms.Control.CaptureMouse}. */
			ReleaseMouseCapture(): void;

			/**
			 * Finds a control in the parent hierarchy with the specified type and
			 * {@link Eto.Widget.ID} if specified
			 */
			FindParent(
				type: unknown,
				id?: string,
			): Eto.Forms.Container;

			/** Finds a control in the parent hierarchy with the specified `id` */
			FindParent(id: string): Eto.Forms.Container;

			/**
			 * Detaches the control by removing it from its parent
			 *
			 * This is essentially a shortcut to myControl.Parent.Remove(myControl);
			 */
			Detach(): void;

			/**
			 * Attaches the control for direct use in a native application
			 *
			 * Use this to use a control directly in a native application.  Note that the native
			 * application must be running the same framework as the current platform.  E.g. a
			 * WinForms application can use an Eto.Forms control when using the Eto.WinForms
			 * platform.  This prepares the control by firing the {@link Eto.Forms.Control.PreLoad},
			 * {@link Eto.Forms.Control.Load}, etc. events.
			 */
			AttachNative(): void;

			/**
			 * Detaches the control when it is used in a native application, when you want to reuse
			 * the control.
			 *
			 * This should only be called after {@link Eto.Forms.Control.AttachNative} has been
			 * called, which is usually done by calling to ToNative(true) .
			 */
			DetachNative(): void;

			/**
			 * Attempts to set the keyboard input focus to this control, or the first child that
			 * accepts focus. For Windows, this will bring it to front and activate it.
			 */
			Focus(): void;

			/**
			 * Suspends the layout of child controls
			 *
			 * This can be used to optimize some platforms while adding, removing, or changing many
			 * child controls at once. It disables the calculation of control positioning until
			 * {@link Eto.Forms.Control.ResumeLayout} is called. Each call to SuspendLayout() must be
			 * balanced with a call to {@link Eto.Forms.Control.ResumeLayout}.
			 */
			SuspendLayout(): void;

			/**
			 * Resumes the layout after it has been suspended, and performs a layout
			 *
			 * This can be used to optimize some platforms while adding, removing, or changing many
			 * child controls at once. Each call to ResumeLayout() must be balanced with a call to
			 * {@link Eto.Forms.Control.SuspendLayout} before it.
			 */
			ResumeLayout(): void;

			/**
			 * Specifies a command to execute for a platform-specific command
			 *
			 * Some platforms have specific system-defined commands that can be associated with a
			 * control. For example, the Mac platform's cut/copy/paste functionality is defined by
			 * the system, and if you want to hook into it, you can use this to map it to your own
			 * defined logic. The valid values of the `systemCommand` parameter are defined by each
			 * platform, and a list can be retrieved using
			 * {@link Eto.Forms.Control.SupportedPlatformCommands}
			 */
			MapPlatformCommand(
				systemCommand: string,
				command: Eto.Forms.Command,
			): void;

			/** Converts a point from screen space to control space. */
			PointFromScreen(point: Eto.Drawing.PointF): Eto.Drawing.PointF;

			/** Converts a point from control space to screen space */
			PointToScreen(point: Eto.Drawing.PointF): Eto.Drawing.PointF;

			/** Converts a rectangle from screen space to control space. */
			RectangleToScreen(rect: Eto.Drawing.RectangleF): Eto.Drawing.RectangleF;

			/** Converts a rectangle from control space to screen space */
			RectangleFromScreen(rect: Eto.Drawing.RectangleF): Eto.Drawing.RectangleF;

			/**
			 * Starts drag operation using this control as drag source.
			 *
			 * This method can be blocking on some platforms (Wpf, WinForms), and non-blocking on
			 * others (Mac, Gtk). Use the {@link Eto.Forms.Control.DragEnd} event to determine when
			 * the drag operation is completed and get its resulting DragEffects.
			 */
			DoDragDrop(
				data: Eto.Forms.DataObject,
				allowedEffects: Eto.Forms.DragEffects,
			): void;

			/**
			 * Starts drag operation using this control as drag source.
			 *
			 * This method can be blocking on some platforms (Wpf, WinForms), and non-blocking on
			 * others (Mac, Gtk). Use the {@link Eto.Forms.Control.DragEnd} event to determine when
			 * the drag operation is completed and get its resulting DragEffects.
			 */
			DoDragDrop(
				data: Eto.Forms.DataObject,
				allowedEffects: Eto.Forms.DragEffects,
				image: Eto.Drawing.Image,
				cursorOffset: Eto.Drawing.PointF,
			): void;

			/**
			 * Triggers the StyleChanged event and re-applies the styles to this control and its
			 * children.
			 */
			TriggerStyleChanged(): void;

			/** Shows a print dialog to print the specified control */
			Print(): void;

			/**
			 * Finds a control in the parent hierarchy with the specified type and
			 * {@link Eto.Widget.ID} if specified
			 */
			FindParent<T>(id?: string): T;

			/**
			 * Finds a control in the parent hierarchy with the specified type and
			 * {@link Eto.Widget.ID} if specified
			 */
			FindParent(
				type: unknown,
				id?: string,
			): Eto.Widget;

			/** Finds a control in the parent hierarchy with the specified `id` */
			FindParent(id: string): Eto.Widget;

			/**
			 * Unbinds any bindings in the {@link Eto.Forms.BindableWidget.Bindings} collection and
			 * removes the bindings
			 *
			 * When you implement {@link Eto.Forms.IBindableWidgetContainer}, this will also unbind
			 * any of its children.
			 */
			Unbind(): void;

			/**
			 * Updates all bindings in this widget
			 *
			 * When you implement {@link Eto.Forms.IBindableWidgetContainer}, this will also update
			 * bindings for all of its children.
			 */
			UpdateBindings(mode?: Eto.Forms.BindingUpdateMode): void;

			/** Disposes of this widget, supressing the finalizer */
			dispose(): void;

			/** Gets a string that represents the current object with its ID if specified. */
			ToString(): string;
		}
	}

	export namespace Eto.Forms {
		/**
		 * Custom modal dialog
		 *
		 * This provides a way to show a modal dialog with custom contents to the user. A dialog
		 * will block user input from the owner form until the dialog is closed.
		 */
		export class Dialog implements
			Eto.IHandlerSource,
			Eto.Forms.IBindable,
			Eto.Forms.IMouseInputSource,
			Eto.Forms.IKeyboardInputSource {
			constructor();

			/** Gets or sets the display mode hint */
			DisplayMode: Eto.Forms.DialogDisplayMode;

			/**
			 * Gets or sets the abort button.
			 *
			 * On some platforms, the abort button would be called automatically if the user presses
			 * the escape key
			 */
			AbortButton: Eto.Forms.Button;

			/**
			 * Gets or sets the default button.
			 *
			 * On some platforms, the abort button would be called automatically if the user presses
			 * the return key on the form
			 */
			DefaultButton: Eto.Forms.Button;

			/**
			 * Gets the positive buttons list, these buttons are automatically added to the dialog.
			 *
			 * Depending on the platform these buttons can be added on the left side or the right
			 * side. The lower the index the closer the button is to the edge.
			 */
			readonly PositiveButtons: unknown;

			/**
			 * Gets the negative buttons list, these buttons are automatically added to the dialog.
			 *
			 * Depending on the platform these buttons can be added on the left side or the right
			 * side. The lower the index the closer the button is to the edge.
			 */
			readonly NegativeButtons: unknown;

			/**
			 * Gets or sets the title of the window
			 *
			 * The title of the window is displayed to the user usually at the top of the window, but
			 * in cases where you show a window in a mobile environment, this may be the title shown
			 * in a navigation controller.
			 */
			Title: string;

			/**
			 * Gets or sets the location of the window
			 *
			 * Note that in multi-monitor setups, the origin of the location is at the upper-left of
			 * {@link Eto.Forms.Screen.PrimaryScreen}.  Also note, that on Linux systems running GTK
			 * via Wayland, this will always point to 0, 0 , and setting it to different values will
			 * have no effect.
			 */
			Location: Eto.Drawing.Point;

			/** Gets or sets the size and location of the window */
			Bounds: Eto.Drawing.Rectangle;

			/**
			 * Gets or sets the tool bar for the window.
			 *
			 * Note that each window can only have a single tool bar
			 */
			ToolBar: Eto.Forms.ToolBar;

			/** Gets or sets the opacity of the window */
			Opacity: number;

			/**
			 * Gets or sets the owner of this window.
			 *
			 * This sets the parent window that has ownership over this window. For a
			 * {@link Eto.Forms.Dialog}, this will be the window that will be disabled while the
			 * modal dialog is shown. With a {@link Eto.Forms.Form}, the specified owner will always
			 * be below the current window when shown, and will  still be responsive to user input.
			 * Typically, but not always, the window will move along with the owner.
			 */
			Owner: Eto.Forms.Window;

			/**
			 * Gets the screen this window is mostly contained in. Typically defined by the screen
			 * center of the window is visible.
			 */
			readonly Screen: Eto.Forms.Screen;

			/**
			 * Gets or sets the menu bar for this window
			 *
			 * Some platforms have a global menu bar (e.g. Ubuntu, OS X). When the window is in
			 * focus, the global menu bar will be changed to reflect the menu assigned.
			 */
			Menu: Eto.Forms.MenuBar;

			/**
			 * Gets or sets the icon for the window to show in the menu bar.
			 *
			 * The icon should have many variations, such as 16x16, 24x24, 32x32, 48x48, 64x64, etc.
			 * This ensures that the many places it is used (title bar, task bar, switch window, etc)
			 * all have optimized icon sizes.  For OS X, the application icon is specified in the
			 * .app bundle, not by this value.
			 */
			Icon: Eto.Drawing.Icon;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Forms.Window} is resizable.
			 */
			Resizable: boolean;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Forms.Window} can be
			 * maximized.
			 *
			 * This may hide or disable the minimize button on the title bar.
			 */
			Maximizable: boolean;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Forms.Window} can be
			 * minimized.
			 *
			 * This may hide or disable the maximize button on the title bar.
			 */
			Minimizable: boolean;

			/**
			 * Gets or sets a value indicating whether the close button should be shown. Defaults to
			 * true
			 *
			 * Note that on some platforms (e.g. Windows) this also hides the system menu and
			 * minimize/maximize buttons. Note that this does not prevent the window from being
			 * closed, to do that use the {@link Eto.Forms.Window.Closing} event.
			 */
			Closeable: boolean;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Forms.Window} will show in the
			 * taskbar.
			 *
			 * Some platforms, e.g. macOS do not show a separate icon for each running window.  You
			 * may also have to add  the LSUIElement key to your app's Info.plist to make your app
			 * hidden in the dock.   See
			 * https://developer.apple.com/library/archive/documentation/General/Reference/InfoPlistKeyReference/Articles/LaunchServicesKeys.html#//apple_ref/doc/uid/TP40009250-108256-TPXREF136
			 */
			ShowInTaskbar: boolean;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Forms.Window} is above all
			 * other windows.
			 *
			 * The window should be above all other windows when this is true.  In some platforms,
			 * this will show above all other windows only when the application has focus.
			 */
			Topmost: boolean;

			/** Gets or sets the state of the window. */
			WindowState: Eto.Forms.WindowState;

			/**
			 * Gets the bounds of the window before it was minimized or maximized, or the current
			 * bounds if {@link Eto.Forms.Window.WindowState} is Normal.
			 *
			 * This is useful to retrieve the desired size and position of the window even though it
			 * is currently maximized or minimized.
			 */
			readonly RestoreBounds: Eto.Drawing.Rectangle;

			/** Gets or sets the style of this window. */
			WindowStyle: Eto.Forms.WindowStyle;

			/**
			 * Gets the number of pixels per logical pixel when on a high DPI display.
			 *
			 * This indicates the number of pixels per logical pixel.   All units in Eto.Forms such
			 * as control size, drawing operations, etc are in logical pixels. When not in high DPI,
			 * this will be 1.0;  Retina displays in OS X will return 2; and in windows this matches
			 * the scale set in the monitor settings.  Use the
			 * {@link Eto.Forms.Window.LogicalPixelSizeChanged} to detect when the window is moved to
			 *  a display with a different DPI.
			 */
			readonly LogicalPixelSize: number;

			/**
			 * Gets or sets a value indicating that the window can be moved by click+dragging the
			 * window background
			 */
			MovableByWindowBackground: boolean;

			/**
			 * Gets or sets a value indicating that the window will automatically resize when its
			 * content changes
			 *
			 * Note that if you set both dimensions of the {@link Eto.Drawing.Size} and/or
			 * {@link Eto.Forms.Container.ClientSize}, this will be set to false.
			 */
			AutoSize: boolean;

			/** Gets an enumeration of controls that are directly contained by this container */
			readonly Controls: Iterable<Eto.Forms.Control>;

			/** Gets or sets the padding around the {@link Eto.Forms.Panel.Content} of the panel. */
			Padding: Eto.Drawing.Padding;

			/** Gets or sets the minimum size of the panel. */
			MinimumSize: Eto.Drawing.Size;

			/**
			 * Gets or sets the context menu for the panel.
			 *
			 * The context menu is usually shown when the user right clicks the control, or in mobile
			 * platforms when the user taps and holds their finger down on the control.
			 */
			ContextMenu: Eto.Forms.ContextMenu;

			/**
			 * Gets or sets the main content of the panel.
			 *
			 * The main content will be offset by the {@link Eto.Forms.Panel.Padding} value
			 * specified, and will take up the entire content area of the control. Some controls may
			 * have decorations that will surround the content, such as a {@link Eto.Forms.GroupBox},
			 * {@link Eto.Forms.TabControl}, or {@link Eto.Forms.Window}
			 */
			Content: Eto.Forms.Control;

			/**
			 * Gets or sets the size for the client area of the control
			 *
			 * The client size differs from the {@link Eto.Forms.Control.Size} in that it excludes
			 * the decorations of the container, such as the title bar and border around a
			 * {@link Eto.Forms.Window}, or the title and line  around a {@link Eto.Forms.GroupBox}.
			 */
			ClientSize: Eto.Drawing.Size;

			/**
			 * Gets an enumeration of all contained child controls, including controls within child
			 * containers
			 */
			readonly Children: Iterable<Eto.Forms.Control>;

			/**
			 * Gets an enumeration of all contained child controls in the visual tree, including
			 * controls within child containers.
			 */
			readonly VisualChildren: Iterable<Eto.Forms.Control>;

			/**
			 * Gets or sets the style provider for this container.
			 *
			 * The style provider is used to style this container and its children.
			 */
			StyleProvider: Eto.IStyleProvider;

			/**
			 * Gets the default style provider for this container.
			 *
			 * Use this to apply styles to any child controls of this container. By default, styles
			 * will apply to all children, including children of children unless
			 * {@link Eto.DefaultStyleProvider.Inherit} is set to false .  Typically, you would set
			 * Inherit to false when creating composite controls that already have all their styles
			 * applied and you don't want any other styles to be inherited.
			 */
			readonly Styles: Eto.DefaultStyleProvider;

			/**
			 * Gets a value indicating that the control is loaded onto a form, that is it has been
			 * created, added to a parent, and shown
			 *
			 * The {@link Eto.Forms.Control.OnLoad(System.EventArgs)} method sets this value to true
			 * after cascading to all children (for a {@link Eto.Forms.Container} ) and calling the
			 * platform handler's implementation.  It is called after adding to a loaded form, or
			 * when showing a new form.  The {@link Eto.Forms.Control.OnUnLoad(System.EventArgs)}
			 * method will set this value to false when the control is removed from its parent
			 */
			readonly Loaded: boolean;

			/**
			 * Gets an enumeration of controls that are in the visual tree.
			 *
			 * This is used to specify which controls are contained by this instance that are part of
			 * the visual tree. This should include all controls including non-logical Eto controls
			 * used for layout.
			 */
			readonly VisualControls: Iterable<Eto.Forms.Control>;

			/**
			 * Gets or sets a user-defined object that contains data about the control
			 *
			 * A common use of the tag property is to store data that is associated with the control
			 * that you can later retrieve.
			 */
			Tag: unknown;

			/**
			 * Gets the logical parent control.
			 *
			 * When the control is part of the visual tree (
				 * {@link Eto.Forms.Control.IsVisualControl} is true), this returns the logical parent
				 * that contains this control. Otherwise this is the same as
				 * {@link Eto.Forms.Control.Parent}.
				 */
				readonly LogicalParent: Eto.Forms.Container;

			/** Gets a value indicating this {@link Eto.Forms.Control} is part of the visual tree. */
			IsVisualControl: boolean;

			/**
			 * Gets or sets the size of the control. Use -1 to specify auto sizing for either the
			 * width and/or height.
			 *
			 * Setting the size of controls is entirely optional as most controls will size
			 * themselves appropriately. When specifying a size, it will be used as the desired size
			 * of the control.  The container will reposition and resize the control depending on the
			 * available size.  For a {@link Eto.Forms.Window}, it is preferred to set the
			 * {@link Eto.Forms.Container.ClientSize} instead, as various platforms have different
			 * sizes of window decorations, toolbars, etc.
			 */
			Size: Eto.Drawing.Size;

			/**
			 * Gets a value indicating this control currently has mouse capture
			 *
			 * Mouse capture can happen during a handled MouseDown event until MouseUp, or it can be
			 * captured explicitly via {@link Eto.Forms.Control.CaptureMouse}.
			 */
			readonly IsMouseCaptured: boolean;

			/** Gets or sets the width of the control size. */
			Width: number;

			/** Gets or sets the height of the control size. */
			Height: number;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Forms.Control} (or its
			 * children) are enabled and accept user input.
			 *
			 * Typically when a control is disabled, the user cannot do anything with the control or
			 * any of its children. Including for example, selecting text in a text control. Certain
			 * controls can have a 'Read Only' mode, such as {@link Eto.Forms.TextBox.ReadOnly} which
			 * allow the user to  select text, but not change its contents.
			 */
			Enabled: boolean;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Forms.Control} is visible to
			 * the user.
			 *
			 * When the visibility of a control is set to false, it will not occupy space in the
			 * layout.
			 */
			Visible: boolean;

			/** Gets the container which this control has been added to, if any */
			readonly Parent: Eto.Forms.Container;

			/**
			 * Gets the visual container of this control, if any.
			 *
			 * Some containers may use other Eto controls to layout its children, such as the
			 * {@link Eto.Forms.StackLayout}. This will return the parent control that visually
			 * contains this control as opposed to {@link Eto.Forms.Control.Parent} which will return
			 * the logical parent.
			 */
			VisualParent: Eto.Forms.Container;

			/** Gets a value indicating this control has been attached to a native container */
			readonly IsAttached: boolean;

			/**
			 * Gets or sets the color for the background of the control
			 *
			 * Note that on some platforms (e.g. Mac), setting the background color of a control can
			 * change the performance characteristics of the control and its children, since it must
			 * enable layers to do so.
			 */
			BackgroundColor: Eto.Drawing.Color;

			/** Gets a value indicating whether this instance has the keyboard input focus. */
			readonly HasFocus: boolean;

			/** Gets a value indicating whether the layout of child controls is suspended. */
			readonly IsSuspended: boolean;

			/** Gets the window this control is contained in */
			readonly ParentWindow: Eto.Forms.Window;

			/**
			 * Gets the supported platform commands that can be used to hook up system functions to
			 * user defined logic
			 *
			 * This lists all available commands that can be mapped using the
			 * {@link Eto.Forms.Control.MapPlatformCommand(System.String,Eto.Forms.Command)} method
			 * of the control.
			 */
			readonly SupportedPlatformCommands: Iterable<string>;

			/** Gets or sets the type of cursor to use when the mouse is hovering over the control */
			Cursor: Eto.Forms.Cursor;

			/** Gets or sets the tool tip to show when the mouse is hovered over the control */
			ToolTip: string;

			/**
			 * Gets or sets the tab index order for this control within its container.
			 *
			 * This sets the order when using the tab key to cycle through controls  Note that some
			 * platforms (Gtk and WinForms) may not support setting the context of the tab order to
			 * StackLayout  or DynamicLayout containers and may not behave exactly as expected. Use
			 * the {@link Eto.PlatformFeatures.TabIndexWithCustomContainers} flag to determine if it
			 * is supported.
			 */
			TabIndex: number;

			/** Gets or sets a value indicating whether this control can serve as drop target. */
			AllowDrop: boolean;

			/**
			 * Gets or sets the parent widget which this widget has been added to, if any
			 *
			 * When implementing child widgets that can participate in the context based binding
			 * (MVVM), You can set this to the parent widget when it is added or removed to it
			 * (usually via a collection).  Note that you should typically provide a public new
			 * [ParentWidget] Parent { get; } property  so that consumers of your API cannot set the
			 * parent to an invalid value.
			 */
			Parent: Eto.Widget;

			/**
			 * Gets an enumeration of all parent widgets in the heirarchy by traversing the
			 * {@link Eto.Forms.BindableWidget.Parent} property.
			 */
			readonly Parents: Iterable<Eto.Widget>;

			/**
			 * Gets or sets the data context for this widget for binding
			 *
			 * Subclasses may override the standard behaviour so that hierarchy of widgets can be
			 * taken into account.  For example, a Control may return the data context of a parent,
			 * if it is not set explicitly.
			 */
			DataContext: unknown;

			/** Gets the collection of bindings that are attached to this widget */
			readonly Bindings: Eto.Forms.BindingCollection;

			/**
			 * Gets a value indicating that the {@link Eto.Forms.BindableWidget.DataContext} property
			 * is changing.
			 *
			 * This can be used to determine when to allow certain logic during the update of the
			 * data context.  It is used to disable binding setters on the model when the data
			 * context changes so that a binding does not cause the view model to be updated when the
			 * state hasn't been fully set yet.
			 */
			IsDataContextChanging: boolean;

			/**
			 * Gets the platform that was used to create the {@link Eto.Widget.Handler} for this
			 * widget
			 *
			 * This gets set to the current {@link Eto.Platform.Instance} during the construction of
			 * the object
			 */
			readonly Platform: Eto.Platform;

			/** Gets the platform-specific handler for this widget */
			Handler: unknown;

			/** Gets the native platform-specific handle for integration purposes */
			readonly NativeHandle: unknown;

			/** Gets the dictionary of properties for this widget */
			readonly Properties: Eto.PropertyStore;

			/** Gets or sets the ID of this widget */
			ID: string;

			/**
			 * Gets or sets the style of this widget
			 *
			 * Styles allow you to attach custom platform-specific logic to a widget. In your
			 * platform-specific assembly, use {@link Style.Add{H}(string, StyleHandler{H})} to add
			 * the style logic with the same id.
			 */
			Style: string;

			/**
			 * Gets the instance of the platform-specific object
			 *
			 * This can sometimes be useful to get the platform-specific object. Some handlers may
			 * not have any backing object for its functionality, so this may be null.  It is more
			 * preferred to use the {@link Eto.Widget.Handler} and cast that to the platform-specific
			 * handler class which can give you additional methods and helpers to do common tasks.
			 * For example, the {@link Eto.Forms.Application} object's handler for OS X has a
			 * AddFullScreenMenuItem property to specify if you want full screen support in your app.
			 */
			readonly ControlObject: unknown;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Widget} has been disposed.
			 *
			 * When the widget is disposed, it can no longer be used.
			 */
			IsDisposed: boolean;

			/**
			 * Shows the dialog modally, blocking the current thread until it is closed.
			 *
			 * The `owner` specifies the control on the window that will be blocked from user input
			 * until the dialog is closed. Calling this method is identical to setting the
			 * {@link Eto.Forms.Window.Owner} property and calling
			 * {@link Eto.Forms.Dialog.ShowModal}.
			 */
			ShowModal(owner: Eto.Forms.Control): void;

			/** Shows the dialog modally, blocking the current thread until it is closed. */
			ShowModal(): void;

			/**
			 * Shows the dialog modally asynchronously
			 *
			 * The `owner` specifies the control on the window that will be blocked from user input
			 * until the dialog is closed. Calling this method is identical to setting the
			 * {@link Eto.Forms.Window.Owner} property and calling
			 * {@link Eto.Forms.Dialog.ShowModalAsync}.
			 */
			ShowModalAsync(owner: Eto.Forms.Control): Promise<void>;

			/** Shows the dialog modally asynchronously */
			ShowModalAsync(): Promise<void>;

			/**
			 * Closes the window
			 *
			 * Note that once a window is closed, it cannot be shown again in most platforms.
			 */
			Close(): void;

			/**
			 * Sets {@link Eto.Forms.Window.WindowState} to {@link Eto.Forms.WindowState.Minimized}
			 */
			Minimize(): void;

			/**
			 * Sets {@link Eto.Forms.Window.WindowState} to {@link Eto.Forms.WindowState.Maximized}
			 */
			Maximize(): void;

			/**
			 * Brings the window in front of all other windows in the z-order.  This should not
			 * activate/focus the window.
			 */
			BringToFront(): void;

			/**
			 * Sends the window behind all other windows in the z-order, and will remain active if it
			 * has focus.
			 */
			SendToBack(): void;

			/** Removes the specified child from the container */
			Remove(child: Eto.Forms.Control): void;

			/** Remove the specified `controls` from this container */
			Remove(controls: Iterable<Eto.Forms.Control>): void;

			/** Removes all controls from this container */
			RemoveAll(): void;

			/**
			 * Finds a child control in this container or any of its child containers with the
			 * specified `id`
			 */
			FindChild<T>(id?: string): T;

			/**
			 * Finds a child control in this container or any of its child containers with the
			 * specified `type`
			 */
			FindChild(
				type: unknown,
				id?: string,
			): Eto.Forms.Control;

			/**
			 * Finds a child control in this container or any of its child containers with the
			 * specified `id`.
			 */
			FindChild(id: string): Eto.Forms.Control;

			/**
			 * Queues a repaint of the entire control on the screen and any of its children.
			 *
			 * This is only useful when the control is visible.
			 */
			Invalidate(): void;

			/**
			 * Queues a repaint of the entire control on the screen
			 *
			 * This is only useful when the control is visible.
			 */
			Invalidate(invalidateChildren: boolean): void;

			/**
			 * Queues a repaint of the specified `rect` of the control and any children.
			 *
			 * This is only useful when the control is visible.
			 */
			Invalidate(rect: Eto.Drawing.Rectangle): void;

			/**
			 * Queues a repaint of the specified `rect` of the control
			 *
			 * This is only useful when the control is visible.
			 */
			Invalidate(
				rect: Eto.Drawing.Rectangle,
				invalidateChildren: boolean,
			): void;

			/**
			 * Updates the layout of this control if necessary.
			 *
			 * This will ensure the control has had all of its layout applied so you can use its
			 * position and size right after this call. Most platforms (except WinForms) use a
			 * deferred layout system so that after adding your control to the form dynamically it
			 * won't get laid out until the next idle loop. This is useful when you need to know the
			 * dimensions of the control immediately. Note that this can be an expensive operation,
			 * so it is recommended to only call this method when necessary and after all of the
			 * controls have been added/updated.
			 */
			UpdateLayout(): void;

			/** Gets the preferred size of this control given infinite space available. */
			GetPreferredSize(): Eto.Drawing.SizeF;

			/** Gets the preferred size of this control given the specified `availableSize`. */
			GetPreferredSize(availableSize: Eto.Drawing.SizeF): Eto.Drawing.SizeF;

			/**
			 * Captures all mouse events to this control.
			 *
			 * This captures all mouse events until {@link Eto.Forms.Control.ReleaseMouseCapture} is
			 * called.  Note that not all platforms will allow a mouse capture unless the mouse is
			 * currently down.
			 */
			CaptureMouse(): boolean;

			/** Releases the mouse capture after a call to {@link Eto.Forms.Control.CaptureMouse}. */
			ReleaseMouseCapture(): void;

			/**
			 * Finds a control in the parent hierarchy with the specified type and
			 * {@link Eto.Widget.ID} if specified
			 */
			FindParent(
				type: unknown,
				id?: string,
			): Eto.Forms.Container;

			/** Finds a control in the parent hierarchy with the specified `id` */
			FindParent(id: string): Eto.Forms.Container;

			/**
			 * Detaches the control by removing it from its parent
			 *
			 * This is essentially a shortcut to myControl.Parent.Remove(myControl);
			 */
			Detach(): void;

			/**
			 * Attaches the control for direct use in a native application
			 *
			 * Use this to use a control directly in a native application.  Note that the native
			 * application must be running the same framework as the current platform.  E.g. a
			 * WinForms application can use an Eto.Forms control when using the Eto.WinForms
			 * platform.  This prepares the control by firing the {@link Eto.Forms.Control.PreLoad},
			 * {@link Eto.Forms.Control.Load}, etc. events.
			 */
			AttachNative(): void;

			/**
			 * Detaches the control when it is used in a native application, when you want to reuse
			 * the control.
			 *
			 * This should only be called after {@link Eto.Forms.Control.AttachNative} has been
			 * called, which is usually done by calling to ToNative(true) .
			 */
			DetachNative(): void;

			/**
			 * Attempts to set the keyboard input focus to this control, or the first child that
			 * accepts focus. For Windows, this will bring it to front and activate it.
			 */
			Focus(): void;

			/**
			 * Suspends the layout of child controls
			 *
			 * This can be used to optimize some platforms while adding, removing, or changing many
			 * child controls at once. It disables the calculation of control positioning until
			 * {@link Eto.Forms.Control.ResumeLayout} is called. Each call to SuspendLayout() must be
			 * balanced with a call to {@link Eto.Forms.Control.ResumeLayout}.
			 */
			SuspendLayout(): void;

			/**
			 * Resumes the layout after it has been suspended, and performs a layout
			 *
			 * This can be used to optimize some platforms while adding, removing, or changing many
			 * child controls at once. Each call to ResumeLayout() must be balanced with a call to
			 * {@link Eto.Forms.Control.SuspendLayout} before it.
			 */
			ResumeLayout(): void;

			/**
			 * Specifies a command to execute for a platform-specific command
			 *
			 * Some platforms have specific system-defined commands that can be associated with a
			 * control. For example, the Mac platform's cut/copy/paste functionality is defined by
			 * the system, and if you want to hook into it, you can use this to map it to your own
			 * defined logic. The valid values of the `systemCommand` parameter are defined by each
			 * platform, and a list can be retrieved using
			 * {@link Eto.Forms.Control.SupportedPlatformCommands}
			 */
			MapPlatformCommand(
				systemCommand: string,
				command: Eto.Forms.Command,
			): void;

			/** Converts a point from screen space to control space. */
			PointFromScreen(point: Eto.Drawing.PointF): Eto.Drawing.PointF;

			/** Converts a point from control space to screen space */
			PointToScreen(point: Eto.Drawing.PointF): Eto.Drawing.PointF;

			/** Converts a rectangle from screen space to control space. */
			RectangleToScreen(rect: Eto.Drawing.RectangleF): Eto.Drawing.RectangleF;

			/** Converts a rectangle from control space to screen space */
			RectangleFromScreen(rect: Eto.Drawing.RectangleF): Eto.Drawing.RectangleF;

			/**
			 * Starts drag operation using this control as drag source.
			 *
			 * This method can be blocking on some platforms (Wpf, WinForms), and non-blocking on
			 * others (Mac, Gtk). Use the {@link Eto.Forms.Control.DragEnd} event to determine when
			 * the drag operation is completed and get its resulting DragEffects.
			 */
			DoDragDrop(
				data: Eto.Forms.DataObject,
				allowedEffects: Eto.Forms.DragEffects,
			): void;

			/**
			 * Starts drag operation using this control as drag source.
			 *
			 * This method can be blocking on some platforms (Wpf, WinForms), and non-blocking on
			 * others (Mac, Gtk). Use the {@link Eto.Forms.Control.DragEnd} event to determine when
			 * the drag operation is completed and get its resulting DragEffects.
			 */
			DoDragDrop(
				data: Eto.Forms.DataObject,
				allowedEffects: Eto.Forms.DragEffects,
				image: Eto.Drawing.Image,
				cursorOffset: Eto.Drawing.PointF,
			): void;

			/**
			 * Triggers the StyleChanged event and re-applies the styles to this control and its
			 * children.
			 */
			TriggerStyleChanged(): void;

			/** Shows a print dialog to print the specified control */
			Print(): void;

			/**
			 * Finds a control in the parent hierarchy with the specified type and
			 * {@link Eto.Widget.ID} if specified
			 */
			FindParent<T>(id?: string): T;

			/**
			 * Finds a control in the parent hierarchy with the specified type and
			 * {@link Eto.Widget.ID} if specified
			 */
			FindParent(
				type: unknown,
				id?: string,
			): Eto.Widget;

			/** Finds a control in the parent hierarchy with the specified `id` */
			FindParent(id: string): Eto.Widget;

			/**
			 * Unbinds any bindings in the {@link Eto.Forms.BindableWidget.Bindings} collection and
			 * removes the bindings
			 *
			 * When you implement {@link Eto.Forms.IBindableWidgetContainer}, this will also unbind
			 * any of its children.
			 */
			Unbind(): void;

			/**
			 * Updates all bindings in this widget
			 *
			 * When you implement {@link Eto.Forms.IBindableWidgetContainer}, this will also update
			 * bindings for all of its children.
			 */
			UpdateBindings(mode?: Eto.Forms.BindingUpdateMode): void;

			/** Disposes of this widget, supressing the finalizer */
			dispose(): void;

			/** Gets a string that represents the current object with its ID if specified. */
			ToString(): string;
		}
	}

	export namespace Eto.Forms.Dialog {
		export interface IHandler extends
			Eto.Forms.Window.IHandler,
			Eto.Forms.Panel.IHandler,
			Eto.Forms.Container.IHandler,
			Eto.Forms.Control.IHandler,
			Eto.Widget.IHandler,
			Eto.Forms.IContextMenuHost {
			DisplayMode: Eto.Forms.DialogDisplayMode;

			DefaultButton: Eto.Forms.Button;

			AbortButton: Eto.Forms.Button;

			ShowModal(): void;

			ShowModalAsync(): Promise<void>;

			InsertDialogButton(
				positive: boolean,
				index: number,
				item: Eto.Forms.Button,
			): void;

			RemoveDialogButton(
				positive: boolean,
				index: number,
				item: Eto.Forms.Button,
			): void;
		}
	}

	export namespace Eto.Forms {
		/**
		 * Enumeration to define the dock position of a control, such as tabs in the
		 * {@link Eto.Forms.TabControl}
		 */
		export enum DockPosition {
			/** Element is docked to the top of the content. */
			Top = 0,

			/** Element is docked to the left of the content. */
			Left = 1,

			/** Element is docked to the right of the content. */
			Right = 2,

			/** Element is docked to the bottom of the content. */
			Bottom = 3,
		}
	}

	export namespace Eto.Forms {
		/**
		 * Filter definition for a {@link Eto.Forms.FileDialog}
		 *
		 * Each filter defines an option for the user to limit the selection of files in the
		 * dialog.
		 */
		export class FileDialogFilter {
			/** Initializes a new instance of the {@link Eto.Forms.FileFilter} class. */
			constructor();

			/** Initializes a new instance of the {@link Eto.Forms.FileFilter} class. */
			constructor(
				name: string,
				extensions: string[],
			);

			/** Gets or sets the name of the filter. */
			Name: string;

			/**
			 * Gets or sets the extensions to filter the file list
			 *
			 * Each extension should include the period. e.g. ".jpeg", ".png", etc.
			 */
			Extensions: string[];

			/**
			 * Returns a {@link System.String} that represents the current
			 * {@link Eto.Forms.FileFilter}.
			 */
			ToString(): string;

			/** Serves as a hash function for a {@link Eto.Forms.FileFilter} object. */
			GetHashCode(): number;
		}
	}

	export namespace Eto.Forms {
		/** Base file dialog class */
		export class FileDialog implements
			Eto.IHandlerSource {
			/** Gets or sets the full name and path of the file that is selected */
			FileName: string;

			/**
			 * Gets the collection of available file filters the user can select from.
			 *
			 * Add entries to this collection to set the filters the user can select when the file
			 * dialog is shown.  Some platforms may either disable (OS X) or hide (GTK/WinForms/WPF)
			 * files that do not match the currently selected filter.
			 */
			readonly Filters: unknown;

			/**
			 * Gets or sets the index of the current filter in the
			 * {@link Eto.Forms.FileDialog.Filters} collection
			 */
			CurrentFilterIndex: number;

			/**
			 * Gets or sets the currently selected filter from the
			 * {@link Eto.Forms.FileDialog.Filters} collection.
			 *
			 * This should always match an instance of a filter in the
			 * {@link Eto.Forms.FileDialog.Filters} collection, otherwise the current filter will be
			 * set to null.
			 */
			CurrentFilter: Eto.Forms.FileFilter;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Forms.FileDialog} checks if
			 * the file exists  before the user can close the dialog.
			 */
			CheckFileExists: boolean;

			/** Gets or sets the title of the dialog. */
			Title: string;

			/**
			 * Gets or sets the directory the file dialog will show files.
			 *
			 * You can use {@link Eto.EtoEnvironment.GetFolderPath(Eto.EtoSpecialFolder)} to set the
			 * initial value of the directory, though the user should be able to change the folder
			 * and keep it
			 */
			Directory: unknown;

			/**
			 * Gets the platform that was used to create the {@link Eto.Widget.Handler} for this
			 * widget
			 *
			 * This gets set to the current {@link Eto.Platform.Instance} during the construction of
			 * the object
			 */
			readonly Platform: Eto.Platform;

			/** Gets the platform-specific handler for this widget */
			Handler: unknown;

			/** Gets the native platform-specific handle for integration purposes */
			readonly NativeHandle: unknown;

			/** Gets the dictionary of properties for this widget */
			readonly Properties: Eto.PropertyStore;

			/** Gets or sets the ID of this widget */
			ID: string;

			/**
			 * Gets or sets the style of this widget
			 *
			 * Styles allow you to attach custom platform-specific logic to a widget. In your
			 * platform-specific assembly, use {@link Style.Add{H}(string, StyleHandler{H})} to add
			 * the style logic with the same id.
			 */
			Style: string;

			/**
			 * Gets the instance of the platform-specific object
			 *
			 * This can sometimes be useful to get the platform-specific object. Some handlers may
			 * not have any backing object for its functionality, so this may be null.  It is more
			 * preferred to use the {@link Eto.Widget.Handler} and cast that to the platform-specific
			 * handler class which can give you additional methods and helpers to do common tasks.
			 * For example, the {@link Eto.Forms.Application} object's handler for OS X has a
			 * AddFullScreenMenuItem property to specify if you want full screen support in your app.
			 */
			readonly ControlObject: unknown;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Widget} has been disposed.
			 *
			 * When the widget is disposed, it can no longer be used.
			 */
			IsDisposed: boolean;

			/** Shows the dialog with the specified parent, blocking until a result is returned. */
			ShowDialog(parent: Eto.Forms.Control): Eto.Forms.DialogResult;

			/**
			 * Shows the dialog with the specified parent window, blocking until a result is
			 * returned.
			 */
			ShowDialog(parent: Eto.Forms.Window): Eto.Forms.DialogResult;

			/** Disposes of this widget, supressing the finalizer */
			dispose(): void;

			/** Gets a string that represents the current object with its ID if specified. */
			ToString(): string;
		}
	}

	export namespace Eto.Forms.FileDialog {
		export interface IHandler extends
			Eto.Forms.CommonDialog.IHandler,
			Eto.Widget.IHandler {
			FileName: string;

			CurrentFilterIndex: number;

			CheckFileExists: boolean;

			Title: string;

			Directory: unknown;

			InsertFilter(
				index: number,
				filter: Eto.Forms.FileFilter,
			): void;

			RemoveFilter(index: number): void;

			ClearFilters(): void;
		}
	}

	export namespace Eto.Forms {
		/**
		 * Filter definition for {@link Eto.Forms.FilePicker} and {@link Eto.Forms.FileDialog}
		 *
		 * Each filter defines an option for the user to limit the selection of files in the
		 * dialog.
		 */
		export class FileFilter {
			/** Initializes a new instance of the {@link Eto.Forms.FileFilter} class. */
			constructor();

			/** Initializes a new instance of the {@link Eto.Forms.FileFilter} class. */
			constructor(
				name: string,
				extensions: string[],
			);

			/** Gets or sets the name of the filter. */
			Name: string;

			/**
			 * Gets or sets the extensions to filter the file list
			 *
			 * Each extension should include the period. e.g. ".jpeg", ".png", etc.
			 */
			Extensions: string[];

			/**
			 * Returns a {@link System.String} that represents the current
			 * {@link Eto.Forms.FileFilter}.
			 */
			ToString(): string;

			/** Serves as a hash function for a {@link Eto.Forms.FileFilter} object. */
			GetHashCode(): number;
		}
	}

	export namespace Eto.Forms {
		/**
		 * Interface for a control that can preserve selected items
		 *
		 * A selection preserver is used to save and restore the selected items when the data
		 * store changes dramatically after a sort or server-side filtering. Controls should
		 * implement {@link Eto.Forms.ISelectableControl<>} to create instances of the selection
		 * preserver.
		 */
		export interface ISelectionPreserver {
			/** Gets or sets the selected items in the control. */
			SelectedItems: Iterable<unknown>;
		}
	}

	export namespace Eto.Forms {
		/**
		 * [Generic type factory] Interface for an object that can select multiple items and
		 * rows.
		 */
		export function ISelectable$(T: IType): IType;

		/** Interface for an object that can select multiple items and rows. */
		export interface ISelectable$1<T> {
			/** Gets the selected items. */
			readonly SelectedItems: Iterable<T>;

			/** Gets or sets the selected rows. */
			SelectedRows: Iterable<number>;

			/** Selects the specified `row`. */
			SelectRow(row: number): void;

			/** Unselects the specified `row`. */
			UnselectRow(row: number): void;

			/** Selects all rows represented in the data store. */
			SelectAll(): void;

			/** Unselects all rows. */
			UnselectAll(): void;
		}
	}

	export namespace Eto.Forms {
		/** [Generic type factory] Interface for a control that can preserve its selection. */
		export function ISelectableControl$(T: IType): IType;

		/** Interface for a control that can preserve its selection. */
		export interface ISelectableControl$1<T> extends Eto.Forms.ISelectable$1<T> {
			/**
			 * Gets a new instance of a selection preserver.
			 *
			 * This returns a selection preserver that can be used to save the selected items of a
			 * control. Typically, this is used when the selection may encompass items that are not
			 * visible in the control.
			 */
			readonly SelectionPreserver: Eto.Forms.ISelectionPreserver;
		}
	}

	export namespace Eto.Forms {
		/**
		 * [Generic type factory] Collection that can filter/sort the items, and keep a selection
		 * of items in the original list.
		 *
		 * This collection is useful when you want the selection to act independant of the
		 * filter. This class will keep the selected items based on the original list, not based
		 * on the filtered view.  For example, if you select an item and set the filter that
		 * eliminates the item from the view,  the
		 * {@link Eto.Forms.SelectableFilterCollection`1.SelectedItems} will still return the
		 * same selected item until it is unselected from the view or from this class directly.
		 */
		export function SelectableFilterCollection$(T: IType): typeof SelectableFilterCollection$1<any>;

		/**
		 * Collection that can filter/sort the items, and keep a selection of items in the
		 * original list.
		 *
		 * This collection is useful when you want the selection to act independant of the
		 * filter. This class will keep the selected items based on the original list, not based
		 * on the filtered view.  For example, if you select an item and set the filter that
		 * eliminates the item from the view,  the
		 * {@link Eto.Forms.SelectableFilterCollection`1.SelectedItems} will still return the
		 * same selected item until it is unselected from the view or from this class directly.
		 */
		export class SelectableFilterCollection$1<T> implements Eto.Forms.ISelectable$1<T> {
			/**
			 * Initializes a new instance of the {@link Eto.Forms.SelectableFilterCollection<>}
			 * class.
			 */
			new(
				parent: Eto.Forms.ISelectableControl$1<unknown>,
				collection: T[],
			): SelectableFilterCollection$1<T>;

			/**
			 * Initializes a new instance of the {@link Eto.Forms.SelectableFilterCollection<>}
			 * class.
			 */
			new(
				parent: Eto.Forms.ISelectableControl$1<unknown>,
				collection: Iterable<T>,
			): SelectableFilterCollection$1<T>;

			/**
			 * Initializes a new instance of the {@link Eto.Forms.SelectableFilterCollection<>}
			 * class.
			 */
			new(parent: Eto.Forms.ISelectableControl$1<unknown>): SelectableFilterCollection$1<T>;

			/** Gets the parent that this collection is attached to. */
			Parent: Eto.Forms.ISelectableControl$1<unknown>;

			/** Gets the selected items. */
			readonly SelectedItems: Iterable<T>;

			/** Gets or sets the selected rows in the underlying list. */
			SelectedRows: Iterable<number>;

			Change: () => IDisposable;

			Filter: (arg1: T) => boolean;

			Sort: unknown;

			readonly Count: number;

			readonly IsReadOnly: boolean;

			/** Selects the specified `row` in the underlying list. */
			SelectRow(row: number): void;

			/** Unselects the specified `row` in the underlying list. */
			UnselectRow(row: number): void;

			/** Unselects all rows. */
			UnselectAll(): void;

			/** Selects all rows in the underlying list. */
			SelectAll(): void;

			/** Clear this collection. */
			Clear(): void;

			/** Remove the specified item from this collection. */
			Remove(item: T): boolean;

			/** Removes the item at the specified `index`. */
			RemoveAt(index: number): void;

			Refresh(): void;

			AddRange(items: Iterable<T>): void;

			InsertRange(
				index: number,
				items: Iterable<T>,
			): void;

			IndexOf(item: T): number;

			Insert(
				index: number,
				item: T,
			): void;

			Add(item: T): void;

			Contains(item: T): boolean;

			CopyTo(
				array: T[],
				arrayIndex: number,
			): void;

			GetEnumerator(): unknown;
		}
	}

	export namespace Eto.Forms {
		/** [Generic type factory] Collection that supports filtering and sorting */
		export function FilterCollection$(T: IType): typeof FilterCollection$1<any>;

		/** Collection that supports filtering and sorting */
		export class FilterCollection$1<T> {
			/**
			 * Initializes a new instance of the {@link Eto.Forms.FilterCollection<>} class with the
			 * specified `collection`.
			 */
			new(collection: Iterable<T>): FilterCollection$1<T>;

			/**
			 * Initializes a new instance of the {@link Eto.Forms.FilterCollection<>} class with the
			 * specified `list` which will keep in sync with any changes to the filtered collection.
			 */
			new(list: T[]): FilterCollection$1<T>;

			/** Initializes a new instance of the {@link Eto.Forms.FilterCollection<>} class. */
			new(): FilterCollection$1<T>;

			/**
			 * Gets or sets the delegate to create a change object each time the collection is
			 * filtered.
			 *
			 * This is used so you can perform operations before or after a change has been made to
			 * the collection. The return value of the delegate is disposed after the change,
			 * allowing the object to perform any operations afterwards.
			 */
			Change: () => IDisposable;

			/**
			 * Gets or sets the filter delegate for items in this collection.
			 *
			 * This will update this collection to contain only items that match the specified filter
			 * from the underlying list. This triggers a collection changed event, so any control
			 * that is using this collection as its data store should automatically update to show
			 * the new results.
			 */
			Filter: (arg1: T) => boolean;

			/** Gets or sets the sort. */
			Sort: unknown;

			/** Gets the count of items in the collection. */
			readonly Count: number;

			/** Gets a value indicating whether this collection is read only. */
			readonly IsReadOnly: boolean;

			/**
			 * Refreshes the list by applying the filter and sort to the contained items
			 *
			 * This is useful when the state of the items change, or your filter delegate is dynamic
			 * and isn't set each time it changes.
			 */
			Refresh(): void;

			/**
			 * Adds the specified `items` to the collection.
			 *
			 * Any item that does not match the existing {@link Eto.Forms.FilterCollection`1.Filter}
			 * will be only added to the underlying collection and not be visible in the filtered
			 * collection.
			 */
			AddRange(items: Iterable<T>): void;

			/**
			 * Inserts the `items` to the collection at the specified `index`.
			 *
			 * Any item that does not match the existing {@link Eto.Forms.FilterCollection`1.Filter}
			 * will be only added to the underlying collection and not be visible in the filtered
			 * collection.
			 */
			InsertRange(
				index: number,
				items: Iterable<T>,
			): void;

			/** Determines the index of a specific item in the collection. */
			IndexOf(item: T): number;

			/** Insert the item at the specified index. */
			Insert(
				index: number,
				item: T,
			): void;

			/** Removes the item at the specified index. */
			RemoveAt(index: number): void;

			/** Add the specified item to the collection. */
			Add(item: T): void;

			/** Clears the items from the collection. */
			Clear(): void;

			/**
			 * Gets a value indicating that the specified `item` is contained within this collection.
			 */
			Contains(item: T): boolean;

			CopyTo(
				array: T[],
				arrayIndex: number,
			): void;

			/** Remove the specified item from the collection. */
			Remove(item: T): boolean;

			/** Gets the enumerator for the collection. */
			GetEnumerator(): unknown;
		}
	}

	export namespace Eto.Forms {
		/**
		 * A specialized modeless Form for floating windows.
		 *
		 * Some platforms have specialized functionality for floating windows (e.g. macOS'
		 * NSPanel) which allows for more interaction with the parent window.   Floating forms
		 * usually dissapear when going the application is not active, and are Topmost to the
		 * application only.  Use this for any auxiliary windows that should float above main
		 * application windows.
		 */
		export class FloatingForm implements
			Eto.IHandlerSource,
			Eto.Forms.IBindable,
			Eto.Forms.IMouseInputSource,
			Eto.Forms.IKeyboardInputSource {
			constructor();

			/**
			 * Gets or sets a value indicating that the form should be activated when initially
			 * shown.
			 *
			 * When true , the form will become the active/focussed window when the
			 * {@link Eto.Forms.Form.Show} method is called. When false , the form will show but will
			 * not get focus until the user clicks on the form.
			 */
			ShowActivated: boolean;

			/**
			 * Gets or sets a value indicating that this form can get keyboard/input focus when the
			 * user clicks on it or any child control.
			 *
			 * This is useful for windows that provide interaction but do not steal focus from the
			 * current window, such as a tooltip, popover, etc.
			 */
			CanFocus: boolean;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Forms.Control} is visible to
			 * the user.
			 *
			 * When the visibility of a control is set to false, it will still occupy space in the
			 * layout, but not be shown. The only exception is for controls like the
			 * {@link Eto.Forms.Splitter}, which will hide a pane if the visibility of one of the
			 * panels is changed.
			 */
			Visible: boolean;

			/**
			 * Gets or sets the title of the window
			 *
			 * The title of the window is displayed to the user usually at the top of the window, but
			 * in cases where you show a window in a mobile environment, this may be the title shown
			 * in a navigation controller.
			 */
			Title: string;

			/**
			 * Gets or sets the location of the window
			 *
			 * Note that in multi-monitor setups, the origin of the location is at the upper-left of
			 * {@link Eto.Forms.Screen.PrimaryScreen}.  Also note, that on Linux systems running GTK
			 * via Wayland, this will always point to 0, 0 , and setting it to different values will
			 * have no effect.
			 */
			Location: Eto.Drawing.Point;

			/** Gets or sets the size and location of the window */
			Bounds: Eto.Drawing.Rectangle;

			/**
			 * Gets or sets the tool bar for the window.
			 *
			 * Note that each window can only have a single tool bar
			 */
			ToolBar: Eto.Forms.ToolBar;

			/** Gets or sets the opacity of the window */
			Opacity: number;

			/**
			 * Gets or sets the owner of this window.
			 *
			 * This sets the parent window that has ownership over this window. For a
			 * {@link Eto.Forms.Dialog}, this will be the window that will be disabled while the
			 * modal dialog is shown. With a {@link Eto.Forms.Form}, the specified owner will always
			 * be below the current window when shown, and will  still be responsive to user input.
			 * Typically, but not always, the window will move along with the owner.
			 */
			Owner: Eto.Forms.Window;

			/**
			 * Gets the screen this window is mostly contained in. Typically defined by the screen
			 * center of the window is visible.
			 */
			readonly Screen: Eto.Forms.Screen;

			/**
			 * Gets or sets the menu bar for this window
			 *
			 * Some platforms have a global menu bar (e.g. Ubuntu, OS X). When the window is in
			 * focus, the global menu bar will be changed to reflect the menu assigned.
			 */
			Menu: Eto.Forms.MenuBar;

			/**
			 * Gets or sets the icon for the window to show in the menu bar.
			 *
			 * The icon should have many variations, such as 16x16, 24x24, 32x32, 48x48, 64x64, etc.
			 * This ensures that the many places it is used (title bar, task bar, switch window, etc)
			 * all have optimized icon sizes.  For OS X, the application icon is specified in the
			 * .app bundle, not by this value.
			 */
			Icon: Eto.Drawing.Icon;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Forms.Window} is resizable.
			 */
			Resizable: boolean;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Forms.Window} can be
			 * maximized.
			 *
			 * This may hide or disable the minimize button on the title bar.
			 */
			Maximizable: boolean;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Forms.Window} can be
			 * minimized.
			 *
			 * This may hide or disable the maximize button on the title bar.
			 */
			Minimizable: boolean;

			/**
			 * Gets or sets a value indicating whether the close button should be shown. Defaults to
			 * true
			 *
			 * Note that on some platforms (e.g. Windows) this also hides the system menu and
			 * minimize/maximize buttons. Note that this does not prevent the window from being
			 * closed, to do that use the {@link Eto.Forms.Window.Closing} event.
			 */
			Closeable: boolean;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Forms.Window} will show in the
			 * taskbar.
			 *
			 * Some platforms, e.g. macOS do not show a separate icon for each running window.  You
			 * may also have to add  the LSUIElement key to your app's Info.plist to make your app
			 * hidden in the dock.   See
			 * https://developer.apple.com/library/archive/documentation/General/Reference/InfoPlistKeyReference/Articles/LaunchServicesKeys.html#//apple_ref/doc/uid/TP40009250-108256-TPXREF136
			 */
			ShowInTaskbar: boolean;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Forms.Window} is above all
			 * other windows.
			 *
			 * The window should be above all other windows when this is true.  In some platforms,
			 * this will show above all other windows only when the application has focus.
			 */
			Topmost: boolean;

			/** Gets or sets the state of the window. */
			WindowState: Eto.Forms.WindowState;

			/**
			 * Gets the bounds of the window before it was minimized or maximized, or the current
			 * bounds if {@link Eto.Forms.Window.WindowState} is Normal.
			 *
			 * This is useful to retrieve the desired size and position of the window even though it
			 * is currently maximized or minimized.
			 */
			readonly RestoreBounds: Eto.Drawing.Rectangle;

			/** Gets or sets the style of this window. */
			WindowStyle: Eto.Forms.WindowStyle;

			/**
			 * Gets the number of pixels per logical pixel when on a high DPI display.
			 *
			 * This indicates the number of pixels per logical pixel.   All units in Eto.Forms such
			 * as control size, drawing operations, etc are in logical pixels. When not in high DPI,
			 * this will be 1.0;  Retina displays in OS X will return 2; and in windows this matches
			 * the scale set in the monitor settings.  Use the
			 * {@link Eto.Forms.Window.LogicalPixelSizeChanged} to detect when the window is moved to
			 *  a display with a different DPI.
			 */
			readonly LogicalPixelSize: number;

			/**
			 * Gets or sets a value indicating that the window can be moved by click+dragging the
			 * window background
			 */
			MovableByWindowBackground: boolean;

			/**
			 * Gets or sets a value indicating that the window will automatically resize when its
			 * content changes
			 *
			 * Note that if you set both dimensions of the {@link Eto.Drawing.Size} and/or
			 * {@link Eto.Forms.Container.ClientSize}, this will be set to false.
			 */
			AutoSize: boolean;

			/** Gets an enumeration of controls that are directly contained by this container */
			readonly Controls: Iterable<Eto.Forms.Control>;

			/** Gets or sets the padding around the {@link Eto.Forms.Panel.Content} of the panel. */
			Padding: Eto.Drawing.Padding;

			/** Gets or sets the minimum size of the panel. */
			MinimumSize: Eto.Drawing.Size;

			/**
			 * Gets or sets the context menu for the panel.
			 *
			 * The context menu is usually shown when the user right clicks the control, or in mobile
			 * platforms when the user taps and holds their finger down on the control.
			 */
			ContextMenu: Eto.Forms.ContextMenu;

			/**
			 * Gets or sets the main content of the panel.
			 *
			 * The main content will be offset by the {@link Eto.Forms.Panel.Padding} value
			 * specified, and will take up the entire content area of the control. Some controls may
			 * have decorations that will surround the content, such as a {@link Eto.Forms.GroupBox},
			 * {@link Eto.Forms.TabControl}, or {@link Eto.Forms.Window}
			 */
			Content: Eto.Forms.Control;

			/**
			 * Gets or sets the size for the client area of the control
			 *
			 * The client size differs from the {@link Eto.Forms.Control.Size} in that it excludes
			 * the decorations of the container, such as the title bar and border around a
			 * {@link Eto.Forms.Window}, or the title and line  around a {@link Eto.Forms.GroupBox}.
			 */
			ClientSize: Eto.Drawing.Size;

			/**
			 * Gets an enumeration of all contained child controls, including controls within child
			 * containers
			 */
			readonly Children: Iterable<Eto.Forms.Control>;

			/**
			 * Gets an enumeration of all contained child controls in the visual tree, including
			 * controls within child containers.
			 */
			readonly VisualChildren: Iterable<Eto.Forms.Control>;

			/**
			 * Gets or sets the style provider for this container.
			 *
			 * The style provider is used to style this container and its children.
			 */
			StyleProvider: Eto.IStyleProvider;

			/**
			 * Gets the default style provider for this container.
			 *
			 * Use this to apply styles to any child controls of this container. By default, styles
			 * will apply to all children, including children of children unless
			 * {@link Eto.DefaultStyleProvider.Inherit} is set to false .  Typically, you would set
			 * Inherit to false when creating composite controls that already have all their styles
			 * applied and you don't want any other styles to be inherited.
			 */
			readonly Styles: Eto.DefaultStyleProvider;

			/**
			 * Gets a value indicating that the control is loaded onto a form, that is it has been
			 * created, added to a parent, and shown
			 *
			 * The {@link Eto.Forms.Control.OnLoad(System.EventArgs)} method sets this value to true
			 * after cascading to all children (for a {@link Eto.Forms.Container} ) and calling the
			 * platform handler's implementation.  It is called after adding to a loaded form, or
			 * when showing a new form.  The {@link Eto.Forms.Control.OnUnLoad(System.EventArgs)}
			 * method will set this value to false when the control is removed from its parent
			 */
			readonly Loaded: boolean;

			/**
			 * Gets an enumeration of controls that are in the visual tree.
			 *
			 * This is used to specify which controls are contained by this instance that are part of
			 * the visual tree. This should include all controls including non-logical Eto controls
			 * used for layout.
			 */
			readonly VisualControls: Iterable<Eto.Forms.Control>;

			/**
			 * Gets or sets a user-defined object that contains data about the control
			 *
			 * A common use of the tag property is to store data that is associated with the control
			 * that you can later retrieve.
			 */
			Tag: unknown;

			/**
			 * Gets the logical parent control.
			 *
			 * When the control is part of the visual tree (
				 * {@link Eto.Forms.Control.IsVisualControl} is true), this returns the logical parent
				 * that contains this control. Otherwise this is the same as
				 * {@link Eto.Forms.Control.Parent}.
				 */
				readonly LogicalParent: Eto.Forms.Container;

			/** Gets a value indicating this {@link Eto.Forms.Control} is part of the visual tree. */
			IsVisualControl: boolean;

			/**
			 * Gets or sets the size of the control. Use -1 to specify auto sizing for either the
			 * width and/or height.
			 *
			 * Setting the size of controls is entirely optional as most controls will size
			 * themselves appropriately. When specifying a size, it will be used as the desired size
			 * of the control.  The container will reposition and resize the control depending on the
			 * available size.  For a {@link Eto.Forms.Window}, it is preferred to set the
			 * {@link Eto.Forms.Container.ClientSize} instead, as various platforms have different
			 * sizes of window decorations, toolbars, etc.
			 */
			Size: Eto.Drawing.Size;

			/**
			 * Gets a value indicating this control currently has mouse capture
			 *
			 * Mouse capture can happen during a handled MouseDown event until MouseUp, or it can be
			 * captured explicitly via {@link Eto.Forms.Control.CaptureMouse}.
			 */
			readonly IsMouseCaptured: boolean;

			/** Gets or sets the width of the control size. */
			Width: number;

			/** Gets or sets the height of the control size. */
			Height: number;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Forms.Control} (or its
			 * children) are enabled and accept user input.
			 *
			 * Typically when a control is disabled, the user cannot do anything with the control or
			 * any of its children. Including for example, selecting text in a text control. Certain
			 * controls can have a 'Read Only' mode, such as {@link Eto.Forms.TextBox.ReadOnly} which
			 * allow the user to  select text, but not change its contents.
			 */
			Enabled: boolean;

			/** Gets the container which this control has been added to, if any */
			readonly Parent: Eto.Forms.Container;

			/**
			 * Gets the visual container of this control, if any.
			 *
			 * Some containers may use other Eto controls to layout its children, such as the
			 * {@link Eto.Forms.StackLayout}. This will return the parent control that visually
			 * contains this control as opposed to {@link Eto.Forms.Control.Parent} which will return
			 * the logical parent.
			 */
			VisualParent: Eto.Forms.Container;

			/** Gets a value indicating this control has been attached to a native container */
			readonly IsAttached: boolean;

			/**
			 * Gets or sets the color for the background of the control
			 *
			 * Note that on some platforms (e.g. Mac), setting the background color of a control can
			 * change the performance characteristics of the control and its children, since it must
			 * enable layers to do so.
			 */
			BackgroundColor: Eto.Drawing.Color;

			/** Gets a value indicating whether this instance has the keyboard input focus. */
			readonly HasFocus: boolean;

			/** Gets a value indicating whether the layout of child controls is suspended. */
			readonly IsSuspended: boolean;

			/** Gets the window this control is contained in */
			readonly ParentWindow: Eto.Forms.Window;

			/**
			 * Gets the supported platform commands that can be used to hook up system functions to
			 * user defined logic
			 *
			 * This lists all available commands that can be mapped using the
			 * {@link Eto.Forms.Control.MapPlatformCommand(System.String,Eto.Forms.Command)} method
			 * of the control.
			 */
			readonly SupportedPlatformCommands: Iterable<string>;

			/** Gets or sets the type of cursor to use when the mouse is hovering over the control */
			Cursor: Eto.Forms.Cursor;

			/** Gets or sets the tool tip to show when the mouse is hovered over the control */
			ToolTip: string;

			/**
			 * Gets or sets the tab index order for this control within its container.
			 *
			 * This sets the order when using the tab key to cycle through controls  Note that some
			 * platforms (Gtk and WinForms) may not support setting the context of the tab order to
			 * StackLayout  or DynamicLayout containers and may not behave exactly as expected. Use
			 * the {@link Eto.PlatformFeatures.TabIndexWithCustomContainers} flag to determine if it
			 * is supported.
			 */
			TabIndex: number;

			/** Gets or sets a value indicating whether this control can serve as drop target. */
			AllowDrop: boolean;

			/**
			 * Gets or sets the parent widget which this widget has been added to, if any
			 *
			 * When implementing child widgets that can participate in the context based binding
			 * (MVVM), You can set this to the parent widget when it is added or removed to it
			 * (usually via a collection).  Note that you should typically provide a public new
			 * [ParentWidget] Parent { get; } property  so that consumers of your API cannot set the
			 * parent to an invalid value.
			 */
			Parent: Eto.Widget;

			/**
			 * Gets an enumeration of all parent widgets in the heirarchy by traversing the
			 * {@link Eto.Forms.BindableWidget.Parent} property.
			 */
			readonly Parents: Iterable<Eto.Widget>;

			/**
			 * Gets or sets the data context for this widget for binding
			 *
			 * Subclasses may override the standard behaviour so that hierarchy of widgets can be
			 * taken into account.  For example, a Control may return the data context of a parent,
			 * if it is not set explicitly.
			 */
			DataContext: unknown;

			/** Gets the collection of bindings that are attached to this widget */
			readonly Bindings: Eto.Forms.BindingCollection;

			/**
			 * Gets a value indicating that the {@link Eto.Forms.BindableWidget.DataContext} property
			 * is changing.
			 *
			 * This can be used to determine when to allow certain logic during the update of the
			 * data context.  It is used to disable binding setters on the model when the data
			 * context changes so that a binding does not cause the view model to be updated when the
			 * state hasn't been fully set yet.
			 */
			IsDataContextChanging: boolean;

			/**
			 * Gets the platform that was used to create the {@link Eto.Widget.Handler} for this
			 * widget
			 *
			 * This gets set to the current {@link Eto.Platform.Instance} during the construction of
			 * the object
			 */
			readonly Platform: Eto.Platform;

			/** Gets the platform-specific handler for this widget */
			Handler: unknown;

			/** Gets the native platform-specific handle for integration purposes */
			readonly NativeHandle: unknown;

			/** Gets the dictionary of properties for this widget */
			readonly Properties: Eto.PropertyStore;

			/** Gets or sets the ID of this widget */
			ID: string;

			/**
			 * Gets or sets the style of this widget
			 *
			 * Styles allow you to attach custom platform-specific logic to a widget. In your
			 * platform-specific assembly, use {@link Style.Add{H}(string, StyleHandler{H})} to add
			 * the style logic with the same id.
			 */
			Style: string;

			/**
			 * Gets the instance of the platform-specific object
			 *
			 * This can sometimes be useful to get the platform-specific object. Some handlers may
			 * not have any backing object for its functionality, so this may be null.  It is more
			 * preferred to use the {@link Eto.Widget.Handler} and cast that to the platform-specific
			 * handler class which can give you additional methods and helpers to do common tasks.
			 * For example, the {@link Eto.Forms.Application} object's handler for OS X has a
			 * AddFullScreenMenuItem property to specify if you want full screen support in your app.
			 */
			readonly ControlObject: unknown;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Widget} has been disposed.
			 *
			 * When the widget is disposed, it can no longer be used.
			 */
			IsDisposed: boolean;

			/** Show the form */
			Show(): void;

			/**
			 * Closes the window
			 *
			 * Note that once a window is closed, it cannot be shown again in most platforms.
			 */
			Close(): void;

			/**
			 * Sets {@link Eto.Forms.Window.WindowState} to {@link Eto.Forms.WindowState.Minimized}
			 */
			Minimize(): void;

			/**
			 * Sets {@link Eto.Forms.Window.WindowState} to {@link Eto.Forms.WindowState.Maximized}
			 */
			Maximize(): void;

			/**
			 * Brings the window in front of all other windows in the z-order.  This should not
			 * activate/focus the window.
			 */
			BringToFront(): void;

			/**
			 * Sends the window behind all other windows in the z-order, and will remain active if it
			 * has focus.
			 */
			SendToBack(): void;

			/** Removes the specified child from the container */
			Remove(child: Eto.Forms.Control): void;

			/** Remove the specified `controls` from this container */
			Remove(controls: Iterable<Eto.Forms.Control>): void;

			/** Removes all controls from this container */
			RemoveAll(): void;

			/**
			 * Finds a child control in this container or any of its child containers with the
			 * specified `id`
			 */
			FindChild<T>(id?: string): T;

			/**
			 * Finds a child control in this container or any of its child containers with the
			 * specified `type`
			 */
			FindChild(
				type: unknown,
				id?: string,
			): Eto.Forms.Control;

			/**
			 * Finds a child control in this container or any of its child containers with the
			 * specified `id`.
			 */
			FindChild(id: string): Eto.Forms.Control;

			/**
			 * Queues a repaint of the entire control on the screen and any of its children.
			 *
			 * This is only useful when the control is visible.
			 */
			Invalidate(): void;

			/**
			 * Queues a repaint of the entire control on the screen
			 *
			 * This is only useful when the control is visible.
			 */
			Invalidate(invalidateChildren: boolean): void;

			/**
			 * Queues a repaint of the specified `rect` of the control and any children.
			 *
			 * This is only useful when the control is visible.
			 */
			Invalidate(rect: Eto.Drawing.Rectangle): void;

			/**
			 * Queues a repaint of the specified `rect` of the control
			 *
			 * This is only useful when the control is visible.
			 */
			Invalidate(
				rect: Eto.Drawing.Rectangle,
				invalidateChildren: boolean,
			): void;

			/**
			 * Updates the layout of this control if necessary.
			 *
			 * This will ensure the control has had all of its layout applied so you can use its
			 * position and size right after this call. Most platforms (except WinForms) use a
			 * deferred layout system so that after adding your control to the form dynamically it
			 * won't get laid out until the next idle loop. This is useful when you need to know the
			 * dimensions of the control immediately. Note that this can be an expensive operation,
			 * so it is recommended to only call this method when necessary and after all of the
			 * controls have been added/updated.
			 */
			UpdateLayout(): void;

			/** Gets the preferred size of this control given infinite space available. */
			GetPreferredSize(): Eto.Drawing.SizeF;

			/** Gets the preferred size of this control given the specified `availableSize`. */
			GetPreferredSize(availableSize: Eto.Drawing.SizeF): Eto.Drawing.SizeF;

			/**
			 * Captures all mouse events to this control.
			 *
			 * This captures all mouse events until {@link Eto.Forms.Control.ReleaseMouseCapture} is
			 * called.  Note that not all platforms will allow a mouse capture unless the mouse is
			 * currently down.
			 */
			CaptureMouse(): boolean;

			/** Releases the mouse capture after a call to {@link Eto.Forms.Control.CaptureMouse}. */
			ReleaseMouseCapture(): void;

			/**
			 * Finds a control in the parent hierarchy with the specified type and
			 * {@link Eto.Widget.ID} if specified
			 */
			FindParent(
				type: unknown,
				id?: string,
			): Eto.Forms.Container;

			/** Finds a control in the parent hierarchy with the specified `id` */
			FindParent(id: string): Eto.Forms.Container;

			/**
			 * Detaches the control by removing it from its parent
			 *
			 * This is essentially a shortcut to myControl.Parent.Remove(myControl);
			 */
			Detach(): void;

			/**
			 * Attaches the control for direct use in a native application
			 *
			 * Use this to use a control directly in a native application.  Note that the native
			 * application must be running the same framework as the current platform.  E.g. a
			 * WinForms application can use an Eto.Forms control when using the Eto.WinForms
			 * platform.  This prepares the control by firing the {@link Eto.Forms.Control.PreLoad},
			 * {@link Eto.Forms.Control.Load}, etc. events.
			 */
			AttachNative(): void;

			/**
			 * Detaches the control when it is used in a native application, when you want to reuse
			 * the control.
			 *
			 * This should only be called after {@link Eto.Forms.Control.AttachNative} has been
			 * called, which is usually done by calling to ToNative(true) .
			 */
			DetachNative(): void;

			/**
			 * Attempts to set the keyboard input focus to this control, or the first child that
			 * accepts focus. For Windows, this will bring it to front and activate it.
			 */
			Focus(): void;

			/**
			 * Suspends the layout of child controls
			 *
			 * This can be used to optimize some platforms while adding, removing, or changing many
			 * child controls at once. It disables the calculation of control positioning until
			 * {@link Eto.Forms.Control.ResumeLayout} is called. Each call to SuspendLayout() must be
			 * balanced with a call to {@link Eto.Forms.Control.ResumeLayout}.
			 */
			SuspendLayout(): void;

			/**
			 * Resumes the layout after it has been suspended, and performs a layout
			 *
			 * This can be used to optimize some platforms while adding, removing, or changing many
			 * child controls at once. Each call to ResumeLayout() must be balanced with a call to
			 * {@link Eto.Forms.Control.SuspendLayout} before it.
			 */
			ResumeLayout(): void;

			/**
			 * Specifies a command to execute for a platform-specific command
			 *
			 * Some platforms have specific system-defined commands that can be associated with a
			 * control. For example, the Mac platform's cut/copy/paste functionality is defined by
			 * the system, and if you want to hook into it, you can use this to map it to your own
			 * defined logic. The valid values of the `systemCommand` parameter are defined by each
			 * platform, and a list can be retrieved using
			 * {@link Eto.Forms.Control.SupportedPlatformCommands}
			 */
			MapPlatformCommand(
				systemCommand: string,
				command: Eto.Forms.Command,
			): void;

			/** Converts a point from screen space to control space. */
			PointFromScreen(point: Eto.Drawing.PointF): Eto.Drawing.PointF;

			/** Converts a point from control space to screen space */
			PointToScreen(point: Eto.Drawing.PointF): Eto.Drawing.PointF;

			/** Converts a rectangle from screen space to control space. */
			RectangleToScreen(rect: Eto.Drawing.RectangleF): Eto.Drawing.RectangleF;

			/** Converts a rectangle from control space to screen space */
			RectangleFromScreen(rect: Eto.Drawing.RectangleF): Eto.Drawing.RectangleF;

			/**
			 * Starts drag operation using this control as drag source.
			 *
			 * This method can be blocking on some platforms (Wpf, WinForms), and non-blocking on
			 * others (Mac, Gtk). Use the {@link Eto.Forms.Control.DragEnd} event to determine when
			 * the drag operation is completed and get its resulting DragEffects.
			 */
			DoDragDrop(
				data: Eto.Forms.DataObject,
				allowedEffects: Eto.Forms.DragEffects,
			): void;

			/**
			 * Starts drag operation using this control as drag source.
			 *
			 * This method can be blocking on some platforms (Wpf, WinForms), and non-blocking on
			 * others (Mac, Gtk). Use the {@link Eto.Forms.Control.DragEnd} event to determine when
			 * the drag operation is completed and get its resulting DragEffects.
			 */
			DoDragDrop(
				data: Eto.Forms.DataObject,
				allowedEffects: Eto.Forms.DragEffects,
				image: Eto.Drawing.Image,
				cursorOffset: Eto.Drawing.PointF,
			): void;

			/**
			 * Triggers the StyleChanged event and re-applies the styles to this control and its
			 * children.
			 */
			TriggerStyleChanged(): void;

			/** Shows a print dialog to print the specified control */
			Print(): void;

			/**
			 * Finds a control in the parent hierarchy with the specified type and
			 * {@link Eto.Widget.ID} if specified
			 */
			FindParent<T>(id?: string): T;

			/**
			 * Finds a control in the parent hierarchy with the specified type and
			 * {@link Eto.Widget.ID} if specified
			 */
			FindParent(
				type: unknown,
				id?: string,
			): Eto.Widget;

			/** Finds a control in the parent hierarchy with the specified `id` */
			FindParent(id: string): Eto.Widget;

			/**
			 * Unbinds any bindings in the {@link Eto.Forms.BindableWidget.Bindings} collection and
			 * removes the bindings
			 *
			 * When you implement {@link Eto.Forms.IBindableWidgetContainer}, this will also unbind
			 * any of its children.
			 */
			Unbind(): void;

			/**
			 * Updates all bindings in this widget
			 *
			 * When you implement {@link Eto.Forms.IBindableWidgetContainer}, this will also update
			 * bindings for all of its children.
			 */
			UpdateBindings(mode?: Eto.Forms.BindingUpdateMode): void;

			/** Disposes of this widget, supressing the finalizer */
			dispose(): void;

			/** Gets a string that represents the current object with its ID if specified. */
			ToString(): string;
		}
	}

	export namespace Eto.Forms.FloatingForm {
		export interface IHandler extends
			Eto.Forms.Form.IHandler,
			Eto.Forms.Window.IHandler,
			Eto.Forms.Panel.IHandler,
			Eto.Forms.Container.IHandler,
			Eto.Forms.Control.IHandler,
			Eto.Widget.IHandler,
			Eto.Forms.IContextMenuHost {
		}
	}

	export namespace Eto.Forms {
		/**
		 * Dialog for a user to pick a font and style
		 *
		 * The font dialog on some platforms may run asynchronously, and return immediately after
		 * the {@link Eto.Forms.CommonDialog.ShowDialog(Eto.Forms.Control)} call. For example, on
		 * OS X the font dialog is a non-modal shared tool window that stays on the screen until
		 * the user dismisses it.  You should always handle the
		 * {@link Eto.Forms.FontDialog.FontChanged} event to determine when the value has
		 * changed.
		 */
		export class FontDialog implements
			Eto.IHandlerSource {
			constructor();

			/** Gets or sets the currently selected font. */
			Font: Eto.Drawing.Font;

			/**
			 * Gets the platform that was used to create the {@link Eto.Widget.Handler} for this
			 * widget
			 *
			 * This gets set to the current {@link Eto.Platform.Instance} during the construction of
			 * the object
			 */
			readonly Platform: Eto.Platform;

			/** Gets the platform-specific handler for this widget */
			Handler: unknown;

			/** Gets the native platform-specific handle for integration purposes */
			readonly NativeHandle: unknown;

			/** Gets the dictionary of properties for this widget */
			readonly Properties: Eto.PropertyStore;

			/** Gets or sets the ID of this widget */
			ID: string;

			/**
			 * Gets or sets the style of this widget
			 *
			 * Styles allow you to attach custom platform-specific logic to a widget. In your
			 * platform-specific assembly, use {@link Style.Add{H}(string, StyleHandler{H})} to add
			 * the style logic with the same id.
			 */
			Style: string;

			/**
			 * Gets the instance of the platform-specific object
			 *
			 * This can sometimes be useful to get the platform-specific object. Some handlers may
			 * not have any backing object for its functionality, so this may be null.  It is more
			 * preferred to use the {@link Eto.Widget.Handler} and cast that to the platform-specific
			 * handler class which can give you additional methods and helpers to do common tasks.
			 * For example, the {@link Eto.Forms.Application} object's handler for OS X has a
			 * AddFullScreenMenuItem property to specify if you want full screen support in your app.
			 */
			readonly ControlObject: unknown;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Widget} has been disposed.
			 *
			 * When the widget is disposed, it can no longer be used.
			 */
			IsDisposed: boolean;

			/** Shows the dialog with the specified parent, blocking until a result is returned. */
			ShowDialog(parent: Eto.Forms.Control): Eto.Forms.DialogResult;

			/**
			 * Shows the dialog with the specified parent window, blocking until a result is
			 * returned.
			 */
			ShowDialog(parent: Eto.Forms.Window): Eto.Forms.DialogResult;

			/** Disposes of this widget, supressing the finalizer */
			dispose(): void;

			/** Gets a string that represents the current object with its ID if specified. */
			ToString(): string;
		}
	}

	export namespace Eto.Forms.FontDialog {
		export interface ICallback extends Eto.Widget.ICallback {
			OnFontChanged(
				widget: Eto.Forms.FontDialog,
				e: unknown,
			): void;
		}
	}

	export namespace Eto.Forms.FontDialog {
		export interface IHandler extends
			Eto.Forms.CommonDialog.IHandler,
			Eto.Widget.IHandler {
			Font: Eto.Drawing.Font;
		}
	}

	export namespace Eto.Forms {
		/** Non-modal form window */
		export class Form implements
			Eto.IHandlerSource,
			Eto.Forms.IBindable,
			Eto.Forms.IMouseInputSource,
			Eto.Forms.IKeyboardInputSource {
			/** Initializes a new instance of the {@link Eto.Forms.Form} class. */
			constructor();

			constructor(handler: Eto.Forms.Form.IHandler);

			/**
			 * Gets or sets a value indicating that the form should be activated when initially
			 * shown.
			 *
			 * When true , the form will become the active/focussed window when the
			 * {@link Eto.Forms.Form.Show} method is called. When false , the form will show but will
			 * not get focus until the user clicks on the form.
			 */
			ShowActivated: boolean;

			/**
			 * Gets or sets a value indicating that this form can get keyboard/input focus when the
			 * user clicks on it or any child control.
			 *
			 * This is useful for windows that provide interaction but do not steal focus from the
			 * current window, such as a tooltip, popover, etc.
			 */
			CanFocus: boolean;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Forms.Control} is visible to
			 * the user.
			 *
			 * When the visibility of a control is set to false, it will still occupy space in the
			 * layout, but not be shown. The only exception is for controls like the
			 * {@link Eto.Forms.Splitter}, which will hide a pane if the visibility of one of the
			 * panels is changed.
			 */
			Visible: boolean;

			/**
			 * Gets or sets the title of the window
			 *
			 * The title of the window is displayed to the user usually at the top of the window, but
			 * in cases where you show a window in a mobile environment, this may be the title shown
			 * in a navigation controller.
			 */
			Title: string;

			/**
			 * Gets or sets the location of the window
			 *
			 * Note that in multi-monitor setups, the origin of the location is at the upper-left of
			 * {@link Eto.Forms.Screen.PrimaryScreen}.  Also note, that on Linux systems running GTK
			 * via Wayland, this will always point to 0, 0 , and setting it to different values will
			 * have no effect.
			 */
			Location: Eto.Drawing.Point;

			/** Gets or sets the size and location of the window */
			Bounds: Eto.Drawing.Rectangle;

			/**
			 * Gets or sets the tool bar for the window.
			 *
			 * Note that each window can only have a single tool bar
			 */
			ToolBar: Eto.Forms.ToolBar;

			/** Gets or sets the opacity of the window */
			Opacity: number;

			/**
			 * Gets or sets the owner of this window.
			 *
			 * This sets the parent window that has ownership over this window. For a
			 * {@link Eto.Forms.Dialog}, this will be the window that will be disabled while the
			 * modal dialog is shown. With a {@link Eto.Forms.Form}, the specified owner will always
			 * be below the current window when shown, and will  still be responsive to user input.
			 * Typically, but not always, the window will move along with the owner.
			 */
			Owner: Eto.Forms.Window;

			/**
			 * Gets the screen this window is mostly contained in. Typically defined by the screen
			 * center of the window is visible.
			 */
			readonly Screen: Eto.Forms.Screen;

			/**
			 * Gets or sets the menu bar for this window
			 *
			 * Some platforms have a global menu bar (e.g. Ubuntu, OS X). When the window is in
			 * focus, the global menu bar will be changed to reflect the menu assigned.
			 */
			Menu: Eto.Forms.MenuBar;

			/**
			 * Gets or sets the icon for the window to show in the menu bar.
			 *
			 * The icon should have many variations, such as 16x16, 24x24, 32x32, 48x48, 64x64, etc.
			 * This ensures that the many places it is used (title bar, task bar, switch window, etc)
			 * all have optimized icon sizes.  For OS X, the application icon is specified in the
			 * .app bundle, not by this value.
			 */
			Icon: Eto.Drawing.Icon;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Forms.Window} is resizable.
			 */
			Resizable: boolean;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Forms.Window} can be
			 * maximized.
			 *
			 * This may hide or disable the minimize button on the title bar.
			 */
			Maximizable: boolean;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Forms.Window} can be
			 * minimized.
			 *
			 * This may hide or disable the maximize button on the title bar.
			 */
			Minimizable: boolean;

			/**
			 * Gets or sets a value indicating whether the close button should be shown. Defaults to
			 * true
			 *
			 * Note that on some platforms (e.g. Windows) this also hides the system menu and
			 * minimize/maximize buttons. Note that this does not prevent the window from being
			 * closed, to do that use the {@link Eto.Forms.Window.Closing} event.
			 */
			Closeable: boolean;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Forms.Window} will show in the
			 * taskbar.
			 *
			 * Some platforms, e.g. macOS do not show a separate icon for each running window.  You
			 * may also have to add  the LSUIElement key to your app's Info.plist to make your app
			 * hidden in the dock.   See
			 * https://developer.apple.com/library/archive/documentation/General/Reference/InfoPlistKeyReference/Articles/LaunchServicesKeys.html#//apple_ref/doc/uid/TP40009250-108256-TPXREF136
			 */
			ShowInTaskbar: boolean;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Forms.Window} is above all
			 * other windows.
			 *
			 * The window should be above all other windows when this is true.  In some platforms,
			 * this will show above all other windows only when the application has focus.
			 */
			Topmost: boolean;

			/** Gets or sets the state of the window. */
			WindowState: Eto.Forms.WindowState;

			/**
			 * Gets the bounds of the window before it was minimized or maximized, or the current
			 * bounds if {@link Eto.Forms.Window.WindowState} is Normal.
			 *
			 * This is useful to retrieve the desired size and position of the window even though it
			 * is currently maximized or minimized.
			 */
			readonly RestoreBounds: Eto.Drawing.Rectangle;

			/** Gets or sets the style of this window. */
			WindowStyle: Eto.Forms.WindowStyle;

			/**
			 * Gets the number of pixels per logical pixel when on a high DPI display.
			 *
			 * This indicates the number of pixels per logical pixel.   All units in Eto.Forms such
			 * as control size, drawing operations, etc are in logical pixels. When not in high DPI,
			 * this will be 1.0;  Retina displays in OS X will return 2; and in windows this matches
			 * the scale set in the monitor settings.  Use the
			 * {@link Eto.Forms.Window.LogicalPixelSizeChanged} to detect when the window is moved to
			 *  a display with a different DPI.
			 */
			readonly LogicalPixelSize: number;

			/**
			 * Gets or sets a value indicating that the window can be moved by click+dragging the
			 * window background
			 */
			MovableByWindowBackground: boolean;

			/**
			 * Gets or sets a value indicating that the window will automatically resize when its
			 * content changes
			 *
			 * Note that if you set both dimensions of the {@link Eto.Drawing.Size} and/or
			 * {@link Eto.Forms.Container.ClientSize}, this will be set to false.
			 */
			AutoSize: boolean;

			/** Gets an enumeration of controls that are directly contained by this container */
			readonly Controls: Iterable<Eto.Forms.Control>;

			/** Gets or sets the padding around the {@link Eto.Forms.Panel.Content} of the panel. */
			Padding: Eto.Drawing.Padding;

			/** Gets or sets the minimum size of the panel. */
			MinimumSize: Eto.Drawing.Size;

			/**
			 * Gets or sets the context menu for the panel.
			 *
			 * The context menu is usually shown when the user right clicks the control, or in mobile
			 * platforms when the user taps and holds their finger down on the control.
			 */
			ContextMenu: Eto.Forms.ContextMenu;

			/**
			 * Gets or sets the main content of the panel.
			 *
			 * The main content will be offset by the {@link Eto.Forms.Panel.Padding} value
			 * specified, and will take up the entire content area of the control. Some controls may
			 * have decorations that will surround the content, such as a {@link Eto.Forms.GroupBox},
			 * {@link Eto.Forms.TabControl}, or {@link Eto.Forms.Window}
			 */
			Content: Eto.Forms.Control;

			/**
			 * Gets or sets the size for the client area of the control
			 *
			 * The client size differs from the {@link Eto.Forms.Control.Size} in that it excludes
			 * the decorations of the container, such as the title bar and border around a
			 * {@link Eto.Forms.Window}, or the title and line  around a {@link Eto.Forms.GroupBox}.
			 */
			ClientSize: Eto.Drawing.Size;

			/**
			 * Gets an enumeration of all contained child controls, including controls within child
			 * containers
			 */
			readonly Children: Iterable<Eto.Forms.Control>;

			/**
			 * Gets an enumeration of all contained child controls in the visual tree, including
			 * controls within child containers.
			 */
			readonly VisualChildren: Iterable<Eto.Forms.Control>;

			/**
			 * Gets or sets the style provider for this container.
			 *
			 * The style provider is used to style this container and its children.
			 */
			StyleProvider: Eto.IStyleProvider;

			/**
			 * Gets the default style provider for this container.
			 *
			 * Use this to apply styles to any child controls of this container. By default, styles
			 * will apply to all children, including children of children unless
			 * {@link Eto.DefaultStyleProvider.Inherit} is set to false .  Typically, you would set
			 * Inherit to false when creating composite controls that already have all their styles
			 * applied and you don't want any other styles to be inherited.
			 */
			readonly Styles: Eto.DefaultStyleProvider;

			/**
			 * Gets a value indicating that the control is loaded onto a form, that is it has been
			 * created, added to a parent, and shown
			 *
			 * The {@link Eto.Forms.Control.OnLoad(System.EventArgs)} method sets this value to true
			 * after cascading to all children (for a {@link Eto.Forms.Container} ) and calling the
			 * platform handler's implementation.  It is called after adding to a loaded form, or
			 * when showing a new form.  The {@link Eto.Forms.Control.OnUnLoad(System.EventArgs)}
			 * method will set this value to false when the control is removed from its parent
			 */
			readonly Loaded: boolean;

			/**
			 * Gets an enumeration of controls that are in the visual tree.
			 *
			 * This is used to specify which controls are contained by this instance that are part of
			 * the visual tree. This should include all controls including non-logical Eto controls
			 * used for layout.
			 */
			readonly VisualControls: Iterable<Eto.Forms.Control>;

			/**
			 * Gets or sets a user-defined object that contains data about the control
			 *
			 * A common use of the tag property is to store data that is associated with the control
			 * that you can later retrieve.
			 */
			Tag: unknown;

			/**
			 * Gets the logical parent control.
			 *
			 * When the control is part of the visual tree (
				 * {@link Eto.Forms.Control.IsVisualControl} is true), this returns the logical parent
				 * that contains this control. Otherwise this is the same as
				 * {@link Eto.Forms.Control.Parent}.
				 */
				readonly LogicalParent: Eto.Forms.Container;

			/** Gets a value indicating this {@link Eto.Forms.Control} is part of the visual tree. */
			IsVisualControl: boolean;

			/**
			 * Gets or sets the size of the control. Use -1 to specify auto sizing for either the
			 * width and/or height.
			 *
			 * Setting the size of controls is entirely optional as most controls will size
			 * themselves appropriately. When specifying a size, it will be used as the desired size
			 * of the control.  The container will reposition and resize the control depending on the
			 * available size.  For a {@link Eto.Forms.Window}, it is preferred to set the
			 * {@link Eto.Forms.Container.ClientSize} instead, as various platforms have different
			 * sizes of window decorations, toolbars, etc.
			 */
			Size: Eto.Drawing.Size;

			/**
			 * Gets a value indicating this control currently has mouse capture
			 *
			 * Mouse capture can happen during a handled MouseDown event until MouseUp, or it can be
			 * captured explicitly via {@link Eto.Forms.Control.CaptureMouse}.
			 */
			readonly IsMouseCaptured: boolean;

			/** Gets or sets the width of the control size. */
			Width: number;

			/** Gets or sets the height of the control size. */
			Height: number;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Forms.Control} (or its
			 * children) are enabled and accept user input.
			 *
			 * Typically when a control is disabled, the user cannot do anything with the control or
			 * any of its children. Including for example, selecting text in a text control. Certain
			 * controls can have a 'Read Only' mode, such as {@link Eto.Forms.TextBox.ReadOnly} which
			 * allow the user to  select text, but not change its contents.
			 */
			Enabled: boolean;

			/** Gets the container which this control has been added to, if any */
			readonly Parent: Eto.Forms.Container;

			/**
			 * Gets the visual container of this control, if any.
			 *
			 * Some containers may use other Eto controls to layout its children, such as the
			 * {@link Eto.Forms.StackLayout}. This will return the parent control that visually
			 * contains this control as opposed to {@link Eto.Forms.Control.Parent} which will return
			 * the logical parent.
			 */
			VisualParent: Eto.Forms.Container;

			/** Gets a value indicating this control has been attached to a native container */
			readonly IsAttached: boolean;

			/**
			 * Gets or sets the color for the background of the control
			 *
			 * Note that on some platforms (e.g. Mac), setting the background color of a control can
			 * change the performance characteristics of the control and its children, since it must
			 * enable layers to do so.
			 */
			BackgroundColor: Eto.Drawing.Color;

			/** Gets a value indicating whether this instance has the keyboard input focus. */
			readonly HasFocus: boolean;

			/** Gets a value indicating whether the layout of child controls is suspended. */
			readonly IsSuspended: boolean;

			/** Gets the window this control is contained in */
			readonly ParentWindow: Eto.Forms.Window;

			/**
			 * Gets the supported platform commands that can be used to hook up system functions to
			 * user defined logic
			 *
			 * This lists all available commands that can be mapped using the
			 * {@link Eto.Forms.Control.MapPlatformCommand(System.String,Eto.Forms.Command)} method
			 * of the control.
			 */
			readonly SupportedPlatformCommands: Iterable<string>;

			/** Gets or sets the type of cursor to use when the mouse is hovering over the control */
			Cursor: Eto.Forms.Cursor;

			/** Gets or sets the tool tip to show when the mouse is hovered over the control */
			ToolTip: string;

			/**
			 * Gets or sets the tab index order for this control within its container.
			 *
			 * This sets the order when using the tab key to cycle through controls  Note that some
			 * platforms (Gtk and WinForms) may not support setting the context of the tab order to
			 * StackLayout  or DynamicLayout containers and may not behave exactly as expected. Use
			 * the {@link Eto.PlatformFeatures.TabIndexWithCustomContainers} flag to determine if it
			 * is supported.
			 */
			TabIndex: number;

			/** Gets or sets a value indicating whether this control can serve as drop target. */
			AllowDrop: boolean;

			/**
			 * Gets or sets the parent widget which this widget has been added to, if any
			 *
			 * When implementing child widgets that can participate in the context based binding
			 * (MVVM), You can set this to the parent widget when it is added or removed to it
			 * (usually via a collection).  Note that you should typically provide a public new
			 * [ParentWidget] Parent { get; } property  so that consumers of your API cannot set the
			 * parent to an invalid value.
			 */
			Parent: Eto.Widget;

			/**
			 * Gets an enumeration of all parent widgets in the heirarchy by traversing the
			 * {@link Eto.Forms.BindableWidget.Parent} property.
			 */
			readonly Parents: Iterable<Eto.Widget>;

			/**
			 * Gets or sets the data context for this widget for binding
			 *
			 * Subclasses may override the standard behaviour so that hierarchy of widgets can be
			 * taken into account.  For example, a Control may return the data context of a parent,
			 * if it is not set explicitly.
			 */
			DataContext: unknown;

			/** Gets the collection of bindings that are attached to this widget */
			readonly Bindings: Eto.Forms.BindingCollection;

			/**
			 * Gets a value indicating that the {@link Eto.Forms.BindableWidget.DataContext} property
			 * is changing.
			 *
			 * This can be used to determine when to allow certain logic during the update of the
			 * data context.  It is used to disable binding setters on the model when the data
			 * context changes so that a binding does not cause the view model to be updated when the
			 * state hasn't been fully set yet.
			 */
			IsDataContextChanging: boolean;

			/**
			 * Gets the platform that was used to create the {@link Eto.Widget.Handler} for this
			 * widget
			 *
			 * This gets set to the current {@link Eto.Platform.Instance} during the construction of
			 * the object
			 */
			readonly Platform: Eto.Platform;

			/** Gets the platform-specific handler for this widget */
			Handler: unknown;

			/** Gets the native platform-specific handle for integration purposes */
			readonly NativeHandle: unknown;

			/** Gets the dictionary of properties for this widget */
			readonly Properties: Eto.PropertyStore;

			/** Gets or sets the ID of this widget */
			ID: string;

			/**
			 * Gets or sets the style of this widget
			 *
			 * Styles allow you to attach custom platform-specific logic to a widget. In your
			 * platform-specific assembly, use {@link Style.Add{H}(string, StyleHandler{H})} to add
			 * the style logic with the same id.
			 */
			Style: string;

			/**
			 * Gets the instance of the platform-specific object
			 *
			 * This can sometimes be useful to get the platform-specific object. Some handlers may
			 * not have any backing object for its functionality, so this may be null.  It is more
			 * preferred to use the {@link Eto.Widget.Handler} and cast that to the platform-specific
			 * handler class which can give you additional methods and helpers to do common tasks.
			 * For example, the {@link Eto.Forms.Application} object's handler for OS X has a
			 * AddFullScreenMenuItem property to specify if you want full screen support in your app.
			 */
			readonly ControlObject: unknown;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Widget} has been disposed.
			 *
			 * When the widget is disposed, it can no longer be used.
			 */
			IsDisposed: boolean;

			/** Show the form */
			Show(): void;

			/**
			 * Closes the window
			 *
			 * Note that once a window is closed, it cannot be shown again in most platforms.
			 */
			Close(): void;

			/**
			 * Sets {@link Eto.Forms.Window.WindowState} to {@link Eto.Forms.WindowState.Minimized}
			 */
			Minimize(): void;

			/**
			 * Sets {@link Eto.Forms.Window.WindowState} to {@link Eto.Forms.WindowState.Maximized}
			 */
			Maximize(): void;

			/**
			 * Brings the window in front of all other windows in the z-order.  This should not
			 * activate/focus the window.
			 */
			BringToFront(): void;

			/**
			 * Sends the window behind all other windows in the z-order, and will remain active if it
			 * has focus.
			 */
			SendToBack(): void;

			/** Removes the specified child from the container */
			Remove(child: Eto.Forms.Control): void;

			/** Remove the specified `controls` from this container */
			Remove(controls: Iterable<Eto.Forms.Control>): void;

			/** Removes all controls from this container */
			RemoveAll(): void;

			/**
			 * Finds a child control in this container or any of its child containers with the
			 * specified `id`
			 */
			FindChild<T>(id?: string): T;

			/**
			 * Finds a child control in this container or any of its child containers with the
			 * specified `type`
			 */
			FindChild(
				type: unknown,
				id?: string,
			): Eto.Forms.Control;

			/**
			 * Finds a child control in this container or any of its child containers with the
			 * specified `id`.
			 */
			FindChild(id: string): Eto.Forms.Control;

			/**
			 * Queues a repaint of the entire control on the screen and any of its children.
			 *
			 * This is only useful when the control is visible.
			 */
			Invalidate(): void;

			/**
			 * Queues a repaint of the entire control on the screen
			 *
			 * This is only useful when the control is visible.
			 */
			Invalidate(invalidateChildren: boolean): void;

			/**
			 * Queues a repaint of the specified `rect` of the control and any children.
			 *
			 * This is only useful when the control is visible.
			 */
			Invalidate(rect: Eto.Drawing.Rectangle): void;

			/**
			 * Queues a repaint of the specified `rect` of the control
			 *
			 * This is only useful when the control is visible.
			 */
			Invalidate(
				rect: Eto.Drawing.Rectangle,
				invalidateChildren: boolean,
			): void;

			/**
			 * Updates the layout of this control if necessary.
			 *
			 * This will ensure the control has had all of its layout applied so you can use its
			 * position and size right after this call. Most platforms (except WinForms) use a
			 * deferred layout system so that after adding your control to the form dynamically it
			 * won't get laid out until the next idle loop. This is useful when you need to know the
			 * dimensions of the control immediately. Note that this can be an expensive operation,
			 * so it is recommended to only call this method when necessary and after all of the
			 * controls have been added/updated.
			 */
			UpdateLayout(): void;

			/** Gets the preferred size of this control given infinite space available. */
			GetPreferredSize(): Eto.Drawing.SizeF;

			/** Gets the preferred size of this control given the specified `availableSize`. */
			GetPreferredSize(availableSize: Eto.Drawing.SizeF): Eto.Drawing.SizeF;

			/**
			 * Captures all mouse events to this control.
			 *
			 * This captures all mouse events until {@link Eto.Forms.Control.ReleaseMouseCapture} is
			 * called.  Note that not all platforms will allow a mouse capture unless the mouse is
			 * currently down.
			 */
			CaptureMouse(): boolean;

			/** Releases the mouse capture after a call to {@link Eto.Forms.Control.CaptureMouse}. */
			ReleaseMouseCapture(): void;

			/**
			 * Finds a control in the parent hierarchy with the specified type and
			 * {@link Eto.Widget.ID} if specified
			 */
			FindParent(
				type: unknown,
				id?: string,
			): Eto.Forms.Container;

			/** Finds a control in the parent hierarchy with the specified `id` */
			FindParent(id: string): Eto.Forms.Container;

			/**
			 * Detaches the control by removing it from its parent
			 *
			 * This is essentially a shortcut to myControl.Parent.Remove(myControl);
			 */
			Detach(): void;

			/**
			 * Attaches the control for direct use in a native application
			 *
			 * Use this to use a control directly in a native application.  Note that the native
			 * application must be running the same framework as the current platform.  E.g. a
			 * WinForms application can use an Eto.Forms control when using the Eto.WinForms
			 * platform.  This prepares the control by firing the {@link Eto.Forms.Control.PreLoad},
			 * {@link Eto.Forms.Control.Load}, etc. events.
			 */
			AttachNative(): void;

			/**
			 * Detaches the control when it is used in a native application, when you want to reuse
			 * the control.
			 *
			 * This should only be called after {@link Eto.Forms.Control.AttachNative} has been
			 * called, which is usually done by calling to ToNative(true) .
			 */
			DetachNative(): void;

			/**
			 * Attempts to set the keyboard input focus to this control, or the first child that
			 * accepts focus. For Windows, this will bring it to front and activate it.
			 */
			Focus(): void;

			/**
			 * Suspends the layout of child controls
			 *
			 * This can be used to optimize some platforms while adding, removing, or changing many
			 * child controls at once. It disables the calculation of control positioning until
			 * {@link Eto.Forms.Control.ResumeLayout} is called. Each call to SuspendLayout() must be
			 * balanced with a call to {@link Eto.Forms.Control.ResumeLayout}.
			 */
			SuspendLayout(): void;

			/**
			 * Resumes the layout after it has been suspended, and performs a layout
			 *
			 * This can be used to optimize some platforms while adding, removing, or changing many
			 * child controls at once. Each call to ResumeLayout() must be balanced with a call to
			 * {@link Eto.Forms.Control.SuspendLayout} before it.
			 */
			ResumeLayout(): void;

			/**
			 * Specifies a command to execute for a platform-specific command
			 *
			 * Some platforms have specific system-defined commands that can be associated with a
			 * control. For example, the Mac platform's cut/copy/paste functionality is defined by
			 * the system, and if you want to hook into it, you can use this to map it to your own
			 * defined logic. The valid values of the `systemCommand` parameter are defined by each
			 * platform, and a list can be retrieved using
			 * {@link Eto.Forms.Control.SupportedPlatformCommands}
			 */
			MapPlatformCommand(
				systemCommand: string,
				command: Eto.Forms.Command,
			): void;

			/** Converts a point from screen space to control space. */
			PointFromScreen(point: Eto.Drawing.PointF): Eto.Drawing.PointF;

			/** Converts a point from control space to screen space */
			PointToScreen(point: Eto.Drawing.PointF): Eto.Drawing.PointF;

			/** Converts a rectangle from screen space to control space. */
			RectangleToScreen(rect: Eto.Drawing.RectangleF): Eto.Drawing.RectangleF;

			/** Converts a rectangle from control space to screen space */
			RectangleFromScreen(rect: Eto.Drawing.RectangleF): Eto.Drawing.RectangleF;

			/**
			 * Starts drag operation using this control as drag source.
			 *
			 * This method can be blocking on some platforms (Wpf, WinForms), and non-blocking on
			 * others (Mac, Gtk). Use the {@link Eto.Forms.Control.DragEnd} event to determine when
			 * the drag operation is completed and get its resulting DragEffects.
			 */
			DoDragDrop(
				data: Eto.Forms.DataObject,
				allowedEffects: Eto.Forms.DragEffects,
			): void;

			/**
			 * Starts drag operation using this control as drag source.
			 *
			 * This method can be blocking on some platforms (Wpf, WinForms), and non-blocking on
			 * others (Mac, Gtk). Use the {@link Eto.Forms.Control.DragEnd} event to determine when
			 * the drag operation is completed and get its resulting DragEffects.
			 */
			DoDragDrop(
				data: Eto.Forms.DataObject,
				allowedEffects: Eto.Forms.DragEffects,
				image: Eto.Drawing.Image,
				cursorOffset: Eto.Drawing.PointF,
			): void;

			/**
			 * Triggers the StyleChanged event and re-applies the styles to this control and its
			 * children.
			 */
			TriggerStyleChanged(): void;

			/** Shows a print dialog to print the specified control */
			Print(): void;

			/**
			 * Finds a control in the parent hierarchy with the specified type and
			 * {@link Eto.Widget.ID} if specified
			 */
			FindParent<T>(id?: string): T;

			/**
			 * Finds a control in the parent hierarchy with the specified type and
			 * {@link Eto.Widget.ID} if specified
			 */
			FindParent(
				type: unknown,
				id?: string,
			): Eto.Widget;

			/** Finds a control in the parent hierarchy with the specified `id` */
			FindParent(id: string): Eto.Widget;

			/**
			 * Unbinds any bindings in the {@link Eto.Forms.BindableWidget.Bindings} collection and
			 * removes the bindings
			 *
			 * When you implement {@link Eto.Forms.IBindableWidgetContainer}, this will also unbind
			 * any of its children.
			 */
			Unbind(): void;

			/**
			 * Updates all bindings in this widget
			 *
			 * When you implement {@link Eto.Forms.IBindableWidgetContainer}, this will also update
			 * bindings for all of its children.
			 */
			UpdateBindings(mode?: Eto.Forms.BindingUpdateMode): void;

			/** Disposes of this widget, supressing the finalizer */
			dispose(): void;

			/** Gets a string that represents the current object with its ID if specified. */
			ToString(): string;
		}
	}

	export namespace Eto.Forms.Form {
		export interface IHandler extends
			Eto.Forms.Window.IHandler,
			Eto.Forms.Panel.IHandler,
			Eto.Forms.Container.IHandler,
			Eto.Forms.Control.IHandler,
			Eto.Widget.IHandler,
			Eto.Forms.IContextMenuHost {
			ShowActivated: boolean;

			CanFocus: boolean;

			Show(): void;
		}
	}

	export namespace Eto.Forms {
		/**
		 * [Generic type factory] Base data store interface to bind to a collection of objects of
		 * a particular type.
		 *
		 * Note that you should use an
		 * {@link System.Collections.ObjectModel.ObservableCollection<>} if you want the control
		 * to respond to changes of the collection.
		 */
		export function IDataStore$(T: IType): IType;

		/**
		 * Base data store interface to bind to a collection of objects of a particular type.
		 *
		 * Note that you should use an
		 * {@link System.Collections.ObjectModel.ObservableCollection<>} if you want the control
		 * to respond to changes of the collection.
		 */
		export interface IDataStore$1<T> {
			/** Gets the number of items in this data store. */
			readonly Count: number;
		}
	}

	export namespace Eto.Forms {
		/**
		 * [Generic type factory] Collection of items that implements the
		 * {@link Eto.Forms.IDataStore<>} interface
		 */
		export function DataStoreCollection$(T: IType): typeof DataStoreCollection$1<any>;

		/** Collection of items that implements the {@link Eto.Forms.IDataStore<>} interface */
		export class DataStoreCollection$1<T> {
			/** Initializes a new instance of the {@link Eto.Forms.DataStoreCollection<>} class. */
			new(): DataStoreCollection$1<T>;

			/**
			 * Initializes a new instance of the {@link Eto.Forms.DataStoreCollection<>} class with
			 * the specified items.
			 */
			new(items: Iterable<T>): DataStoreCollection$1<T>;

			Sort(comparer: unknown): void;

			Sort(comparison: unknown): void;

			AddRange(items: Iterable<T>): void;
		}
	}

	export namespace Eto.Forms {
		/** Defines an interface for controls or classes that implement keyboard events. */
		export interface IKeyboardInputSource {
		}
	}

	export namespace Eto.Forms {
		/** Defines an interface for controls or classes that implement mouse events. */
		export interface IMouseInputSource {
		}
	}

	export namespace Eto.Forms {
		/** Enumeration of values that correspond to physical keys on a keyboard */
		export enum Keys {
			/** No key */
			None = 0,

			/** The A key */
			A = 1,

			/** The B key */
			B = 2,

			/** The C key */
			C = 3,

			/** The D key */
			D = 4,

			/** The E key */
			E = 5,

			/** The F key */
			F = 6,

			/** The G key */
			G = 7,

			/** The H key */
			H = 8,

			/** The I key */
			I = 9,

			/** The J key */
			J = 10,

			/** The K key */
			K = 11,

			/** The L key */
			L = 12,

			/** The M key */
			M = 13,

			/** The N key */
			N = 14,

			/** The O key */
			O = 15,

			/** The P key */
			P = 16,

			/** The Q key */
			Q = 17,

			/** The R key */
			R = 18,

			/** The S key */
			S = 19,

			/** The T key */
			T = 20,

			/** The U key */
			U = 21,

			/** The V key */
			V = 22,

			/** The W key */
			W = 23,

			/** The X key */
			X = 24,

			/** The Y key */
			Y = 25,

			/** The Z key */
			Z = 26,

			/** The F1 key */
			F1 = 27,

			/** The F2 key */
			F2 = 28,

			/** The F3 key */
			F3 = 29,

			/** The F4 key */
			F4 = 30,

			/** The F5 key */
			F5 = 31,

			/** The F6 key */
			F6 = 32,

			/** The F7 key */
			F7 = 33,

			/** The F8 key */
			F8 = 34,

			/** The F9 key */
			F9 = 35,

			/** The F10 key */
			F10 = 36,

			/** The F11 key */
			F11 = 37,

			/** The F12 key */
			F12 = 38,

			/** The 0 digit key */
			D0 = 39,

			/** The 1 digit key */
			D1 = 40,

			/** The 2 digit key */
			D2 = 41,

			/** The 3 digit key */
			D3 = 42,

			/** The 4 digit key */
			D4 = 43,

			/** The 5 digit key */
			D5 = 44,

			/** The 6 digit key */
			D6 = 45,

			/** The 7 digit key */
			D7 = 46,

			/** The 8 digit key */
			D8 = 47,

			/** The 9 digit key */
			D9 = 48,

			/** The Minus '-' key */
			Minus = 49,

			/**
			 * The Plus '+' Key, which usually produces an '=' when pressed without shift and is
			 * beside the backspace key.
			 */
			Plus = 85,

			/** The Grave '`' key */
			Grave = 51,

			/** The Insert key */
			Insert = 52,

			/** The Home key */
			Home = 53,

			/** The Page Up key */
			PageUp = 54,

			/** The Page Down key */
			PageDown = 55,

			/** The Delete key */
			Delete = 56,

			/** The End key */
			End = 57,

			/** The Divide '/' key, usually on the keypad/number pad */
			Divide = 58,

			/** The Decimal '.' key, usually on the keypad/number pad */
			Decimal = 59,

			/** The Backspace key */
			Backspace = 60,

			/** The Up key */
			Up = 61,

			/** The Down key */
			Down = 62,

			/** The Left key */
			Left = 63,

			/** The Right key */
			Right = 64,

			/** The Tab key */
			Tab = 65,

			/** The Space key */
			Space = 66,

			/** The Caps Lock key */
			CapsLock = 67,

			/** The Scroll Lock key */
			ScrollLock = 68,

			/** The Print Screen key */
			PrintScreen = 69,

			/** The Number Lock key */
			NumberLock = 70,

			/** The Enter key */
			Enter = 71,

			/** The Escape key */
			Escape = 72,

			/** The Multiply '*' key, usually on the keypad/number pad */
			Multiply = 73,

			/** The Add '+' key, usually on the keypad/number pad */
			Add = 74,

			/** The Subtract '-' key, usually on the keypad/number pad */
			Subtract = 75,

			/** The Help key */
			Help = 76,

			/** The Pause key */
			Pause = 77,

			/** The Clear key */
			Clear = 78,

			/** The Equal '=' key on the keypad/number pad */
			KeypadEqual = 79,

			/** The menu (alt) key */
			Menu = 80,

			/** The Backslash '\' key */
			Backslash = 81,

			/** The Equal '=' key */
			Equal = 85,

			/** The Semicolon ';' key */
			Semicolon = 86,

			/** The Quote ''' key */
			Quote = 87,

			/** The Comma ',' key */
			Comma = 88,

			/** The Period '.' key */
			Period = 89,

			/** The Forward Slash '/' key */
			ForwardSlash = 96,

			/** The Slash '/' key */
			Slash = 96,

			/** The Right Bracket ']' key */
			RightBracket = 97,

			/** The Left Bracket '['  key */
			LeftBracket = 98,

			/** The context menu key */
			ContextMenu = 99,

			/** The keypad/number pad '0' key */
			Keypad0 = 112,

			/** The keypad/number pad '1' key */
			Keypad1 = 113,

			/** The keypad/number pad '2' key */
			Keypad2 = 114,

			/** The keypad/number pad '3' key */
			Keypad3 = 115,

			/** The keypad/number pad '4' key */
			Keypad4 = 116,

			/** The keypad/number pad '5' key */
			Keypad5 = 117,

			/** The keypad/number pad '6' key */
			Keypad6 = 118,

			/** The keypad/number pad '7' key */
			Keypad7 = 119,

			/** The keypad/number pad '8' key */
			Keypad8 = 120,

			/** The keypad/number pad '9' key */
			Keypad9 = 121,

			/** The left shift key */
			LeftShift = 122,

			/** The right shift key */
			RightShift = 123,

			/** The left control key */
			LeftControl = 124,

			/** The right control key */
			RightControl = 125,

			/** The left alt/option key */
			LeftAlt = 126,

			/** The right alt/option key */
			RightAlt = 127,

			/** The right application/windows key */
			LeftApplication = 128,

			/** The right application/windows key */
			RightApplication = 129,

			/** The F13 key */
			F13 = 130,

			/** The F14 key */
			F14 = 131,

			/** The F15 key */
			F15 = 132,

			/** The F16 key */
			F16 = 133,

			/** The F17 key */
			F17 = 134,

			/** The F18 key */
			F18 = 135,

			/** The F19 key */
			F19 = 136,

			/** The F20 key */
			F20 = 137,

			/** The F21 key */
			F21 = 138,

			/** The F22 key */
			F22 = 139,

			/** The F23 key */
			F23 = 140,

			/** The F24 key */
			F24 = 141,

			/** The Shift Key Modifier */
			Shift = 4096,

			/** The Alt Key Modifier */
			Alt = 8192,

			/** The Control Key Modifier */
			Control = 16384,

			/** The Application/Windows Key Modifier */
			Application = 32768,

			/**
			 * The mask for the modifiers ( {@link Eto.Forms.Keys.Shift} / {@link Eto.Forms.Keys.Alt}
			 * / {@link Eto.Forms.Keys.Control} / {@link Eto.Forms.Keys.Application} )
			 */
			ModifierMask = 61440,

			/** The mask for the key value without modifiers */
			KeyMask = 4095,
		}
	}

	export namespace Eto.Forms {
		/** Extensions for the {@link Eto.Forms.Keys} enumeration */
		export namespace KeysExtensions {
			/** Converts the specified key to a shortcut string such as Ctrl+Alt+Z */
			export function ToShortcutString(
				key: Eto.Forms.Keys,
				separator?: string,
			): string;
		}
	}

	export namespace Eto.Forms {
		/** General keyboard methods */
		export namespace Keyboard {
			/**
			 * Gets an enumeration of all keys supported by the
			 * {@link Eto.Forms.Keyboard.IsKeyLocked(Eto.Forms.Keys)} method.
			 */
			export const SupportedLockKeys: Iterable<Eto.Forms.Keys>;

			/**
			 * Gets the current modifier state for keys such as {@link Eto.Forms.Keys.Control},
			 * {@link Eto.Forms.Keys.Alt} and {@link Eto.Forms.Keys.Shift}.
			 *
			 * This typically will only return a value for the current event, such as during a mouse
			 * or keyboard event.
			 */
			export const Modifiers: Eto.Forms.Keys;

			/**
			 * Determines if the specified `key` is in a locked state, such as the
			 * {@link Eto.Forms.Keys.CapsLock}, {@link Eto.Forms.Keys.ScrollLock},
			 * {@link Eto.Forms.Keys.NumberLock}, or {@link Eto.Forms.Keys.Insert} key.
			 */
			export function IsKeyLocked(key: Eto.Forms.Keys): boolean;
		}
	}

	export namespace Eto.Forms.Keyboard {
		export interface IHandler {
			readonly SupportedLockKeys: Iterable<Eto.Forms.Keys>;

			readonly Modifiers: Eto.Forms.Keys;

			IsKeyLocked(key: Eto.Forms.Keys): boolean;
		}
	}

	export namespace Eto.Forms {
		/** Control item for the {@link Eto.Forms.DynamicLayout} */
		export class DynamicControl {
			constructor();

			/** Gets or sets the control that this item contains */
			Control: Eto.Forms.Control;

			/**
			 * Gets or sets the horizontal scale of the item
			 *
			 * When true, the control takes up all remaining horizontal space available. If there is
			 * more than one item with this set to true, then they share the remaining space equally.
			 */
			XScale?: boolean;

			/**
			 * Gets or sets the vertical scale of the item
			 *
			 * When true, the control takes up all remaining vertical space available. If there is
			 * more than one item with this set to true, then they share the remaining space equally.
			 */
			YScale?: boolean;

			/** Creates the content for this item */
			Create(layout: Eto.Forms.DynamicLayout): Eto.Forms.Control;

			/** Create the item and add to the specified layout and co-ordinates */
			Create(
				layout: Eto.Forms.DynamicLayout,
				parent: Eto.Forms.TableLayout,
				x: number,
				y: number,
			): void;
		}
	}

	export namespace Eto.Forms {
		/** Base item for the {@link Eto.Forms.DynamicLayout} */
		export class DynamicItem {
			/**
			 * Gets or sets the horizontal scale of the item
			 *
			 * When true, the control takes up all remaining horizontal space available. If there is
			 * more than one item with this set to true, then they share the remaining space equally.
			 */
			XScale?: boolean;

			/**
			 * Gets or sets the vertical scale of the item
			 *
			 * When true, the control takes up all remaining vertical space available. If there is
			 * more than one item with this set to true, then they share the remaining space equally.
			 */
			YScale?: boolean;

			/** Creates the content for this item */
			Create(layout: Eto.Forms.DynamicLayout): Eto.Forms.Control;

			/** Create the item and add to the specified layout and co-ordinates */
			Create(
				layout: Eto.Forms.DynamicLayout,
				parent: Eto.Forms.TableLayout,
				x: number,
				y: number,
			): void;
		}
	}

	export namespace Eto.Forms {
		/**
		 * Dynamic and extensible layout
		 *
		 * The dynamic layout allows you to build a complex structure of controls easily. The
		 * core functionality allows  you to build a hierarchical set of tables with rows and
		 * columns of controls.  A vertical section begins a new table, whereas a horizontal
		 * section refers to a row in a table. The dynamic layout intrinsically starts with a
		 * vertical section.  You can define your layout verbosely or succinctly as you see fit.
		 * The Begin.../End... methods allow you define the vertical/horizontal sections
		 * individually with separate commands, whereas you can also create a layout entirely
		 * with a constructor or initializer pattern using the
		 * {@link Eto.Forms.DynamicLayout.Rows}, {@link Eto.Forms.DynamicTable.Rows}, and
		 * {@link Eto.Forms.DynamicRow.Items} properties.  To learn about how scaling works, see
		 * {@link Eto.Forms.TableLayout}
		 */
		export class DynamicLayout implements
			Eto.IHandlerSource,
			Eto.Forms.IBindable,
			Eto.Forms.IMouseInputSource,
			Eto.Forms.IKeyboardInputSource {
			/** Initializes a new instance of the {@link Eto.Forms.DynamicLayout} class. */
			constructor();

			/**
			 * Initializes a new instance of the {@link Eto.Forms.DynamicLayout} class with the
			 * specified rows
			 */
			constructor(rows: Eto.Forms.DynamicRow[]);

			/**
			 * Initializes a new instance of the {@link Eto.Forms.DynamicLayout} class with the
			 * specified rows
			 */
			constructor(rows: Iterable<Eto.Forms.DynamicRow>);

			/** Gets or sets the top level rows in the layout */
			readonly Rows: unknown;

			/**
			 * Gets a value indicating whether the layout has been created
			 *
			 * The layout automatically will be created during the
			 * {@link Eto.Forms.DynamicLayout.OnPreLoad(System.EventArgs)} or
			 * {@link Eto.Forms.DynamicLayout.OnLoad(System.EventArgs)}
			 */
			IsCreated: boolean;

			/** Gets or sets the padding around the entire content of the layout */
			Padding?: Eto.Drawing.Padding;

			/** Gets or sets the spacing between the first level of cells */
			Spacing?: Eto.Drawing.Size;

			/**
			 * Gets or sets the default padding for all child {@link Eto.Forms.DynamicTable}
			 * instances (vertical sections)
			 */
			DefaultPadding?: Eto.Drawing.Padding;

			/** Gets or sets the default spacing for all cells in the layout */
			DefaultSpacing?: Eto.Drawing.Size;

			/** Gets an enumeration of controls that are directly contained by this container */
			readonly Controls: Iterable<Eto.Forms.Control>;

			/**
			 * Gets an enumeration of controls that are in the visual tree.
			 *
			 * This is used to specify which controls are contained by this instance that are part of
			 * the visual tree. This should include all controls including non-logical Eto controls
			 * used for layout.
			 */
			readonly VisualControls: Iterable<Eto.Forms.Control>;

			/** Gets or sets the padding around the {@link Eto.Forms.Panel.Content} of the panel. */
			Padding: Eto.Drawing.Padding;

			/** Gets or sets the minimum size of the panel. */
			MinimumSize: Eto.Drawing.Size;

			/**
			 * Gets or sets the context menu for the panel.
			 *
			 * The context menu is usually shown when the user right clicks the control, or in mobile
			 * platforms when the user taps and holds their finger down on the control.
			 */
			ContextMenu: Eto.Forms.ContextMenu;

			/**
			 * Gets or sets the main content of the panel.
			 *
			 * The main content will be offset by the {@link Eto.Forms.Panel.Padding} value
			 * specified, and will take up the entire content area of the control. Some controls may
			 * have decorations that will surround the content, such as a {@link Eto.Forms.GroupBox},
			 * {@link Eto.Forms.TabControl}, or {@link Eto.Forms.Window}
			 */
			Content: Eto.Forms.Control;

			/**
			 * Gets or sets the size for the client area of the control
			 *
			 * The client size differs from the {@link Eto.Forms.Control.Size} in that it excludes
			 * the decorations of the container, such as the title bar and border around a
			 * {@link Eto.Forms.Window}, or the title and line  around a {@link Eto.Forms.GroupBox}.
			 */
			ClientSize: Eto.Drawing.Size;

			/**
			 * Gets an enumeration of all contained child controls, including controls within child
			 * containers
			 */
			readonly Children: Iterable<Eto.Forms.Control>;

			/**
			 * Gets an enumeration of all contained child controls in the visual tree, including
			 * controls within child containers.
			 */
			readonly VisualChildren: Iterable<Eto.Forms.Control>;

			/**
			 * Gets or sets the style provider for this container.
			 *
			 * The style provider is used to style this container and its children.
			 */
			StyleProvider: Eto.IStyleProvider;

			/**
			 * Gets the default style provider for this container.
			 *
			 * Use this to apply styles to any child controls of this container. By default, styles
			 * will apply to all children, including children of children unless
			 * {@link Eto.DefaultStyleProvider.Inherit} is set to false .  Typically, you would set
			 * Inherit to false when creating composite controls that already have all their styles
			 * applied and you don't want any other styles to be inherited.
			 */
			readonly Styles: Eto.DefaultStyleProvider;

			/**
			 * Gets a value indicating that the control is loaded onto a form, that is it has been
			 * created, added to a parent, and shown
			 *
			 * The {@link Eto.Forms.Control.OnLoad(System.EventArgs)} method sets this value to true
			 * after cascading to all children (for a {@link Eto.Forms.Container} ) and calling the
			 * platform handler's implementation.  It is called after adding to a loaded form, or
			 * when showing a new form.  The {@link Eto.Forms.Control.OnUnLoad(System.EventArgs)}
			 * method will set this value to false when the control is removed from its parent
			 */
			readonly Loaded: boolean;

			/**
			 * Gets or sets a user-defined object that contains data about the control
			 *
			 * A common use of the tag property is to store data that is associated with the control
			 * that you can later retrieve.
			 */
			Tag: unknown;

			/**
			 * Gets the logical parent control.
			 *
			 * When the control is part of the visual tree (
				 * {@link Eto.Forms.Control.IsVisualControl} is true), this returns the logical parent
				 * that contains this control. Otherwise this is the same as
				 * {@link Eto.Forms.Control.Parent}.
				 */
				readonly LogicalParent: Eto.Forms.Container;

			/** Gets a value indicating this {@link Eto.Forms.Control} is part of the visual tree. */
			IsVisualControl: boolean;

			/**
			 * Gets or sets the size of the control. Use -1 to specify auto sizing for either the
			 * width and/or height.
			 *
			 * Setting the size of controls is entirely optional as most controls will size
			 * themselves appropriately. When specifying a size, it will be used as the desired size
			 * of the control.  The container will reposition and resize the control depending on the
			 * available size.  For a {@link Eto.Forms.Window}, it is preferred to set the
			 * {@link Eto.Forms.Container.ClientSize} instead, as various platforms have different
			 * sizes of window decorations, toolbars, etc.
			 */
			Size: Eto.Drawing.Size;

			/**
			 * Gets a value indicating this control currently has mouse capture
			 *
			 * Mouse capture can happen during a handled MouseDown event until MouseUp, or it can be
			 * captured explicitly via {@link Eto.Forms.Control.CaptureMouse}.
			 */
			readonly IsMouseCaptured: boolean;

			/** Gets or sets the width of the control size. */
			Width: number;

			/** Gets or sets the height of the control size. */
			Height: number;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Forms.Control} (or its
			 * children) are enabled and accept user input.
			 *
			 * Typically when a control is disabled, the user cannot do anything with the control or
			 * any of its children. Including for example, selecting text in a text control. Certain
			 * controls can have a 'Read Only' mode, such as {@link Eto.Forms.TextBox.ReadOnly} which
			 * allow the user to  select text, but not change its contents.
			 */
			Enabled: boolean;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Forms.Control} is visible to
			 * the user.
			 *
			 * When the visibility of a control is set to false, it will not occupy space in the
			 * layout.
			 */
			Visible: boolean;

			/** Gets the container which this control has been added to, if any */
			readonly Parent: Eto.Forms.Container;

			/**
			 * Gets the visual container of this control, if any.
			 *
			 * Some containers may use other Eto controls to layout its children, such as the
			 * {@link Eto.Forms.StackLayout}. This will return the parent control that visually
			 * contains this control as opposed to {@link Eto.Forms.Control.Parent} which will return
			 * the logical parent.
			 */
			VisualParent: Eto.Forms.Container;

			/** Gets a value indicating this control has been attached to a native container */
			readonly IsAttached: boolean;

			/**
			 * Gets or sets the color for the background of the control
			 *
			 * Note that on some platforms (e.g. Mac), setting the background color of a control can
			 * change the performance characteristics of the control and its children, since it must
			 * enable layers to do so.
			 */
			BackgroundColor: Eto.Drawing.Color;

			/** Gets a value indicating whether this instance has the keyboard input focus. */
			readonly HasFocus: boolean;

			/** Gets a value indicating whether the layout of child controls is suspended. */
			readonly IsSuspended: boolean;

			/** Gets the window this control is contained in */
			readonly ParentWindow: Eto.Forms.Window;

			/**
			 * Gets the supported platform commands that can be used to hook up system functions to
			 * user defined logic
			 *
			 * This lists all available commands that can be mapped using the
			 * {@link Eto.Forms.Control.MapPlatformCommand(System.String,Eto.Forms.Command)} method
			 * of the control.
			 */
			readonly SupportedPlatformCommands: Iterable<string>;

			/** Gets the bounding rectangle of this control relative to its container */
			readonly Bounds: Eto.Drawing.Rectangle;

			/**
			 * Gets the location of the control as positioned by the container
			 *
			 * A control's location is set by the container. This can be used to determine where the
			 * control is for overlaying floating windows, menus, etc.
			 */
			readonly Location: Eto.Drawing.Point;

			/** Gets or sets the type of cursor to use when the mouse is hovering over the control */
			Cursor: Eto.Forms.Cursor;

			/** Gets or sets the tool tip to show when the mouse is hovered over the control */
			ToolTip: string;

			/**
			 * Gets or sets the tab index order for this control within its container.
			 *
			 * This sets the order when using the tab key to cycle through controls  Note that some
			 * platforms (Gtk and WinForms) may not support setting the context of the tab order to
			 * StackLayout  or DynamicLayout containers and may not behave exactly as expected. Use
			 * the {@link Eto.PlatformFeatures.TabIndexWithCustomContainers} flag to determine if it
			 * is supported.
			 */
			TabIndex: number;

			/** Gets or sets a value indicating whether this control can serve as drop target. */
			AllowDrop: boolean;

			/**
			 * Gets or sets the parent widget which this widget has been added to, if any
			 *
			 * When implementing child widgets that can participate in the context based binding
			 * (MVVM), You can set this to the parent widget when it is added or removed to it
			 * (usually via a collection).  Note that you should typically provide a public new
			 * [ParentWidget] Parent { get; } property  so that consumers of your API cannot set the
			 * parent to an invalid value.
			 */
			Parent: Eto.Widget;

			/**
			 * Gets an enumeration of all parent widgets in the heirarchy by traversing the
			 * {@link Eto.Forms.BindableWidget.Parent} property.
			 */
			readonly Parents: Iterable<Eto.Widget>;

			/**
			 * Gets or sets the data context for this widget for binding
			 *
			 * Subclasses may override the standard behaviour so that hierarchy of widgets can be
			 * taken into account.  For example, a Control may return the data context of a parent,
			 * if it is not set explicitly.
			 */
			DataContext: unknown;

			/** Gets the collection of bindings that are attached to this widget */
			readonly Bindings: Eto.Forms.BindingCollection;

			/**
			 * Gets a value indicating that the {@link Eto.Forms.BindableWidget.DataContext} property
			 * is changing.
			 *
			 * This can be used to determine when to allow certain logic during the update of the
			 * data context.  It is used to disable binding setters on the model when the data
			 * context changes so that a binding does not cause the view model to be updated when the
			 * state hasn't been fully set yet.
			 */
			IsDataContextChanging: boolean;

			/**
			 * Gets the platform that was used to create the {@link Eto.Widget.Handler} for this
			 * widget
			 *
			 * This gets set to the current {@link Eto.Platform.Instance} during the construction of
			 * the object
			 */
			readonly Platform: Eto.Platform;

			/** Gets the platform-specific handler for this widget */
			Handler: unknown;

			/** Gets the native platform-specific handle for integration purposes */
			readonly NativeHandle: unknown;

			/** Gets the dictionary of properties for this widget */
			readonly Properties: Eto.PropertyStore;

			/** Gets or sets the ID of this widget */
			ID: string;

			/**
			 * Gets or sets the style of this widget
			 *
			 * Styles allow you to attach custom platform-specific logic to a widget. In your
			 * platform-specific assembly, use {@link Style.Add{H}(string, StyleHandler{H})} to add
			 * the style logic with the same id.
			 */
			Style: string;

			/**
			 * Gets the instance of the platform-specific object
			 *
			 * This can sometimes be useful to get the platform-specific object. Some handlers may
			 * not have any backing object for its functionality, so this may be null.  It is more
			 * preferred to use the {@link Eto.Widget.Handler} and cast that to the platform-specific
			 * handler class which can give you additional methods and helpers to do common tasks.
			 * For example, the {@link Eto.Forms.Application} object's handler for OS X has a
			 * AddFullScreenMenuItem property to specify if you want full screen support in your app.
			 */
			readonly ControlObject: unknown;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Widget} has been disposed.
			 *
			 * When the widget is disposed, it can no longer be used.
			 */
			IsDisposed: boolean;

			/**
			 * Begins a new vertical section in the layout
			 *
			 * After calling this method, each subsequent call to
			 * {@link Eto.Forms.DynamicLayout.Add(Eto.Forms.Control,System.Nullable{System.Boolean},System.Nullable{System.Boolean})}
			 * will add controls in a vertical orientation.  When finished adding controls to the
			 * vertical section, call either {@link Eto.Forms.DynamicLayout.EndVertical} or
			 * {@link Eto.Forms.DynamicLayout.EndBeginVertical(System.Nullable{Eto.Drawing.Padding},System.Nullable{Eto.Drawing.Size},System.Nullable{System.Boolean},System.Nullable{System.Boolean})}.
			 */
			BeginVertical(
				padding?: Eto.Drawing.Padding,
				spacing?: Eto.Drawing.Size,
				xscale?: boolean,
				yscale?: boolean,
			): Eto.Forms.DynamicTable;

			/**
			 * Ends the current vertical section
			 *
			 * This should be balanced with every call to
			 * {@link Eto.Forms.DynamicLayout.BeginVertical(System.Nullable{Eto.Drawing.Padding},System.Nullable{Eto.Drawing.Size},System.Nullable{System.Boolean},System.Nullable{System.Boolean})}.
			 * Alternatively, you can call
			 * {@link Eto.Forms.DynamicLayout.EndBeginVertical(System.Nullable{Eto.Drawing.Padding},System.Nullable{Eto.Drawing.Size},System.Nullable{System.Boolean},System.Nullable{System.Boolean})}
			 * to end the current vertical section and start a new one.
			 */
			EndVertical(): void;

			/**
			 * Ends the current vertical section, then begins a new vertical section
			 *
			 * When finished adding controls to the vertical section, call
			 * {@link Eto.Forms.DynamicLayout.EndVertical}
			 */
			EndBeginVertical(
				padding?: Eto.Drawing.Padding,
				spacing?: Eto.Drawing.Size,
				xscale?: boolean,
				yscale?: boolean,
			): Eto.Forms.DynamicTable;

			/**
			 * Begins a new horizontal row section
			 *
			 * After calling this method, each subsequent call to
			 * {@link Eto.Forms.DynamicLayout.Add(Eto.Forms.Control,System.Nullable{System.Boolean},System.Nullable{System.Boolean})}
			 * will add controls in a horizontal orientation.  When finished adding controls to the
			 * horizontal section, call {@link Eto.Forms.DynamicLayout.EndHorizontal}
			 */
			BeginHorizontal(yscale?: boolean): Eto.Forms.DynamicRow;

			/**
			 * Ends the current horizontal section
			 *
			 * This should be balanced with every call to
			 * {@link Eto.Forms.DynamicLayout.BeginHorizontal(System.Nullable{System.Boolean})}.
			 * Alternatively, you can call
			 * {@link Eto.Forms.DynamicLayout.EndBeginHorizontal(System.Nullable{System.Boolean})} to
			 * end the current horizontal section and start a new one with a new row.
			 */
			EndHorizontal(): void;

			/**
			 * Ends the current horizontal section, then begins a new horizontal section with a new
			 * row
			 *
			 * When finished adding controls to the vertical section, call
			 * {@link Eto.Forms.DynamicLayout.EndHorizontal}
			 */
			EndBeginHorizontal(yscale?: boolean): Eto.Forms.DynamicRow;

			/**
			 * Creates a new section where all controls will be centered together.
			 *
			 * This is useful when you want to create a section that groups controls which align
			 * themselves together but are centered in the parent. When finished adding controls to
			 * the centered section, call {@link Eto.Forms.DynamicLayout.EndCentered}. To center
			 * vertically, set `yscale` to true .
			 */
			BeginCentered(
				padding?: Eto.Drawing.Padding,
				spacing?: Eto.Drawing.Size,
				xscale?: boolean,
				yscale?: boolean,
			): void;

			/**
			 * Ends the current centered section.
			 *
			 * This should be balanced with every call to
			 * {@link Eto.Forms.DynamicLayout.BeginCentered(System.Nullable{Eto.Drawing.Padding},System.Nullable{Eto.Drawing.Size},System.Nullable{System.Boolean},System.Nullable{System.Boolean})}.
			 */
			EndCentered(): void;

			/**
			 * Begins a the group section in the dynamic layout with a title.
			 *
			 * Should be balanced with a call to {@link Eto.Forms.DynamicLayout.EndGroup}.
			 */
			BeginGroup(
				title: string,
				padding?: Eto.Drawing.Padding,
				spacing?: Eto.Drawing.Size,
				xscale?: boolean,
				yscale?: boolean,
			): Eto.Forms.DynamicGroup;

			/**
			 * Ends a group.
			 *
			 * Should be balanced with a previous call to
			 * {@link Eto.Forms.DynamicLayout.BeginGroup(System.String,System.Nullable{Eto.Drawing.Padding},System.Nullable{Eto.Drawing.Size},System.Nullable{System.Boolean},System.Nullable{System.Boolean})}.
			 */
			EndGroup(): void;

			/**
			 * Begins a the scrollable section in the dynamic layout with a specified border.
			 *
			 * Should be balanced with a call to {@link Eto.Forms.DynamicLayout.EndScrollable}.
			 */
			BeginScrollable(
				border?: Eto.Forms.BorderType,
				padding?: Eto.Drawing.Padding,
				spacing?: Eto.Drawing.Size,
				xscale?: boolean,
				yscale?: boolean,
			): Eto.Forms.DynamicScrollable;

			/**
			 * Ends a scrollable section.
			 *
			 * Should be balanced with a previous call to
			 * {@link Eto.Forms.DynamicLayout.BeginScrollable(Eto.Forms.BorderType,System.Nullable{Eto.Drawing.Padding},System.Nullable{Eto.Drawing.Size},System.Nullable{System.Boolean},System.Nullable{System.Boolean})}.
			 */
			EndScrollable(): void;

			/**
			 * Add the control with the optional scaling
			 *
			 * This will add either horizontally or vertically depending on whether
			 * {@link Eto.Forms.DynamicLayout.BeginVertical(System.Nullable{Eto.Drawing.Padding},System.Nullable{Eto.Drawing.Size},System.Nullable{System.Boolean},System.Nullable{System.Boolean})}
			 * or {@link Eto.Forms.DynamicLayout.BeginHorizontal(System.Nullable{System.Boolean})}
			 * was called last.  The x/y scaling specified applies either to the entire column or row
			 * in the parent table that the control was added to, not just this individual control.
			 */
			Add(
				control: Eto.Forms.Control,
				xscale?: boolean,
				yscale?: boolean,
			): Eto.Forms.DynamicControl;

			/**
			 * Adds a list of controls
			 *
			 * This enumerates the collection and calls
			 * {@link Eto.Forms.DynamicLayout.Add(Eto.Forms.Control,System.Nullable{System.Boolean},System.Nullable{System.Boolean})}
			 * for each control.
			 */
			AddRange(controls: Iterable<Eto.Forms.Control>): void;

			/**
			 * Adds a list of controls
			 *
			 * This enumerates the collection and calls
			 * {@link Eto.Forms.DynamicLayout.Add(Eto.Forms.Control,System.Nullable{System.Boolean},System.Nullable{System.Boolean})}
			 * for each control.
			 */
			AddRange(controls: Eto.Forms.Control[]): void;

			/**
			 * Adds a separate horizontal row of items in a new vertical section
			 *
			 * This performs the same as the following, but in a single line: layout.BeginVertical();
			 * 	layout.BeginHorizontal(); 	layout.Add(control1); 	layout.Add(control2); 	...
			 * 	layout.EndHorizontal(); 	layout.EndVertical();
			 */
			AddSeparateRow(controls: Eto.Forms.Control[]): Eto.Forms.DynamicRow;

			/**
			 * Adds a separate horizontal row of items in a new vertical section
			 *
			 * This performs the same as the following, but in a single line:
			 * layout.BeginVertical(padding, spacing, xscale, yscale); 	layout.BeginHorizontal();
			 * 	layout.Add(control1); 	layout.Add(control2); 	... 	layout.EndHorizontal();
			 * 	layout.EndVertical();
			 */
			AddSeparateRow(
				padding?: Eto.Drawing.Padding,
				spacing?: Eto.Drawing.Size,
				xscale?: boolean,
				yscale?: boolean,
				controls?: Iterable<Eto.Forms.Control>,
			): Eto.Forms.DynamicRow;

			/**
			 * Adds a separate vertical column of items in a new vertical section
			 *
			 * This performs the same as the following, but in a single line: layout.BeginVertical();
			 * 	layout.Add(control1); 	layout.Add(control2); 	... 	layout.EndVertical();
			 */
			AddSeparateColumn(controls: Eto.Forms.Control[]): Eto.Forms.DynamicTable;

			/**
			 * Adds a separate vertical column of items in a new vertical section
			 *
			 * This performs the same as the following, but in a single line:
			 * layout.BeginVertical(padding, spacing, xscale, yscale); 	layout.Add(control1);
			 * 	layout.Add(control2); 	... 	layout.EndVertical();
			 */
			AddSeparateColumn(
				padding?: Eto.Drawing.Padding,
				spacing?: number,
				xscale?: boolean,
				yscale?: boolean,
				controls?: Iterable<Eto.Forms.Control>,
			): Eto.Forms.DynamicTable;

			/** Adds a new row of controls to the current vertical section */
			AddRow(controls: Eto.Forms.Control[]): Eto.Forms.DynamicRow;

			/**
			 * Adds a control centered in a new vertical section
			 *
			 * This adds scaled blank space around the control, and sizes the control to its
			 * preferred size. This is similar to doing the following: layout.BeginVertical(padding,
			 * spacing, xscale, yscale); 	layout.Add(null); // spacing at top
			 * 	layout.BeginHorizontal(); 	layout.Add(null); // spacing to left 	layout.Add(control);
			 * 	layout.Add(null); // spacing to right 	layout.EndHorizontal();  	layout.Add(null); //
			 * spacing at bottom  	layout.EndVertical();
			 */
			AddCentered(
				control: Eto.Forms.Control,
				padding?: Eto.Drawing.Padding,
				spacing?: Eto.Drawing.Size,
				xscale?: boolean,
				yscale?: boolean,
				horizontalCenter?: boolean,
				verticalCenter?: boolean,
			): void;

			/**
			 * Adds a control to the layout with its preferred size instead of taking the entire
			 * space of the cell
			 */
			AddAutoSized(
				control: Eto.Forms.Control,
				padding?: Eto.Drawing.Padding,
				spacing?: Eto.Drawing.Size,
				xscale?: boolean,
				yscale?: boolean,
				centered?: boolean,
			): void;

			/**
			 * Adds a column of controls in a new vertical section
			 *
			 * This allows you to add columns of controls.  If you are in a horizontal section, you
			 * can call this method repeatedly to add columns of controls that are sized
			 * independently from eachother.  This is a shortcut for the following:
			 * layout.BeginVertical(); 	layout.Add(control1); 	... 	layout.EndVertical();
			 */
			AddColumn(controls: Eto.Forms.Control[]): void;

			/** Adds an empty space.  Equivalent to calling Add(null); */
			AddSpace(
				xscale?: boolean,
				yscale?: boolean,
			): Eto.Forms.DynamicControl;

			/**
			 * Creates the layout content
			 *
			 * This is called automatically during the PreLoad or Load event, but can be called
			 * manually if changes are made after initially created
			 */
			Create(): void;

			/**
			 * Clears the layout so it can be recreated
			 *
			 * You must call {@link Eto.Forms.DynamicLayout.Create} when done updating the layout
			 */
			Clear(): void;

			/** Removes the specified child from the container */
			Remove(child: Eto.Forms.Control): void;

			/** Remove the specified `controls` from this container */
			Remove(controls: Iterable<Eto.Forms.Control>): void;

			/** Removes all controls from this container */
			RemoveAll(): void;

			/**
			 * Finds a child control in this container or any of its child containers with the
			 * specified `id`
			 */
			FindChild<T>(id?: string): T;

			/**
			 * Finds a child control in this container or any of its child containers with the
			 * specified `type`
			 */
			FindChild(
				type: unknown,
				id?: string,
			): Eto.Forms.Control;

			/**
			 * Finds a child control in this container or any of its child containers with the
			 * specified `id`.
			 */
			FindChild(id: string): Eto.Forms.Control;

			/**
			 * Queues a repaint of the entire control on the screen and any of its children.
			 *
			 * This is only useful when the control is visible.
			 */
			Invalidate(): void;

			/**
			 * Queues a repaint of the entire control on the screen
			 *
			 * This is only useful when the control is visible.
			 */
			Invalidate(invalidateChildren: boolean): void;

			/**
			 * Queues a repaint of the specified `rect` of the control and any children.
			 *
			 * This is only useful when the control is visible.
			 */
			Invalidate(rect: Eto.Drawing.Rectangle): void;

			/**
			 * Queues a repaint of the specified `rect` of the control
			 *
			 * This is only useful when the control is visible.
			 */
			Invalidate(
				rect: Eto.Drawing.Rectangle,
				invalidateChildren: boolean,
			): void;

			/**
			 * Updates the layout of this control if necessary.
			 *
			 * This will ensure the control has had all of its layout applied so you can use its
			 * position and size right after this call. Most platforms (except WinForms) use a
			 * deferred layout system so that after adding your control to the form dynamically it
			 * won't get laid out until the next idle loop. This is useful when you need to know the
			 * dimensions of the control immediately. Note that this can be an expensive operation,
			 * so it is recommended to only call this method when necessary and after all of the
			 * controls have been added/updated.
			 */
			UpdateLayout(): void;

			/** Gets the preferred size of this control given infinite space available. */
			GetPreferredSize(): Eto.Drawing.SizeF;

			/** Gets the preferred size of this control given the specified `availableSize`. */
			GetPreferredSize(availableSize: Eto.Drawing.SizeF): Eto.Drawing.SizeF;

			/**
			 * Captures all mouse events to this control.
			 *
			 * This captures all mouse events until {@link Eto.Forms.Control.ReleaseMouseCapture} is
			 * called.  Note that not all platforms will allow a mouse capture unless the mouse is
			 * currently down.
			 */
			CaptureMouse(): boolean;

			/** Releases the mouse capture after a call to {@link Eto.Forms.Control.CaptureMouse}. */
			ReleaseMouseCapture(): void;

			/**
			 * Finds a control in the parent hierarchy with the specified type and
			 * {@link Eto.Widget.ID} if specified
			 */
			FindParent(
				type: unknown,
				id?: string,
			): Eto.Forms.Container;

			/** Finds a control in the parent hierarchy with the specified `id` */
			FindParent(id: string): Eto.Forms.Container;

			/**
			 * Detaches the control by removing it from its parent
			 *
			 * This is essentially a shortcut to myControl.Parent.Remove(myControl);
			 */
			Detach(): void;

			/**
			 * Attaches the control for direct use in a native application
			 *
			 * Use this to use a control directly in a native application.  Note that the native
			 * application must be running the same framework as the current platform.  E.g. a
			 * WinForms application can use an Eto.Forms control when using the Eto.WinForms
			 * platform.  This prepares the control by firing the {@link Eto.Forms.Control.PreLoad},
			 * {@link Eto.Forms.Control.Load}, etc. events.
			 */
			AttachNative(): void;

			/**
			 * Detaches the control when it is used in a native application, when you want to reuse
			 * the control.
			 *
			 * This should only be called after {@link Eto.Forms.Control.AttachNative} has been
			 * called, which is usually done by calling to ToNative(true) .
			 */
			DetachNative(): void;

			/**
			 * Attempts to set the keyboard input focus to this control, or the first child that
			 * accepts focus. For Windows, this will bring it to front and activate it.
			 */
			Focus(): void;

			/**
			 * Suspends the layout of child controls
			 *
			 * This can be used to optimize some platforms while adding, removing, or changing many
			 * child controls at once. It disables the calculation of control positioning until
			 * {@link Eto.Forms.Control.ResumeLayout} is called. Each call to SuspendLayout() must be
			 * balanced with a call to {@link Eto.Forms.Control.ResumeLayout}.
			 */
			SuspendLayout(): void;

			/**
			 * Resumes the layout after it has been suspended, and performs a layout
			 *
			 * This can be used to optimize some platforms while adding, removing, or changing many
			 * child controls at once. Each call to ResumeLayout() must be balanced with a call to
			 * {@link Eto.Forms.Control.SuspendLayout} before it.
			 */
			ResumeLayout(): void;

			/**
			 * Specifies a command to execute for a platform-specific command
			 *
			 * Some platforms have specific system-defined commands that can be associated with a
			 * control. For example, the Mac platform's cut/copy/paste functionality is defined by
			 * the system, and if you want to hook into it, you can use this to map it to your own
			 * defined logic. The valid values of the `systemCommand` parameter are defined by each
			 * platform, and a list can be retrieved using
			 * {@link Eto.Forms.Control.SupportedPlatformCommands}
			 */
			MapPlatformCommand(
				systemCommand: string,
				command: Eto.Forms.Command,
			): void;

			/** Converts a point from screen space to control space. */
			PointFromScreen(point: Eto.Drawing.PointF): Eto.Drawing.PointF;

			/** Converts a point from control space to screen space */
			PointToScreen(point: Eto.Drawing.PointF): Eto.Drawing.PointF;

			/** Converts a rectangle from screen space to control space. */
			RectangleToScreen(rect: Eto.Drawing.RectangleF): Eto.Drawing.RectangleF;

			/** Converts a rectangle from control space to screen space */
			RectangleFromScreen(rect: Eto.Drawing.RectangleF): Eto.Drawing.RectangleF;

			/**
			 * Starts drag operation using this control as drag source.
			 *
			 * This method can be blocking on some platforms (Wpf, WinForms), and non-blocking on
			 * others (Mac, Gtk). Use the {@link Eto.Forms.Control.DragEnd} event to determine when
			 * the drag operation is completed and get its resulting DragEffects.
			 */
			DoDragDrop(
				data: Eto.Forms.DataObject,
				allowedEffects: Eto.Forms.DragEffects,
			): void;

			/**
			 * Starts drag operation using this control as drag source.
			 *
			 * This method can be blocking on some platforms (Wpf, WinForms), and non-blocking on
			 * others (Mac, Gtk). Use the {@link Eto.Forms.Control.DragEnd} event to determine when
			 * the drag operation is completed and get its resulting DragEffects.
			 */
			DoDragDrop(
				data: Eto.Forms.DataObject,
				allowedEffects: Eto.Forms.DragEffects,
				image: Eto.Drawing.Image,
				cursorOffset: Eto.Drawing.PointF,
			): void;

			/**
			 * Triggers the StyleChanged event and re-applies the styles to this control and its
			 * children.
			 */
			TriggerStyleChanged(): void;

			/** Shows a print dialog to print the specified control */
			Print(): void;

			/**
			 * Finds a control in the parent hierarchy with the specified type and
			 * {@link Eto.Widget.ID} if specified
			 */
			FindParent<T>(id?: string): T;

			/**
			 * Finds a control in the parent hierarchy with the specified type and
			 * {@link Eto.Widget.ID} if specified
			 */
			FindParent(
				type: unknown,
				id?: string,
			): Eto.Widget;

			/** Finds a control in the parent hierarchy with the specified `id` */
			FindParent(id: string): Eto.Widget;

			/**
			 * Unbinds any bindings in the {@link Eto.Forms.BindableWidget.Bindings} collection and
			 * removes the bindings
			 *
			 * When you implement {@link Eto.Forms.IBindableWidgetContainer}, this will also unbind
			 * any of its children.
			 */
			Unbind(): void;

			/**
			 * Updates all bindings in this widget
			 *
			 * When you implement {@link Eto.Forms.IBindableWidgetContainer}, this will also update
			 * bindings for all of its children.
			 */
			UpdateBindings(mode?: Eto.Forms.BindingUpdateMode): void;

			/** Disposes of this widget, supressing the finalizer */
			dispose(): void;

			/** Gets a string that represents the current object with its ID if specified. */
			ToString(): string;
		}
	}

	export namespace Eto.Forms {
		/** Represents a row for a {@link Eto.Forms.DynamicTable} */
		export class DynamicRow {
			/** Initializes a new instance of the {@link Eto.Forms.DynamicRow} class. */
			constructor();

			/** Initializes a new instance of the {@link Eto.Forms.DynamicRow} class. */
			constructor(items: Eto.Forms.DynamicItem[]);

			/** Initializes a new instance of the {@link Eto.Forms.DynamicRow} class. */
			constructor(items: Iterable<Eto.Forms.DynamicItem>);

			/** Initializes a new instance of the {@link Eto.Forms.DynamicRow} class. */
			constructor(
				controls: Iterable<Eto.Forms.Control>,
				xscale?: boolean,
				yscale?: boolean,
			);

			/** Gets the table this row is contained in */
			Table: Eto.Forms.DynamicTable;

			/** Gets or sets the items on this row. */
			readonly Items: unknown;

			/** Add the specified controls to the row */
			Add(controls: Eto.Forms.Control[]): void;

			/** Add the specified items to the row */
			Add(items: Eto.Forms.DynamicItem[]): void;

			/** Add the specified items to the row */
			Add(items: Iterable<Eto.Forms.DynamicItem>): void;

			/** Add the controls to the row, with specified xscale and yscale. */
			Add(
				controls: Iterable<Eto.Forms.Control>,
				xscale?: boolean,
				yscale?: boolean,
			): void;
		}
	}

	export namespace Eto.Forms {
		/**
		 * Table item for the {@link Eto.Forms.DynamicLayout}
		 *
		 * This represents a table, which in a dynamic layout is used to represent a vertical
		 * section. The maximum number of items in the {@link Eto.Forms.DynamicTable.Rows}
		 * determines the columns of the table.
		 */
		export class DynamicTable {
			/** Initializes a new instance of the {@link Eto.Forms.DynamicTable} class. */
			constructor();

			/** Initializes a new instance of the {@link Eto.Forms.DynamicTable} class. */
			constructor(rows: Eto.Forms.DynamicRow[]);

			/** Initializes a new instance of the {@link Eto.Forms.DynamicTable} class. */
			constructor(rows: Iterable<Eto.Forms.DynamicRow>);

			/** Gets or sets the collection of rows in the table */
			readonly Rows: unknown;

			/** Gets the table layout this item represents */
			Table: Eto.Forms.TableLayout;

			/** Gets or sets the parent table */
			Parent: Eto.Forms.DynamicTable;

			/** Gets or sets the padding around the table cells */
			Padding?: Eto.Drawing.Padding;

			/** Gets or sets the spacing between the table cells */
			Spacing?: Eto.Drawing.Size;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Forms.DynamicTable} is
			 * visible.
			 */
			Visible: boolean;

			/**
			 * Gets or sets the horizontal scale of the item
			 *
			 * When true, the control takes up all remaining horizontal space available. If there is
			 * more than one item with this set to true, then they share the remaining space equally.
			 */
			XScale?: boolean;

			/**
			 * Gets or sets the vertical scale of the item
			 *
			 * When true, the control takes up all remaining vertical space available. If there is
			 * more than one item with this set to true, then they share the remaining space equally.
			 */
			YScale?: boolean;

			/** Add the specified item to the current row */
			Add(item: Eto.Forms.DynamicItem): void;

			/** Adds the specified item to a new row */
			AddRow(item: Eto.Forms.DynamicItem): void;

			/** Adds the specified row to the table */
			AddRow(row: Eto.Forms.DynamicRow): void;

			/** Creates the content for this item */
			Create(layout: Eto.Forms.DynamicLayout): Eto.Forms.Control;

			/** Create the item and add to the specified layout and co-ordinates */
			Create(
				layout: Eto.Forms.DynamicLayout,
				parent: Eto.Forms.TableLayout,
				x: number,
				y: number,
			): void;
		}
	}

	export namespace Eto.Forms {
		/**
		 * Used to easily insert a {@link Eto.Forms.DynamicGroup.GroupBox} into a dynamic layout
		 */
		export class DynamicGroup {
			constructor();

			/** Gets or sets the title of the group box. */
			Title: string;

			/** Gets the group box instance when the layout has been generated. */
			GroupBox: Eto.Forms.GroupBox;

			/** Gets or sets the collection of rows in the table */
			readonly Rows: unknown;

			/** Gets the table layout this item represents */
			readonly Table: Eto.Forms.TableLayout;

			/** Gets or sets the parent table */
			readonly Parent: Eto.Forms.DynamicTable;

			/** Gets or sets the padding around the table cells */
			Padding?: Eto.Drawing.Padding;

			/** Gets or sets the spacing between the table cells */
			Spacing?: Eto.Drawing.Size;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Forms.DynamicTable} is
			 * visible.
			 */
			Visible: boolean;

			/**
			 * Gets or sets the horizontal scale of the item
			 *
			 * When true, the control takes up all remaining horizontal space available. If there is
			 * more than one item with this set to true, then they share the remaining space equally.
			 */
			XScale?: boolean;

			/**
			 * Gets or sets the vertical scale of the item
			 *
			 * When true, the control takes up all remaining vertical space available. If there is
			 * more than one item with this set to true, then they share the remaining space equally.
			 */
			YScale?: boolean;

			/** Creates the group box layout. */
			Create(layout: Eto.Forms.DynamicLayout): Eto.Forms.Control;

			/** Add the specified item to the current row */
			Add(item: Eto.Forms.DynamicItem): void;

			/** Adds the specified item to a new row */
			AddRow(item: Eto.Forms.DynamicItem): void;

			/** Adds the specified row to the table */
			AddRow(row: Eto.Forms.DynamicRow): void;

			/** Create the item and add to the specified layout and co-ordinates */
			Create(
				layout: Eto.Forms.DynamicLayout,
				parent: Eto.Forms.TableLayout,
				x: number,
				y: number,
			): void;
		}
	}

	export namespace Eto.Forms {
		/**
		 * Used to easily insert a {@link Eto.Forms.DynamicScrollable.Scrollable} into a dynamic
		 * layout
		 */
		export class DynamicScrollable {
			constructor();

			/** Gets or sets the border for the contained scrollable */
			Border: Eto.Forms.BorderType;

			/** Gets the Scrollable instance when the layout has been generated. */
			Scrollable: Eto.Forms.Scrollable;

			/** Gets or sets the collection of rows in the table */
			readonly Rows: unknown;

			/** Gets the table layout this item represents */
			readonly Table: Eto.Forms.TableLayout;

			/** Gets or sets the parent table */
			readonly Parent: Eto.Forms.DynamicTable;

			/** Gets or sets the padding around the table cells */
			Padding?: Eto.Drawing.Padding;

			/** Gets or sets the spacing between the table cells */
			Spacing?: Eto.Drawing.Size;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Forms.DynamicTable} is
			 * visible.
			 */
			Visible: boolean;

			/**
			 * Gets or sets the horizontal scale of the item
			 *
			 * When true, the control takes up all remaining horizontal space available. If there is
			 * more than one item with this set to true, then they share the remaining space equally.
			 */
			XScale?: boolean;

			/**
			 * Gets or sets the vertical scale of the item
			 *
			 * When true, the control takes up all remaining vertical space available. If there is
			 * more than one item with this set to true, then they share the remaining space equally.
			 */
			YScale?: boolean;

			/** Creates the group box layout. */
			Create(layout: Eto.Forms.DynamicLayout): Eto.Forms.Control;

			/** Add the specified item to the current row */
			Add(item: Eto.Forms.DynamicItem): void;

			/** Adds the specified item to a new row */
			AddRow(item: Eto.Forms.DynamicItem): void;

			/** Adds the specified row to the table */
			AddRow(row: Eto.Forms.DynamicRow): void;

			/** Create the item and add to the specified layout and co-ordinates */
			Create(
				layout: Eto.Forms.DynamicLayout,
				parent: Eto.Forms.TableLayout,
				x: number,
				y: number,
			): void;
		}
	}

	export namespace Eto.Forms {
		/**
		 * Base class for all layout-based containers
		 *
		 * Layout based containers are used to position child controls, and provides extra
		 * functionality to update the layout manually.
		 */
		export class Layout implements
			Eto.IHandlerSource,
			Eto.Forms.IBindable,
			Eto.Forms.IMouseInputSource,
			Eto.Forms.IKeyboardInputSource {
			/**
			 * Gets or sets the size for the client area of the control
			 *
			 * The client size differs from the {@link Eto.Forms.Control.Size} in that it excludes
			 * the decorations of the container, such as the title bar and border around a
			 * {@link Eto.Forms.Window}, or the title and line  around a {@link Eto.Forms.GroupBox}.
			 */
			ClientSize: Eto.Drawing.Size;

			/**
			 * Gets an enumeration of logical controls that are directly contained by this container
			 *
			 * These controls are directly contained by the container, but do not include controls
			 * that are used to form the visual appearance, if any.  Controls like the
			 * {@link Eto.Forms.StackLayout}, {@link Eto.Forms.DynamicLayout} or a  customized
			 * container using the {@link Eto.Forms.ThemedContainerHandler<,,>} should not  include
			 * any intermediate controls.
			 */
			readonly Controls: Iterable<Eto.Forms.Control>;

			/**
			 * Gets an enumeration of all contained child controls, including controls within child
			 * containers
			 */
			readonly Children: Iterable<Eto.Forms.Control>;

			/**
			 * Gets an enumeration of all contained child controls in the visual tree, including
			 * controls within child containers.
			 */
			readonly VisualChildren: Iterable<Eto.Forms.Control>;

			/**
			 * Gets or sets the style provider for this container.
			 *
			 * The style provider is used to style this container and its children.
			 */
			StyleProvider: Eto.IStyleProvider;

			/**
			 * Gets the default style provider for this container.
			 *
			 * Use this to apply styles to any child controls of this container. By default, styles
			 * will apply to all children, including children of children unless
			 * {@link Eto.DefaultStyleProvider.Inherit} is set to false .  Typically, you would set
			 * Inherit to false when creating composite controls that already have all their styles
			 * applied and you don't want any other styles to be inherited.
			 */
			readonly Styles: Eto.DefaultStyleProvider;

			/**
			 * Gets a value indicating that the control is loaded onto a form, that is it has been
			 * created, added to a parent, and shown
			 *
			 * The {@link Eto.Forms.Control.OnLoad(System.EventArgs)} method sets this value to true
			 * after cascading to all children (for a {@link Eto.Forms.Container} ) and calling the
			 * platform handler's implementation.  It is called after adding to a loaded form, or
			 * when showing a new form.  The {@link Eto.Forms.Control.OnUnLoad(System.EventArgs)}
			 * method will set this value to false when the control is removed from its parent
			 */
			readonly Loaded: boolean;

			/**
			 * Gets an enumeration of controls that are in the visual tree.
			 *
			 * This is used to specify which controls are contained by this instance that are part of
			 * the visual tree. This should include all controls including non-logical Eto controls
			 * used for layout.
			 */
			readonly VisualControls: Iterable<Eto.Forms.Control>;

			/**
			 * Gets or sets a user-defined object that contains data about the control
			 *
			 * A common use of the tag property is to store data that is associated with the control
			 * that you can later retrieve.
			 */
			Tag: unknown;

			/**
			 * Gets the logical parent control.
			 *
			 * When the control is part of the visual tree (
				 * {@link Eto.Forms.Control.IsVisualControl} is true), this returns the logical parent
				 * that contains this control. Otherwise this is the same as
				 * {@link Eto.Forms.Control.Parent}.
				 */
				readonly LogicalParent: Eto.Forms.Container;

			/** Gets a value indicating this {@link Eto.Forms.Control} is part of the visual tree. */
			IsVisualControl: boolean;

			/**
			 * Gets or sets the size of the control. Use -1 to specify auto sizing for either the
			 * width and/or height.
			 *
			 * Setting the size of controls is entirely optional as most controls will size
			 * themselves appropriately. When specifying a size, it will be used as the desired size
			 * of the control.  The container will reposition and resize the control depending on the
			 * available size.  For a {@link Eto.Forms.Window}, it is preferred to set the
			 * {@link Eto.Forms.Container.ClientSize} instead, as various platforms have different
			 * sizes of window decorations, toolbars, etc.
			 */
			Size: Eto.Drawing.Size;

			/**
			 * Gets a value indicating this control currently has mouse capture
			 *
			 * Mouse capture can happen during a handled MouseDown event until MouseUp, or it can be
			 * captured explicitly via {@link Eto.Forms.Control.CaptureMouse}.
			 */
			readonly IsMouseCaptured: boolean;

			/** Gets or sets the width of the control size. */
			Width: number;

			/** Gets or sets the height of the control size. */
			Height: number;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Forms.Control} (or its
			 * children) are enabled and accept user input.
			 *
			 * Typically when a control is disabled, the user cannot do anything with the control or
			 * any of its children. Including for example, selecting text in a text control. Certain
			 * controls can have a 'Read Only' mode, such as {@link Eto.Forms.TextBox.ReadOnly} which
			 * allow the user to  select text, but not change its contents.
			 */
			Enabled: boolean;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Forms.Control} is visible to
			 * the user.
			 *
			 * When the visibility of a control is set to false, it will not occupy space in the
			 * layout.
			 */
			Visible: boolean;

			/** Gets the container which this control has been added to, if any */
			readonly Parent: Eto.Forms.Container;

			/**
			 * Gets the visual container of this control, if any.
			 *
			 * Some containers may use other Eto controls to layout its children, such as the
			 * {@link Eto.Forms.StackLayout}. This will return the parent control that visually
			 * contains this control as opposed to {@link Eto.Forms.Control.Parent} which will return
			 * the logical parent.
			 */
			VisualParent: Eto.Forms.Container;

			/** Gets a value indicating this control has been attached to a native container */
			readonly IsAttached: boolean;

			/**
			 * Gets or sets the color for the background of the control
			 *
			 * Note that on some platforms (e.g. Mac), setting the background color of a control can
			 * change the performance characteristics of the control and its children, since it must
			 * enable layers to do so.
			 */
			BackgroundColor: Eto.Drawing.Color;

			/** Gets a value indicating whether this instance has the keyboard input focus. */
			readonly HasFocus: boolean;

			/** Gets a value indicating whether the layout of child controls is suspended. */
			readonly IsSuspended: boolean;

			/** Gets the window this control is contained in */
			readonly ParentWindow: Eto.Forms.Window;

			/**
			 * Gets the supported platform commands that can be used to hook up system functions to
			 * user defined logic
			 *
			 * This lists all available commands that can be mapped using the
			 * {@link Eto.Forms.Control.MapPlatformCommand(System.String,Eto.Forms.Command)} method
			 * of the control.
			 */
			readonly SupportedPlatformCommands: Iterable<string>;

			/** Gets the bounding rectangle of this control relative to its container */
			readonly Bounds: Eto.Drawing.Rectangle;

			/**
			 * Gets the location of the control as positioned by the container
			 *
			 * A control's location is set by the container. This can be used to determine where the
			 * control is for overlaying floating windows, menus, etc.
			 */
			readonly Location: Eto.Drawing.Point;

			/** Gets or sets the type of cursor to use when the mouse is hovering over the control */
			Cursor: Eto.Forms.Cursor;

			/** Gets or sets the tool tip to show when the mouse is hovered over the control */
			ToolTip: string;

			/**
			 * Gets or sets the tab index order for this control within its container.
			 *
			 * This sets the order when using the tab key to cycle through controls  Note that some
			 * platforms (Gtk and WinForms) may not support setting the context of the tab order to
			 * StackLayout  or DynamicLayout containers and may not behave exactly as expected. Use
			 * the {@link Eto.PlatformFeatures.TabIndexWithCustomContainers} flag to determine if it
			 * is supported.
			 */
			TabIndex: number;

			/** Gets or sets a value indicating whether this control can serve as drop target. */
			AllowDrop: boolean;

			/**
			 * Gets or sets the parent widget which this widget has been added to, if any
			 *
			 * When implementing child widgets that can participate in the context based binding
			 * (MVVM), You can set this to the parent widget when it is added or removed to it
			 * (usually via a collection).  Note that you should typically provide a public new
			 * [ParentWidget] Parent { get; } property  so that consumers of your API cannot set the
			 * parent to an invalid value.
			 */
			Parent: Eto.Widget;

			/**
			 * Gets an enumeration of all parent widgets in the heirarchy by traversing the
			 * {@link Eto.Forms.BindableWidget.Parent} property.
			 */
			readonly Parents: Iterable<Eto.Widget>;

			/**
			 * Gets or sets the data context for this widget for binding
			 *
			 * Subclasses may override the standard behaviour so that hierarchy of widgets can be
			 * taken into account.  For example, a Control may return the data context of a parent,
			 * if it is not set explicitly.
			 */
			DataContext: unknown;

			/** Gets the collection of bindings that are attached to this widget */
			readonly Bindings: Eto.Forms.BindingCollection;

			/**
			 * Gets a value indicating that the {@link Eto.Forms.BindableWidget.DataContext} property
			 * is changing.
			 *
			 * This can be used to determine when to allow certain logic during the update of the
			 * data context.  It is used to disable binding setters on the model when the data
			 * context changes so that a binding does not cause the view model to be updated when the
			 * state hasn't been fully set yet.
			 */
			IsDataContextChanging: boolean;

			/**
			 * Gets the platform that was used to create the {@link Eto.Widget.Handler} for this
			 * widget
			 *
			 * This gets set to the current {@link Eto.Platform.Instance} during the construction of
			 * the object
			 */
			readonly Platform: Eto.Platform;

			/** Gets the platform-specific handler for this widget */
			Handler: unknown;

			/** Gets the native platform-specific handle for integration purposes */
			readonly NativeHandle: unknown;

			/** Gets the dictionary of properties for this widget */
			readonly Properties: Eto.PropertyStore;

			/** Gets or sets the ID of this widget */
			ID: string;

			/**
			 * Gets or sets the style of this widget
			 *
			 * Styles allow you to attach custom platform-specific logic to a widget. In your
			 * platform-specific assembly, use {@link Style.Add{H}(string, StyleHandler{H})} to add
			 * the style logic with the same id.
			 */
			Style: string;

			/**
			 * Gets the instance of the platform-specific object
			 *
			 * This can sometimes be useful to get the platform-specific object. Some handlers may
			 * not have any backing object for its functionality, so this may be null.  It is more
			 * preferred to use the {@link Eto.Widget.Handler} and cast that to the platform-specific
			 * handler class which can give you additional methods and helpers to do common tasks.
			 * For example, the {@link Eto.Forms.Application} object's handler for OS X has a
			 * AddFullScreenMenuItem property to specify if you want full screen support in your app.
			 */
			readonly ControlObject: unknown;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Widget} has been disposed.
			 *
			 * When the widget is disposed, it can no longer be used.
			 */
			IsDisposed: boolean;

			/**
			 * Re-calculates the layout of the controls and re-positions them, if necessary
			 *
			 * All layouts should theoretically work without having to manually update them, but in
			 * certain cases this may be necessary to be called.
			 */
			Update(): void;

			/** Begins the initialization when loading from xaml or other code generated scenarios */
			BeginInit(): void;

			/** Ends the initialization when loading from xaml or other code generated scenarios */
			EndInit(): void;

			/** Remove the specified `controls` from this container */
			Remove(controls: Iterable<Eto.Forms.Control>): void;

			/** Removes all controls from this container */
			RemoveAll(): void;

			/** Removes the specified `child` control */
			Remove(child: Eto.Forms.Control): void;

			/**
			 * Finds a child control in this container or any of its child containers with the
			 * specified `id`
			 */
			FindChild<T>(id?: string): T;

			/**
			 * Finds a child control in this container or any of its child containers with the
			 * specified `type`
			 */
			FindChild(
				type: unknown,
				id?: string,
			): Eto.Forms.Control;

			/**
			 * Finds a child control in this container or any of its child containers with the
			 * specified `id`.
			 */
			FindChild(id: string): Eto.Forms.Control;

			/**
			 * Queues a repaint of the entire control on the screen and any of its children.
			 *
			 * This is only useful when the control is visible.
			 */
			Invalidate(): void;

			/**
			 * Queues a repaint of the entire control on the screen
			 *
			 * This is only useful when the control is visible.
			 */
			Invalidate(invalidateChildren: boolean): void;

			/**
			 * Queues a repaint of the specified `rect` of the control and any children.
			 *
			 * This is only useful when the control is visible.
			 */
			Invalidate(rect: Eto.Drawing.Rectangle): void;

			/**
			 * Queues a repaint of the specified `rect` of the control
			 *
			 * This is only useful when the control is visible.
			 */
			Invalidate(
				rect: Eto.Drawing.Rectangle,
				invalidateChildren: boolean,
			): void;

			/**
			 * Updates the layout of this control if necessary.
			 *
			 * This will ensure the control has had all of its layout applied so you can use its
			 * position and size right after this call. Most platforms (except WinForms) use a
			 * deferred layout system so that after adding your control to the form dynamically it
			 * won't get laid out until the next idle loop. This is useful when you need to know the
			 * dimensions of the control immediately. Note that this can be an expensive operation,
			 * so it is recommended to only call this method when necessary and after all of the
			 * controls have been added/updated.
			 */
			UpdateLayout(): void;

			/** Gets the preferred size of this control given infinite space available. */
			GetPreferredSize(): Eto.Drawing.SizeF;

			/** Gets the preferred size of this control given the specified `availableSize`. */
			GetPreferredSize(availableSize: Eto.Drawing.SizeF): Eto.Drawing.SizeF;

			/**
			 * Captures all mouse events to this control.
			 *
			 * This captures all mouse events until {@link Eto.Forms.Control.ReleaseMouseCapture} is
			 * called.  Note that not all platforms will allow a mouse capture unless the mouse is
			 * currently down.
			 */
			CaptureMouse(): boolean;

			/** Releases the mouse capture after a call to {@link Eto.Forms.Control.CaptureMouse}. */
			ReleaseMouseCapture(): void;

			/**
			 * Finds a control in the parent hierarchy with the specified type and
			 * {@link Eto.Widget.ID} if specified
			 */
			FindParent(
				type: unknown,
				id?: string,
			): Eto.Forms.Container;

			/** Finds a control in the parent hierarchy with the specified `id` */
			FindParent(id: string): Eto.Forms.Container;

			/**
			 * Detaches the control by removing it from its parent
			 *
			 * This is essentially a shortcut to myControl.Parent.Remove(myControl);
			 */
			Detach(): void;

			/**
			 * Attaches the control for direct use in a native application
			 *
			 * Use this to use a control directly in a native application.  Note that the native
			 * application must be running the same framework as the current platform.  E.g. a
			 * WinForms application can use an Eto.Forms control when using the Eto.WinForms
			 * platform.  This prepares the control by firing the {@link Eto.Forms.Control.PreLoad},
			 * {@link Eto.Forms.Control.Load}, etc. events.
			 */
			AttachNative(): void;

			/**
			 * Detaches the control when it is used in a native application, when you want to reuse
			 * the control.
			 *
			 * This should only be called after {@link Eto.Forms.Control.AttachNative} has been
			 * called, which is usually done by calling to ToNative(true) .
			 */
			DetachNative(): void;

			/**
			 * Attempts to set the keyboard input focus to this control, or the first child that
			 * accepts focus. For Windows, this will bring it to front and activate it.
			 */
			Focus(): void;

			/**
			 * Suspends the layout of child controls
			 *
			 * This can be used to optimize some platforms while adding, removing, or changing many
			 * child controls at once. It disables the calculation of control positioning until
			 * {@link Eto.Forms.Control.ResumeLayout} is called. Each call to SuspendLayout() must be
			 * balanced with a call to {@link Eto.Forms.Control.ResumeLayout}.
			 */
			SuspendLayout(): void;

			/**
			 * Resumes the layout after it has been suspended, and performs a layout
			 *
			 * This can be used to optimize some platforms while adding, removing, or changing many
			 * child controls at once. Each call to ResumeLayout() must be balanced with a call to
			 * {@link Eto.Forms.Control.SuspendLayout} before it.
			 */
			ResumeLayout(): void;

			/**
			 * Specifies a command to execute for a platform-specific command
			 *
			 * Some platforms have specific system-defined commands that can be associated with a
			 * control. For example, the Mac platform's cut/copy/paste functionality is defined by
			 * the system, and if you want to hook into it, you can use this to map it to your own
			 * defined logic. The valid values of the `systemCommand` parameter are defined by each
			 * platform, and a list can be retrieved using
			 * {@link Eto.Forms.Control.SupportedPlatformCommands}
			 */
			MapPlatformCommand(
				systemCommand: string,
				command: Eto.Forms.Command,
			): void;

			/** Converts a point from screen space to control space. */
			PointFromScreen(point: Eto.Drawing.PointF): Eto.Drawing.PointF;

			/** Converts a point from control space to screen space */
			PointToScreen(point: Eto.Drawing.PointF): Eto.Drawing.PointF;

			/** Converts a rectangle from screen space to control space. */
			RectangleToScreen(rect: Eto.Drawing.RectangleF): Eto.Drawing.RectangleF;

			/** Converts a rectangle from control space to screen space */
			RectangleFromScreen(rect: Eto.Drawing.RectangleF): Eto.Drawing.RectangleF;

			/**
			 * Starts drag operation using this control as drag source.
			 *
			 * This method can be blocking on some platforms (Wpf, WinForms), and non-blocking on
			 * others (Mac, Gtk). Use the {@link Eto.Forms.Control.DragEnd} event to determine when
			 * the drag operation is completed and get its resulting DragEffects.
			 */
			DoDragDrop(
				data: Eto.Forms.DataObject,
				allowedEffects: Eto.Forms.DragEffects,
			): void;

			/**
			 * Starts drag operation using this control as drag source.
			 *
			 * This method can be blocking on some platforms (Wpf, WinForms), and non-blocking on
			 * others (Mac, Gtk). Use the {@link Eto.Forms.Control.DragEnd} event to determine when
			 * the drag operation is completed and get its resulting DragEffects.
			 */
			DoDragDrop(
				data: Eto.Forms.DataObject,
				allowedEffects: Eto.Forms.DragEffects,
				image: Eto.Drawing.Image,
				cursorOffset: Eto.Drawing.PointF,
			): void;

			/**
			 * Triggers the StyleChanged event and re-applies the styles to this control and its
			 * children.
			 */
			TriggerStyleChanged(): void;

			/** Shows a print dialog to print the specified control */
			Print(): void;

			/**
			 * Finds a control in the parent hierarchy with the specified type and
			 * {@link Eto.Widget.ID} if specified
			 */
			FindParent<T>(id?: string): T;

			/**
			 * Finds a control in the parent hierarchy with the specified type and
			 * {@link Eto.Widget.ID} if specified
			 */
			FindParent(
				type: unknown,
				id?: string,
			): Eto.Widget;

			/** Finds a control in the parent hierarchy with the specified `id` */
			FindParent(id: string): Eto.Widget;

			/**
			 * Unbinds any bindings in the {@link Eto.Forms.BindableWidget.Bindings} collection and
			 * removes the bindings
			 *
			 * When you implement {@link Eto.Forms.IBindableWidgetContainer}, this will also unbind
			 * any of its children.
			 */
			Unbind(): void;

			/**
			 * Updates all bindings in this widget
			 *
			 * When you implement {@link Eto.Forms.IBindableWidgetContainer}, this will also update
			 * bindings for all of its children.
			 */
			UpdateBindings(mode?: Eto.Forms.BindingUpdateMode): void;

			/** Disposes of this widget, supressing the finalizer */
			dispose(): void;

			/** Gets a string that represents the current object with its ID if specified. */
			ToString(): string;
		}
	}

	export namespace Eto.Forms.Layout {
		export interface IHandler extends
			Eto.Forms.Container.IHandler,
			Eto.Forms.Control.IHandler,
			Eto.Widget.IHandler {
			Update(): void;
		}
	}

	export namespace Eto.Forms.Layout {
		export interface IPositionalLayoutHandler {
			Add(
				control: Eto.Forms.Control,
				x: number,
				y: number,
			): void;

			Move(
				control: Eto.Forms.Control,
				x: number,
				y: number,
			): void;

			Remove(control: Eto.Forms.Control): void;
		}
	}

	export namespace Eto.Forms {
		/**
		 * Layout to position controls by pixel coordinates
		 *
		 * This layout can be used if you want to position controls based on pixel sizes. Note
		 * that controls will automatically size themselves and it is recommended to use a
		 * {@link Eto.Forms.DynamicLayout} or {@link Eto.Forms.TableLayout} instead, as this will
		 * better work across all platforms since each platform might have different standard
		 * sizes.
		 */
		export class PixelLayout implements
			Eto.IHandlerSource,
			Eto.Forms.IBindable,
			Eto.Forms.IMouseInputSource,
			Eto.Forms.IKeyboardInputSource {
			constructor();

			/** Gets an enumeration of controls that are directly contained by this container */
			readonly Controls: Iterable<Eto.Forms.Control>;

			/**
			 * Gets a collection of controls that are contained by this layout
			 *
			 * When adding children using this, you can position them using the
			 * {@link Eto.Forms.PixelLayout.SetLocation(Eto.Forms.Control,Eto.Drawing.Point)} static
			 * method.
			 */
			readonly Contents: unknown;

			/**
			 * Gets or sets the size for the client area of the control
			 *
			 * The client size differs from the {@link Eto.Forms.Control.Size} in that it excludes
			 * the decorations of the container, such as the title bar and border around a
			 * {@link Eto.Forms.Window}, or the title and line  around a {@link Eto.Forms.GroupBox}.
			 */
			ClientSize: Eto.Drawing.Size;

			/**
			 * Gets an enumeration of all contained child controls, including controls within child
			 * containers
			 */
			readonly Children: Iterable<Eto.Forms.Control>;

			/**
			 * Gets an enumeration of all contained child controls in the visual tree, including
			 * controls within child containers.
			 */
			readonly VisualChildren: Iterable<Eto.Forms.Control>;

			/**
			 * Gets or sets the style provider for this container.
			 *
			 * The style provider is used to style this container and its children.
			 */
			StyleProvider: Eto.IStyleProvider;

			/**
			 * Gets the default style provider for this container.
			 *
			 * Use this to apply styles to any child controls of this container. By default, styles
			 * will apply to all children, including children of children unless
			 * {@link Eto.DefaultStyleProvider.Inherit} is set to false .  Typically, you would set
			 * Inherit to false when creating composite controls that already have all their styles
			 * applied and you don't want any other styles to be inherited.
			 */
			readonly Styles: Eto.DefaultStyleProvider;

			/**
			 * Gets a value indicating that the control is loaded onto a form, that is it has been
			 * created, added to a parent, and shown
			 *
			 * The {@link Eto.Forms.Control.OnLoad(System.EventArgs)} method sets this value to true
			 * after cascading to all children (for a {@link Eto.Forms.Container} ) and calling the
			 * platform handler's implementation.  It is called after adding to a loaded form, or
			 * when showing a new form.  The {@link Eto.Forms.Control.OnUnLoad(System.EventArgs)}
			 * method will set this value to false when the control is removed from its parent
			 */
			readonly Loaded: boolean;

			/**
			 * Gets an enumeration of controls that are in the visual tree.
			 *
			 * This is used to specify which controls are contained by this instance that are part of
			 * the visual tree. This should include all controls including non-logical Eto controls
			 * used for layout.
			 */
			readonly VisualControls: Iterable<Eto.Forms.Control>;

			/**
			 * Gets or sets a user-defined object that contains data about the control
			 *
			 * A common use of the tag property is to store data that is associated with the control
			 * that you can later retrieve.
			 */
			Tag: unknown;

			/**
			 * Gets the logical parent control.
			 *
			 * When the control is part of the visual tree (
				 * {@link Eto.Forms.Control.IsVisualControl} is true), this returns the logical parent
				 * that contains this control. Otherwise this is the same as
				 * {@link Eto.Forms.Control.Parent}.
				 */
				readonly LogicalParent: Eto.Forms.Container;

			/** Gets a value indicating this {@link Eto.Forms.Control} is part of the visual tree. */
			IsVisualControl: boolean;

			/**
			 * Gets or sets the size of the control. Use -1 to specify auto sizing for either the
			 * width and/or height.
			 *
			 * Setting the size of controls is entirely optional as most controls will size
			 * themselves appropriately. When specifying a size, it will be used as the desired size
			 * of the control.  The container will reposition and resize the control depending on the
			 * available size.  For a {@link Eto.Forms.Window}, it is preferred to set the
			 * {@link Eto.Forms.Container.ClientSize} instead, as various platforms have different
			 * sizes of window decorations, toolbars, etc.
			 */
			Size: Eto.Drawing.Size;

			/**
			 * Gets a value indicating this control currently has mouse capture
			 *
			 * Mouse capture can happen during a handled MouseDown event until MouseUp, or it can be
			 * captured explicitly via {@link Eto.Forms.Control.CaptureMouse}.
			 */
			readonly IsMouseCaptured: boolean;

			/** Gets or sets the width of the control size. */
			Width: number;

			/** Gets or sets the height of the control size. */
			Height: number;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Forms.Control} (or its
			 * children) are enabled and accept user input.
			 *
			 * Typically when a control is disabled, the user cannot do anything with the control or
			 * any of its children. Including for example, selecting text in a text control. Certain
			 * controls can have a 'Read Only' mode, such as {@link Eto.Forms.TextBox.ReadOnly} which
			 * allow the user to  select text, but not change its contents.
			 */
			Enabled: boolean;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Forms.Control} is visible to
			 * the user.
			 *
			 * When the visibility of a control is set to false, it will not occupy space in the
			 * layout.
			 */
			Visible: boolean;

			/** Gets the container which this control has been added to, if any */
			readonly Parent: Eto.Forms.Container;

			/**
			 * Gets the visual container of this control, if any.
			 *
			 * Some containers may use other Eto controls to layout its children, such as the
			 * {@link Eto.Forms.StackLayout}. This will return the parent control that visually
			 * contains this control as opposed to {@link Eto.Forms.Control.Parent} which will return
			 * the logical parent.
			 */
			VisualParent: Eto.Forms.Container;

			/** Gets a value indicating this control has been attached to a native container */
			readonly IsAttached: boolean;

			/**
			 * Gets or sets the color for the background of the control
			 *
			 * Note that on some platforms (e.g. Mac), setting the background color of a control can
			 * change the performance characteristics of the control and its children, since it must
			 * enable layers to do so.
			 */
			BackgroundColor: Eto.Drawing.Color;

			/** Gets a value indicating whether this instance has the keyboard input focus. */
			readonly HasFocus: boolean;

			/** Gets a value indicating whether the layout of child controls is suspended. */
			readonly IsSuspended: boolean;

			/** Gets the window this control is contained in */
			readonly ParentWindow: Eto.Forms.Window;

			/**
			 * Gets the supported platform commands that can be used to hook up system functions to
			 * user defined logic
			 *
			 * This lists all available commands that can be mapped using the
			 * {@link Eto.Forms.Control.MapPlatformCommand(System.String,Eto.Forms.Command)} method
			 * of the control.
			 */
			readonly SupportedPlatformCommands: Iterable<string>;

			/** Gets the bounding rectangle of this control relative to its container */
			readonly Bounds: Eto.Drawing.Rectangle;

			/**
			 * Gets the location of the control as positioned by the container
			 *
			 * A control's location is set by the container. This can be used to determine where the
			 * control is for overlaying floating windows, menus, etc.
			 */
			readonly Location: Eto.Drawing.Point;

			/** Gets or sets the type of cursor to use when the mouse is hovering over the control */
			Cursor: Eto.Forms.Cursor;

			/** Gets or sets the tool tip to show when the mouse is hovered over the control */
			ToolTip: string;

			/**
			 * Gets or sets the tab index order for this control within its container.
			 *
			 * This sets the order when using the tab key to cycle through controls  Note that some
			 * platforms (Gtk and WinForms) may not support setting the context of the tab order to
			 * StackLayout  or DynamicLayout containers and may not behave exactly as expected. Use
			 * the {@link Eto.PlatformFeatures.TabIndexWithCustomContainers} flag to determine if it
			 * is supported.
			 */
			TabIndex: number;

			/** Gets or sets a value indicating whether this control can serve as drop target. */
			AllowDrop: boolean;

			/**
			 * Gets or sets the parent widget which this widget has been added to, if any
			 *
			 * When implementing child widgets that can participate in the context based binding
			 * (MVVM), You can set this to the parent widget when it is added or removed to it
			 * (usually via a collection).  Note that you should typically provide a public new
			 * [ParentWidget] Parent { get; } property  so that consumers of your API cannot set the
			 * parent to an invalid value.
			 */
			Parent: Eto.Widget;

			/**
			 * Gets an enumeration of all parent widgets in the heirarchy by traversing the
			 * {@link Eto.Forms.BindableWidget.Parent} property.
			 */
			readonly Parents: Iterable<Eto.Widget>;

			/**
			 * Gets or sets the data context for this widget for binding
			 *
			 * Subclasses may override the standard behaviour so that hierarchy of widgets can be
			 * taken into account.  For example, a Control may return the data context of a parent,
			 * if it is not set explicitly.
			 */
			DataContext: unknown;

			/** Gets the collection of bindings that are attached to this widget */
			readonly Bindings: Eto.Forms.BindingCollection;

			/**
			 * Gets a value indicating that the {@link Eto.Forms.BindableWidget.DataContext} property
			 * is changing.
			 *
			 * This can be used to determine when to allow certain logic during the update of the
			 * data context.  It is used to disable binding setters on the model when the data
			 * context changes so that a binding does not cause the view model to be updated when the
			 * state hasn't been fully set yet.
			 */
			IsDataContextChanging: boolean;

			/**
			 * Gets the platform that was used to create the {@link Eto.Widget.Handler} for this
			 * widget
			 *
			 * This gets set to the current {@link Eto.Platform.Instance} during the construction of
			 * the object
			 */
			readonly Platform: Eto.Platform;

			/** Gets the platform-specific handler for this widget */
			Handler: unknown;

			/** Gets the native platform-specific handle for integration purposes */
			readonly NativeHandle: unknown;

			/** Gets the dictionary of properties for this widget */
			readonly Properties: Eto.PropertyStore;

			/** Gets or sets the ID of this widget */
			ID: string;

			/**
			 * Gets or sets the style of this widget
			 *
			 * Styles allow you to attach custom platform-specific logic to a widget. In your
			 * platform-specific assembly, use {@link Style.Add{H}(string, StyleHandler{H})} to add
			 * the style logic with the same id.
			 */
			Style: string;

			/**
			 * Gets the instance of the platform-specific object
			 *
			 * This can sometimes be useful to get the platform-specific object. Some handlers may
			 * not have any backing object for its functionality, so this may be null.  It is more
			 * preferred to use the {@link Eto.Widget.Handler} and cast that to the platform-specific
			 * handler class which can give you additional methods and helpers to do common tasks.
			 * For example, the {@link Eto.Forms.Application} object's handler for OS X has a
			 * AddFullScreenMenuItem property to specify if you want full screen support in your app.
			 */
			readonly ControlObject: unknown;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Widget} has been disposed.
			 *
			 * When the widget is disposed, it can no longer be used.
			 */
			IsDisposed: boolean;

			/** Gets the location of the control in the container */
			static GetLocation(control: Eto.Forms.Control): Eto.Drawing.Point;

			/** Sets the location of the specified control */
			static SetLocation(
				control: Eto.Forms.Control,
				value: Eto.Drawing.Point,
			): void;

			/** Adds a control to the layout with the specified pixel coordinates */
			Add(
				control: Eto.Forms.Control,
				x: number,
				y: number,
			): void;

			/** Adds a control at the specified location */
			Add(
				control: Eto.Forms.Control,
				location: Eto.Drawing.Point,
			): void;

			/** Moves the control to the specified coordinates */
			Move(
				control: Eto.Forms.Control,
				x: number,
				y: number,
			): void;

			/** Moves a control to the specified location. */
			Move(
				control: Eto.Forms.Control,
				location: Eto.Drawing.Point,
			): void;

			/** Remove the specified child control. */
			Remove(child: Eto.Forms.Control): void;

			/** Ends the initialization when loading from xaml or other code generated scenarios */
			EndInit(): void;

			/**
			 * Re-calculates the layout of the controls and re-positions them, if necessary
			 *
			 * All layouts should theoretically work without having to manually update them, but in
			 * certain cases this may be necessary to be called.
			 */
			Update(): void;

			/** Begins the initialization when loading from xaml or other code generated scenarios */
			BeginInit(): void;

			/** Remove the specified `controls` from this container */
			Remove(controls: Iterable<Eto.Forms.Control>): void;

			/** Removes all controls from this container */
			RemoveAll(): void;

			/**
			 * Finds a child control in this container or any of its child containers with the
			 * specified `id`
			 */
			FindChild<T>(id?: string): T;

			/**
			 * Finds a child control in this container or any of its child containers with the
			 * specified `type`
			 */
			FindChild(
				type: unknown,
				id?: string,
			): Eto.Forms.Control;

			/**
			 * Finds a child control in this container or any of its child containers with the
			 * specified `id`.
			 */
			FindChild(id: string): Eto.Forms.Control;

			/**
			 * Queues a repaint of the entire control on the screen and any of its children.
			 *
			 * This is only useful when the control is visible.
			 */
			Invalidate(): void;

			/**
			 * Queues a repaint of the entire control on the screen
			 *
			 * This is only useful when the control is visible.
			 */
			Invalidate(invalidateChildren: boolean): void;

			/**
			 * Queues a repaint of the specified `rect` of the control and any children.
			 *
			 * This is only useful when the control is visible.
			 */
			Invalidate(rect: Eto.Drawing.Rectangle): void;

			/**
			 * Queues a repaint of the specified `rect` of the control
			 *
			 * This is only useful when the control is visible.
			 */
			Invalidate(
				rect: Eto.Drawing.Rectangle,
				invalidateChildren: boolean,
			): void;

			/**
			 * Updates the layout of this control if necessary.
			 *
			 * This will ensure the control has had all of its layout applied so you can use its
			 * position and size right after this call. Most platforms (except WinForms) use a
			 * deferred layout system so that after adding your control to the form dynamically it
			 * won't get laid out until the next idle loop. This is useful when you need to know the
			 * dimensions of the control immediately. Note that this can be an expensive operation,
			 * so it is recommended to only call this method when necessary and after all of the
			 * controls have been added/updated.
			 */
			UpdateLayout(): void;

			/** Gets the preferred size of this control given infinite space available. */
			GetPreferredSize(): Eto.Drawing.SizeF;

			/** Gets the preferred size of this control given the specified `availableSize`. */
			GetPreferredSize(availableSize: Eto.Drawing.SizeF): Eto.Drawing.SizeF;

			/**
			 * Captures all mouse events to this control.
			 *
			 * This captures all mouse events until {@link Eto.Forms.Control.ReleaseMouseCapture} is
			 * called.  Note that not all platforms will allow a mouse capture unless the mouse is
			 * currently down.
			 */
			CaptureMouse(): boolean;

			/** Releases the mouse capture after a call to {@link Eto.Forms.Control.CaptureMouse}. */
			ReleaseMouseCapture(): void;

			/**
			 * Finds a control in the parent hierarchy with the specified type and
			 * {@link Eto.Widget.ID} if specified
			 */
			FindParent(
				type: unknown,
				id?: string,
			): Eto.Forms.Container;

			/** Finds a control in the parent hierarchy with the specified `id` */
			FindParent(id: string): Eto.Forms.Container;

			/**
			 * Detaches the control by removing it from its parent
			 *
			 * This is essentially a shortcut to myControl.Parent.Remove(myControl);
			 */
			Detach(): void;

			/**
			 * Attaches the control for direct use in a native application
			 *
			 * Use this to use a control directly in a native application.  Note that the native
			 * application must be running the same framework as the current platform.  E.g. a
			 * WinForms application can use an Eto.Forms control when using the Eto.WinForms
			 * platform.  This prepares the control by firing the {@link Eto.Forms.Control.PreLoad},
			 * {@link Eto.Forms.Control.Load}, etc. events.
			 */
			AttachNative(): void;

			/**
			 * Detaches the control when it is used in a native application, when you want to reuse
			 * the control.
			 *
			 * This should only be called after {@link Eto.Forms.Control.AttachNative} has been
			 * called, which is usually done by calling to ToNative(true) .
			 */
			DetachNative(): void;

			/**
			 * Attempts to set the keyboard input focus to this control, or the first child that
			 * accepts focus. For Windows, this will bring it to front and activate it.
			 */
			Focus(): void;

			/**
			 * Suspends the layout of child controls
			 *
			 * This can be used to optimize some platforms while adding, removing, or changing many
			 * child controls at once. It disables the calculation of control positioning until
			 * {@link Eto.Forms.Control.ResumeLayout} is called. Each call to SuspendLayout() must be
			 * balanced with a call to {@link Eto.Forms.Control.ResumeLayout}.
			 */
			SuspendLayout(): void;

			/**
			 * Resumes the layout after it has been suspended, and performs a layout
			 *
			 * This can be used to optimize some platforms while adding, removing, or changing many
			 * child controls at once. Each call to ResumeLayout() must be balanced with a call to
			 * {@link Eto.Forms.Control.SuspendLayout} before it.
			 */
			ResumeLayout(): void;

			/**
			 * Specifies a command to execute for a platform-specific command
			 *
			 * Some platforms have specific system-defined commands that can be associated with a
			 * control. For example, the Mac platform's cut/copy/paste functionality is defined by
			 * the system, and if you want to hook into it, you can use this to map it to your own
			 * defined logic. The valid values of the `systemCommand` parameter are defined by each
			 * platform, and a list can be retrieved using
			 * {@link Eto.Forms.Control.SupportedPlatformCommands}
			 */
			MapPlatformCommand(
				systemCommand: string,
				command: Eto.Forms.Command,
			): void;

			/** Converts a point from screen space to control space. */
			PointFromScreen(point: Eto.Drawing.PointF): Eto.Drawing.PointF;

			/** Converts a point from control space to screen space */
			PointToScreen(point: Eto.Drawing.PointF): Eto.Drawing.PointF;

			/** Converts a rectangle from screen space to control space. */
			RectangleToScreen(rect: Eto.Drawing.RectangleF): Eto.Drawing.RectangleF;

			/** Converts a rectangle from control space to screen space */
			RectangleFromScreen(rect: Eto.Drawing.RectangleF): Eto.Drawing.RectangleF;

			/**
			 * Starts drag operation using this control as drag source.
			 *
			 * This method can be blocking on some platforms (Wpf, WinForms), and non-blocking on
			 * others (Mac, Gtk). Use the {@link Eto.Forms.Control.DragEnd} event to determine when
			 * the drag operation is completed and get its resulting DragEffects.
			 */
			DoDragDrop(
				data: Eto.Forms.DataObject,
				allowedEffects: Eto.Forms.DragEffects,
			): void;

			/**
			 * Starts drag operation using this control as drag source.
			 *
			 * This method can be blocking on some platforms (Wpf, WinForms), and non-blocking on
			 * others (Mac, Gtk). Use the {@link Eto.Forms.Control.DragEnd} event to determine when
			 * the drag operation is completed and get its resulting DragEffects.
			 */
			DoDragDrop(
				data: Eto.Forms.DataObject,
				allowedEffects: Eto.Forms.DragEffects,
				image: Eto.Drawing.Image,
				cursorOffset: Eto.Drawing.PointF,
			): void;

			/**
			 * Triggers the StyleChanged event and re-applies the styles to this control and its
			 * children.
			 */
			TriggerStyleChanged(): void;

			/** Shows a print dialog to print the specified control */
			Print(): void;

			/**
			 * Finds a control in the parent hierarchy with the specified type and
			 * {@link Eto.Widget.ID} if specified
			 */
			FindParent<T>(id?: string): T;

			/**
			 * Finds a control in the parent hierarchy with the specified type and
			 * {@link Eto.Widget.ID} if specified
			 */
			FindParent(
				type: unknown,
				id?: string,
			): Eto.Widget;

			/** Finds a control in the parent hierarchy with the specified `id` */
			FindParent(id: string): Eto.Widget;

			/**
			 * Unbinds any bindings in the {@link Eto.Forms.BindableWidget.Bindings} collection and
			 * removes the bindings
			 *
			 * When you implement {@link Eto.Forms.IBindableWidgetContainer}, this will also unbind
			 * any of its children.
			 */
			Unbind(): void;

			/**
			 * Updates all bindings in this widget
			 *
			 * When you implement {@link Eto.Forms.IBindableWidgetContainer}, this will also update
			 * bindings for all of its children.
			 */
			UpdateBindings(mode?: Eto.Forms.BindingUpdateMode): void;

			/** Disposes of this widget, supressing the finalizer */
			dispose(): void;

			/** Gets a string that represents the current object with its ID if specified. */
			ToString(): string;
		}
	}

	export namespace Eto.Forms.PixelLayout {
		export interface IHandler extends
			Eto.Forms.Layout.IHandler,
			Eto.Forms.Container.IHandler,
			Eto.Forms.Control.IHandler,
			Eto.Widget.IHandler,
			Eto.Forms.Layout.IPositionalLayoutHandler {
		}
	}

	export namespace Eto.Forms {
		/** Horizontal alignment for controls */
		export enum HorizontalAlignment {
			/** Controls are aligned to the left of the container. */
			Left = 0,

			/** Controls are centered. */
			Center = 1,

			/** Controls are aligned to the right of the container. */
			Right = 2,

			/** Controls stretch to fill the entire width of the container. */
			Stretch = 3,
		}
	}

	export namespace Eto.Forms {
		/** Vertical alignment for controls */
		export enum VerticalAlignment {
			/** Controls are aligned to the top of the container. */
			Top = 0,

			/** Controls are centered. */
			Center = 1,

			/** Controls are aligned to the bottom of the container. */
			Bottom = 2,

			/** Controls stretch to fill the entire height of the container. */
			Stretch = 3,
		}
	}

	export namespace Eto.Forms {
		/** Item for a single control in a {@link Eto.Forms.StackLayout}. */
		export class StackLayoutItem {
			/** Initializes a new instance of the {@link Eto.Forms.StackLayoutItem} class. */
			constructor();

			/** Initializes a new instance of the {@link Eto.Forms.StackLayoutItem} class. */
			constructor(
				control: Eto.Forms.Control,
				expand?: boolean,
			);

			/**
			 * Initializes a new instance of the {@link Eto.Forms.StackLayoutItem} class when the
			 * StackLayout.Orientation is Vertical.
			 */
			constructor(
				control: Eto.Forms.Control,
				alignment: Eto.Forms.HorizontalAlignment | undefined,
				expand?: boolean,
			);

			/**
			 * Initializes a new instance of the {@link Eto.Forms.StackLayoutItem} class when the
			 * StackLayout.Orientation is Horizontal.
			 */
			constructor(
				control: Eto.Forms.Control,
				alignment: Eto.Forms.VerticalAlignment | undefined,
				expand?: boolean,
			);

			/** Gets or sets the control for this item. */
			Control: Eto.Forms.Control;

			/**
			 * Gets or sets the horizontal alignment for the control for vertical stack layouts, or
			 * null to use {@link Eto.Forms.StackLayout.HorizontalContentAlignment}.
			 */
			HorizontalAlignment?: Eto.Forms.HorizontalAlignment;

			/**
			 * Gets or sets the vertical alignment for the control for horizontal stack layouts, or
			 * null to use {@link Eto.Forms.StackLayout.VerticalContentAlignment}.
			 */
			VerticalAlignment?: Eto.Forms.VerticalAlignment;

			/**
			 * Gets or sets a value indicating whether the control expands to available space in the
			 * direction of the layout.
			 */
			Expand: boolean;
		}
	}

	export namespace Eto.Forms {
		/**
		 * Layout to stack controls horizontally or vertically, with the ability for each child
		 * to be aligned to a side of the layout.
		 */
		export class StackLayout implements
			Eto.IHandlerSource,
			Eto.Forms.IBindable,
			Eto.Forms.IMouseInputSource,
			Eto.Forms.IKeyboardInputSource {
			/** Initializes a new instance of the {@link Eto.Forms.StackLayout} class. */
			constructor();

			/**
			 * Initializes a new instance of the {@link Eto.Forms.StackLayout} class with the
			 * specified items.
			 */
			constructor(items: Eto.Forms.StackLayoutItem[]);

			/**
			 * Gets or sets the orientation of the controls in the stack layout.
			 *
			 * When the orientation is Horizontal, the
			 * {@link Eto.Forms.StackLayout.VerticalContentAlignment} specifies the default vertical
			 * alignment for child controls. When the orientation is Vertical, the
			 * {@link Eto.Forms.StackLayout.HorizontalContentAlignment} specifies the default
			 * horizontal alignment for child controls.
			 */
			Orientation: Eto.Forms.Orientation;

			/** Gets or sets the spacing between each of the controls in the stack. */
			Spacing: number;

			/**
			 * Gets or sets the default horizontal alignment of the child controls in the stack
			 * layout when the {@link Eto.Forms.StackLayout.Orientation} is Vertical.
			 *
			 * The alignment can also be specified on a per-child basis with the
			 * {@link Eto.Forms.StackLayoutItem.HorizontalAlignment} property.
			 */
			HorizontalContentAlignment: Eto.Forms.HorizontalAlignment;

			/**
			 * Gets or sets the default vertical alignment of the child controls in the stack layout
			 * when the {@link Eto.Forms.StackLayout.Orientation} is Horizontal.
			 *
			 * The alignment can also be specified on a per-child basis with the
			 * {@link Eto.Forms.StackLayoutItem.VerticalAlignment} property.
			 */
			VerticalContentAlignment: Eto.Forms.VerticalAlignment;

			/**
			 * Gets or sets a value indicating whether the Label's alignment will be changed to match
			 * the alignment of the StackLayout.
			 *
			 * This is used so labels can be updated automatically to match the content alignment of
			 * the stack. For example, when {@link Eto.Forms.StackLayout.HorizontalContentAlignment}
			 * is Center, then all Labels will get their {@link Eto.Forms.Label.TextAlignment} set to
			 * {@link Eto.Forms.TextAlignment.Center}.
			 */
			AlignLabels: boolean;

			/** Gets the collection of items in the stack layout. */
			readonly Items: unknown;

			/**
			 * Gets the controls for the layout
			 *
			 * This will return the list of controls in the stack layout when not created, and when
			 * it is, it will return the embedded TableLayout.
			 */
			readonly Controls: Iterable<Eto.Forms.Control>;

			/**
			 * Gets an enumeration of controls that are in the visual tree.
			 *
			 * This is used to specify which controls are contained by this instance that are part of
			 * the visual tree. This should include all controls including non-logical Eto controls
			 * used for layout.
			 */
			readonly VisualControls: Iterable<Eto.Forms.Control>;

			/** Gets or sets the padding around the {@link Eto.Forms.Panel.Content} of the panel. */
			Padding: Eto.Drawing.Padding;

			/** Gets or sets the minimum size of the panel. */
			MinimumSize: Eto.Drawing.Size;

			/**
			 * Gets or sets the context menu for the panel.
			 *
			 * The context menu is usually shown when the user right clicks the control, or in mobile
			 * platforms when the user taps and holds their finger down on the control.
			 */
			ContextMenu: Eto.Forms.ContextMenu;

			/**
			 * Gets or sets the main content of the panel.
			 *
			 * The main content will be offset by the {@link Eto.Forms.Panel.Padding} value
			 * specified, and will take up the entire content area of the control. Some controls may
			 * have decorations that will surround the content, such as a {@link Eto.Forms.GroupBox},
			 * {@link Eto.Forms.TabControl}, or {@link Eto.Forms.Window}
			 */
			Content: Eto.Forms.Control;

			/**
			 * Gets or sets the size for the client area of the control
			 *
			 * The client size differs from the {@link Eto.Forms.Control.Size} in that it excludes
			 * the decorations of the container, such as the title bar and border around a
			 * {@link Eto.Forms.Window}, or the title and line  around a {@link Eto.Forms.GroupBox}.
			 */
			ClientSize: Eto.Drawing.Size;

			/**
			 * Gets an enumeration of all contained child controls, including controls within child
			 * containers
			 */
			readonly Children: Iterable<Eto.Forms.Control>;

			/**
			 * Gets an enumeration of all contained child controls in the visual tree, including
			 * controls within child containers.
			 */
			readonly VisualChildren: Iterable<Eto.Forms.Control>;

			/**
			 * Gets or sets the style provider for this container.
			 *
			 * The style provider is used to style this container and its children.
			 */
			StyleProvider: Eto.IStyleProvider;

			/**
			 * Gets the default style provider for this container.
			 *
			 * Use this to apply styles to any child controls of this container. By default, styles
			 * will apply to all children, including children of children unless
			 * {@link Eto.DefaultStyleProvider.Inherit} is set to false .  Typically, you would set
			 * Inherit to false when creating composite controls that already have all their styles
			 * applied and you don't want any other styles to be inherited.
			 */
			readonly Styles: Eto.DefaultStyleProvider;

			/**
			 * Gets a value indicating that the control is loaded onto a form, that is it has been
			 * created, added to a parent, and shown
			 *
			 * The {@link Eto.Forms.Control.OnLoad(System.EventArgs)} method sets this value to true
			 * after cascading to all children (for a {@link Eto.Forms.Container} ) and calling the
			 * platform handler's implementation.  It is called after adding to a loaded form, or
			 * when showing a new form.  The {@link Eto.Forms.Control.OnUnLoad(System.EventArgs)}
			 * method will set this value to false when the control is removed from its parent
			 */
			readonly Loaded: boolean;

			/**
			 * Gets or sets a user-defined object that contains data about the control
			 *
			 * A common use of the tag property is to store data that is associated with the control
			 * that you can later retrieve.
			 */
			Tag: unknown;

			/**
			 * Gets the logical parent control.
			 *
			 * When the control is part of the visual tree (
				 * {@link Eto.Forms.Control.IsVisualControl} is true), this returns the logical parent
				 * that contains this control. Otherwise this is the same as
				 * {@link Eto.Forms.Control.Parent}.
				 */
				readonly LogicalParent: Eto.Forms.Container;

			/** Gets a value indicating this {@link Eto.Forms.Control} is part of the visual tree. */
			IsVisualControl: boolean;

			/**
			 * Gets or sets the size of the control. Use -1 to specify auto sizing for either the
			 * width and/or height.
			 *
			 * Setting the size of controls is entirely optional as most controls will size
			 * themselves appropriately. When specifying a size, it will be used as the desired size
			 * of the control.  The container will reposition and resize the control depending on the
			 * available size.  For a {@link Eto.Forms.Window}, it is preferred to set the
			 * {@link Eto.Forms.Container.ClientSize} instead, as various platforms have different
			 * sizes of window decorations, toolbars, etc.
			 */
			Size: Eto.Drawing.Size;

			/**
			 * Gets a value indicating this control currently has mouse capture
			 *
			 * Mouse capture can happen during a handled MouseDown event until MouseUp, or it can be
			 * captured explicitly via {@link Eto.Forms.Control.CaptureMouse}.
			 */
			readonly IsMouseCaptured: boolean;

			/** Gets or sets the width of the control size. */
			Width: number;

			/** Gets or sets the height of the control size. */
			Height: number;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Forms.Control} (or its
			 * children) are enabled and accept user input.
			 *
			 * Typically when a control is disabled, the user cannot do anything with the control or
			 * any of its children. Including for example, selecting text in a text control. Certain
			 * controls can have a 'Read Only' mode, such as {@link Eto.Forms.TextBox.ReadOnly} which
			 * allow the user to  select text, but not change its contents.
			 */
			Enabled: boolean;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Forms.Control} is visible to
			 * the user.
			 *
			 * When the visibility of a control is set to false, it will not occupy space in the
			 * layout.
			 */
			Visible: boolean;

			/** Gets the container which this control has been added to, if any */
			readonly Parent: Eto.Forms.Container;

			/**
			 * Gets the visual container of this control, if any.
			 *
			 * Some containers may use other Eto controls to layout its children, such as the
			 * {@link Eto.Forms.StackLayout}. This will return the parent control that visually
			 * contains this control as opposed to {@link Eto.Forms.Control.Parent} which will return
			 * the logical parent.
			 */
			VisualParent: Eto.Forms.Container;

			/** Gets a value indicating this control has been attached to a native container */
			readonly IsAttached: boolean;

			/**
			 * Gets or sets the color for the background of the control
			 *
			 * Note that on some platforms (e.g. Mac), setting the background color of a control can
			 * change the performance characteristics of the control and its children, since it must
			 * enable layers to do so.
			 */
			BackgroundColor: Eto.Drawing.Color;

			/** Gets a value indicating whether this instance has the keyboard input focus. */
			readonly HasFocus: boolean;

			/** Gets a value indicating whether the layout of child controls is suspended. */
			readonly IsSuspended: boolean;

			/** Gets the window this control is contained in */
			readonly ParentWindow: Eto.Forms.Window;

			/**
			 * Gets the supported platform commands that can be used to hook up system functions to
			 * user defined logic
			 *
			 * This lists all available commands that can be mapped using the
			 * {@link Eto.Forms.Control.MapPlatformCommand(System.String,Eto.Forms.Command)} method
			 * of the control.
			 */
			readonly SupportedPlatformCommands: Iterable<string>;

			/** Gets the bounding rectangle of this control relative to its container */
			readonly Bounds: Eto.Drawing.Rectangle;

			/**
			 * Gets the location of the control as positioned by the container
			 *
			 * A control's location is set by the container. This can be used to determine where the
			 * control is for overlaying floating windows, menus, etc.
			 */
			readonly Location: Eto.Drawing.Point;

			/** Gets or sets the type of cursor to use when the mouse is hovering over the control */
			Cursor: Eto.Forms.Cursor;

			/** Gets or sets the tool tip to show when the mouse is hovered over the control */
			ToolTip: string;

			/**
			 * Gets or sets the tab index order for this control within its container.
			 *
			 * This sets the order when using the tab key to cycle through controls  Note that some
			 * platforms (Gtk and WinForms) may not support setting the context of the tab order to
			 * StackLayout  or DynamicLayout containers and may not behave exactly as expected. Use
			 * the {@link Eto.PlatformFeatures.TabIndexWithCustomContainers} flag to determine if it
			 * is supported.
			 */
			TabIndex: number;

			/** Gets or sets a value indicating whether this control can serve as drop target. */
			AllowDrop: boolean;

			/**
			 * Gets or sets the parent widget which this widget has been added to, if any
			 *
			 * When implementing child widgets that can participate in the context based binding
			 * (MVVM), You can set this to the parent widget when it is added or removed to it
			 * (usually via a collection).  Note that you should typically provide a public new
			 * [ParentWidget] Parent { get; } property  so that consumers of your API cannot set the
			 * parent to an invalid value.
			 */
			Parent: Eto.Widget;

			/**
			 * Gets an enumeration of all parent widgets in the heirarchy by traversing the
			 * {@link Eto.Forms.BindableWidget.Parent} property.
			 */
			readonly Parents: Iterable<Eto.Widget>;

			/**
			 * Gets or sets the data context for this widget for binding
			 *
			 * Subclasses may override the standard behaviour so that hierarchy of widgets can be
			 * taken into account.  For example, a Control may return the data context of a parent,
			 * if it is not set explicitly.
			 */
			DataContext: unknown;

			/** Gets the collection of bindings that are attached to this widget */
			readonly Bindings: Eto.Forms.BindingCollection;

			/**
			 * Gets a value indicating that the {@link Eto.Forms.BindableWidget.DataContext} property
			 * is changing.
			 *
			 * This can be used to determine when to allow certain logic during the update of the
			 * data context.  It is used to disable binding setters on the model when the data
			 * context changes so that a binding does not cause the view model to be updated when the
			 * state hasn't been fully set yet.
			 */
			IsDataContextChanging: boolean;

			/**
			 * Gets the platform that was used to create the {@link Eto.Widget.Handler} for this
			 * widget
			 *
			 * This gets set to the current {@link Eto.Platform.Instance} during the construction of
			 * the object
			 */
			readonly Platform: Eto.Platform;

			/** Gets the platform-specific handler for this widget */
			Handler: unknown;

			/** Gets the native platform-specific handle for integration purposes */
			readonly NativeHandle: unknown;

			/** Gets the dictionary of properties for this widget */
			readonly Properties: Eto.PropertyStore;

			/** Gets or sets the ID of this widget */
			ID: string;

			/**
			 * Gets or sets the style of this widget
			 *
			 * Styles allow you to attach custom platform-specific logic to a widget. In your
			 * platform-specific assembly, use {@link Style.Add{H}(string, StyleHandler{H})} to add
			 * the style logic with the same id.
			 */
			Style: string;

			/**
			 * Gets the instance of the platform-specific object
			 *
			 * This can sometimes be useful to get the platform-specific object. Some handlers may
			 * not have any backing object for its functionality, so this may be null.  It is more
			 * preferred to use the {@link Eto.Widget.Handler} and cast that to the platform-specific
			 * handler class which can give you additional methods and helpers to do common tasks.
			 * For example, the {@link Eto.Forms.Application} object's handler for OS X has a
			 * AddFullScreenMenuItem property to specify if you want full screen support in your app.
			 */
			readonly ControlObject: unknown;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Widget} has been disposed.
			 *
			 * When the widget is disposed, it can no longer be used.
			 */
			IsDisposed: boolean;

			/** Suspends the layout of child controls */
			SuspendLayout(): void;

			/** Resumes the layout after it has been suspended, and performs a layout */
			ResumeLayout(): void;

			/** Removes the specified child from the container */
			Remove(child: Eto.Forms.Control): void;

			/** Remove the specified `controls` from this container */
			Remove(controls: Iterable<Eto.Forms.Control>): void;

			/** Removes all controls from this container */
			RemoveAll(): void;

			/**
			 * Finds a child control in this container or any of its child containers with the
			 * specified `id`
			 */
			FindChild<T>(id?: string): T;

			/**
			 * Finds a child control in this container or any of its child containers with the
			 * specified `type`
			 */
			FindChild(
				type: unknown,
				id?: string,
			): Eto.Forms.Control;

			/**
			 * Finds a child control in this container or any of its child containers with the
			 * specified `id`.
			 */
			FindChild(id: string): Eto.Forms.Control;

			/**
			 * Queues a repaint of the entire control on the screen and any of its children.
			 *
			 * This is only useful when the control is visible.
			 */
			Invalidate(): void;

			/**
			 * Queues a repaint of the entire control on the screen
			 *
			 * This is only useful when the control is visible.
			 */
			Invalidate(invalidateChildren: boolean): void;

			/**
			 * Queues a repaint of the specified `rect` of the control and any children.
			 *
			 * This is only useful when the control is visible.
			 */
			Invalidate(rect: Eto.Drawing.Rectangle): void;

			/**
			 * Queues a repaint of the specified `rect` of the control
			 *
			 * This is only useful when the control is visible.
			 */
			Invalidate(
				rect: Eto.Drawing.Rectangle,
				invalidateChildren: boolean,
			): void;

			/**
			 * Updates the layout of this control if necessary.
			 *
			 * This will ensure the control has had all of its layout applied so you can use its
			 * position and size right after this call. Most platforms (except WinForms) use a
			 * deferred layout system so that after adding your control to the form dynamically it
			 * won't get laid out until the next idle loop. This is useful when you need to know the
			 * dimensions of the control immediately. Note that this can be an expensive operation,
			 * so it is recommended to only call this method when necessary and after all of the
			 * controls have been added/updated.
			 */
			UpdateLayout(): void;

			/** Gets the preferred size of this control given infinite space available. */
			GetPreferredSize(): Eto.Drawing.SizeF;

			/** Gets the preferred size of this control given the specified `availableSize`. */
			GetPreferredSize(availableSize: Eto.Drawing.SizeF): Eto.Drawing.SizeF;

			/**
			 * Captures all mouse events to this control.
			 *
			 * This captures all mouse events until {@link Eto.Forms.Control.ReleaseMouseCapture} is
			 * called.  Note that not all platforms will allow a mouse capture unless the mouse is
			 * currently down.
			 */
			CaptureMouse(): boolean;

			/** Releases the mouse capture after a call to {@link Eto.Forms.Control.CaptureMouse}. */
			ReleaseMouseCapture(): void;

			/**
			 * Finds a control in the parent hierarchy with the specified type and
			 * {@link Eto.Widget.ID} if specified
			 */
			FindParent(
				type: unknown,
				id?: string,
			): Eto.Forms.Container;

			/** Finds a control in the parent hierarchy with the specified `id` */
			FindParent(id: string): Eto.Forms.Container;

			/**
			 * Detaches the control by removing it from its parent
			 *
			 * This is essentially a shortcut to myControl.Parent.Remove(myControl);
			 */
			Detach(): void;

			/**
			 * Attaches the control for direct use in a native application
			 *
			 * Use this to use a control directly in a native application.  Note that the native
			 * application must be running the same framework as the current platform.  E.g. a
			 * WinForms application can use an Eto.Forms control when using the Eto.WinForms
			 * platform.  This prepares the control by firing the {@link Eto.Forms.Control.PreLoad},
			 * {@link Eto.Forms.Control.Load}, etc. events.
			 */
			AttachNative(): void;

			/**
			 * Detaches the control when it is used in a native application, when you want to reuse
			 * the control.
			 *
			 * This should only be called after {@link Eto.Forms.Control.AttachNative} has been
			 * called, which is usually done by calling to ToNative(true) .
			 */
			DetachNative(): void;

			/**
			 * Attempts to set the keyboard input focus to this control, or the first child that
			 * accepts focus. For Windows, this will bring it to front and activate it.
			 */
			Focus(): void;

			/**
			 * Specifies a command to execute for a platform-specific command
			 *
			 * Some platforms have specific system-defined commands that can be associated with a
			 * control. For example, the Mac platform's cut/copy/paste functionality is defined by
			 * the system, and if you want to hook into it, you can use this to map it to your own
			 * defined logic. The valid values of the `systemCommand` parameter are defined by each
			 * platform, and a list can be retrieved using
			 * {@link Eto.Forms.Control.SupportedPlatformCommands}
			 */
			MapPlatformCommand(
				systemCommand: string,
				command: Eto.Forms.Command,
			): void;

			/** Converts a point from screen space to control space. */
			PointFromScreen(point: Eto.Drawing.PointF): Eto.Drawing.PointF;

			/** Converts a point from control space to screen space */
			PointToScreen(point: Eto.Drawing.PointF): Eto.Drawing.PointF;

			/** Converts a rectangle from screen space to control space. */
			RectangleToScreen(rect: Eto.Drawing.RectangleF): Eto.Drawing.RectangleF;

			/** Converts a rectangle from control space to screen space */
			RectangleFromScreen(rect: Eto.Drawing.RectangleF): Eto.Drawing.RectangleF;

			/**
			 * Starts drag operation using this control as drag source.
			 *
			 * This method can be blocking on some platforms (Wpf, WinForms), and non-blocking on
			 * others (Mac, Gtk). Use the {@link Eto.Forms.Control.DragEnd} event to determine when
			 * the drag operation is completed and get its resulting DragEffects.
			 */
			DoDragDrop(
				data: Eto.Forms.DataObject,
				allowedEffects: Eto.Forms.DragEffects,
			): void;

			/**
			 * Starts drag operation using this control as drag source.
			 *
			 * This method can be blocking on some platforms (Wpf, WinForms), and non-blocking on
			 * others (Mac, Gtk). Use the {@link Eto.Forms.Control.DragEnd} event to determine when
			 * the drag operation is completed and get its resulting DragEffects.
			 */
			DoDragDrop(
				data: Eto.Forms.DataObject,
				allowedEffects: Eto.Forms.DragEffects,
				image: Eto.Drawing.Image,
				cursorOffset: Eto.Drawing.PointF,
			): void;

			/**
			 * Triggers the StyleChanged event and re-applies the styles to this control and its
			 * children.
			 */
			TriggerStyleChanged(): void;

			/** Shows a print dialog to print the specified control */
			Print(): void;

			/**
			 * Finds a control in the parent hierarchy with the specified type and
			 * {@link Eto.Widget.ID} if specified
			 */
			FindParent<T>(id?: string): T;

			/**
			 * Finds a control in the parent hierarchy with the specified type and
			 * {@link Eto.Widget.ID} if specified
			 */
			FindParent(
				type: unknown,
				id?: string,
			): Eto.Widget;

			/** Finds a control in the parent hierarchy with the specified `id` */
			FindParent(id: string): Eto.Widget;

			/**
			 * Unbinds any bindings in the {@link Eto.Forms.BindableWidget.Bindings} collection and
			 * removes the bindings
			 *
			 * When you implement {@link Eto.Forms.IBindableWidgetContainer}, this will also unbind
			 * any of its children.
			 */
			Unbind(): void;

			/**
			 * Updates all bindings in this widget
			 *
			 * When you implement {@link Eto.Forms.IBindableWidgetContainer}, this will also update
			 * bindings for all of its children.
			 */
			UpdateBindings(mode?: Eto.Forms.BindingUpdateMode): void;

			/** Disposes of this widget, supressing the finalizer */
			dispose(): void;

			/** Gets a string that represents the current object with its ID if specified. */
			ToString(): string;
		}
	}

	export namespace Eto.Forms {
		/** Represents a cell in a {@link Eto.Forms.TableRow} */
		export class TableCell {
			/** Initializes a new instance of the {@link Eto.Forms.TableCell} class. */
			constructor();

			/** Initializes a new instance of the {@link Eto.Forms.TableCell} class. */
			constructor(
				control: Eto.Forms.Control,
				scaleWidth?: boolean,
			);

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Forms.TableCell} will scale
			 * its width
			 *
			 * All controls in the same column of this cell will get the same scaling value. Scaling
			 * will make the column expand to fit the rest of the width of the container, minus the
			 * preferred width of any non-scaled columns.  If there are no columns with width
			 * scaling, the last column will automatically get scaled.  With scaling turned off,
			 * cells in the column will fit the preferred size of the widest control.
			 */
			ScaleWidth: boolean;

			/** Gets or sets the control in this cell, or null for an empty space */
			Control: Eto.Forms.Control;
		}
	}

	export namespace Eto.Forms {
		/**
		 * Layout for controls in a table
		 *
		 * This is similar to an html table, though each control will fill its entire cell.
		 */
		export class TableLayout implements
			Eto.IHandlerSource,
			Eto.Forms.IBindable,
			Eto.Forms.IMouseInputSource,
			Eto.Forms.IKeyboardInputSource {
			/** Initializes a new instance of the {@link Eto.Forms.TableLayout} class. */
			constructor();

			/**
			 * Initializes a new instance of the {@link Eto.Forms.TableLayout} class with the
			 * specified number of columns and rows.
			 */
			constructor(
				columns: number,
				rows: number,
			);

			/**
			 * Initializes a new instance of the {@link Eto.Forms.TableLayout} class with the
			 * specified dimensions.
			 */
			constructor(dimensions: Eto.Drawing.Size);

			/**
			 * Initializes a new instance of the {@link Eto.Forms.TableLayout} class with the
			 * specified rows.
			 */
			constructor(rows: Eto.Forms.TableRow[]);

			/**
			 * Initializes a new instance of the {@link Eto.Forms.TableLayout} class with the
			 * specified rows.
			 */
			constructor(rows: Iterable<Eto.Forms.TableRow>);

			/**
			 * Initializes a new instance of the {@link Eto.Forms.TableLayout} class with the
			 * specified rows.
			 */
			constructor(
				yscale: boolean,
				rows: Eto.Forms.TableRow[],
			);

			/** Gets an enumeration of controls that are directly contained by this container */
			readonly Controls: Iterable<Eto.Forms.Control>;

			/** Gets the collection of rows in the table */
			Rows: unknown;

			/** Gets the dimensions of the table in cells. */
			readonly Dimensions: Eto.Drawing.Size;

			/**
			 * Gets or sets the horizontal and vertical spacing between each of the cells of the
			 * table.
			 */
			Spacing: Eto.Drawing.Size;

			/** Gets or sets the padding bordering the table. */
			Padding: Eto.Drawing.Padding;

			/**
			 * Gets or sets the size for the client area of the control
			 *
			 * The client size differs from the {@link Eto.Forms.Control.Size} in that it excludes
			 * the decorations of the container, such as the title bar and border around a
			 * {@link Eto.Forms.Window}, or the title and line  around a {@link Eto.Forms.GroupBox}.
			 */
			ClientSize: Eto.Drawing.Size;

			/**
			 * Gets an enumeration of all contained child controls, including controls within child
			 * containers
			 */
			readonly Children: Iterable<Eto.Forms.Control>;

			/**
			 * Gets an enumeration of all contained child controls in the visual tree, including
			 * controls within child containers.
			 */
			readonly VisualChildren: Iterable<Eto.Forms.Control>;

			/**
			 * Gets or sets the style provider for this container.
			 *
			 * The style provider is used to style this container and its children.
			 */
			StyleProvider: Eto.IStyleProvider;

			/**
			 * Gets the default style provider for this container.
			 *
			 * Use this to apply styles to any child controls of this container. By default, styles
			 * will apply to all children, including children of children unless
			 * {@link Eto.DefaultStyleProvider.Inherit} is set to false .  Typically, you would set
			 * Inherit to false when creating composite controls that already have all their styles
			 * applied and you don't want any other styles to be inherited.
			 */
			readonly Styles: Eto.DefaultStyleProvider;

			/**
			 * Gets a value indicating that the control is loaded onto a form, that is it has been
			 * created, added to a parent, and shown
			 *
			 * The {@link Eto.Forms.Control.OnLoad(System.EventArgs)} method sets this value to true
			 * after cascading to all children (for a {@link Eto.Forms.Container} ) and calling the
			 * platform handler's implementation.  It is called after adding to a loaded form, or
			 * when showing a new form.  The {@link Eto.Forms.Control.OnUnLoad(System.EventArgs)}
			 * method will set this value to false when the control is removed from its parent
			 */
			readonly Loaded: boolean;

			/**
			 * Gets an enumeration of controls that are in the visual tree.
			 *
			 * This is used to specify which controls are contained by this instance that are part of
			 * the visual tree. This should include all controls including non-logical Eto controls
			 * used for layout.
			 */
			readonly VisualControls: Iterable<Eto.Forms.Control>;

			/**
			 * Gets or sets a user-defined object that contains data about the control
			 *
			 * A common use of the tag property is to store data that is associated with the control
			 * that you can later retrieve.
			 */
			Tag: unknown;

			/**
			 * Gets the logical parent control.
			 *
			 * When the control is part of the visual tree (
				 * {@link Eto.Forms.Control.IsVisualControl} is true), this returns the logical parent
				 * that contains this control. Otherwise this is the same as
				 * {@link Eto.Forms.Control.Parent}.
				 */
				readonly LogicalParent: Eto.Forms.Container;

			/** Gets a value indicating this {@link Eto.Forms.Control} is part of the visual tree. */
			IsVisualControl: boolean;

			/**
			 * Gets or sets the size of the control. Use -1 to specify auto sizing for either the
			 * width and/or height.
			 *
			 * Setting the size of controls is entirely optional as most controls will size
			 * themselves appropriately. When specifying a size, it will be used as the desired size
			 * of the control.  The container will reposition and resize the control depending on the
			 * available size.  For a {@link Eto.Forms.Window}, it is preferred to set the
			 * {@link Eto.Forms.Container.ClientSize} instead, as various platforms have different
			 * sizes of window decorations, toolbars, etc.
			 */
			Size: Eto.Drawing.Size;

			/**
			 * Gets a value indicating this control currently has mouse capture
			 *
			 * Mouse capture can happen during a handled MouseDown event until MouseUp, or it can be
			 * captured explicitly via {@link Eto.Forms.Control.CaptureMouse}.
			 */
			readonly IsMouseCaptured: boolean;

			/** Gets or sets the width of the control size. */
			Width: number;

			/** Gets or sets the height of the control size. */
			Height: number;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Forms.Control} (or its
			 * children) are enabled and accept user input.
			 *
			 * Typically when a control is disabled, the user cannot do anything with the control or
			 * any of its children. Including for example, selecting text in a text control. Certain
			 * controls can have a 'Read Only' mode, such as {@link Eto.Forms.TextBox.ReadOnly} which
			 * allow the user to  select text, but not change its contents.
			 */
			Enabled: boolean;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Forms.Control} is visible to
			 * the user.
			 *
			 * When the visibility of a control is set to false, it will not occupy space in the
			 * layout.
			 */
			Visible: boolean;

			/** Gets the container which this control has been added to, if any */
			readonly Parent: Eto.Forms.Container;

			/**
			 * Gets the visual container of this control, if any.
			 *
			 * Some containers may use other Eto controls to layout its children, such as the
			 * {@link Eto.Forms.StackLayout}. This will return the parent control that visually
			 * contains this control as opposed to {@link Eto.Forms.Control.Parent} which will return
			 * the logical parent.
			 */
			VisualParent: Eto.Forms.Container;

			/** Gets a value indicating this control has been attached to a native container */
			readonly IsAttached: boolean;

			/**
			 * Gets or sets the color for the background of the control
			 *
			 * Note that on some platforms (e.g. Mac), setting the background color of a control can
			 * change the performance characteristics of the control and its children, since it must
			 * enable layers to do so.
			 */
			BackgroundColor: Eto.Drawing.Color;

			/** Gets a value indicating whether this instance has the keyboard input focus. */
			readonly HasFocus: boolean;

			/** Gets a value indicating whether the layout of child controls is suspended. */
			readonly IsSuspended: boolean;

			/** Gets the window this control is contained in */
			readonly ParentWindow: Eto.Forms.Window;

			/**
			 * Gets the supported platform commands that can be used to hook up system functions to
			 * user defined logic
			 *
			 * This lists all available commands that can be mapped using the
			 * {@link Eto.Forms.Control.MapPlatformCommand(System.String,Eto.Forms.Command)} method
			 * of the control.
			 */
			readonly SupportedPlatformCommands: Iterable<string>;

			/** Gets the bounding rectangle of this control relative to its container */
			readonly Bounds: Eto.Drawing.Rectangle;

			/**
			 * Gets the location of the control as positioned by the container
			 *
			 * A control's location is set by the container. This can be used to determine where the
			 * control is for overlaying floating windows, menus, etc.
			 */
			readonly Location: Eto.Drawing.Point;

			/** Gets or sets the type of cursor to use when the mouse is hovering over the control */
			Cursor: Eto.Forms.Cursor;

			/** Gets or sets the tool tip to show when the mouse is hovered over the control */
			ToolTip: string;

			/**
			 * Gets or sets the tab index order for this control within its container.
			 *
			 * This sets the order when using the tab key to cycle through controls  Note that some
			 * platforms (Gtk and WinForms) may not support setting the context of the tab order to
			 * StackLayout  or DynamicLayout containers and may not behave exactly as expected. Use
			 * the {@link Eto.PlatformFeatures.TabIndexWithCustomContainers} flag to determine if it
			 * is supported.
			 */
			TabIndex: number;

			/** Gets or sets a value indicating whether this control can serve as drop target. */
			AllowDrop: boolean;

			/**
			 * Gets or sets the parent widget which this widget has been added to, if any
			 *
			 * When implementing child widgets that can participate in the context based binding
			 * (MVVM), You can set this to the parent widget when it is added or removed to it
			 * (usually via a collection).  Note that you should typically provide a public new
			 * [ParentWidget] Parent { get; } property  so that consumers of your API cannot set the
			 * parent to an invalid value.
			 */
			Parent: Eto.Widget;

			/**
			 * Gets an enumeration of all parent widgets in the heirarchy by traversing the
			 * {@link Eto.Forms.BindableWidget.Parent} property.
			 */
			readonly Parents: Iterable<Eto.Widget>;

			/**
			 * Gets or sets the data context for this widget for binding
			 *
			 * Subclasses may override the standard behaviour so that hierarchy of widgets can be
			 * taken into account.  For example, a Control may return the data context of a parent,
			 * if it is not set explicitly.
			 */
			DataContext: unknown;

			/** Gets the collection of bindings that are attached to this widget */
			readonly Bindings: Eto.Forms.BindingCollection;

			/**
			 * Gets a value indicating that the {@link Eto.Forms.BindableWidget.DataContext} property
			 * is changing.
			 *
			 * This can be used to determine when to allow certain logic during the update of the
			 * data context.  It is used to disable binding setters on the model when the data
			 * context changes so that a binding does not cause the view model to be updated when the
			 * state hasn't been fully set yet.
			 */
			IsDataContextChanging: boolean;

			/**
			 * Gets the platform that was used to create the {@link Eto.Widget.Handler} for this
			 * widget
			 *
			 * This gets set to the current {@link Eto.Platform.Instance} during the construction of
			 * the object
			 */
			readonly Platform: Eto.Platform;

			/** Gets the platform-specific handler for this widget */
			Handler: unknown;

			/** Gets the native platform-specific handle for integration purposes */
			readonly NativeHandle: unknown;

			/** Gets the dictionary of properties for this widget */
			readonly Properties: Eto.PropertyStore;

			/** Gets or sets the ID of this widget */
			ID: string;

			/**
			 * Gets or sets the style of this widget
			 *
			 * Styles allow you to attach custom platform-specific logic to a widget. In your
			 * platform-specific assembly, use {@link Style.Add{H}(string, StyleHandler{H})} to add
			 * the style logic with the same id.
			 */
			Style: string;

			/**
			 * Gets the instance of the platform-specific object
			 *
			 * This can sometimes be useful to get the platform-specific object. Some handlers may
			 * not have any backing object for its functionality, so this may be null.  It is more
			 * preferred to use the {@link Eto.Widget.Handler} and cast that to the platform-specific
			 * handler class which can give you additional methods and helpers to do common tasks.
			 * For example, the {@link Eto.Forms.Application} object's handler for OS X has a
			 * AddFullScreenMenuItem property to specify if you want full screen support in your app.
			 */
			readonly ControlObject: unknown;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Widget} has been disposed.
			 *
			 * When the widget is disposed, it can no longer be used.
			 */
			IsDisposed: boolean;

			/**
			 * Creates a table layout with an auto sized control.
			 *
			 * Since controls fill an entire cell, you can use this method to create a layout that
			 * will ensure that the specified `control` gets its preferred size instead of stretching
			 * to fill the container.  By default, extra space will be added to the right and bottom,
			 * unless `centered` is true , which will add equal space to the top/bottom, and
			 * left/right.
			 */
			static AutoSized(
				control: Eto.Forms.Control,
				padding?: Eto.Drawing.Padding,
				centered?: boolean,
			): Eto.Forms.TableLayout;

			/**
			 * Creates a horizontal table layout with the specified cells.
			 *
			 * Since table layouts are by default vertical by defining the rows and the cells for
			 * each row, it is verbose to create nested tables when you want a horizontal table.
			 * E.g. new TableLayout(new TableRow(...)) .  This method is used to easily create a
			 * single row table layout with a horizontal set of cells. E.g.
			 * TableLayout.Horizontal(...)
			 */
			static Horizontal(cells: Eto.Forms.TableCell[]): Eto.Forms.TableLayout;

			/**
			 * Creates a horizontal table layout with the specified cells scaled equally.
			 *
			 * Since table layouts are by default vertical by defining the rows and the cells for
			 * each row, it is verbose to create nested tables when you want a horizontal table.
			 * E.g. new TableLayout(new TableRow(...)) .  This method is used to easily create a
			 * single row table layout with a horizontal set of cells. E.g.
			 * TableLayout.HorizontalScaled(...) The difference between Horizontal and
			 * HorizontalScaled is that this method sets ScaleWidth on each cell.
			 */
			static HorizontalScaled(cells: Eto.Forms.TableCell[]): Eto.Forms.TableLayout;

			/**
			 * Creates a horizontal table layout with the specified cells.
			 *
			 * Since table layouts are by default vertical by defining the rows and the cells for
			 * each row, it is verbose to create nested tables when you want a horizontal table.
			 * E.g. new TableLayout(new TableRow(...)) .  This method is used to easily create a
			 * single row table layout with a horizontal set of cells. E.g.
			 * TableLayout.Horizontal(...)
			 */
			static Horizontal(
				spacing: number,
				cells: Eto.Forms.TableCell[],
			): Eto.Forms.TableLayout;

			/**
			 * Creates a horizontal table layout with the specified cells scaled equally.
			 *
			 * Since table layouts are by default vertical by defining the rows and the cells for
			 * each row, it is verbose to create nested tables when you want a horizontal table.
			 * E.g. new TableLayout(new TableRow(...)) .  This method is used to easily create a
			 * single row table layout with a horizontal set of cells. E.g.
			 * TableLayout.HorizontalScaled(...) The difference between Horizontal and
			 * HorizontalScaled is that this method sets ScaleWidth on each cell.
			 */
			static HorizontalScaled(
				spacing: number,
				cells: Eto.Forms.TableCell[],
			): Eto.Forms.TableLayout;

			/** Sets the scale for the specified column. */
			SetColumnScale(
				column: number,
				scale?: boolean,
			): void;

			/** Gets the scale for the specified column. */
			GetColumnScale(column: number): boolean;

			/** Sets the scale for the specified row. */
			SetRowScale(
				row: number,
				scale?: boolean,
			): void;

			/** Gets the scale for the specified row. */
			GetRowScale(row: number): boolean;

			/**
			 * Adds a control to the specified x &amp; y coordinates.
			 *
			 * If a control already exists in the location, it is replaced. Only one control can
			 * exist in a cell.
			 */
			Add(
				control: Eto.Forms.Control,
				x: number,
				y: number,
			): void;

			/**
			 * Adds a control to the specified x &amp; y coordinates.
			 *
			 * If a control already exists in the location, it is replaced. Only one control can
			 * exist in a cell. The `xscale` and `yscale` parameters are to easily set the scaling
			 * for the current row/column while adding the control.
			 */
			Add(
				control: Eto.Forms.Control,
				x: number,
				y: number,
				xscale: boolean,
				yscale: boolean,
			): void;

			/**
			 * Adds a control to the specified location.
			 *
			 * If a control already exists in the location, it is replaced. Only one control can
			 * exist in a cell.
			 */
			Add(
				control: Eto.Forms.Control,
				location: Eto.Drawing.Point,
			): void;

			/**
			 * Moves the specified control to the new x and y coordinates.
			 *
			 * If a control already exists in the new location, it will be replaced. Only one control
			 * can exist in a cell. The old location of the control will have an empty space.
			 */
			Move(
				control: Eto.Forms.Control,
				x: number,
				y: number,
			): void;

			/**
			 * Move the specified control to a new location.
			 *
			 * If a control already exists in the new location, it will be replaced. Only one control
			 * can exist in a cell. The old location of the control will have an empty space.
			 */
			Move(
				control: Eto.Forms.Control,
				location: Eto.Drawing.Point,
			): void;

			/** Remove the specified child control. */
			Remove(child: Eto.Forms.Control): void;

			/** Ends the initialization when loading from xaml or other code generated scenarios */
			EndInit(): void;

			/**
			 * Re-calculates the layout of the controls and re-positions them, if necessary
			 *
			 * All layouts should theoretically work without having to manually update them, but in
			 * certain cases this may be necessary to be called.
			 */
			Update(): void;

			/** Begins the initialization when loading from xaml or other code generated scenarios */
			BeginInit(): void;

			/** Remove the specified `controls` from this container */
			Remove(controls: Iterable<Eto.Forms.Control>): void;

			/** Removes all controls from this container */
			RemoveAll(): void;

			/**
			 * Finds a child control in this container or any of its child containers with the
			 * specified `id`
			 */
			FindChild<T>(id?: string): T;

			/**
			 * Finds a child control in this container or any of its child containers with the
			 * specified `type`
			 */
			FindChild(
				type: unknown,
				id?: string,
			): Eto.Forms.Control;

			/**
			 * Finds a child control in this container or any of its child containers with the
			 * specified `id`.
			 */
			FindChild(id: string): Eto.Forms.Control;

			/**
			 * Queues a repaint of the entire control on the screen and any of its children.
			 *
			 * This is only useful when the control is visible.
			 */
			Invalidate(): void;

			/**
			 * Queues a repaint of the entire control on the screen
			 *
			 * This is only useful when the control is visible.
			 */
			Invalidate(invalidateChildren: boolean): void;

			/**
			 * Queues a repaint of the specified `rect` of the control and any children.
			 *
			 * This is only useful when the control is visible.
			 */
			Invalidate(rect: Eto.Drawing.Rectangle): void;

			/**
			 * Queues a repaint of the specified `rect` of the control
			 *
			 * This is only useful when the control is visible.
			 */
			Invalidate(
				rect: Eto.Drawing.Rectangle,
				invalidateChildren: boolean,
			): void;

			/**
			 * Updates the layout of this control if necessary.
			 *
			 * This will ensure the control has had all of its layout applied so you can use its
			 * position and size right after this call. Most platforms (except WinForms) use a
			 * deferred layout system so that after adding your control to the form dynamically it
			 * won't get laid out until the next idle loop. This is useful when you need to know the
			 * dimensions of the control immediately. Note that this can be an expensive operation,
			 * so it is recommended to only call this method when necessary and after all of the
			 * controls have been added/updated.
			 */
			UpdateLayout(): void;

			/** Gets the preferred size of this control given infinite space available. */
			GetPreferredSize(): Eto.Drawing.SizeF;

			/** Gets the preferred size of this control given the specified `availableSize`. */
			GetPreferredSize(availableSize: Eto.Drawing.SizeF): Eto.Drawing.SizeF;

			/**
			 * Captures all mouse events to this control.
			 *
			 * This captures all mouse events until {@link Eto.Forms.Control.ReleaseMouseCapture} is
			 * called.  Note that not all platforms will allow a mouse capture unless the mouse is
			 * currently down.
			 */
			CaptureMouse(): boolean;

			/** Releases the mouse capture after a call to {@link Eto.Forms.Control.CaptureMouse}. */
			ReleaseMouseCapture(): void;

			/**
			 * Finds a control in the parent hierarchy with the specified type and
			 * {@link Eto.Widget.ID} if specified
			 */
			FindParent(
				type: unknown,
				id?: string,
			): Eto.Forms.Container;

			/** Finds a control in the parent hierarchy with the specified `id` */
			FindParent(id: string): Eto.Forms.Container;

			/**
			 * Detaches the control by removing it from its parent
			 *
			 * This is essentially a shortcut to myControl.Parent.Remove(myControl);
			 */
			Detach(): void;

			/**
			 * Attaches the control for direct use in a native application
			 *
			 * Use this to use a control directly in a native application.  Note that the native
			 * application must be running the same framework as the current platform.  E.g. a
			 * WinForms application can use an Eto.Forms control when using the Eto.WinForms
			 * platform.  This prepares the control by firing the {@link Eto.Forms.Control.PreLoad},
			 * {@link Eto.Forms.Control.Load}, etc. events.
			 */
			AttachNative(): void;

			/**
			 * Detaches the control when it is used in a native application, when you want to reuse
			 * the control.
			 *
			 * This should only be called after {@link Eto.Forms.Control.AttachNative} has been
			 * called, which is usually done by calling to ToNative(true) .
			 */
			DetachNative(): void;

			/**
			 * Attempts to set the keyboard input focus to this control, or the first child that
			 * accepts focus. For Windows, this will bring it to front and activate it.
			 */
			Focus(): void;

			/**
			 * Suspends the layout of child controls
			 *
			 * This can be used to optimize some platforms while adding, removing, or changing many
			 * child controls at once. It disables the calculation of control positioning until
			 * {@link Eto.Forms.Control.ResumeLayout} is called. Each call to SuspendLayout() must be
			 * balanced with a call to {@link Eto.Forms.Control.ResumeLayout}.
			 */
			SuspendLayout(): void;

			/**
			 * Resumes the layout after it has been suspended, and performs a layout
			 *
			 * This can be used to optimize some platforms while adding, removing, or changing many
			 * child controls at once. Each call to ResumeLayout() must be balanced with a call to
			 * {@link Eto.Forms.Control.SuspendLayout} before it.
			 */
			ResumeLayout(): void;

			/**
			 * Specifies a command to execute for a platform-specific command
			 *
			 * Some platforms have specific system-defined commands that can be associated with a
			 * control. For example, the Mac platform's cut/copy/paste functionality is defined by
			 * the system, and if you want to hook into it, you can use this to map it to your own
			 * defined logic. The valid values of the `systemCommand` parameter are defined by each
			 * platform, and a list can be retrieved using
			 * {@link Eto.Forms.Control.SupportedPlatformCommands}
			 */
			MapPlatformCommand(
				systemCommand: string,
				command: Eto.Forms.Command,
			): void;

			/** Converts a point from screen space to control space. */
			PointFromScreen(point: Eto.Drawing.PointF): Eto.Drawing.PointF;

			/** Converts a point from control space to screen space */
			PointToScreen(point: Eto.Drawing.PointF): Eto.Drawing.PointF;

			/** Converts a rectangle from screen space to control space. */
			RectangleToScreen(rect: Eto.Drawing.RectangleF): Eto.Drawing.RectangleF;

			/** Converts a rectangle from control space to screen space */
			RectangleFromScreen(rect: Eto.Drawing.RectangleF): Eto.Drawing.RectangleF;

			/**
			 * Starts drag operation using this control as drag source.
			 *
			 * This method can be blocking on some platforms (Wpf, WinForms), and non-blocking on
			 * others (Mac, Gtk). Use the {@link Eto.Forms.Control.DragEnd} event to determine when
			 * the drag operation is completed and get its resulting DragEffects.
			 */
			DoDragDrop(
				data: Eto.Forms.DataObject,
				allowedEffects: Eto.Forms.DragEffects,
			): void;

			/**
			 * Starts drag operation using this control as drag source.
			 *
			 * This method can be blocking on some platforms (Wpf, WinForms), and non-blocking on
			 * others (Mac, Gtk). Use the {@link Eto.Forms.Control.DragEnd} event to determine when
			 * the drag operation is completed and get its resulting DragEffects.
			 */
			DoDragDrop(
				data: Eto.Forms.DataObject,
				allowedEffects: Eto.Forms.DragEffects,
				image: Eto.Drawing.Image,
				cursorOffset: Eto.Drawing.PointF,
			): void;

			/**
			 * Triggers the StyleChanged event and re-applies the styles to this control and its
			 * children.
			 */
			TriggerStyleChanged(): void;

			/** Shows a print dialog to print the specified control */
			Print(): void;

			/**
			 * Finds a control in the parent hierarchy with the specified type and
			 * {@link Eto.Widget.ID} if specified
			 */
			FindParent<T>(id?: string): T;

			/**
			 * Finds a control in the parent hierarchy with the specified type and
			 * {@link Eto.Widget.ID} if specified
			 */
			FindParent(
				type: unknown,
				id?: string,
			): Eto.Widget;

			/** Finds a control in the parent hierarchy with the specified `id` */
			FindParent(id: string): Eto.Widget;

			/**
			 * Unbinds any bindings in the {@link Eto.Forms.BindableWidget.Bindings} collection and
			 * removes the bindings
			 *
			 * When you implement {@link Eto.Forms.IBindableWidgetContainer}, this will also unbind
			 * any of its children.
			 */
			Unbind(): void;

			/**
			 * Updates all bindings in this widget
			 *
			 * When you implement {@link Eto.Forms.IBindableWidgetContainer}, this will also update
			 * bindings for all of its children.
			 */
			UpdateBindings(mode?: Eto.Forms.BindingUpdateMode): void;

			/** Disposes of this widget, supressing the finalizer */
			dispose(): void;

			/** Gets a string that represents the current object with its ID if specified. */
			ToString(): string;
		}
	}

	export namespace Eto.Forms.TableLayout {
		export interface IHandler extends
			Eto.Forms.Layout.IHandler,
			Eto.Forms.Container.IHandler,
			Eto.Forms.Control.IHandler,
			Eto.Widget.IHandler,
			Eto.Forms.Layout.IPositionalLayoutHandler {
			Spacing: Eto.Drawing.Size;

			Padding: Eto.Drawing.Padding;

			CreateControl(
				columns: number,
				rows: number,
			): void;

			GetColumnScale(column: number): boolean;

			SetColumnScale(
				column: number,
				scale: boolean,
			): void;

			GetRowScale(row: number): boolean;

			SetRowScale(
				row: number,
				scale: boolean,
			): void;
		}
	}

	export namespace Eto.Forms {
		/** Represents the contents of a row in a {@link Eto.Forms.TableLayout} */
		export class TableRow {
			/** Initializes a new instance of the {@link Eto.Forms.TableRow} class. */
			constructor();

			/**
			 * Initializes a new instance of the {@link Eto.Forms.TableRow} class with the specified
			 * cells.
			 */
			constructor(cells: Eto.Forms.TableCell[]);

			/**
			 * Initializes a new instance of the {@link Eto.Forms.TableRow} class with the specified
			 * cells.
			 */
			constructor(cells: Iterable<Eto.Forms.TableCell>);

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Forms.TableCell} will scale
			 * its height
			 *
			 * All controls in the same row of this cell will get the same scaling value. Scaling
			 * will make the row expand to fit the rest of the height of the container, minus the
			 * preferred height of any non-scaled rows.  If there are no rows with height scaling,
			 * the last row will automatically get scaled.  With scaling turned off, cells in the row
			 * will fit the preferred size of the tallest control.
			 */
			ScaleHeight: boolean;

			/** Gets or sets the cells in this row. */
			Cells: unknown;

			/**
			 * Creates a scaled table row with the specified `cells`
			 *
			 * This is the same as creating a new TableRow and setting ScaleHeight = true.
			 */
			static Scaled(cells: Eto.Forms.TableCell[]): Eto.Forms.TableRow;

			/**
			 * Creates a scaled table row with the specified `cells`
			 *
			 * This is the same as creating a new TableRow and setting ScaleHeight = true.
			 */
			static Scaled(cells: Iterable<Eto.Forms.TableCell>): Eto.Forms.TableRow;
		}
	}

	export namespace Eto.Forms {
		/**
		 * Interface for an item in a list control.
		 *
		 * If you have a list of your own objects, it is more efficient to use them directly with
		 * the list control by  passing a collection to the DataStore property, and using
		 * TextBinding/KeyBinding to specify how to get/set the Text and Key properties.
		 * Otherwise, use {@link Eto.Forms.ListItem} to define items.  This may be deprecated in
		 * the future.
		 */
		export interface IListItem {
			/** Gets or sets the text of the item. */
			Text: string;

			/**
			 * Gets or sets the unique key of the item.
			 *
			 * The key is typically used to identify each item uniquely.  If no key is specified, the
			 * {@link Eto.Forms.IListItem.Text} is used as the key.
			 */
			readonly Key: string;
		}
	}

	export namespace Eto.Forms {
		/**
		 * Represents an item for list controls.
		 *
		 * If you have a list of your own objects, it is more efficient to use them directly with
		 * the list control by  passing a collection to the DataStore property, and use
		 * {@link Eto.Forms.ListControl.ItemTextBinding} and
		 * {@link Eto.Forms.ListControl.ItemKeyBinding} instead.
		 */
		export class ListItem implements Eto.Forms.IListItem {
			constructor();

			/** Gets or sets the text of the item. */
			Text: string;

			/**
			 * Gets or sets the unique key of the item.
			 *
			 * The key is typically used to identify each item uniquely.  If no key is specified, the
			 * {@link Eto.Forms.ListItem.Text} is used as the key.
			 */
			Key: string;

			/** Gets or sets custom data for the item. */
			Tag: unknown;

			/** Gets the listItem's string */
			ToString(): string;
		}
	}

	export namespace Eto.Forms {
		/**
		 * List item for list controls that accept an image (e.g. {@link Eto.Forms.ListBox} )
		 *
		 * If you have a list of your own objects, it is more efficient to use them directly with
		 * the list control by  passing a collection to the DataStore property, and use
		 * {@link Eto.Forms.ListControl.ItemTextBinding},
		 * {@link Eto.Forms.ListControl.ItemKeyBinding}, and
		 * {@link Eto.Forms.ListBox.ItemImageBinding}.
		 */
		export class ImageListItem implements
			Eto.Forms.IListItem,
			Eto.Forms.IImageListItem {
			constructor();

			/** Gets or sets the image for this item. */
			Image: Eto.Drawing.Image;

			/** Gets or sets the text of the item. */
			Text: string;

			/**
			 * Gets or sets the unique key of the item.
			 *
			 * The key is typically used to identify each item uniquely.  If no key is specified, the
			 * {@link Eto.Forms.ListItem.Text} is used as the key.
			 */
			Key: string;

			/** Gets or sets custom data for the item. */
			Tag: unknown;

			/** Gets the listItem's string */
			ToString(): string;
		}
	}

	export namespace Eto.Forms {
		/** Event arguments for localization */
		export class LocalizeEventArgs {
			constructor();

			/** Gets the text to localize */
			Text: string;

			/** Gets or sets the localized text. */
			LocalizedText: string;

			/** Gets the source widget for the localized text */
			Source: unknown;
		}
	}

	export namespace Eto.Forms {
		/**
		 * [Generic type factory] Implements a fixed masked text provider that converts to the
		 * specified type of  , using the standard System.ComponentModel.MaskedTextProvider.
		 */
		export function FixedMaskedTextProvider$(T: IType): typeof FixedMaskedTextProvider$1<any>;

		/**
		 * Implements a fixed masked text provider that converts to the specified type of  ,
		 * using the standard System.ComponentModel.MaskedTextProvider.
		 */
		export class FixedMaskedTextProvider$1<T> implements
			Eto.Forms.IMaskedTextProvider,
			Eto.Forms.IMaskedTextProvider$1<T> {
			/**
			 * Initializes a new instance of the {@link Eto.Forms.FixedMaskedTextProvider<>} class.
			 */
			new(
				mask: string,
				culture?: unknown,
				allowPromptAsInput?: boolean,
				restrictToAscii?: boolean,
			): FixedMaskedTextProvider$1<T>;

			/** Gets or sets a delegate to convert the mask string to a value of type  */
			ConvertToValue: (arg1: string) => T;

			/** Gets or sets a delegate to convert the a value of type  to the mask string. */
			ConvertToText: (arg1: T) => string;

			/** Gets or sets the translated value of the mask. */
			Value: T;

			/** Gets the culture for the mask, as specified in the constructor. */
			readonly Culture: unknown;

			/**
			 * Gets the mask for this provider, as specified in the constructor.
			 *
			 * The mask format can consist of the following characters:  0 - Required digit from 0-9.
			 * 9 - Optional digit or space. # - Optional digit, space, or sign (+/-).  If blank, then
			 * it is output as a space in the Text value. L - Required upper or lowercase letter. ? -
			 * Optional upper or lowercase letter. &amp; - Required character. If
			 * {@link Eto.Forms.FixedMaskedTextProvider.AsciiOnly} is true, then behaves like L. C -
			 * Optional character. If {@link Eto.Forms.FixedMaskedTextProvider.AsciiOnly} is true,
			 * then behaves like ?. A - Required alphanumeric character. If
			 * {@link Eto.Forms.FixedMaskedTextProvider.AsciiOnly} is true, then behaves like L. a -
			 * Optional alphanumeric. If {@link Eto.Forms.FixedMaskedTextProvider.AsciiOnly} is true,
			 * then behaves like ?. . - Decimal placeholder based on the specified
			 * {@link Eto.Forms.FixedMaskedTextProvider.Culture} for the mask. , - Thousands
			 * placeholder based on the specified {@link Eto.Forms.FixedMaskedTextProvider.Culture}
			 * for the mask. : - Time separator based on the specified
			 * {@link Eto.Forms.FixedMaskedTextProvider.Culture} for the mask. / - Date separator
			 * based on the specified {@link Eto.Forms.FixedMaskedTextProvider.Culture} for the mask.
			 * $ - Currency symbol based on the specified
			 * {@link Eto.Forms.FixedMaskedTextProvider.Culture} for the mask. &lt; - Shift all
			 * characters that follow to lower case. &gt; - Shift all characters that follow to upper
			 * case. | - Disables a previous shift to upper or lower case. \ - Escape the following
			 * character into a literal. All other characters are treated as literal and cannot be
			 * moved or deleted.
			 */
			readonly Mask: string;

			/**
			 * Gets a value indicating whether the
			 * {@link Eto.Forms.FixedMaskedTextProvider.PromptChar} can be a valid input character by
			 * the user.
			 */
			readonly AllowPromptAsInput: boolean;

			/** Gets or sets the character to show for each unfilled edit position in the mask. */
			PromptChar: unknown;

			/**
			 * In password mode, gets or sets the character to show for filled edit characters in the
			 * mask.
			 */
			PasswordChar: unknown;

			/**
			 * Gets a value indicating whether the input only accepts ascii characters A-Z or a-z.
			 */
			readonly AsciiOnly: boolean;

			/** Gets the display text, including prompt characters. */
			readonly DisplayText: string;

			/**
			 * Gets or sets the text, usually excluding prompt or literal characters depending on the
			 * mask provider.
			 */
			Text: string;

			/**
			 * Gets a value indicating whether the mask has all required text to pass its validation.
			 */
			readonly MaskCompleted: boolean;

			/** Gets or sets a value indicating whether the mask should be password protected. */
			IsPassword: boolean;

			/**
			 * Gets or sets a value indicating that the
			 * {@link Eto.Forms.FixedMaskedTextProvider.Text} property includes literals in the mask.
			 */
			IncludeLiterals: boolean;

			/**
			 * Gets or sets a value indicating that the
			 * {@link Eto.Forms.FixedMaskedTextProvider.Text} property includes prompt characters for
			 * each edit position in the mask.
			 */
			IncludePrompt: boolean;

			/**
			 * Gets or sets a value indicating that the user can type literals to skip them in the
			 * mask.
			 */
			SkipLiterals: boolean;

			/**
			 * Gets or sets a value indicating that the cursor position will advance past literals to
			 * the next available  edit position automatically.
			 */
			AutoAdvance: boolean;

			/** Gets an enumeration of all valid edit positions in the mask. */
			readonly EditPositions: Iterable<number>;

			/** Gets a value indicating the mask is empty with no characters filled out. */
			readonly IsEmpty: boolean;

			/**
			 * Gets a value indicating that all available edit positions in the mask have been filled
			 * out.
			 */
			readonly MaskFull: boolean;

			Insert(
				character: unknown,
				position: number,
			): boolean;

			Replace(
				character: unknown,
				position: number,
			): boolean;

			Delete(
				position: number,
				length: number,
				forward: boolean,
			): boolean;

			Clear(
				position: number,
				length: number,
				forward: boolean,
			): boolean;
		}
	}

	export namespace Eto.Forms {
		/**
		 * Implements a fixed masked text provider, using the standard
		 * System.ComponentModel.MaskedTextProvider.
		 *
		 * This wraps the standard provider in an interface used by the
		 * {@link Eto.Forms.MaskedTextBox} so that we can provide different implementations of
		 * masked text providers.  The implementation of this is defined in each platform
		 * assembly so that we can use this from a PCL assembly.
		 */
		export class FixedMaskedTextProvider implements Eto.Forms.IMaskedTextProvider {
			/** Initializes a new instance of the {@link Eto.Forms.FixedMaskedTextProvider} class. */
			constructor(
				mask: string,
				culture?: unknown,
				allowPromptAsInput?: boolean,
				restrictToAscii?: boolean,
			);

			/** Gets the culture for the mask, as specified in the constructor. */
			readonly Culture: unknown;

			/**
			 * Gets the mask for this provider, as specified in the constructor.
			 *
			 * The mask format can consist of the following characters:  0 - Required digit from 0-9.
			 * 9 - Optional digit or space. # - Optional digit, space, or sign (+/-).  If blank, then
			 * it is output as a space in the Text value. L - Required upper or lowercase letter. ? -
			 * Optional upper or lowercase letter. &amp; - Required character. If
			 * {@link Eto.Forms.FixedMaskedTextProvider.AsciiOnly} is true, then behaves like L. C -
			 * Optional character. If {@link Eto.Forms.FixedMaskedTextProvider.AsciiOnly} is true,
			 * then behaves like ?. A - Required alphanumeric character. If
			 * {@link Eto.Forms.FixedMaskedTextProvider.AsciiOnly} is true, then behaves like L. a -
			 * Optional alphanumeric. If {@link Eto.Forms.FixedMaskedTextProvider.AsciiOnly} is true,
			 * then behaves like ?. . - Decimal placeholder based on the specified
			 * {@link Eto.Forms.FixedMaskedTextProvider.Culture} for the mask. , - Thousands
			 * placeholder based on the specified {@link Eto.Forms.FixedMaskedTextProvider.Culture}
			 * for the mask. : - Time separator based on the specified
			 * {@link Eto.Forms.FixedMaskedTextProvider.Culture} for the mask. / - Date separator
			 * based on the specified {@link Eto.Forms.FixedMaskedTextProvider.Culture} for the mask.
			 * $ - Currency symbol based on the specified
			 * {@link Eto.Forms.FixedMaskedTextProvider.Culture} for the mask. &lt; - Shift all
			 * characters that follow to lower case. &gt; - Shift all characters that follow to upper
			 * case. | - Disables a previous shift to upper or lower case. \ - Escape the following
			 * character into a literal. All other characters are treated as literal and cannot be
			 * moved or deleted.
			 */
			readonly Mask: string;

			/**
			 * Gets a value indicating whether the
			 * {@link Eto.Forms.FixedMaskedTextProvider.PromptChar} can be a valid input character by
			 * the user.
			 */
			readonly AllowPromptAsInput: boolean;

			/** Gets or sets the character to show for each unfilled edit position in the mask. */
			PromptChar: unknown;

			/**
			 * In password mode, gets or sets the character to show for filled edit characters in the
			 * mask.
			 */
			PasswordChar: unknown;

			/**
			 * Gets a value indicating whether the input only accepts ascii characters A-Z or a-z.
			 */
			readonly AsciiOnly: boolean;

			/** Gets the display text, including prompt characters. */
			readonly DisplayText: string;

			/**
			 * Gets or sets the text, usually excluding prompt or literal characters depending on the
			 * mask provider.
			 */
			Text: string;

			/**
			 * Gets a value indicating whether the mask has all required text to pass its validation.
			 */
			readonly MaskCompleted: boolean;

			/** Gets or sets a value indicating whether the mask should be password protected. */
			IsPassword: boolean;

			/**
			 * Gets or sets a value indicating that the
			 * {@link Eto.Forms.FixedMaskedTextProvider.Text} property includes literals in the mask.
			 */
			IncludeLiterals: boolean;

			/**
			 * Gets or sets a value indicating that the
			 * {@link Eto.Forms.FixedMaskedTextProvider.Text} property includes prompt characters for
			 * each edit position in the mask.
			 */
			IncludePrompt: boolean;

			/**
			 * Gets or sets a value indicating that the user can type literals to skip them in the
			 * mask.
			 */
			SkipLiterals: boolean;

			/**
			 * Gets or sets a value indicating that the cursor position will advance past literals to
			 * the next available  edit position automatically.
			 */
			AutoAdvance: boolean;

			/** Gets an enumeration of all valid edit positions in the mask. */
			readonly EditPositions: Iterable<number>;

			/** Gets a value indicating the mask is empty with no characters filled out. */
			readonly IsEmpty: boolean;

			/**
			 * Gets a value indicating that all available edit positions in the mask have been filled
			 * out.
			 */
			readonly MaskFull: boolean;

			Insert(
				character: unknown,
				position: number,
			): boolean;

			Replace(
				character: unknown,
				position: number,
			): boolean;

			Delete(
				position: number,
				length: number,
				forward: boolean,
			): boolean;

			Clear(
				position: number,
				length: number,
				forward: boolean,
			): boolean;
		}
	}

	export namespace Eto.Forms.FixedMaskedTextProvider {
		export interface IHandler extends Eto.Forms.IMaskedTextProvider {
			readonly Culture: unknown;

			readonly Mask: string;

			readonly AllowPromptAsInput: boolean;

			readonly AsciiOnly: boolean;

			IsPassword: boolean;

			PromptChar: unknown;

			PasswordChar: unknown;

			IncludeLiterals: boolean;

			IncludePrompt: boolean;

			SkipLiterals: boolean;

			AutoAdvance: boolean;

			readonly MaskFull: boolean;

			Create(
				mask: string,
				culture: unknown,
				allowPromptAsInput: boolean,
				restrictToAscii: boolean,
			): void;
		}
	}

	export namespace Eto.Forms {
		/**
		 * Interface for a masked text provider that can be used with
		 * {@link Eto.Forms.MaskedTextBox}.
		 *
		 * This defines the interface that the {@link Eto.Forms.MaskedTextBox} uses when
		 * inserting, deleting, and clearing characters from a masked string.  This can be
		 * implemented by both variable and fixed masks (unlike the standard
		 * System.ComponentModel.MaskedTextProvider),  and provides a way to create your own
		 * completely custom masks. You can also use the
		 * {@link Eto.Forms.VariableMaskedTextProvider} as a base for custom masks to implement
		 * the default functionality.
		 */
		export interface IMaskedTextProvider {
			/** Gets the display text, including prompt characters. */
			readonly DisplayText: string;

			/**
			 * Gets or sets the text, usually excluding prompt or literal characters depending on the
			 * mask provider.
			 */
			Text: string;

			/**
			 * Gets a value indicating whether the mask has all required text to pass its validation.
			 */
			readonly MaskCompleted: boolean;

			/** Gets an enumeration of all valid edit positions in the mask. */
			readonly EditPositions: Iterable<number>;

			/** Gets a value indicating the mask is empty with no characters filled out. */
			readonly IsEmpty: boolean;

			Insert(
				character: unknown,
				position: number,
			): boolean;

			Replace(
				character: unknown,
				position: number,
			): boolean;

			Delete(
				position: number,
				length: number,
				forward: boolean,
			): boolean;

			Clear(
				position: number,
				length: number,
				forward: boolean,
			): boolean;
		}
	}

	export namespace Eto.Forms {
		/**
		 * [Generic type factory] Interface for a masked text provider that can be translated to
		 * a specific value.
		 */
		export function IMaskedTextProvider$(T: IType): IType;

		/** Interface for a masked text provider that can be translated to a specific value. */
		export interface IMaskedTextProvider$1<T> extends Eto.Forms.IMaskedTextProvider {
			/** Gets or sets the translated value of the mask. */
			Value: T;
		}
	}

	export namespace Eto.Forms {
		/**
		 * [Generic type factory] Masked text provider for numeric input of the specified type.
		 */
		export function NumericMaskedTextProvider$(T: IType): typeof NumericMaskedTextProvider$1<any>;

		/** Masked text provider for numeric input of the specified type. */
		export class NumericMaskedTextProvider$1<T> implements
			Eto.Forms.IMaskedTextProvider,
			Eto.Forms.IMaskedTextProvider$1<T> {
			/**
			 * Initializes a new instance of the {@link Eto.Forms.NumericMaskedTextProvider<>} class.
			 */
			new(): NumericMaskedTextProvider$1<T>;

			/** Gets or sets the translated value of the mask. */
			Value: T;

			/**
			 * Gets or sets a value indicating that the mask can optionally include a decimal, as
			 * specified by the {@link Eto.Forms.NumericMaskedTextProvider.DecimalCharacter}.
			 */
			AllowDecimal: boolean;

			/**
			 * Gets or sets a value indicating that the mask can optionally include the sign, as
			 * specified by {@link Eto.Forms.NumericMaskedTextProvider.SignCharacters}.
			 */
			AllowSign: boolean;

			/**
			 * Gets or sets the sign characters when
			 * {@link Eto.Forms.NumericMaskedTextProvider.AllowSign} is true . Default is '+' and
			 * '-'.
			 */
			SignCharacters: unknown[];

			/** Gets or sets a delegate used to validate the mask. */
			Validate: (arg1: string) => boolean;

			/**
			 * Gets or sets the decimal character when
			 * {@link Eto.Forms.NumericMaskedTextProvider.AllowDecimal} is true . Default is '.'.
			 */
			DecimalCharacter: unknown;

			/**
			 * Gets or sets the alternate decimal character that can be accepted.
			 *
			 * This is useful when the DecimalCharacter is localized but you still want to allow
			 * alternate characters
			 */
			AltDecimalCharacters: unknown[];

			/**
			 * Gets or sets the culture of the
			 * {@link Eto.Forms.NumericMaskedTextProvider.DecimalCharacter} and
			 * {@link Eto.Forms.NumericMaskedTextProvider.SignCharacters} formatting characters.
			 */
			Culture: unknown;

			/**
			 * Gets a value indicating whether the mask has all required text to pass its validation.
			 */
			readonly MaskCompleted: boolean;

			/** Gets the display text, including prompt characters. */
			readonly DisplayText: string;

			/**
			 * Gets or sets the text, usually excluding prompt or literal characters depending on the
			 * mask provider.
			 */
			Text: string;

			/** Gets an enumeration of all valid edit positions in the mask. */
			readonly EditPositions: Iterable<number>;

			/** Gets a value indicating the mask is empty with no characters filled out. */
			readonly IsEmpty: boolean;

			Replace(
				character: unknown,
				position: number,
			): boolean;

			Insert(
				character: unknown,
				position: number,
			): boolean;

			Delete(
				position: number,
				length: number,
				forward: boolean,
			): boolean;

			Clear(
				position: number,
				length: number,
				forward: boolean,
			): boolean;
		}
	}

	export namespace Eto.Forms {
		/** Masked text provider for numeric input. */
		export class NumericMaskedTextProvider implements Eto.Forms.IMaskedTextProvider {
			/**
			 * Initializes a new instance of the {@link Eto.Forms.NumericMaskedTextProvider} class.
			 */
			constructor();

			/**
			 * Gets or sets a value indicating that the mask can optionally include a decimal, as
			 * specified by the {@link Eto.Forms.NumericMaskedTextProvider.DecimalCharacter}.
			 */
			AllowDecimal: boolean;

			/**
			 * Gets or sets a value indicating that the mask can optionally include the sign, as
			 * specified by {@link Eto.Forms.NumericMaskedTextProvider.SignCharacters}.
			 */
			AllowSign: boolean;

			/**
			 * Gets or sets the sign characters when
			 * {@link Eto.Forms.NumericMaskedTextProvider.AllowSign} is true . Default is '+' and
			 * '-'.
			 */
			SignCharacters: unknown[];

			/** Gets or sets a delegate used to validate the mask. */
			Validate: (arg1: string) => boolean;

			/**
			 * Gets or sets the decimal character when
			 * {@link Eto.Forms.NumericMaskedTextProvider.AllowDecimal} is true . Default is '.'.
			 */
			DecimalCharacter: unknown;

			/**
			 * Gets or sets the alternate decimal character that can be accepted.
			 *
			 * This is useful when the DecimalCharacter is localized but you still want to allow
			 * alternate characters
			 */
			AltDecimalCharacters: unknown[];

			/**
			 * Gets or sets the culture of the
			 * {@link Eto.Forms.NumericMaskedTextProvider.DecimalCharacter} and
			 * {@link Eto.Forms.NumericMaskedTextProvider.SignCharacters} formatting characters.
			 */
			Culture: unknown;

			/**
			 * Gets a value indicating whether the mask has all required text to pass its validation.
			 */
			readonly MaskCompleted: boolean;

			/** Gets the display text, including prompt characters. */
			readonly DisplayText: string;

			/**
			 * Gets or sets the text, usually excluding prompt or literal characters depending on the
			 * mask provider.
			 */
			Text: string;

			/** Gets an enumeration of all valid edit positions in the mask. */
			readonly EditPositions: Iterable<number>;

			/** Gets a value indicating the mask is empty with no characters filled out. */
			readonly IsEmpty: boolean;

			Replace(
				character: unknown,
				position: number,
			): boolean;

			Insert(
				character: unknown,
				position: number,
			): boolean;

			Delete(
				position: number,
				length: number,
				forward: boolean,
			): boolean;

			Clear(
				position: number,
				length: number,
				forward: boolean,
			): boolean;
		}
	}

	export namespace Eto.Forms {
		/** Base masked text provider that can be used for variable length masks. */
		export class VariableMaskedTextProvider implements Eto.Forms.IMaskedTextProvider {
			/**
			 * Gets a value indicating whether the mask has all required text to pass its validation.
			 */
			readonly MaskCompleted: boolean;

			/** Gets the display text, including prompt characters. */
			readonly DisplayText: string;

			/**
			 * Gets or sets the text, usually excluding prompt or literal characters depending on the
			 * mask provider.
			 */
			Text: string;

			/** Gets an enumeration of all valid edit positions in the mask. */
			readonly EditPositions: Iterable<number>;

			/** Gets a value indicating the mask is empty with no characters filled out. */
			readonly IsEmpty: boolean;

			Insert(
				character: unknown,
				position: number,
			): boolean;

			Replace(
				character: unknown,
				position: number,
			): boolean;

			Delete(
				position: number,
				length: number,
				forward: boolean,
			): boolean;

			Clear(
				position: number,
				length: number,
				forward: boolean,
			): boolean;
		}
	}

	export namespace Eto.Forms {
		/** Menu item for a button / submenu */
		export class ButtonMenuItem implements
			Eto.IHandlerSource,
			Eto.Forms.IBindable,
			Eto.Forms.ICommandItem,
			Eto.Forms.ISubmenu {
			/** Initializes a new instance of the {@link Eto.Forms.ButtonMenuItem} class. */
			constructor();

			/**
			 * Initializes a new instance of the {@link Eto.Forms.ButtonMenuItem} class with the
			 * specified `click` handler.
			 *
			 * This is a convenience constructor to set up the click event.
			 */
			constructor(click: unknown);

			/**
			 * Initializes a new instance of the {@link Eto.Forms.ButtonMenuItem} class with the
			 * specified command.
			 */
			constructor(command: Eto.Forms.Command);

			/** Gets the collection of menu items. */
			readonly Items: Eto.Forms.MenuItemCollection;

			/**
			 * Gets a value indicating whether this sub menu should trim its child menu items when
			 * loaded onto a form
			 *
			 * Trimming will collapse any duplicate splitter items. This is done so that you can
			 * easily merge your menus.
			 */
			Trim: boolean;

			/**
			 * Gets or sets the image to show for the menu item.
			 *
			 * Some platforms (e.g. OS X) will not show an image by default, but can be enabled using
			 * the handler implementation via styles.
			 */
			Image: Eto.Drawing.Image;

			/**
			 * Gets or sets the order that the menu item should use when inserted into a submenu.
			 *
			 * The order can be used to sort your menu items when added in a different order.  This
			 * is useful when you have menu items added from different areas of your program.
			 */
			Order: number;

			/**
			 * Gets or sets the command to invoke when the menu item is pressed.
			 *
			 * This will invoke the specified command when the menu item is pressed. The
			 * {@link System.Windows.Input.ICommand.CanExecute(System.Object)} will also used to set
			 * the enabled/disabled state of the menu item.
			 */
			Command: unknown;

			/**
			 * Gets or sets the parameter to pass to the {@link Eto.Forms.MenuItem.Command} when
			 * executing or determining its CanExecute state.
			 */
			CommandParameter: unknown;

			/** Gets or sets the text of the menu item, with mnemonics identified with &amp;. */
			Text: string;

			/** Gets or sets a user-defined tag for the menu item. */
			Tag: unknown;

			/** Gets or sets the tool tip of the item. */
			ToolTip: string;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Forms.MenuItem} is enabled.
			 */
			Enabled: boolean;

			/** Gets or sets the shortcut key the user can press to activate the menu item. */
			Shortcut: Eto.Forms.Keys;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Forms.MenuItem} is visible.
			 */
			Visible: boolean;

			/**
			 * Gets or sets the parent widget which this widget has been added to, if any
			 *
			 * When implementing child widgets that can participate in the context based binding
			 * (MVVM), You can set this to the parent widget when it is added or removed to it
			 * (usually via a collection).  Note that you should typically provide a public new
			 * [ParentWidget] Parent { get; } property  so that consumers of your API cannot set the
			 * parent to an invalid value.
			 */
			Parent: Eto.Widget;

			/**
			 * Gets an enumeration of all parent widgets in the heirarchy by traversing the
			 * {@link Eto.Forms.BindableWidget.Parent} property.
			 */
			readonly Parents: Iterable<Eto.Widget>;

			/**
			 * Gets or sets the data context for this widget for binding
			 *
			 * Subclasses may override the standard behaviour so that hierarchy of widgets can be
			 * taken into account.  For example, a Control may return the data context of a parent,
			 * if it is not set explicitly.
			 */
			DataContext: unknown;

			/** Gets the collection of bindings that are attached to this widget */
			readonly Bindings: Eto.Forms.BindingCollection;

			/**
			 * Gets a value indicating that the {@link Eto.Forms.BindableWidget.DataContext} property
			 * is changing.
			 *
			 * This can be used to determine when to allow certain logic during the update of the
			 * data context.  It is used to disable binding setters on the model when the data
			 * context changes so that a binding does not cause the view model to be updated when the
			 * state hasn't been fully set yet.
			 */
			IsDataContextChanging: boolean;

			/**
			 * Gets the platform that was used to create the {@link Eto.Widget.Handler} for this
			 * widget
			 *
			 * This gets set to the current {@link Eto.Platform.Instance} during the construction of
			 * the object
			 */
			readonly Platform: Eto.Platform;

			/** Gets the platform-specific handler for this widget */
			Handler: unknown;

			/** Gets the native platform-specific handle for integration purposes */
			readonly NativeHandle: unknown;

			/** Gets the dictionary of properties for this widget */
			readonly Properties: Eto.PropertyStore;

			/** Gets or sets the ID of this widget */
			ID: string;

			/**
			 * Gets or sets the style of this widget
			 *
			 * Styles allow you to attach custom platform-specific logic to a widget. In your
			 * platform-specific assembly, use {@link Style.Add{H}(string, StyleHandler{H})} to add
			 * the style logic with the same id.
			 */
			Style: string;

			/**
			 * Gets the instance of the platform-specific object
			 *
			 * This can sometimes be useful to get the platform-specific object. Some handlers may
			 * not have any backing object for its functionality, so this may be null.  It is more
			 * preferred to use the {@link Eto.Widget.Handler} and cast that to the platform-specific
			 * handler class which can give you additional methods and helpers to do common tasks.
			 * For example, the {@link Eto.Forms.Application} object's handler for OS X has a
			 * AddFullScreenMenuItem property to specify if you want full screen support in your app.
			 */
			readonly ControlObject: unknown;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Widget} has been disposed.
			 *
			 * When the widget is disposed, it can no longer be used.
			 */
			IsDisposed: boolean;

			/**
			 * Performs the click handler for this item.
			 *
			 * This performs the click by calling
			 * {@link Eto.Forms.MenuItem.OnClick(System.EventArgs)} which triggers the
			 * {@link Eto.Forms.MenuItem.Click} event.
			 */
			PerformClick(): void;

			/**
			 * Executes the {@link Eto.Forms.MenuItem.OnValidate(System.EventArgs)} for this item.
			 *
			 * This allows you to manually validate the menu item to determine its enabled state.
			 */
			PerformValidate(): void;

			/**
			 * Finds a control in the parent hierarchy with the specified type and
			 * {@link Eto.Widget.ID} if specified
			 */
			FindParent<T>(id?: string): T;

			/**
			 * Finds a control in the parent hierarchy with the specified type and
			 * {@link Eto.Widget.ID} if specified
			 */
			FindParent(
				type: unknown,
				id?: string,
			): Eto.Widget;

			/** Finds a control in the parent hierarchy with the specified `id` */
			FindParent(id: string): Eto.Widget;

			/**
			 * Unbinds any bindings in the {@link Eto.Forms.BindableWidget.Bindings} collection and
			 * removes the bindings
			 *
			 * When you implement {@link Eto.Forms.IBindableWidgetContainer}, this will also unbind
			 * any of its children.
			 */
			Unbind(): void;

			/**
			 * Updates all bindings in this widget
			 *
			 * When you implement {@link Eto.Forms.IBindableWidgetContainer}, this will also update
			 * bindings for all of its children.
			 */
			UpdateBindings(mode?: Eto.Forms.BindingUpdateMode): void;

			/** Disposes of this widget, supressing the finalizer */
			dispose(): void;

			/** Gets a string that represents the current object with its ID if specified. */
			ToString(): string;
		}
	}

	export namespace Eto.Forms.ButtonMenuItem {
		export interface IHandler extends
			Eto.Forms.MenuItem.IHandler,
			Eto.Widget.IHandler,
			Eto.Forms.Menu.ISubmenuHandler {
			Image: Eto.Drawing.Image;
		}
	}

	export namespace Eto.Forms {
		/**
		 * Menu item that can be toggled on and off
		 *
		 * Most platforms show a check box next to the item when selected.  Some platforms may
		 * not show the item's image.
		 */
		export class CheckMenuItem implements
			Eto.IHandlerSource,
			Eto.Forms.IBindable,
			Eto.Forms.ICommandItem {
			/** Initializes a new instance of the {@link Eto.Forms.CheckMenuItem} class. */
			constructor();

			/**
			 * Initializes a new instance of the {@link Eto.Forms.CheckMenuItem} class with the
			 * specified `checkedChanged` handler.
			 */
			constructor(checkedChanged: unknown);

			/**
			 * Initializes a new instance of the {@link Eto.Forms.CheckMenuItem} class with the
			 * specified command.
			 */
			constructor(command: Eto.Forms.CheckCommand);

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Forms.CheckMenuItem} is
			 * checked.
			 */
			Checked: boolean;

			/**
			 * Gets or sets the order that the menu item should use when inserted into a submenu.
			 *
			 * The order can be used to sort your menu items when added in a different order.  This
			 * is useful when you have menu items added from different areas of your program.
			 */
			Order: number;

			/**
			 * Gets or sets the command to invoke when the menu item is pressed.
			 *
			 * This will invoke the specified command when the menu item is pressed. The
			 * {@link System.Windows.Input.ICommand.CanExecute(System.Object)} will also used to set
			 * the enabled/disabled state of the menu item.
			 */
			Command: unknown;

			/**
			 * Gets or sets the parameter to pass to the {@link Eto.Forms.MenuItem.Command} when
			 * executing or determining its CanExecute state.
			 */
			CommandParameter: unknown;

			/** Gets or sets the text of the menu item, with mnemonics identified with &amp;. */
			Text: string;

			/** Gets or sets a user-defined tag for the menu item. */
			Tag: unknown;

			/** Gets or sets the tool tip of the item. */
			ToolTip: string;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Forms.MenuItem} is enabled.
			 */
			Enabled: boolean;

			/** Gets or sets the shortcut key the user can press to activate the menu item. */
			Shortcut: Eto.Forms.Keys;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Forms.MenuItem} is visible.
			 */
			Visible: boolean;

			/**
			 * Gets or sets the parent widget which this widget has been added to, if any
			 *
			 * When implementing child widgets that can participate in the context based binding
			 * (MVVM), You can set this to the parent widget when it is added or removed to it
			 * (usually via a collection).  Note that you should typically provide a public new
			 * [ParentWidget] Parent { get; } property  so that consumers of your API cannot set the
			 * parent to an invalid value.
			 */
			Parent: Eto.Widget;

			/**
			 * Gets an enumeration of all parent widgets in the heirarchy by traversing the
			 * {@link Eto.Forms.BindableWidget.Parent} property.
			 */
			readonly Parents: Iterable<Eto.Widget>;

			/**
			 * Gets or sets the data context for this widget for binding
			 *
			 * Subclasses may override the standard behaviour so that hierarchy of widgets can be
			 * taken into account.  For example, a Control may return the data context of a parent,
			 * if it is not set explicitly.
			 */
			DataContext: unknown;

			/** Gets the collection of bindings that are attached to this widget */
			readonly Bindings: Eto.Forms.BindingCollection;

			/**
			 * Gets a value indicating that the {@link Eto.Forms.BindableWidget.DataContext} property
			 * is changing.
			 *
			 * This can be used to determine when to allow certain logic during the update of the
			 * data context.  It is used to disable binding setters on the model when the data
			 * context changes so that a binding does not cause the view model to be updated when the
			 * state hasn't been fully set yet.
			 */
			IsDataContextChanging: boolean;

			/**
			 * Gets the platform that was used to create the {@link Eto.Widget.Handler} for this
			 * widget
			 *
			 * This gets set to the current {@link Eto.Platform.Instance} during the construction of
			 * the object
			 */
			readonly Platform: Eto.Platform;

			/** Gets the platform-specific handler for this widget */
			Handler: unknown;

			/** Gets the native platform-specific handle for integration purposes */
			readonly NativeHandle: unknown;

			/** Gets the dictionary of properties for this widget */
			readonly Properties: Eto.PropertyStore;

			/** Gets or sets the ID of this widget */
			ID: string;

			/**
			 * Gets or sets the style of this widget
			 *
			 * Styles allow you to attach custom platform-specific logic to a widget. In your
			 * platform-specific assembly, use {@link Style.Add{H}(string, StyleHandler{H})} to add
			 * the style logic with the same id.
			 */
			Style: string;

			/**
			 * Gets the instance of the platform-specific object
			 *
			 * This can sometimes be useful to get the platform-specific object. Some handlers may
			 * not have any backing object for its functionality, so this may be null.  It is more
			 * preferred to use the {@link Eto.Widget.Handler} and cast that to the platform-specific
			 * handler class which can give you additional methods and helpers to do common tasks.
			 * For example, the {@link Eto.Forms.Application} object's handler for OS X has a
			 * AddFullScreenMenuItem property to specify if you want full screen support in your app.
			 */
			readonly ControlObject: unknown;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Widget} has been disposed.
			 *
			 * When the widget is disposed, it can no longer be used.
			 */
			IsDisposed: boolean;

			/**
			 * Performs the click handler for this item which toggles the check state.
			 *
			 * This performs the click by calling
			 * {@link Eto.Forms.MenuItem.OnClick(System.EventArgs)} which triggers the
			 * {@link Eto.Forms.MenuItem.Click} event. The {@link Eto.Forms.CheckMenuItem.Checked}
			 * state will also be toggled.
			 */
			PerformClick(): void;

			/**
			 * Executes the {@link Eto.Forms.MenuItem.OnValidate(System.EventArgs)} for this item.
			 *
			 * This allows you to manually validate the menu item to determine its enabled state.
			 */
			PerformValidate(): void;

			/**
			 * Finds a control in the parent hierarchy with the specified type and
			 * {@link Eto.Widget.ID} if specified
			 */
			FindParent<T>(id?: string): T;

			/**
			 * Finds a control in the parent hierarchy with the specified type and
			 * {@link Eto.Widget.ID} if specified
			 */
			FindParent(
				type: unknown,
				id?: string,
			): Eto.Widget;

			/** Finds a control in the parent hierarchy with the specified `id` */
			FindParent(id: string): Eto.Widget;

			/**
			 * Unbinds any bindings in the {@link Eto.Forms.BindableWidget.Bindings} collection and
			 * removes the bindings
			 *
			 * When you implement {@link Eto.Forms.IBindableWidgetContainer}, this will also unbind
			 * any of its children.
			 */
			Unbind(): void;

			/**
			 * Updates all bindings in this widget
			 *
			 * When you implement {@link Eto.Forms.IBindableWidgetContainer}, this will also update
			 * bindings for all of its children.
			 */
			UpdateBindings(mode?: Eto.Forms.BindingUpdateMode): void;

			/** Disposes of this widget, supressing the finalizer */
			dispose(): void;

			/** Gets a string that represents the current object with its ID if specified. */
			ToString(): string;
		}
	}

	export namespace Eto.Forms.CheckMenuItem {
		export interface ICallback extends
			Eto.Forms.MenuItem.ICallback,
			Eto.Widget.ICallback {
			OnCheckedChanged(
				widget: Eto.Forms.CheckMenuItem,
				e: unknown,
			): void;
		}
	}

	export namespace Eto.Forms.CheckMenuItem {
		export interface IHandler extends
			Eto.Forms.MenuItem.IHandler,
			Eto.Widget.IHandler {
			Checked: boolean;
		}
	}

	export namespace Eto.Forms {
		/** Interface for widgets/handlers that implement a context menu */
		export interface IContextMenuHost {
			/**
			 * Gets or sets the context menu to show when the user right clicks or presses the menu
			 * key
			 */
			ContextMenu: Eto.Forms.ContextMenu;
		}
	}

	export namespace Eto.Forms {
		/**
		 * Represents a context menu that can be shown typically when users right click or press
		 * the menu key on a control
		 */
		export class ContextMenu implements
			Eto.IHandlerSource,
			Eto.Forms.IBindable,
			Eto.Forms.ISubmenu {
			/** Initializes a new instance of the {@link Eto.Forms.ContextMenu} class. */
			constructor();

			/** Initializes a new instance of the {@link Eto.Forms.ContextMenu} class. */
			constructor(items: Iterable<Eto.Forms.MenuItem>);

			/** Initializes a new instance of the {@link Eto.Forms.ContextMenu} class. */
			constructor(items: Eto.Forms.MenuItem[]);

			/** Gets the menu items in the context menu */
			readonly Items: Eto.Forms.MenuItemCollection;

			/**
			 * Gets a value indicating whether this sub menu should trim its child menu items when
			 * loaded onto a form
			 *
			 * Trimming will collapse any duplicate splitter items. This is done so that you can
			 * easily merge your menus.
			 */
			Trim: boolean;

			/**
			 * Gets or sets the parent widget which this widget has been added to, if any
			 *
			 * When implementing child widgets that can participate in the context based binding
			 * (MVVM), You can set this to the parent widget when it is added or removed to it
			 * (usually via a collection).  Note that you should typically provide a public new
			 * [ParentWidget] Parent { get; } property  so that consumers of your API cannot set the
			 * parent to an invalid value.
			 */
			Parent: Eto.Widget;

			/**
			 * Gets an enumeration of all parent widgets in the heirarchy by traversing the
			 * {@link Eto.Forms.BindableWidget.Parent} property.
			 */
			readonly Parents: Iterable<Eto.Widget>;

			/**
			 * Gets or sets the data context for this widget for binding
			 *
			 * Subclasses may override the standard behaviour so that hierarchy of widgets can be
			 * taken into account.  For example, a Control may return the data context of a parent,
			 * if it is not set explicitly.
			 */
			DataContext: unknown;

			/** Gets the collection of bindings that are attached to this widget */
			readonly Bindings: Eto.Forms.BindingCollection;

			/**
			 * Gets a value indicating that the {@link Eto.Forms.BindableWidget.DataContext} property
			 * is changing.
			 *
			 * This can be used to determine when to allow certain logic during the update of the
			 * data context.  It is used to disable binding setters on the model when the data
			 * context changes so that a binding does not cause the view model to be updated when the
			 * state hasn't been fully set yet.
			 */
			IsDataContextChanging: boolean;

			/**
			 * Gets the platform that was used to create the {@link Eto.Widget.Handler} for this
			 * widget
			 *
			 * This gets set to the current {@link Eto.Platform.Instance} during the construction of
			 * the object
			 */
			readonly Platform: Eto.Platform;

			/** Gets the platform-specific handler for this widget */
			Handler: unknown;

			/** Gets the native platform-specific handle for integration purposes */
			readonly NativeHandle: unknown;

			/** Gets the dictionary of properties for this widget */
			readonly Properties: Eto.PropertyStore;

			/** Gets or sets the ID of this widget */
			ID: string;

			/**
			 * Gets or sets the style of this widget
			 *
			 * Styles allow you to attach custom platform-specific logic to a widget. In your
			 * platform-specific assembly, use {@link Style.Add{H}(string, StyleHandler{H})} to add
			 * the style logic with the same id.
			 */
			Style: string;

			/**
			 * Gets the instance of the platform-specific object
			 *
			 * This can sometimes be useful to get the platform-specific object. Some handlers may
			 * not have any backing object for its functionality, so this may be null.  It is more
			 * preferred to use the {@link Eto.Widget.Handler} and cast that to the platform-specific
			 * handler class which can give you additional methods and helpers to do common tasks.
			 * For example, the {@link Eto.Forms.Application} object's handler for OS X has a
			 * AddFullScreenMenuItem property to specify if you want full screen support in your app.
			 */
			readonly ControlObject: unknown;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Widget} has been disposed.
			 *
			 * When the widget is disposed, it can no longer be used.
			 */
			IsDisposed: boolean;

			/** Show the context menu at the current mouse position. */
			Show(): void;

			/**
			 * Show the context menu for the specified control, usually at the current mouse
			 * position.
			 */
			Show(relativeTo: Eto.Forms.Control): void;

			/**
			 * Shows the context menu at the specified screen co-ordinates
			 *
			 * Note that the operating system may move the location of the menu to make it fully
			 * visible.
			 */
			Show(location: Eto.Drawing.PointF): void;

			/**
			 * Shows the context menu at the specified location relative to a control.
			 *
			 * Note that the operating system may move the context menu to make it fully visible.
			 */
			Show(
				relativeTo: Eto.Forms.Control,
				location: Eto.Drawing.PointF | undefined,
			): void;

			/**
			 * Finds a control in the parent hierarchy with the specified type and
			 * {@link Eto.Widget.ID} if specified
			 */
			FindParent<T>(id?: string): T;

			/**
			 * Finds a control in the parent hierarchy with the specified type and
			 * {@link Eto.Widget.ID} if specified
			 */
			FindParent(
				type: unknown,
				id?: string,
			): Eto.Widget;

			/** Finds a control in the parent hierarchy with the specified `id` */
			FindParent(id: string): Eto.Widget;

			/**
			 * Unbinds any bindings in the {@link Eto.Forms.BindableWidget.Bindings} collection and
			 * removes the bindings
			 *
			 * When you implement {@link Eto.Forms.IBindableWidgetContainer}, this will also unbind
			 * any of its children.
			 */
			Unbind(): void;

			/**
			 * Updates all bindings in this widget
			 *
			 * When you implement {@link Eto.Forms.IBindableWidgetContainer}, this will also update
			 * bindings for all of its children.
			 */
			UpdateBindings(mode?: Eto.Forms.BindingUpdateMode): void;

			/** Disposes of this widget, supressing the finalizer */
			dispose(): void;

			/** Gets a string that represents the current object with its ID if specified. */
			ToString(): string;
		}
	}

	export namespace Eto.Forms.ContextMenu {
		export interface ICallback extends Eto.Widget.ICallback {
			OnOpening(
				widget: Eto.Forms.ContextMenu,
				e: unknown,
			): void;

			OnClosed(
				widget: Eto.Forms.ContextMenu,
				e: unknown,
			): void;

			OnClosing(
				widget: Eto.Forms.ContextMenu,
				e: unknown,
			): void;
		}
	}

	export namespace Eto.Forms.ContextMenu {
		export interface IHandler extends
			Eto.Widget.IHandler,
			Eto.Forms.Menu.ISubmenuHandler {
			Show(
				relativeTo: Eto.Forms.Control,
				location: Eto.Drawing.PointF | undefined,
			): void;
		}
	}

	export namespace Eto.Forms {
		/** Base class for menu items */
		export class Menu implements
			Eto.IHandlerSource,
			Eto.Forms.IBindable {
			/**
			 * Gets or sets the parent widget which this widget has been added to, if any
			 *
			 * When implementing child widgets that can participate in the context based binding
			 * (MVVM), You can set this to the parent widget when it is added or removed to it
			 * (usually via a collection).  Note that you should typically provide a public new
			 * [ParentWidget] Parent { get; } property  so that consumers of your API cannot set the
			 * parent to an invalid value.
			 */
			Parent: Eto.Widget;

			/**
			 * Gets an enumeration of all parent widgets in the heirarchy by traversing the
			 * {@link Eto.Forms.BindableWidget.Parent} property.
			 */
			readonly Parents: Iterable<Eto.Widget>;

			/**
			 * Gets or sets the data context for this widget for binding
			 *
			 * Subclasses may override the standard behaviour so that hierarchy of widgets can be
			 * taken into account.  For example, a Control may return the data context of a parent,
			 * if it is not set explicitly.
			 */
			DataContext: unknown;

			/** Gets the collection of bindings that are attached to this widget */
			readonly Bindings: Eto.Forms.BindingCollection;

			/**
			 * Gets a value indicating that the {@link Eto.Forms.BindableWidget.DataContext} property
			 * is changing.
			 *
			 * This can be used to determine when to allow certain logic during the update of the
			 * data context.  It is used to disable binding setters on the model when the data
			 * context changes so that a binding does not cause the view model to be updated when the
			 * state hasn't been fully set yet.
			 */
			IsDataContextChanging: boolean;

			/**
			 * Gets the platform that was used to create the {@link Eto.Widget.Handler} for this
			 * widget
			 *
			 * This gets set to the current {@link Eto.Platform.Instance} during the construction of
			 * the object
			 */
			readonly Platform: Eto.Platform;

			/** Gets the platform-specific handler for this widget */
			Handler: unknown;

			/** Gets the native platform-specific handle for integration purposes */
			readonly NativeHandle: unknown;

			/** Gets the dictionary of properties for this widget */
			readonly Properties: Eto.PropertyStore;

			/** Gets or sets the ID of this widget */
			ID: string;

			/**
			 * Gets or sets the style of this widget
			 *
			 * Styles allow you to attach custom platform-specific logic to a widget. In your
			 * platform-specific assembly, use {@link Style.Add{H}(string, StyleHandler{H})} to add
			 * the style logic with the same id.
			 */
			Style: string;

			/**
			 * Gets the instance of the platform-specific object
			 *
			 * This can sometimes be useful to get the platform-specific object. Some handlers may
			 * not have any backing object for its functionality, so this may be null.  It is more
			 * preferred to use the {@link Eto.Widget.Handler} and cast that to the platform-specific
			 * handler class which can give you additional methods and helpers to do common tasks.
			 * For example, the {@link Eto.Forms.Application} object's handler for OS X has a
			 * AddFullScreenMenuItem property to specify if you want full screen support in your app.
			 */
			readonly ControlObject: unknown;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Widget} has been disposed.
			 *
			 * When the widget is disposed, it can no longer be used.
			 */
			IsDisposed: boolean;

			/**
			 * Finds a control in the parent hierarchy with the specified type and
			 * {@link Eto.Widget.ID} if specified
			 */
			FindParent<T>(id?: string): T;

			/**
			 * Finds a control in the parent hierarchy with the specified type and
			 * {@link Eto.Widget.ID} if specified
			 */
			FindParent(
				type: unknown,
				id?: string,
			): Eto.Widget;

			/** Finds a control in the parent hierarchy with the specified `id` */
			FindParent(id: string): Eto.Widget;

			/**
			 * Unbinds any bindings in the {@link Eto.Forms.BindableWidget.Bindings} collection and
			 * removes the bindings
			 *
			 * When you implement {@link Eto.Forms.IBindableWidgetContainer}, this will also unbind
			 * any of its children.
			 */
			Unbind(): void;

			/**
			 * Updates all bindings in this widget
			 *
			 * When you implement {@link Eto.Forms.IBindableWidgetContainer}, this will also update
			 * bindings for all of its children.
			 */
			UpdateBindings(mode?: Eto.Forms.BindingUpdateMode): void;

			/** Disposes of this widget, supressing the finalizer */
			dispose(): void;

			/** Gets a string that represents the current object with its ID if specified. */
			ToString(): string;
		}
	}

	export namespace Eto.Forms.Menu {
		export interface ISubmenuHandler {
			AddMenu(
				index: number,
				item: Eto.Forms.MenuItem,
			): void;

			RemoveMenu(item: Eto.Forms.MenuItem): void;

			Clear(): void;
		}
	}

	export namespace Eto.Forms {
		/** Flags for the groups of system {@link Eto.Forms.MenuBar} items */
		export enum MenuBarSystemItems {
			/** Do not add any system items to the menu */
			None = 0,

			/** Add common menu items */
			Common = 1,

			/**
			 * Add a Quit menu item, if one is not specified by {@link Eto.Forms.MenuBar.QuitItem}
			 */
			Quit = 4,

			/** Add all system-defined menu bar items */
			All = 5,
		}
	}

	export namespace Eto.Forms {
		/** Menu bar for a form */
		export class MenuBar implements
			Eto.IHandlerSource,
			Eto.Forms.IBindable,
			Eto.Forms.ISubmenu {
			/** Initializes a new instance of the {@link Eto.Forms.MenuBar} class. */
			constructor();

			/**
			 * Initializes a new instance of the {@link Eto.Forms.MenuBar} class with the specified
			 * items.
			 */
			constructor(items: Iterable<Eto.Forms.MenuItem>);

			/**
			 * Initializes a new instance of the {@link Eto.Forms.MenuBar} class with the specified
			 * items.
			 */
			constructor(items: Eto.Forms.MenuItem[]);

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Forms.MenuBar} will trim the
			 * items when set to a form
			 *
			 * You may wish to turn this off if you are setting the menu regularily based on the
			 * context of your app, since it can effect performance.
			 */
			Trim: boolean;

			/**
			 * Gets or sets which system items will be automatically included with the menu.
			 *
			 * Some operating systems, such as OS X require you to create your own standard items to
			 * enable the ability to do things such as close a window, cut/paste, hide apps, quit an
			 * app, etc.  By default, the menu will be merged with your custom menu so that all of
			 * these system functions will work.  For Quit and About menu items, use the
			 * {@link Eto.Forms.MenuBar.QuitItem} and {@link Eto.Forms.MenuBar.AboutItem} instead so
			 * that they are placed in the correct/expected location on every platform.
			 */
			IncludeSystemItems: Eto.Forms.MenuBarSystemItems;

			/**
			 * Gets the system commands for the menu.
			 *
			 * These system commands are used for any of the items added when
			 * {@link Eto.Forms.MenuBar.IncludeSystemItems} is set to anything other than
			 * {@link Eto.Forms.MenuBarSystemItems.None}. You can modify this collection to remove
			 * items from the system menu, or update which items should be used instead. This is only
			 * needed for advanced scenarios and should not be required to be used in normal
			 * circumstances.
			 */
			readonly SystemCommands: unknown;

			/** Gets the collection of menu items */
			readonly Items: Eto.Forms.MenuItemCollection;

			/**
			 * Gets or sets the quit item for the application.
			 *
			 * This allows you to set the quit item for the application.  Some platforms (OS X) may
			 * add a quit item to the menu even if one is not defined as it is standard practice to
			 * allow users to quit the application with a menu item. This will be in the File menu
			 * for most platforms, and the Application menu for OS X.
			 */
			QuitItem: Eto.Forms.MenuItem;

			/**
			 * Gets or sets the item to show an about dialog for the application
			 *
			 * This allows you to set an item to show an about dialog for the application. OS X will
			 * place this in the Application menu, other platforms place this at the bottom of the
			 * Help menu.
			 */
			AboutItem: Eto.Forms.MenuItem;

			/**
			 * Gets the menu that contains application-level items.
			 *
			 * This allows you to change the application menu's text (File for most platforms,
			 * Application menu for OS X)
			 */
			readonly ApplicationMenu: Eto.Forms.ButtonMenuItem;

			/**
			 * Gets the item collection for the {@link Eto.Forms.MenuBar.ApplicationMenu}, to easily
			 * add items declaratively/programatically.
			 */
			readonly ApplicationItems: Eto.Forms.MenuItemCollection;

			/**
			 * Gets the help menu for the application for showing help items
			 *
			 * This allows you to change the help menu's text ('Help' by default on all platforms).
			 * This is usually used for the {@link Eto.Forms.MenuBar.AboutItem} on most platforms,
			 * other than OS X.
			 */
			readonly HelpMenu: Eto.Forms.ButtonMenuItem;

			/**
			 * Gets the item collection for the {@link Eto.Forms.MenuBar.HelpMenu}, to easily add
			 * items declaratively/programatically.
			 */
			readonly HelpItems: Eto.Forms.MenuItemCollection;

			/**
			 * Gets or sets the parent widget which this widget has been added to, if any
			 *
			 * When implementing child widgets that can participate in the context based binding
			 * (MVVM), You can set this to the parent widget when it is added or removed to it
			 * (usually via a collection).  Note that you should typically provide a public new
			 * [ParentWidget] Parent { get; } property  so that consumers of your API cannot set the
			 * parent to an invalid value.
			 */
			Parent: Eto.Widget;

			/**
			 * Gets an enumeration of all parent widgets in the heirarchy by traversing the
			 * {@link Eto.Forms.BindableWidget.Parent} property.
			 */
			readonly Parents: Iterable<Eto.Widget>;

			/**
			 * Gets or sets the data context for this widget for binding
			 *
			 * Subclasses may override the standard behaviour so that hierarchy of widgets can be
			 * taken into account.  For example, a Control may return the data context of a parent,
			 * if it is not set explicitly.
			 */
			DataContext: unknown;

			/** Gets the collection of bindings that are attached to this widget */
			readonly Bindings: Eto.Forms.BindingCollection;

			/**
			 * Gets a value indicating that the {@link Eto.Forms.BindableWidget.DataContext} property
			 * is changing.
			 *
			 * This can be used to determine when to allow certain logic during the update of the
			 * data context.  It is used to disable binding setters on the model when the data
			 * context changes so that a binding does not cause the view model to be updated when the
			 * state hasn't been fully set yet.
			 */
			IsDataContextChanging: boolean;

			/**
			 * Gets the platform that was used to create the {@link Eto.Widget.Handler} for this
			 * widget
			 *
			 * This gets set to the current {@link Eto.Platform.Instance} during the construction of
			 * the object
			 */
			readonly Platform: Eto.Platform;

			/** Gets the platform-specific handler for this widget */
			Handler: unknown;

			/** Gets the native platform-specific handle for integration purposes */
			readonly NativeHandle: unknown;

			/** Gets the dictionary of properties for this widget */
			readonly Properties: Eto.PropertyStore;

			/** Gets or sets the ID of this widget */
			ID: string;

			/**
			 * Gets or sets the style of this widget
			 *
			 * Styles allow you to attach custom platform-specific logic to a widget. In your
			 * platform-specific assembly, use {@link Style.Add{H}(string, StyleHandler{H})} to add
			 * the style logic with the same id.
			 */
			Style: string;

			/**
			 * Gets the instance of the platform-specific object
			 *
			 * This can sometimes be useful to get the platform-specific object. Some handlers may
			 * not have any backing object for its functionality, so this may be null.  It is more
			 * preferred to use the {@link Eto.Widget.Handler} and cast that to the platform-specific
			 * handler class which can give you additional methods and helpers to do common tasks.
			 * For example, the {@link Eto.Forms.Application} object's handler for OS X has a
			 * AddFullScreenMenuItem property to specify if you want full screen support in your app.
			 */
			readonly ControlObject: unknown;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Widget} has been disposed.
			 *
			 * When the widget is disposed, it can no longer be used.
			 */
			IsDisposed: boolean;

			/**
			 * Finds a control in the parent hierarchy with the specified type and
			 * {@link Eto.Widget.ID} if specified
			 */
			FindParent<T>(id?: string): T;

			/**
			 * Finds a control in the parent hierarchy with the specified type and
			 * {@link Eto.Widget.ID} if specified
			 */
			FindParent(
				type: unknown,
				id?: string,
			): Eto.Widget;

			/** Finds a control in the parent hierarchy with the specified `id` */
			FindParent(id: string): Eto.Widget;

			/**
			 * Unbinds any bindings in the {@link Eto.Forms.BindableWidget.Bindings} collection and
			 * removes the bindings
			 *
			 * When you implement {@link Eto.Forms.IBindableWidgetContainer}, this will also unbind
			 * any of its children.
			 */
			Unbind(): void;

			/**
			 * Updates all bindings in this widget
			 *
			 * When you implement {@link Eto.Forms.IBindableWidgetContainer}, this will also update
			 * bindings for all of its children.
			 */
			UpdateBindings(mode?: Eto.Forms.BindingUpdateMode): void;

			/** Disposes of this widget, supressing the finalizer */
			dispose(): void;

			/** Gets a string that represents the current object with its ID if specified. */
			ToString(): string;
		}
	}

	export namespace Eto.Forms.MenuBar {
		export interface IHandler extends
			Eto.Widget.IHandler,
			Eto.Forms.Menu.ISubmenuHandler {
			readonly ApplicationMenu: Eto.Forms.ButtonMenuItem;

			readonly HelpMenu: Eto.Forms.ButtonMenuItem;

			SetQuitItem(item: Eto.Forms.MenuItem): void;

			SetAboutItem(item: Eto.Forms.MenuItem): void;

			CreateSystemMenu(): void;

			CreateLegacySystemMenu(): void;

			GetSystemCommands(): Iterable<Eto.Forms.Command>;
		}
	}

	export namespace Eto.Forms {
		/**
		 * Interface to access common properties of both {@link Eto.Forms.MenuItem} and
		 * {@link Eto.Forms.ToolItem}.
		 */
		export interface ICommandItem {
			/** Gets or sets the text of the item, with mnemonic. */
			Text: string;

			/** Gets or sets the tool tip to show when hovering the mouse over the item. */
			ToolTip: string;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Forms.ICommandItem} is
			 * enabled.
			 */
			Enabled: boolean;
		}
	}

	export namespace Eto.Forms {
		/** Base class for items in a menu */
		export class MenuItem implements
			Eto.IHandlerSource,
			Eto.Forms.IBindable,
			Eto.Forms.ICommandItem {
			/**
			 * Gets or sets the order that the menu item should use when inserted into a submenu.
			 *
			 * The order can be used to sort your menu items when added in a different order.  This
			 * is useful when you have menu items added from different areas of your program.
			 */
			Order: number;

			/**
			 * Gets or sets the command to invoke when the menu item is pressed.
			 *
			 * This will invoke the specified command when the menu item is pressed. The
			 * {@link System.Windows.Input.ICommand.CanExecute(System.Object)} will also used to set
			 * the enabled/disabled state of the menu item.
			 */
			Command: unknown;

			/**
			 * Gets or sets the parameter to pass to the {@link Eto.Forms.MenuItem.Command} when
			 * executing or determining its CanExecute state.
			 */
			CommandParameter: unknown;

			/** Gets or sets the text of the menu item, with mnemonics identified with &amp;. */
			Text: string;

			/** Gets or sets a user-defined tag for the menu item. */
			Tag: unknown;

			/** Gets or sets the tool tip of the item. */
			ToolTip: string;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Forms.MenuItem} is enabled.
			 */
			Enabled: boolean;

			/** Gets or sets the shortcut key the user can press to activate the menu item. */
			Shortcut: Eto.Forms.Keys;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Forms.MenuItem} is visible.
			 */
			Visible: boolean;

			/**
			 * Gets or sets the parent widget which this widget has been added to, if any
			 *
			 * When implementing child widgets that can participate in the context based binding
			 * (MVVM), You can set this to the parent widget when it is added or removed to it
			 * (usually via a collection).  Note that you should typically provide a public new
			 * [ParentWidget] Parent { get; } property  so that consumers of your API cannot set the
			 * parent to an invalid value.
			 */
			Parent: Eto.Widget;

			/**
			 * Gets an enumeration of all parent widgets in the heirarchy by traversing the
			 * {@link Eto.Forms.BindableWidget.Parent} property.
			 */
			readonly Parents: Iterable<Eto.Widget>;

			/**
			 * Gets or sets the data context for this widget for binding
			 *
			 * Subclasses may override the standard behaviour so that hierarchy of widgets can be
			 * taken into account.  For example, a Control may return the data context of a parent,
			 * if it is not set explicitly.
			 */
			DataContext: unknown;

			/** Gets the collection of bindings that are attached to this widget */
			readonly Bindings: Eto.Forms.BindingCollection;

			/**
			 * Gets a value indicating that the {@link Eto.Forms.BindableWidget.DataContext} property
			 * is changing.
			 *
			 * This can be used to determine when to allow certain logic during the update of the
			 * data context.  It is used to disable binding setters on the model when the data
			 * context changes so that a binding does not cause the view model to be updated when the
			 * state hasn't been fully set yet.
			 */
			IsDataContextChanging: boolean;

			/**
			 * Gets the platform that was used to create the {@link Eto.Widget.Handler} for this
			 * widget
			 *
			 * This gets set to the current {@link Eto.Platform.Instance} during the construction of
			 * the object
			 */
			readonly Platform: Eto.Platform;

			/** Gets the platform-specific handler for this widget */
			Handler: unknown;

			/** Gets the native platform-specific handle for integration purposes */
			readonly NativeHandle: unknown;

			/** Gets the dictionary of properties for this widget */
			readonly Properties: Eto.PropertyStore;

			/** Gets or sets the ID of this widget */
			ID: string;

			/**
			 * Gets or sets the style of this widget
			 *
			 * Styles allow you to attach custom platform-specific logic to a widget. In your
			 * platform-specific assembly, use {@link Style.Add{H}(string, StyleHandler{H})} to add
			 * the style logic with the same id.
			 */
			Style: string;

			/**
			 * Gets the instance of the platform-specific object
			 *
			 * This can sometimes be useful to get the platform-specific object. Some handlers may
			 * not have any backing object for its functionality, so this may be null.  It is more
			 * preferred to use the {@link Eto.Widget.Handler} and cast that to the platform-specific
			 * handler class which can give you additional methods and helpers to do common tasks.
			 * For example, the {@link Eto.Forms.Application} object's handler for OS X has a
			 * AddFullScreenMenuItem property to specify if you want full screen support in your app.
			 */
			readonly ControlObject: unknown;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Widget} has been disposed.
			 *
			 * When the widget is disposed, it can no longer be used.
			 */
			IsDisposed: boolean;

			/**
			 * Performs the click handler for this item.
			 *
			 * This performs the click by calling
			 * {@link Eto.Forms.MenuItem.OnClick(System.EventArgs)} which triggers the
			 * {@link Eto.Forms.MenuItem.Click} event.
			 */
			PerformClick(): void;

			/**
			 * Executes the {@link Eto.Forms.MenuItem.OnValidate(System.EventArgs)} for this item.
			 *
			 * This allows you to manually validate the menu item to determine its enabled state.
			 */
			PerformValidate(): void;

			/**
			 * Finds a control in the parent hierarchy with the specified type and
			 * {@link Eto.Widget.ID} if specified
			 */
			FindParent<T>(id?: string): T;

			/**
			 * Finds a control in the parent hierarchy with the specified type and
			 * {@link Eto.Widget.ID} if specified
			 */
			FindParent(
				type: unknown,
				id?: string,
			): Eto.Widget;

			/** Finds a control in the parent hierarchy with the specified `id` */
			FindParent(id: string): Eto.Widget;

			/**
			 * Unbinds any bindings in the {@link Eto.Forms.BindableWidget.Bindings} collection and
			 * removes the bindings
			 *
			 * When you implement {@link Eto.Forms.IBindableWidgetContainer}, this will also unbind
			 * any of its children.
			 */
			Unbind(): void;

			/**
			 * Updates all bindings in this widget
			 *
			 * When you implement {@link Eto.Forms.IBindableWidgetContainer}, this will also update
			 * bindings for all of its children.
			 */
			UpdateBindings(mode?: Eto.Forms.BindingUpdateMode): void;

			/** Disposes of this widget, supressing the finalizer */
			dispose(): void;

			/** Gets a string that represents the current object with its ID if specified. */
			ToString(): string;
		}
	}

	export namespace Eto.Forms.MenuItem {
		export interface ICallback extends Eto.Widget.ICallback {
			OnClick(
				widget: Eto.Forms.MenuItem,
				e: unknown,
			): void;

			OnValidate(
				widget: Eto.Forms.MenuItem,
				e: unknown,
			): void;
		}
	}

	export namespace Eto.Forms.MenuItem {
		export interface IHandler extends Eto.Widget.IHandler {
			Shortcut: Eto.Forms.Keys;

			Text: string;

			ToolTip: string;

			Enabled: boolean;

			Visible: boolean;

			CreateFromCommand(command: Eto.Forms.Command): void;
		}
	}

	export namespace Eto.Forms {
		/** Collection for menu items. */
		export class MenuItemCollection {
			/** Trims the items in this collection and all submenus. */
			Trim(): void;

			/** Adds a menu item to the specified collection based on its Order. */
			Add(item: Eto.Forms.MenuItem): void;

			/** Add the specified command with the specified order. */
			Add(
				command: Eto.Forms.Command,
				order?: number,
			): Eto.Forms.MenuItem;

			/** Adds the separator with the specified order. */
			AddSeparator(order?: number): void;

			/** Adds the specified menu items to the collection. */
			AddRange(items: Iterable<Eto.Forms.MenuItem>): void;

			/** Adds the specified commands to the collection starting at the specified order. */
			AddRange(
				commands: Iterable<Eto.Forms.Command>,
				order?: number,
			): void;

			/**
			 * Gets the submenu from the collection with the specified text, optionally creating one
			 * if not found.
			 */
			GetSubmenu(
				submenuText: string,
				order?: number,
				plaintextMatch?: boolean,
				create?: boolean,
			): Eto.Forms.ButtonMenuItem;
		}
	}

	export namespace Eto.Forms {
		/**
		 * Menu item to choose from a set of options
		 *
		 * The RadioMenuItem works with other radio items to present a list of options that the
		 * user can select from. When a radio button is toggled on, all others that are linked
		 * together will be toggled off.  To link radio buttons together, use the
		 * {@link Eto.Forms.RadioMenuItem(RadioMenuItem)} constructor to specify the controller
		 * radio item, which can be created with the default constructor.
		 */
		export class RadioMenuItem implements
			Eto.IHandlerSource,
			Eto.Forms.IBindable,
			Eto.Forms.ICommandItem {
			/** Initializes a new instance of the {@link Eto.Forms.RadioMenuItem} class. */
			constructor();

			/** Initializes a new instance of the {@link Eto.Forms.RadioMenuItem} class. */
			constructor(controller: Eto.Forms.RadioMenuItem);

			/**
			 * Initializes a new instance of the {@link Eto.Forms.RadioMenuItem} class with the
			 * specified command and controller.
			 */
			constructor(
				command: Eto.Forms.RadioCommand,
				controller?: Eto.Forms.RadioMenuItem,
			);

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Forms.RadioMenuItem} is
			 * checked.
			 */
			Checked: boolean;

			/**
			 * Gets or sets the order that the menu item should use when inserted into a submenu.
			 *
			 * The order can be used to sort your menu items when added in a different order.  This
			 * is useful when you have menu items added from different areas of your program.
			 */
			Order: number;

			/**
			 * Gets or sets the command to invoke when the menu item is pressed.
			 *
			 * This will invoke the specified command when the menu item is pressed. The
			 * {@link System.Windows.Input.ICommand.CanExecute(System.Object)} will also used to set
			 * the enabled/disabled state of the menu item.
			 */
			Command: unknown;

			/**
			 * Gets or sets the parameter to pass to the {@link Eto.Forms.MenuItem.Command} when
			 * executing or determining its CanExecute state.
			 */
			CommandParameter: unknown;

			/** Gets or sets the text of the menu item, with mnemonics identified with &amp;. */
			Text: string;

			/** Gets or sets a user-defined tag for the menu item. */
			Tag: unknown;

			/** Gets or sets the tool tip of the item. */
			ToolTip: string;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Forms.MenuItem} is enabled.
			 */
			Enabled: boolean;

			/** Gets or sets the shortcut key the user can press to activate the menu item. */
			Shortcut: Eto.Forms.Keys;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Forms.MenuItem} is visible.
			 */
			Visible: boolean;

			/**
			 * Gets or sets the parent widget which this widget has been added to, if any
			 *
			 * When implementing child widgets that can participate in the context based binding
			 * (MVVM), You can set this to the parent widget when it is added or removed to it
			 * (usually via a collection).  Note that you should typically provide a public new
			 * [ParentWidget] Parent { get; } property  so that consumers of your API cannot set the
			 * parent to an invalid value.
			 */
			Parent: Eto.Widget;

			/**
			 * Gets an enumeration of all parent widgets in the heirarchy by traversing the
			 * {@link Eto.Forms.BindableWidget.Parent} property.
			 */
			readonly Parents: Iterable<Eto.Widget>;

			/**
			 * Gets or sets the data context for this widget for binding
			 *
			 * Subclasses may override the standard behaviour so that hierarchy of widgets can be
			 * taken into account.  For example, a Control may return the data context of a parent,
			 * if it is not set explicitly.
			 */
			DataContext: unknown;

			/** Gets the collection of bindings that are attached to this widget */
			readonly Bindings: Eto.Forms.BindingCollection;

			/**
			 * Gets a value indicating that the {@link Eto.Forms.BindableWidget.DataContext} property
			 * is changing.
			 *
			 * This can be used to determine when to allow certain logic during the update of the
			 * data context.  It is used to disable binding setters on the model when the data
			 * context changes so that a binding does not cause the view model to be updated when the
			 * state hasn't been fully set yet.
			 */
			IsDataContextChanging: boolean;

			/**
			 * Gets the platform that was used to create the {@link Eto.Widget.Handler} for this
			 * widget
			 *
			 * This gets set to the current {@link Eto.Platform.Instance} during the construction of
			 * the object
			 */
			readonly Platform: Eto.Platform;

			/** Gets the platform-specific handler for this widget */
			Handler: unknown;

			/** Gets the native platform-specific handle for integration purposes */
			readonly NativeHandle: unknown;

			/** Gets the dictionary of properties for this widget */
			readonly Properties: Eto.PropertyStore;

			/** Gets or sets the ID of this widget */
			ID: string;

			/**
			 * Gets or sets the style of this widget
			 *
			 * Styles allow you to attach custom platform-specific logic to a widget. In your
			 * platform-specific assembly, use {@link Style.Add{H}(string, StyleHandler{H})} to add
			 * the style logic with the same id.
			 */
			Style: string;

			/**
			 * Gets the instance of the platform-specific object
			 *
			 * This can sometimes be useful to get the platform-specific object. Some handlers may
			 * not have any backing object for its functionality, so this may be null.  It is more
			 * preferred to use the {@link Eto.Widget.Handler} and cast that to the platform-specific
			 * handler class which can give you additional methods and helpers to do common tasks.
			 * For example, the {@link Eto.Forms.Application} object's handler for OS X has a
			 * AddFullScreenMenuItem property to specify if you want full screen support in your app.
			 */
			readonly ControlObject: unknown;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Widget} has been disposed.
			 *
			 * When the widget is disposed, it can no longer be used.
			 */
			IsDisposed: boolean;

			/**
			 * Performs the click handler for this item which sets the check state to true.
			 *
			 * This performs the click by calling
			 * {@link Eto.Forms.MenuItem.OnClick(System.EventArgs)} which triggers the
			 * {@link Eto.Forms.MenuItem.Click} event. The {@link Eto.Forms.RadioMenuItem.Checked}
			 * state will also be set to true.
			 */
			PerformClick(): void;

			/**
			 * Executes the {@link Eto.Forms.MenuItem.OnValidate(System.EventArgs)} for this item.
			 *
			 * This allows you to manually validate the menu item to determine its enabled state.
			 */
			PerformValidate(): void;

			/**
			 * Finds a control in the parent hierarchy with the specified type and
			 * {@link Eto.Widget.ID} if specified
			 */
			FindParent<T>(id?: string): T;

			/**
			 * Finds a control in the parent hierarchy with the specified type and
			 * {@link Eto.Widget.ID} if specified
			 */
			FindParent(
				type: unknown,
				id?: string,
			): Eto.Widget;

			/** Finds a control in the parent hierarchy with the specified `id` */
			FindParent(id: string): Eto.Widget;

			/**
			 * Unbinds any bindings in the {@link Eto.Forms.BindableWidget.Bindings} collection and
			 * removes the bindings
			 *
			 * When you implement {@link Eto.Forms.IBindableWidgetContainer}, this will also unbind
			 * any of its children.
			 */
			Unbind(): void;

			/**
			 * Updates all bindings in this widget
			 *
			 * When you implement {@link Eto.Forms.IBindableWidgetContainer}, this will also update
			 * bindings for all of its children.
			 */
			UpdateBindings(mode?: Eto.Forms.BindingUpdateMode): void;

			/** Disposes of this widget, supressing the finalizer */
			dispose(): void;

			/** Gets a string that represents the current object with its ID if specified. */
			ToString(): string;
		}
	}

	export namespace Eto.Forms.RadioMenuItem {
		export interface ICallback extends
			Eto.Forms.MenuItem.ICallback,
			Eto.Widget.ICallback {
			OnCheckedChanged(
				widget: Eto.Forms.RadioMenuItem,
				e: unknown,
			): void;
		}
	}

	export namespace Eto.Forms.RadioMenuItem {
		export interface IHandler extends
			Eto.Forms.MenuItem.IHandler,
			Eto.Widget.IHandler {
			Checked: boolean;

			Create(controller: Eto.Forms.RadioMenuItem): void;
		}
	}

	export namespace Eto.Forms {
		/** Menu item to separate menu items */
		export class SeparatorMenuItem implements
			Eto.IHandlerSource,
			Eto.Forms.IBindable,
			Eto.Forms.ICommandItem {
			constructor();

			/**
			 * Gets or sets the order that the menu item should use when inserted into a submenu.
			 *
			 * The order can be used to sort your menu items when added in a different order.  This
			 * is useful when you have menu items added from different areas of your program.
			 */
			Order: number;

			/**
			 * Gets or sets the command to invoke when the menu item is pressed.
			 *
			 * This will invoke the specified command when the menu item is pressed. The
			 * {@link System.Windows.Input.ICommand.CanExecute(System.Object)} will also used to set
			 * the enabled/disabled state of the menu item.
			 */
			Command: unknown;

			/**
			 * Gets or sets the parameter to pass to the {@link Eto.Forms.MenuItem.Command} when
			 * executing or determining its CanExecute state.
			 */
			CommandParameter: unknown;

			/** Gets or sets the text of the menu item, with mnemonics identified with &amp;. */
			Text: string;

			/** Gets or sets a user-defined tag for the menu item. */
			Tag: unknown;

			/** Gets or sets the tool tip of the item. */
			ToolTip: string;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Forms.MenuItem} is enabled.
			 */
			Enabled: boolean;

			/** Gets or sets the shortcut key the user can press to activate the menu item. */
			Shortcut: Eto.Forms.Keys;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Forms.MenuItem} is visible.
			 */
			Visible: boolean;

			/**
			 * Gets or sets the parent widget which this widget has been added to, if any
			 *
			 * When implementing child widgets that can participate in the context based binding
			 * (MVVM), You can set this to the parent widget when it is added or removed to it
			 * (usually via a collection).  Note that you should typically provide a public new
			 * [ParentWidget] Parent { get; } property  so that consumers of your API cannot set the
			 * parent to an invalid value.
			 */
			Parent: Eto.Widget;

			/**
			 * Gets an enumeration of all parent widgets in the heirarchy by traversing the
			 * {@link Eto.Forms.BindableWidget.Parent} property.
			 */
			readonly Parents: Iterable<Eto.Widget>;

			/**
			 * Gets or sets the data context for this widget for binding
			 *
			 * Subclasses may override the standard behaviour so that hierarchy of widgets can be
			 * taken into account.  For example, a Control may return the data context of a parent,
			 * if it is not set explicitly.
			 */
			DataContext: unknown;

			/** Gets the collection of bindings that are attached to this widget */
			readonly Bindings: Eto.Forms.BindingCollection;

			/**
			 * Gets a value indicating that the {@link Eto.Forms.BindableWidget.DataContext} property
			 * is changing.
			 *
			 * This can be used to determine when to allow certain logic during the update of the
			 * data context.  It is used to disable binding setters on the model when the data
			 * context changes so that a binding does not cause the view model to be updated when the
			 * state hasn't been fully set yet.
			 */
			IsDataContextChanging: boolean;

			/**
			 * Gets the platform that was used to create the {@link Eto.Widget.Handler} for this
			 * widget
			 *
			 * This gets set to the current {@link Eto.Platform.Instance} during the construction of
			 * the object
			 */
			readonly Platform: Eto.Platform;

			/** Gets the platform-specific handler for this widget */
			Handler: unknown;

			/** Gets the native platform-specific handle for integration purposes */
			readonly NativeHandle: unknown;

			/** Gets the dictionary of properties for this widget */
			readonly Properties: Eto.PropertyStore;

			/** Gets or sets the ID of this widget */
			ID: string;

			/**
			 * Gets or sets the style of this widget
			 *
			 * Styles allow you to attach custom platform-specific logic to a widget. In your
			 * platform-specific assembly, use {@link Style.Add{H}(string, StyleHandler{H})} to add
			 * the style logic with the same id.
			 */
			Style: string;

			/**
			 * Gets the instance of the platform-specific object
			 *
			 * This can sometimes be useful to get the platform-specific object. Some handlers may
			 * not have any backing object for its functionality, so this may be null.  It is more
			 * preferred to use the {@link Eto.Widget.Handler} and cast that to the platform-specific
			 * handler class which can give you additional methods and helpers to do common tasks.
			 * For example, the {@link Eto.Forms.Application} object's handler for OS X has a
			 * AddFullScreenMenuItem property to specify if you want full screen support in your app.
			 */
			readonly ControlObject: unknown;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Widget} has been disposed.
			 *
			 * When the widget is disposed, it can no longer be used.
			 */
			IsDisposed: boolean;

			/**
			 * Performs the click handler for this item.
			 *
			 * This performs the click by calling
			 * {@link Eto.Forms.MenuItem.OnClick(System.EventArgs)} which triggers the
			 * {@link Eto.Forms.MenuItem.Click} event.
			 */
			PerformClick(): void;

			/**
			 * Executes the {@link Eto.Forms.MenuItem.OnValidate(System.EventArgs)} for this item.
			 *
			 * This allows you to manually validate the menu item to determine its enabled state.
			 */
			PerformValidate(): void;

			/**
			 * Finds a control in the parent hierarchy with the specified type and
			 * {@link Eto.Widget.ID} if specified
			 */
			FindParent<T>(id?: string): T;

			/**
			 * Finds a control in the parent hierarchy with the specified type and
			 * {@link Eto.Widget.ID} if specified
			 */
			FindParent(
				type: unknown,
				id?: string,
			): Eto.Widget;

			/** Finds a control in the parent hierarchy with the specified `id` */
			FindParent(id: string): Eto.Widget;

			/**
			 * Unbinds any bindings in the {@link Eto.Forms.BindableWidget.Bindings} collection and
			 * removes the bindings
			 *
			 * When you implement {@link Eto.Forms.IBindableWidgetContainer}, this will also unbind
			 * any of its children.
			 */
			Unbind(): void;

			/**
			 * Updates all bindings in this widget
			 *
			 * When you implement {@link Eto.Forms.IBindableWidgetContainer}, this will also update
			 * bindings for all of its children.
			 */
			UpdateBindings(mode?: Eto.Forms.BindingUpdateMode): void;

			/** Disposes of this widget, supressing the finalizer */
			dispose(): void;

			/** Gets a string that represents the current object with its ID if specified. */
			ToString(): string;
		}
	}

	export namespace Eto.Forms.SeparatorMenuItem {
		export interface IHandler extends
			Eto.Forms.MenuItem.IHandler,
			Eto.Widget.IHandler {
		}
	}

	export namespace Eto.Forms {
		/** Interface for submenus to access common Items properties */
		export interface ISubmenu {
			/** Gets the collection of menu items to show in the submenu. */
			readonly Items: Eto.Forms.MenuItemCollection;

			/**
			 * Gets a value indicating whether this sub menu should trim its child menu items when
			 * loaded onto a form
			 *
			 * Trimming will collapse any duplicate splitter items.  This is done so that you can
			 * easily merge your menus.
			 */
			readonly Trim: boolean;
		}
	}

	export namespace Eto.Forms {
		/** Extensions for the {@link Eto.Forms.ISubmenu} interface. */
		export namespace SubmenuExtensions {
			/**
			 * Gets an enumeration of all children of the specified submenu.
			 *
			 * This traverses all items of the submenu, and any children of those items if they
			 * implement {@link Eto.Forms.ISubmenu} as well.
			 */
			export function GetChildren(submenu: Eto.Forms.ISubmenu): Iterable<Eto.Forms.MenuItem>;
		}
	}

	export namespace Eto.Forms {
		/** Extension methods from {@link Eto.Forms.SubmenuExtensions} */
		export interface ISubmenu {
			/**
			 * Gets an enumeration of all children of the specified submenu.
			 *
			 * This traverses all items of the submenu, and any children of those items if they
			 * implement {@link Eto.Forms.ISubmenu} as well.
			 */
			GetChildren(): Iterable<Eto.Forms.MenuItem>;
		}
	}

	export namespace Eto.Forms {
		/**
		 * Menu item for a submenu
		 *
		 * This will always show as a submenu, even when no items have been added. The
		 * {@link Eto.Forms.SubMenuItem.Opening} can be used to populate or modify the submenu
		 * before it opens.
		 */
		export class SubMenuItem implements
			Eto.IHandlerSource,
			Eto.Forms.IBindable,
			Eto.Forms.ICommandItem,
			Eto.Forms.ISubmenu {
			/** Initializes a new instance of the {@link Eto.Forms.SubMenuItem} class. */
			constructor();

			/**
			 * Initializes a new instance of the {@link Eto.Forms.SubMenuItem} class with the
			 * specified `items`.
			 */
			constructor(items: Eto.Forms.MenuItem[]);

			/** Gets the collection of menu items. */
			readonly Items: Eto.Forms.MenuItemCollection;

			/**
			 * Gets a value indicating whether this sub menu should trim its child menu items when
			 * loaded onto a form
			 *
			 * Trimming will collapse any duplicate splitter items. This is done so that you can
			 * easily merge your menus.
			 */
			Trim: boolean;

			/**
			 * Gets or sets the image to show for the menu item.
			 *
			 * Some platforms (e.g. OS X) will not show an image by default, but can be enabled using
			 * the handler implementation via styles.
			 */
			Image: Eto.Drawing.Image;

			/**
			 * Gets or sets the order that the menu item should use when inserted into a submenu.
			 *
			 * The order can be used to sort your menu items when added in a different order.  This
			 * is useful when you have menu items added from different areas of your program.
			 */
			Order: number;

			/**
			 * Gets or sets the command to invoke when the menu item is pressed.
			 *
			 * This will invoke the specified command when the menu item is pressed. The
			 * {@link System.Windows.Input.ICommand.CanExecute(System.Object)} will also used to set
			 * the enabled/disabled state of the menu item.
			 */
			Command: unknown;

			/**
			 * Gets or sets the parameter to pass to the {@link Eto.Forms.MenuItem.Command} when
			 * executing or determining its CanExecute state.
			 */
			CommandParameter: unknown;

			/** Gets or sets the text of the menu item, with mnemonics identified with &amp;. */
			Text: string;

			/** Gets or sets a user-defined tag for the menu item. */
			Tag: unknown;

			/** Gets or sets the tool tip of the item. */
			ToolTip: string;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Forms.MenuItem} is enabled.
			 */
			Enabled: boolean;

			/** Gets or sets the shortcut key the user can press to activate the menu item. */
			Shortcut: Eto.Forms.Keys;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Forms.MenuItem} is visible.
			 */
			Visible: boolean;

			/**
			 * Gets or sets the parent widget which this widget has been added to, if any
			 *
			 * When implementing child widgets that can participate in the context based binding
			 * (MVVM), You can set this to the parent widget when it is added or removed to it
			 * (usually via a collection).  Note that you should typically provide a public new
			 * [ParentWidget] Parent { get; } property  so that consumers of your API cannot set the
			 * parent to an invalid value.
			 */
			Parent: Eto.Widget;

			/**
			 * Gets an enumeration of all parent widgets in the heirarchy by traversing the
			 * {@link Eto.Forms.BindableWidget.Parent} property.
			 */
			readonly Parents: Iterable<Eto.Widget>;

			/**
			 * Gets or sets the data context for this widget for binding
			 *
			 * Subclasses may override the standard behaviour so that hierarchy of widgets can be
			 * taken into account.  For example, a Control may return the data context of a parent,
			 * if it is not set explicitly.
			 */
			DataContext: unknown;

			/** Gets the collection of bindings that are attached to this widget */
			readonly Bindings: Eto.Forms.BindingCollection;

			/**
			 * Gets a value indicating that the {@link Eto.Forms.BindableWidget.DataContext} property
			 * is changing.
			 *
			 * This can be used to determine when to allow certain logic during the update of the
			 * data context.  It is used to disable binding setters on the model when the data
			 * context changes so that a binding does not cause the view model to be updated when the
			 * state hasn't been fully set yet.
			 */
			IsDataContextChanging: boolean;

			/**
			 * Gets the platform that was used to create the {@link Eto.Widget.Handler} for this
			 * widget
			 *
			 * This gets set to the current {@link Eto.Platform.Instance} during the construction of
			 * the object
			 */
			readonly Platform: Eto.Platform;

			/** Gets the platform-specific handler for this widget */
			Handler: unknown;

			/** Gets the native platform-specific handle for integration purposes */
			readonly NativeHandle: unknown;

			/** Gets the dictionary of properties for this widget */
			readonly Properties: Eto.PropertyStore;

			/** Gets or sets the ID of this widget */
			ID: string;

			/**
			 * Gets or sets the style of this widget
			 *
			 * Styles allow you to attach custom platform-specific logic to a widget. In your
			 * platform-specific assembly, use {@link Style.Add{H}(string, StyleHandler{H})} to add
			 * the style logic with the same id.
			 */
			Style: string;

			/**
			 * Gets the instance of the platform-specific object
			 *
			 * This can sometimes be useful to get the platform-specific object. Some handlers may
			 * not have any backing object for its functionality, so this may be null.  It is more
			 * preferred to use the {@link Eto.Widget.Handler} and cast that to the platform-specific
			 * handler class which can give you additional methods and helpers to do common tasks.
			 * For example, the {@link Eto.Forms.Application} object's handler for OS X has a
			 * AddFullScreenMenuItem property to specify if you want full screen support in your app.
			 */
			readonly ControlObject: unknown;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Widget} has been disposed.
			 *
			 * When the widget is disposed, it can no longer be used.
			 */
			IsDisposed: boolean;

			/**
			 * Performs the click handler for this item.
			 *
			 * This performs the click by calling
			 * {@link Eto.Forms.MenuItem.OnClick(System.EventArgs)} which triggers the
			 * {@link Eto.Forms.MenuItem.Click} event.
			 */
			PerformClick(): void;

			/**
			 * Executes the {@link Eto.Forms.MenuItem.OnValidate(System.EventArgs)} for this item.
			 *
			 * This allows you to manually validate the menu item to determine its enabled state.
			 */
			PerformValidate(): void;

			/**
			 * Finds a control in the parent hierarchy with the specified type and
			 * {@link Eto.Widget.ID} if specified
			 */
			FindParent<T>(id?: string): T;

			/**
			 * Finds a control in the parent hierarchy with the specified type and
			 * {@link Eto.Widget.ID} if specified
			 */
			FindParent(
				type: unknown,
				id?: string,
			): Eto.Widget;

			/** Finds a control in the parent hierarchy with the specified `id` */
			FindParent(id: string): Eto.Widget;

			/**
			 * Unbinds any bindings in the {@link Eto.Forms.BindableWidget.Bindings} collection and
			 * removes the bindings
			 *
			 * When you implement {@link Eto.Forms.IBindableWidgetContainer}, this will also unbind
			 * any of its children.
			 */
			Unbind(): void;

			/**
			 * Updates all bindings in this widget
			 *
			 * When you implement {@link Eto.Forms.IBindableWidgetContainer}, this will also update
			 * bindings for all of its children.
			 */
			UpdateBindings(mode?: Eto.Forms.BindingUpdateMode): void;

			/** Disposes of this widget, supressing the finalizer */
			dispose(): void;

			/** Gets a string that represents the current object with its ID if specified. */
			ToString(): string;
		}
	}

	export namespace Eto.Forms.SubMenuItem {
		export interface ICallback extends
			Eto.Forms.MenuItem.ICallback,
			Eto.Widget.ICallback {
			OnOpening(
				widget: Eto.Forms.SubMenuItem,
				e: unknown,
			): void;

			OnClosed(
				widget: Eto.Forms.SubMenuItem,
				e: unknown,
			): void;

			OnClosing(
				widget: Eto.Forms.SubMenuItem,
				e: unknown,
			): void;
		}
	}

	export namespace Eto.Forms.SubMenuItem {
		export interface IHandler extends
			Eto.Forms.ButtonMenuItem.IHandler,
			Eto.Forms.MenuItem.IHandler,
			Eto.Widget.IHandler,
			Eto.Forms.Menu.ISubmenuHandler {
		}
	}

	export namespace Eto.Forms {
		/**
		 * Message box buttons for methods of {@link Eto.Forms.MessageBox}
		 *
		 * This defined which buttons to show on the message box.  If there are different buttons
		 * you require, you can use {@link Eto.Forms.Dialog} instead to create your own.
		 */
		export enum MessageBoxButtons {
			/** Only a single OK button */
			OK = 0,

			/** OK and Cancel buttons */
			OKCancel = 1,

			/** Yes and no buttons */
			YesNo = 2,

			/** Yes, no, and cancel buttons */
			YesNoCancel = 3,
		}
	}

	export namespace Eto.Forms {
		/**
		 * Message box type, to define the appearance of a {@link Eto.Forms.MessageBox}
		 *
		 * Usually the icon shown on the message box will change depending on this value.
		 */
		export enum MessageBoxType {
			/** Informational message box, usually signified a lower case 'i' icon */
			Information = 0,

			/** Warning message box, usually signified by an exclamation mark icon */
			Warning = 1,

			/** Error message box, usually signified by a stop sign */
			Error = 2,

			/** Question message box, usually signified by a question mark icon */
			Question = 3,
		}
	}

	export namespace Eto.Forms {
		/**
		 * Message box default button selection for a {@link Eto.Forms.MessageBox}
		 *
		 * This enumeration specifies the default button of the message box, which is usually
		 * focussed when the message box is shown, and selectable when the user presses the
		 * Return key.
		 */
		export enum MessageBoxDefaultButton {
			/**
			 * Automatically select the default button, preferring the negative form first such as
			 * {@link Eto.Forms.MessageBoxDefaultButton.Cancel}, then
			 * {@link Eto.Forms.MessageBoxDefaultButton.No}.
			 */
			Default = 0,

			/** The OK button is default */
			OK = 1,

			/** The Yes button is default */
			Yes = 1,

			/** The No button is default */
			No = 2,

			/** The Cancel button is default */
			Cancel = 3,
		}
	}

	export namespace Eto.Forms {
		/**
		 * Methods to show a standard message box with display text, buttons, and typically an
		 * icon indicating the type
		 */
		export namespace MessageBox {
			/** Shows a message box, blocking input to all windows of the application until closed */
			export function Show(
				text: string,
				type?: Eto.Forms.MessageBoxType,
			): Eto.Forms.DialogResult;

			/** Shows a message box, blocking input to all windows of the application until closed */
			export function Show(
				text: string,
				caption: string,
				type?: Eto.Forms.MessageBoxType,
			): Eto.Forms.DialogResult;

			/** Shows a message box, blocking only the window of the specified `parent` */
			export function Show(
				parent: Eto.Forms.Control,
				text: string,
				type?: Eto.Forms.MessageBoxType,
			): Eto.Forms.DialogResult;

			/** Shows a message box, blocking only the window of the specified `parent` */
			export function Show(
				parent: Eto.Forms.Control,
				text: string,
				caption: string,
				type?: Eto.Forms.MessageBoxType,
			): Eto.Forms.DialogResult;

			/** Shows a message box, blocking input to all windows of the application until closed */
			export function Show(
				text: string,
				buttons: Eto.Forms.MessageBoxButtons,
				type?: Eto.Forms.MessageBoxType,
				defaultButton?: Eto.Forms.MessageBoxDefaultButton,
			): Eto.Forms.DialogResult;

			/** Shows a message box, blocking input to all windows of the application until closed */
			export function Show(
				text: string,
				caption: string,
				buttons: Eto.Forms.MessageBoxButtons,
				type?: Eto.Forms.MessageBoxType,
				defaultButton?: Eto.Forms.MessageBoxDefaultButton,
			): Eto.Forms.DialogResult;

			/** Shows a message box, blocking only the window of the specified `parent` */
			export function Show(
				parent: Eto.Forms.Control,
				text: string,
				buttons: Eto.Forms.MessageBoxButtons,
				type?: Eto.Forms.MessageBoxType,
				defaultButton?: Eto.Forms.MessageBoxDefaultButton,
			): Eto.Forms.DialogResult;

			/** Shows a message box, blocking only the window of the specified `parent` */
			export function Show(
				parent: Eto.Forms.Control,
				text: string,
				caption: string,
				buttons: Eto.Forms.MessageBoxButtons,
				type?: Eto.Forms.MessageBoxType,
				defaultButton?: Eto.Forms.MessageBoxDefaultButton,
			): Eto.Forms.DialogResult;
		}
	}

	export namespace Eto.Forms.MessageBox {
		export interface IHandler {
			Text: string;

			Caption: string;

			Type: Eto.Forms.MessageBoxType;

			Buttons: Eto.Forms.MessageBoxButtons;

			DefaultButton: Eto.Forms.MessageBoxDefaultButton;

			ShowDialog(parent: Eto.Forms.Control): Eto.Forms.DialogResult;
		}
	}

	export namespace Eto.Forms {
		/** Static methods to get the current mouse state */
		export namespace Mouse {
			/**
			 * Gets a value indicating whether the current platform supports mouse functions in this
			 * class
			 */
			export const IsSupported: boolean;

			/** Gets or sets the current mouse position in screen coordinates */
			export var Position: Eto.Drawing.PointF;

			/** Gets the current state of the mouse buttons */
			export const Buttons: Eto.Forms.MouseButtons;

			/** Returns true if any of the specified mouse buttons is pressed. */
			export function IsAnyButtonPressed(buttons: Eto.Forms.MouseButtons): boolean;

			/**
			 * Temporarily sets the current mouse pointer to the specified `cursor`.
			 *
			 * Some platforms may or may not support this in some cases, and usually the cursor gets
			 * reset when it is moved. Usually you would set the cursor using the
			 * {@link Eto.Forms.Control.Cursor} property instead.
			 */
			export function SetCursor(cursor: Eto.Forms.Cursor): void;
		}
	}

	export namespace Eto.Forms.Mouse {
		export interface IHandler {
			Position: Eto.Drawing.PointF;

			readonly Buttons: Eto.Forms.MouseButtons;

			SetCursor(cursor: Eto.Forms.Cursor): void;
		}
	}

	export namespace Eto.Forms {
		/**
		 * System toast notification.
		 *
		 * Create a new instance of this class for each notification sent as they are not
		 * reusable.  The ID and {@link Eto.Forms.Notification.UserData} should be used to
		 * specify what action would happen when the user clicks the notification (if
		 * applicable).  All notifications should be handled by the
		 * {@link Eto.Forms.Application.NotificationActivated} event.  Note that in some
		 * platforms (e.g. macOS), the application may have a notification clicked when the
		 * application isn't even started.  In this case, the application is started an then sent
		 * the notification to the {@link Eto.Forms.Application.NotificationActivated}
		 * immediately.
		 */
		export class Notification implements
			Eto.IHandlerSource {
			constructor();

			/**
			 * Gets or sets the icon for the {@link Eto.Forms.Notification}.
			 *
			 * Currently does nothing on WPF and WinForms.
			 */
			Icon: Eto.Drawing.Icon;

			/**
			 * Gets or sets the content image of the notification
			 *
			 * This is used to provide context to the user for what the notification is for.
			 * Currently does nothing on WPF and WinForms. On these platforms set-up a global Style
			 * Style.Add&lt;NotificationHandler&gt;("info", h =&gt; h.NotificationIcon =
			 * NotificationIcon.Info); and the use it via new Notification { Style = "info" }
			 */
			ContentImage: Eto.Drawing.Image;

			/** Gets or sets the message of the {@link Eto.Forms.Notification}. */
			Message: string;

			/**
			 * Gets a value indicating whether this {@link Eto.Forms.Notification} requires a
			 * {@link Eto.Forms.TrayIndicator} to be displayed.
			 *
			 * Usually if a tray is required but not provided, one will be created for the purposes
			 * of showing the notification with the same icon as the
			 * {@link Eto.Forms.Application.MainForm}.
			 */
			readonly RequiresTrayIndicator: boolean;

			/** Gets or sets the title for the {@link Eto.Forms.Notification}. */
			Title: string;

			/**
			 * Gets or sets user data for the notification.
			 *
			 * Use this to store application-specific data that would be useful for knowing what
			 * caused the notification.  The data you store would usually determine what action to
			 * perform in the application.  This is returned via
			 * {@link Eto.Forms.Application.NotificationActivated} via the
			 * {@link Eto.Forms.NotificationEventArgs}.
			 */
			UserData: string;

			/**
			 * Gets the platform that was used to create the {@link Eto.Widget.Handler} for this
			 * widget
			 *
			 * This gets set to the current {@link Eto.Platform.Instance} during the construction of
			 * the object
			 */
			readonly Platform: Eto.Platform;

			/** Gets the platform-specific handler for this widget */
			Handler: unknown;

			/** Gets the native platform-specific handle for integration purposes */
			readonly NativeHandle: unknown;

			/** Gets the dictionary of properties for this widget */
			readonly Properties: Eto.PropertyStore;

			/** Gets or sets the ID of this widget */
			ID: string;

			/**
			 * Gets or sets the style of this widget
			 *
			 * Styles allow you to attach custom platform-specific logic to a widget. In your
			 * platform-specific assembly, use {@link Style.Add{H}(string, StyleHandler{H})} to add
			 * the style logic with the same id.
			 */
			Style: string;

			/**
			 * Gets the instance of the platform-specific object
			 *
			 * This can sometimes be useful to get the platform-specific object. Some handlers may
			 * not have any backing object for its functionality, so this may be null.  It is more
			 * preferred to use the {@link Eto.Widget.Handler} and cast that to the platform-specific
			 * handler class which can give you additional methods and helpers to do common tasks.
			 * For example, the {@link Eto.Forms.Application} object's handler for OS X has a
			 * AddFullScreenMenuItem property to specify if you want full screen support in your app.
			 */
			readonly ControlObject: unknown;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Widget} has been disposed.
			 *
			 * When the widget is disposed, it can no longer be used.
			 */
			IsDisposed: boolean;

			/**
			 * Shows the current notification.
			 *
			 * On some platforms like Gtk and Windows 10 the indicator is not needed, while on the
			 * others like Windows 7 it's required.  You can find out if the indicator is needed by
			 * looking at {@link Eto.Forms.Notification.RequiresTrayIndicator} property.
			 */
			Show(indicator?: Eto.Forms.TrayIndicator): void;

			/** Disposes of this widget, supressing the finalizer */
			dispose(): void;

			/** Gets a string that represents the current object with its ID if specified. */
			ToString(): string;
		}
	}

	export namespace Eto.Forms.Notification {
		export interface IHandler extends Eto.Widget.IHandler {
			Title: string;

			UserData: string;

			Message: string;

			readonly RequiresTrayIndicator: boolean;

			ContentImage: Eto.Drawing.Image;

			Show(indicator?: Eto.Forms.TrayIndicator): void;
		}
	}

	export namespace Eto.Forms {
		/** Event arguments when handling a notification event */
		export class NotificationEventArgs {
			/** Initializes a new instance of the NotificationEventArgs class */
			constructor(
				id: string,
				userData: string,
			);

			/** Identifier of the notification that was sent */
			readonly ID: string;

			/** Custom user data of the notification */
			readonly UserData: string;
		}
	}

	export namespace Eto.Forms {
		/** Dialog to select a file (or files) from the file system to open in the application */
		export class OpenFileDialog implements
			Eto.IHandlerSource {
			constructor();

			/**
			 * Gets or sets a value indicating whether the user can select multiple files, or a
			 * single file.
			 */
			MultiSelect: boolean;

			/**
			 * Gets the full path of the files selected by the user, when
			 * {@link Eto.Forms.OpenFileDialog.MultiSelect} is true.
			 *
			 * This will return a single file name if {@link Eto.Forms.OpenFileDialog.MultiSelect} is
			 * false.
			 */
			readonly Filenames: Iterable<string>;

			/** Gets or sets the full name and path of the file that is selected */
			FileName: string;

			/**
			 * Gets the collection of available file filters the user can select from.
			 *
			 * Add entries to this collection to set the filters the user can select when the file
			 * dialog is shown.  Some platforms may either disable (OS X) or hide (GTK/WinForms/WPF)
			 * files that do not match the currently selected filter.
			 */
			readonly Filters: unknown;

			/**
			 * Gets or sets the index of the current filter in the
			 * {@link Eto.Forms.FileDialog.Filters} collection
			 */
			CurrentFilterIndex: number;

			/**
			 * Gets or sets the currently selected filter from the
			 * {@link Eto.Forms.FileDialog.Filters} collection.
			 *
			 * This should always match an instance of a filter in the
			 * {@link Eto.Forms.FileDialog.Filters} collection, otherwise the current filter will be
			 * set to null.
			 */
			CurrentFilter: Eto.Forms.FileFilter;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Forms.FileDialog} checks if
			 * the file exists  before the user can close the dialog.
			 */
			CheckFileExists: boolean;

			/** Gets or sets the title of the dialog. */
			Title: string;

			/**
			 * Gets or sets the directory the file dialog will show files.
			 *
			 * You can use {@link Eto.EtoEnvironment.GetFolderPath(Eto.EtoSpecialFolder)} to set the
			 * initial value of the directory, though the user should be able to change the folder
			 * and keep it
			 */
			Directory: unknown;

			/**
			 * Gets the platform that was used to create the {@link Eto.Widget.Handler} for this
			 * widget
			 *
			 * This gets set to the current {@link Eto.Platform.Instance} during the construction of
			 * the object
			 */
			readonly Platform: Eto.Platform;

			/** Gets the platform-specific handler for this widget */
			Handler: unknown;

			/** Gets the native platform-specific handle for integration purposes */
			readonly NativeHandle: unknown;

			/** Gets the dictionary of properties for this widget */
			readonly Properties: Eto.PropertyStore;

			/** Gets or sets the ID of this widget */
			ID: string;

			/**
			 * Gets or sets the style of this widget
			 *
			 * Styles allow you to attach custom platform-specific logic to a widget. In your
			 * platform-specific assembly, use {@link Style.Add{H}(string, StyleHandler{H})} to add
			 * the style logic with the same id.
			 */
			Style: string;

			/**
			 * Gets the instance of the platform-specific object
			 *
			 * This can sometimes be useful to get the platform-specific object. Some handlers may
			 * not have any backing object for its functionality, so this may be null.  It is more
			 * preferred to use the {@link Eto.Widget.Handler} and cast that to the platform-specific
			 * handler class which can give you additional methods and helpers to do common tasks.
			 * For example, the {@link Eto.Forms.Application} object's handler for OS X has a
			 * AddFullScreenMenuItem property to specify if you want full screen support in your app.
			 */
			readonly ControlObject: unknown;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Widget} has been disposed.
			 *
			 * When the widget is disposed, it can no longer be used.
			 */
			IsDisposed: boolean;

			/** Shows the dialog with the specified parent, blocking until a result is returned. */
			ShowDialog(parent: Eto.Forms.Control): Eto.Forms.DialogResult;

			/**
			 * Shows the dialog with the specified parent window, blocking until a result is
			 * returned.
			 */
			ShowDialog(parent: Eto.Forms.Window): Eto.Forms.DialogResult;

			/** Disposes of this widget, supressing the finalizer */
			dispose(): void;

			/** Gets a string that represents the current object with its ID if specified. */
			ToString(): string;
		}
	}

	export namespace Eto.Forms.OpenFileDialog {
		export interface IHandler extends
			Eto.Forms.FileDialog.IHandler,
			Eto.Forms.CommonDialog.IHandler,
			Eto.Widget.IHandler {
			MultiSelect: boolean;

			readonly Filenames: Iterable<string>;
		}
	}

	export namespace Eto.Forms {
		/**
		 * Dialog for a user to pick the default application for the given file.
		 *
		 * The OpenWithDialog on some platforms may run asynchronously, and return immediately
		 * after the {@link Eto.Forms.CommonDialog.ShowDialog(Eto.Forms.Control)} call. On some
		 * platforms, like Windows, it might not even look like a standard dialog.
		 */
		export class OpenWithDialog implements
			Eto.IHandlerSource {
			/** Initializes a new instance of the {@link Eto.Forms.OpenWithDialog} class. */
			constructor(filepath: string);

			/**
			 * Gets the platform that was used to create the {@link Eto.Widget.Handler} for this
			 * widget
			 *
			 * This gets set to the current {@link Eto.Platform.Instance} during the construction of
			 * the object
			 */
			readonly Platform: Eto.Platform;

			/** Gets the platform-specific handler for this widget */
			Handler: unknown;

			/** Gets the native platform-specific handle for integration purposes */
			readonly NativeHandle: unknown;

			/** Gets the dictionary of properties for this widget */
			readonly Properties: Eto.PropertyStore;

			/** Gets or sets the ID of this widget */
			ID: string;

			/**
			 * Gets or sets the style of this widget
			 *
			 * Styles allow you to attach custom platform-specific logic to a widget. In your
			 * platform-specific assembly, use {@link Style.Add{H}(string, StyleHandler{H})} to add
			 * the style logic with the same id.
			 */
			Style: string;

			/**
			 * Gets the instance of the platform-specific object
			 *
			 * This can sometimes be useful to get the platform-specific object. Some handlers may
			 * not have any backing object for its functionality, so this may be null.  It is more
			 * preferred to use the {@link Eto.Widget.Handler} and cast that to the platform-specific
			 * handler class which can give you additional methods and helpers to do common tasks.
			 * For example, the {@link Eto.Forms.Application} object's handler for OS X has a
			 * AddFullScreenMenuItem property to specify if you want full screen support in your app.
			 */
			readonly ControlObject: unknown;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Widget} has been disposed.
			 *
			 * When the widget is disposed, it can no longer be used.
			 */
			IsDisposed: boolean;

			/** Shows the dialog with the specified parent, blocking until a result is returned. */
			ShowDialog(parent: Eto.Forms.Control): Eto.Forms.DialogResult;

			/**
			 * Shows the dialog with the specified parent window, blocking until a result is
			 * returned.
			 */
			ShowDialog(parent: Eto.Forms.Window): Eto.Forms.DialogResult;

			/** Disposes of this widget, supressing the finalizer */
			dispose(): void;

			/** Gets a string that represents the current object with its ID if specified. */
			ToString(): string;
		}
	}

	export namespace Eto.Forms.OpenWithDialog {
		export interface IHandler extends
			Eto.Forms.CommonDialog.IHandler,
			Eto.Widget.IHandler {
			FilePath: string;
		}
	}

	export namespace Eto.Forms {
		/** Represents either horizontal or vertical orientation for controls. */
		export enum Orientation {
			/** The control or layout should be oriented horizontally. */
			Horizontal = 0,

			/** The control or layout should be oriented vertically. */
			Vertical = 1,
		}
	}

	export namespace Eto.Forms {
		/** Settings for a single printed page. Not currently mapped to any platform. */
		export class PageSettings implements
			Eto.IHandlerSource {
			constructor();

			/** Gets the printable area for the page */
			readonly PrintableArea: Eto.Drawing.RectangleF;

			/**
			 * Gets the platform that was used to create the {@link Eto.Widget.Handler} for this
			 * widget
			 *
			 * This gets set to the current {@link Eto.Platform.Instance} during the construction of
			 * the object
			 */
			readonly Platform: Eto.Platform;

			/** Gets the platform-specific handler for this widget */
			Handler: unknown;

			/** Gets the native platform-specific handle for integration purposes */
			readonly NativeHandle: unknown;

			/** Gets the dictionary of properties for this widget */
			readonly Properties: Eto.PropertyStore;

			/** Gets or sets the ID of this widget */
			ID: string;

			/**
			 * Gets or sets the style of this widget
			 *
			 * Styles allow you to attach custom platform-specific logic to a widget. In your
			 * platform-specific assembly, use {@link Style.Add{H}(string, StyleHandler{H})} to add
			 * the style logic with the same id.
			 */
			Style: string;

			/**
			 * Gets the instance of the platform-specific object
			 *
			 * This can sometimes be useful to get the platform-specific object. Some handlers may
			 * not have any backing object for its functionality, so this may be null.  It is more
			 * preferred to use the {@link Eto.Widget.Handler} and cast that to the platform-specific
			 * handler class which can give you additional methods and helpers to do common tasks.
			 * For example, the {@link Eto.Forms.Application} object's handler for OS X has a
			 * AddFullScreenMenuItem property to specify if you want full screen support in your app.
			 */
			readonly ControlObject: unknown;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Widget} has been disposed.
			 *
			 * When the widget is disposed, it can no longer be used.
			 */
			IsDisposed: boolean;

			/** Disposes of this widget, supressing the finalizer */
			dispose(): void;

			/** Gets a string that represents the current object with its ID if specified. */
			ToString(): string;
		}
	}

	export namespace Eto.Forms.PageSettings {
		export interface IHandler extends Eto.Widget.IHandler {
			readonly PrintableArea: Eto.Drawing.RectangleF;
		}
	}

	export namespace Eto.Forms {
		/** Dialog to show when printing a document or adjusting print settings */
		export class PrintDialog implements
			Eto.IHandlerSource {
			constructor();

			/** Gets or sets the print settings the print dialog is modifying. */
			PrintSettings: Eto.Forms.PrintSettings;

			/**
			 * Gets or sets a value indicating whether the user can select to print the current
			 * selection.
			 *
			 * If this is true, the {@link Eto.Forms.PrintSettings.PrintSelection} can be set by the
			 * user to {@link Eto.Forms.PrintSelection.Selection}. You must handle this case and only
			 * generate the pages for your selected content.
			 */
			AllowSelection: boolean;

			/** Gets or sets a value indicating whether the user can select the page range. */
			AllowPageRange: boolean;

			/**
			 * Gets the platform that was used to create the {@link Eto.Widget.Handler} for this
			 * widget
			 *
			 * This gets set to the current {@link Eto.Platform.Instance} during the construction of
			 * the object
			 */
			readonly Platform: Eto.Platform;

			/** Gets the platform-specific handler for this widget */
			Handler: unknown;

			/** Gets the native platform-specific handle for integration purposes */
			readonly NativeHandle: unknown;

			/** Gets the dictionary of properties for this widget */
			readonly Properties: Eto.PropertyStore;

			/** Gets or sets the ID of this widget */
			ID: string;

			/**
			 * Gets or sets the style of this widget
			 *
			 * Styles allow you to attach custom platform-specific logic to a widget. In your
			 * platform-specific assembly, use {@link Style.Add{H}(string, StyleHandler{H})} to add
			 * the style logic with the same id.
			 */
			Style: string;

			/**
			 * Gets the instance of the platform-specific object
			 *
			 * This can sometimes be useful to get the platform-specific object. Some handlers may
			 * not have any backing object for its functionality, so this may be null.  It is more
			 * preferred to use the {@link Eto.Widget.Handler} and cast that to the platform-specific
			 * handler class which can give you additional methods and helpers to do common tasks.
			 * For example, the {@link Eto.Forms.Application} object's handler for OS X has a
			 * AddFullScreenMenuItem property to specify if you want full screen support in your app.
			 */
			readonly ControlObject: unknown;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Widget} has been disposed.
			 *
			 * When the widget is disposed, it can no longer be used.
			 */
			IsDisposed: boolean;

			/**
			 * Shows the print dialog for the specified `document`, printing after closed if the user
			 * selects to print.
			 */
			ShowDialog(
				parent: Eto.Forms.Control,
				document: Eto.Forms.PrintDocument,
			): Eto.Forms.DialogResult;

			/** Shows the dialog with the specified parent, blocking until a result is returned. */
			ShowDialog(parent: Eto.Forms.Control): Eto.Forms.DialogResult;

			/**
			 * Shows the dialog with the specified parent window, blocking until a result is
			 * returned.
			 */
			ShowDialog(parent: Eto.Forms.Window): Eto.Forms.DialogResult;

			/** Disposes of this widget, supressing the finalizer */
			dispose(): void;

			/** Gets a string that represents the current object with its ID if specified. */
			ToString(): string;
		}
	}

	export namespace Eto.Forms.PrintDialog {
		export interface IHandler extends
			Eto.Forms.CommonDialog.IHandler,
			Eto.Widget.IHandler {
			Document: Eto.Forms.PrintDocument;

			PrintSettings: Eto.Forms.PrintSettings;

			AllowPageRange: boolean;

			AllowSelection: boolean;
		}
	}

	export namespace Eto.Forms {
		/**
		 * Represents a document that can be printed
		 *
		 * A print document uses the {@link Eto.Drawing.Graphics} to render its output via the
		 * {@link Eto.Forms.PrintDocument.PrintPage} event.
		 */
		export class PrintDocument implements
			Eto.IHandlerSource {
			/**
			 * Initializes a new instance of the PrintDocument class with custom drawn content only.
			 */
			constructor();

			/**
			 * Initializes a new instance of the PrintDocument class with the specified control as
			 * the print content.
			 */
			constructor(control: Eto.Forms.Control);

			/** Gets or sets the name of the document to show in the printer queue */
			Name: string;

			/**
			 * Gets or sets the print settings for the document when printing.
			 *
			 * You can adjust the settings using the {@link Eto.Forms.PrintDialog}, or use
			 * {@link Eto.Forms.PrintDialog.ShowDialog(Eto.Forms.Control,Eto.Forms.PrintDocument)} to
			 * allow the user to adjust the settings before printing.
			 */
			PrintSettings: Eto.Forms.PrintSettings;

			/**
			 * Gets or sets the total number of pages available to be printed in this document.
			 *
			 * This must be set to the number of pages your document contains before printing or
			 * showing the print dialog.
			 */
			PageCount: number;

			/**
			 * Gets the platform that was used to create the {@link Eto.Widget.Handler} for this
			 * widget
			 *
			 * This gets set to the current {@link Eto.Platform.Instance} during the construction of
			 * the object
			 */
			readonly Platform: Eto.Platform;

			/** Gets the platform-specific handler for this widget */
			Handler: unknown;

			/** Gets the native platform-specific handle for integration purposes */
			readonly NativeHandle: unknown;

			/** Gets the dictionary of properties for this widget */
			readonly Properties: Eto.PropertyStore;

			/** Gets or sets the ID of this widget */
			ID: string;

			/**
			 * Gets or sets the style of this widget
			 *
			 * Styles allow you to attach custom platform-specific logic to a widget. In your
			 * platform-specific assembly, use {@link Style.Add{H}(string, StyleHandler{H})} to add
			 * the style logic with the same id.
			 */
			Style: string;

			/**
			 * Gets the instance of the platform-specific object
			 *
			 * This can sometimes be useful to get the platform-specific object. Some handlers may
			 * not have any backing object for its functionality, so this may be null.  It is more
			 * preferred to use the {@link Eto.Widget.Handler} and cast that to the platform-specific
			 * handler class which can give you additional methods and helpers to do common tasks.
			 * For example, the {@link Eto.Forms.Application} object's handler for OS X has a
			 * AddFullScreenMenuItem property to specify if you want full screen support in your app.
			 */
			readonly ControlObject: unknown;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Widget} has been disposed.
			 *
			 * When the widget is disposed, it can no longer be used.
			 */
			IsDisposed: boolean;

			/**
			 * Prints this document immediately using the current
			 * {@link Eto.Forms.PrintDocument.PrintSettings}
			 *
			 * This skips the print dialog, so if you want the user to adjust settings before
			 * printing, use
			 * {@link Eto.Forms.PrintDialog.ShowDialog(Eto.Forms.Control,Eto.Forms.PrintDocument)}.
			 */
			Print(): void;

			/** Disposes of this widget, supressing the finalizer */
			dispose(): void;

			/** Gets a string that represents the current object with its ID if specified. */
			ToString(): string;
		}
	}

	export namespace Eto.Forms.PrintDocument {
		export interface ICallback extends Eto.Widget.ICallback {
			OnPrinting(
				widget: Eto.Forms.PrintDocument,
				e: unknown,
			): void;

			OnPrinted(
				widget: Eto.Forms.PrintDocument,
				e: unknown,
			): void;

			OnPrintPage(
				widget: Eto.Forms.PrintDocument,
				e: Eto.Forms.PrintPageEventArgs,
			): void;
		}
	}

	export namespace Eto.Forms.PrintDocument {
		export interface IHandler extends Eto.Widget.IHandler {
			Name: string;

			PrintSettings: Eto.Forms.PrintSettings;

			PageCount: number;

			Print(): void;

			Create(): void;

			Create(control: Eto.Forms.Control): void;
		}
	}

	export namespace Eto.Forms {
		/** Event arguments when printing a page. */
		export class PrintPageEventArgs {
			/** Initializes a new instance of the {@link Eto.Forms.PrintPageEventArgs} class. */
			constructor(
				graphics: Eto.Drawing.Graphics,
				pageSize: Eto.Drawing.SizeF,
				currentPage: number,
			);

			/** Gets the graphics context to draw the page's content. */
			Graphics: Eto.Drawing.Graphics;

			/**
			 * Gets the size of the page, in device units.
			 *
			 * This should be used to position elements on the page when using the
			 * {@link Eto.Forms.PrintPageEventArgs.Graphics} to draw the page's content.
			 */
			PageSize: Eto.Drawing.SizeF;

			/** Gets the current page that is being printed. */
			CurrentPage: number;
		}
	}

	export namespace Eto.Forms {
		/** Dialog to show a print preview dialog which the user can print from */
		export class PrintPreviewDialog implements
			Eto.IHandlerSource {
			/** Initializes a new instance of the PrintPreviewDialog for the specified `document`. */
			constructor(document: Eto.Forms.PrintDocument);

			/** Gets the document the preview dialog is presenting */
			readonly Document: Eto.Forms.PrintDocument;

			/** Gets or sets the print settings the print dialog is modifying. */
			PrintSettings: Eto.Forms.PrintSettings;

			/**
			 * Gets the platform that was used to create the {@link Eto.Widget.Handler} for this
			 * widget
			 *
			 * This gets set to the current {@link Eto.Platform.Instance} during the construction of
			 * the object
			 */
			readonly Platform: Eto.Platform;

			/** Gets the platform-specific handler for this widget */
			Handler: unknown;

			/** Gets the native platform-specific handle for integration purposes */
			readonly NativeHandle: unknown;

			/** Gets the dictionary of properties for this widget */
			readonly Properties: Eto.PropertyStore;

			/** Gets or sets the ID of this widget */
			ID: string;

			/**
			 * Gets or sets the style of this widget
			 *
			 * Styles allow you to attach custom platform-specific logic to a widget. In your
			 * platform-specific assembly, use {@link Style.Add{H}(string, StyleHandler{H})} to add
			 * the style logic with the same id.
			 */
			Style: string;

			/**
			 * Gets the instance of the platform-specific object
			 *
			 * This can sometimes be useful to get the platform-specific object. Some handlers may
			 * not have any backing object for its functionality, so this may be null.  It is more
			 * preferred to use the {@link Eto.Widget.Handler} and cast that to the platform-specific
			 * handler class which can give you additional methods and helpers to do common tasks.
			 * For example, the {@link Eto.Forms.Application} object's handler for OS X has a
			 * AddFullScreenMenuItem property to specify if you want full screen support in your app.
			 */
			readonly ControlObject: unknown;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Widget} has been disposed.
			 *
			 * When the widget is disposed, it can no longer be used.
			 */
			IsDisposed: boolean;

			/** Shows the print preview dialog with the specified `parent` */
			ShowDialog(parent: Eto.Forms.Window): Eto.Forms.DialogResult;

			/** Shows the dialog with the specified parent, blocking until a result is returned. */
			ShowDialog(parent: Eto.Forms.Control): Eto.Forms.DialogResult;

			/** Disposes of this widget, supressing the finalizer */
			dispose(): void;

			/** Gets a string that represents the current object with its ID if specified. */
			ToString(): string;
		}
	}

	export namespace Eto.Forms.PrintPreviewDialog {
		export interface IHandler extends
			Eto.Forms.CommonDialog.IHandler,
			Eto.Widget.IHandler {
			Document: Eto.Forms.PrintDocument;

			PrintSettings: Eto.Forms.PrintSettings;
		}
	}

	export namespace Eto.Forms {
		/** Orientation of the printed page. */
		export enum PageOrientation {
			/** Print the page in portrait mode. */
			Portrait = 0,

			/** Print the page in landscape mode. */
			Landscape = 1,
		}
	}

	export namespace Eto.Forms {
		/** Selection mode when printing */
		export enum PrintSelection {
			/** Print all pages */
			AllPages = 0,

			/** Print the selection (defined by the application) */
			Selection = 1,

			/** Print the selected pages from {@link Eto.Forms.PrintSettings.SelectedPageRange} */
			SelectedPages = 2,
		}
	}

	export namespace Eto.Forms {
		/**
		 * Settings for printing a {@link Eto.Forms.PrintDocument}
		 *
		 * This defines the parameters for printing such as how many copies, page range,
		 * orientation, etc.
		 */
		export class PrintSettings implements
			Eto.IHandlerSource {
			/** Initializes a new instance of the {@link Eto.Forms.PrintSettings} class. */
			constructor();

			constructor(handler: Eto.Forms.PrintSettings.IHandler);

			/** Gets or sets the number of copies to print. */
			Copies: number;

			/** Gets or sets the maximum page range the user can select. */
			MaximumPageRange: Eto.Forms.Range$1<number>;

			/**
			 * Gets or sets the user's selected page range.
			 *
			 * This will control which pages get rendered with the
			 * {@link Eto.Forms.PrintDocument.PrintPage}
			 */
			SelectedPageRange: Eto.Forms.Range$1<number>;

			/** Gets or sets the orientation of the page when printing */
			Orientation: Eto.Forms.PageOrientation;

			/** Gets or sets the print selection mode */
			PrintSelection: Eto.Forms.PrintSelection;

			/**
			 * Gets or sets a value indicating whether to collate the copies.
			 *
			 * When true , all pages of the document will be printed together for each copy. e.g.
			 * 123, 123, 123. When false , each page will print all copies together, e.g. 111, 222,
			 * 333.
			 */
			Collate: boolean;

			/**
			 * Gets or sets a value indicating whether to print in reverse.
			 *
			 * Printing in reverse will typically finish the job with the first page of the document
			 * at the top, since most printers stack the pages from bottom to top.
			 */
			Reverse: boolean;

			/**
			 * Gets the platform that was used to create the {@link Eto.Widget.Handler} for this
			 * widget
			 *
			 * This gets set to the current {@link Eto.Platform.Instance} during the construction of
			 * the object
			 */
			readonly Platform: Eto.Platform;

			/** Gets the platform-specific handler for this widget */
			Handler: unknown;

			/** Gets the native platform-specific handle for integration purposes */
			readonly NativeHandle: unknown;

			/** Gets the dictionary of properties for this widget */
			readonly Properties: Eto.PropertyStore;

			/** Gets or sets the ID of this widget */
			ID: string;

			/**
			 * Gets or sets the style of this widget
			 *
			 * Styles allow you to attach custom platform-specific logic to a widget. In your
			 * platform-specific assembly, use {@link Style.Add{H}(string, StyleHandler{H})} to add
			 * the style logic with the same id.
			 */
			Style: string;

			/**
			 * Gets the instance of the platform-specific object
			 *
			 * This can sometimes be useful to get the platform-specific object. Some handlers may
			 * not have any backing object for its functionality, so this may be null.  It is more
			 * preferred to use the {@link Eto.Widget.Handler} and cast that to the platform-specific
			 * handler class which can give you additional methods and helpers to do common tasks.
			 * For example, the {@link Eto.Forms.Application} object's handler for OS X has a
			 * AddFullScreenMenuItem property to specify if you want full screen support in your app.
			 */
			readonly ControlObject: unknown;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Widget} has been disposed.
			 *
			 * When the widget is disposed, it can no longer be used.
			 */
			IsDisposed: boolean;

			/** Disposes of this widget, supressing the finalizer */
			dispose(): void;

			/** Gets a string that represents the current object with its ID if specified. */
			ToString(): string;
		}
	}

	export namespace Eto.Forms.PrintSettings {
		export interface IHandler extends Eto.Widget.IHandler {
			Copies: number;

			MaximumPageRange: Eto.Forms.Range$1<number>;

			SelectedPageRange: Eto.Forms.Range$1<number>;

			PrintSelection: Eto.Forms.PrintSelection;

			Orientation: Eto.Forms.PageOrientation;

			Collate: boolean;

			Reverse: boolean;
		}
	}

	export namespace Eto.Forms {
		/**
		 * [Generic type factory] Represents an immutable, inclusive start/end range of
		 * {@link System.IComparable<>} values
		 */
		export function Range$(T: IType): typeof Range$1<any>;

		/**
		 * Represents an immutable, inclusive start/end range of {@link System.IComparable<>}
		 * values
		 */
		export class Range$1<T> {
			/**
			 * Initializes a new instance of the {@link Eto.Forms.Range<>} struct with a value for
			 * both the start and end.
			 */
			new(value: T): Range$1<T>;

			/** Initializes a new instance of the {@link Eto.Forms.Range<>} struct. */
			new(
				start: T,
				end: T,
			): Range$1<T>;

			/** Gets the start value of the range */
			readonly Start: T;

			/** Gets the end value of the range. */
			readonly End: T;

			/** Creates a copy of the current range with a different start value. */
			WithStart(start: T): Eto.Forms.Range$1<T>;

			/** Creates a copy of the current range with a different end value. */
			WithEnd(end: T): Eto.Forms.Range$1<T>;

			/**
			 * Determines if the specified `value` is between or equal to the
			 * {@link Eto.Forms.Range`1.Start} and {@link Eto.Forms.Range`1.End} of this range.
			 */
			Contains(value: T): boolean;

			/**
			 * Iterates the range between the start and end values.
			 *
			 * This can be used to return an enumerable that iterates between the start and end of
			 * the range given the specified `increment` function.
			 */
			Iterate(increment: (arg1: T) => T): Iterable<T>;

			/**
			 * Determines if the specified `range` touches (but doesn't intersect) this instance.
			 *
			 * This can be used to determine if one range comes after or before another range, given
			 * the specified `increment` function. The increment function is used as this class does
			 * not assume how to increment each value, e.g. for a {@link System.DateTime} value, you
			 * can increment by day, minute, second, etc.
			 */
			Touches(
				range: Eto.Forms.Range$1<T>,
				increment: (arg1: T) => T,
			): boolean;

			/** Determines if the specified `range` intersects (overlaps) this instance. */
			Intersects(range: Eto.Forms.Range$1<T>): boolean;

			/** Gets the intersection of this instance and the specified `range`. */
			Intersect(range: Eto.Forms.Range$1<T>): Eto.Forms.Range$1<T> | undefined;

			/**
			 * Gets the union of this instance and the specified `range`, including touching ranges.
			 *
			 * This is similar to {@link Eto.Forms.Range`1.Union(Eto.Forms.Range{`0})}, however this
			 * handles when the two ranges are touching. The `increment` delegate is used to
			 * determine if the ranges are touching by incrementing the ends of the ranges and
			 * comparing that value to the start of the other range.
			 */
			Union(
				range: Eto.Forms.Range$1<T>,
				increment: (arg1: T) => T,
			): Eto.Forms.Range$1<T> | undefined;

			/**
			 * Gets the union of this instance and an intersecting `range`.
			 *
			 * This is similar to
			 * {@link Eto.Forms.Range`1.Union(Eto.Forms.Range{`0},System.Func{`0,`0})}, however this
			 * only handles when the two ranges are intersecting. To union two ranges that touch, use
			 * the {@link Eto.Forms.Range`1.Union(Eto.Forms.Range{`0},System.Func{`0,`0})} method
			 * instead.
			 */
			Union(range: Eto.Forms.Range$1<T>): Eto.Forms.Range$1<T> | undefined;

			/**
			 * Determines whether the specified {@link System.Object} is equal to the current
			 * {@link Eto.Forms.Range<>}.
			 */
			Equals(obj: unknown): boolean;

			/** Serves as a hash function for a {@link Eto.Forms.Range<>} object. */
			GetHashCode(): number;

			/**
			 * Returns a {@link System.String} that represents the current {@link Eto.Forms.Range<>}.
			 */
			ToString(): string;

			/**
			 * Determines whether the specified `other` range is equal to the current
			 * {@link Eto.Forms.Range<>}.
			 */
			Equals(other: Eto.Forms.Range$1<T>): boolean;
		}
	}

	export namespace Eto.Forms {
		/** Extensions for the {@link Eto.Forms.Range<>} structure */
		export namespace RangeExtensions {
			/** Gets the interval for the specified `range` between the start and end dates. */
			export function Interval(range: Eto.Forms.Range$1<DateTime>): number;

			/** Gets the length of the specified `range` between the start and end values. */
			export function Length(range: Eto.Forms.Range$1<number>): number;

			/**
			 * Creates a new range starting at the same position as the specified `range` and a new
			 * length.
			 */
			export function WithLength(
				range: Eto.Forms.Range$1<number>,
				length: number,
			): Eto.Forms.Range$1<number>;
		}
	}

	export namespace Eto.Forms {
		/** Helpers for the {@link Eto.Forms.Range<>} structure. */
		export namespace Range {
			/** Creates a new integer range with the specified start and length. */
			export function FromLength(
				start: number,
				length: number,
			): Eto.Forms.Range$1<number>;

			/** Creates a new long range with the specified start and length. */
			export function FromLength(
				start: number,
				length: number,
			): Eto.Forms.Range$1<number>;
		}
	}

	export namespace Eto.Forms {
		/** Command to relay execution and execute state to delegates */
		export class RelayCommand {
			/**
			 * Initializes a new instance of the {@link Eto.Forms.RelayCommand} class.
			 *
			 * The {@link Eto.Forms.RelayCommand`1.CanExecute(System.Object)} will always return
			 * true.
			 */
			constructor(execute: () => void);

			/**
			 * Initializes a new instance of the {@link Eto.Forms.RelayCommand} class.
			 *
			 * This constructor allows you to specify whether the command can be executed. If the
			 * state of the `canExecute` delegate changes, you can call
			 * {@link Eto.Forms.RelayCommand`1.UpdateCanExecute} to tell the control that is bound to
			 * this command to call the delegate again.
			 */
			constructor(
				execute: () => void,
				canExecute: () => boolean,
			);

			CanExecute(parameter: unknown): boolean;

			Execute(parameter: unknown): void;

			UpdateCanExecute(): void;
		}
	}

	export namespace Eto.Forms {
		/** [Generic type factory] Command to relay execution and execute state to delegates */
		export function RelayCommand$(T: IType): typeof RelayCommand$1<any>;

		/** Command to relay execution and execute state to delegates */
		export class RelayCommand$1<T> {
			/**
			 * Initializes a new instance of the {@link Eto.Forms.RelayCommand<>} class.
			 *
			 * The {@link Eto.Forms.RelayCommand`1.CanExecute(System.Object)} will always return
			 * true.
			 */
			new(execute: (arg1: T) => void): RelayCommand$1<T>;

			/**
			 * Initializes a new instance of the {@link Eto.Forms.RelayCommand<>} class.
			 *
			 * This constructor allows you to specify whether the command can be executed. If the
			 * state of the `canExecute` delegate changes, you can call
			 * {@link Eto.Forms.RelayCommand`1.UpdateCanExecute} to tell the control that is bound to
			 * this command to call the delegate again.
			 */
			new(
				execute: (arg1: T) => void,
				canExecute: (value: T) => boolean,
			): RelayCommand$1<T>;

			/** Determines whether this command can execute with the specified parameter. */
			CanExecute(parameter: unknown): boolean;

			/** Executes the command with the specified parameter. */
			Execute(parameter: unknown): void;

			/**
			 * Tells consumers of this command that the
			 * {@link Eto.Forms.RelayCommand`1.CanExecute(System.Object)} state has changed and
			 * should be queried again.
			 */
			UpdateCanExecute(): void;
		}
	}

	export namespace Eto.Forms {
		/**
		 * [Generic type factory] A {@link Eto.Forms.IValueCommand<>} class that uses delegates
		 * for getting and setting the value of the command
		 *
		 * This can be used to delegate the getting/setting of the value to separate methods.
		 * Call {@link Eto.Forms.RelayValueCommand`2.UpdateValue} to signal that the value has
		 * changed.
		 */
		export function RelayValueCommand$(TValue: IType): typeof RelayValueCommand$1<any>;

		/**
		 * A {@link Eto.Forms.IValueCommand<>} class that uses delegates for getting and setting
		 * the value of the command
		 *
		 * This can be used to delegate the getting/setting of the value to separate methods.
		 * Call {@link Eto.Forms.RelayValueCommand`2.UpdateValue} to signal that the value has
		 * changed.
		 */
		export class RelayValueCommand$1<TValue> implements Eto.Forms.IValueCommand$1<TValue> {
			/** Initializes a new instance of the {@link Eto.Forms.RelayValueCommand<>} class. */
			new(
				getValue: () => TValue,
				setValue: (arg1: TValue) => void,
				execute?: () => void,
				canExecute?: () => boolean,
			): RelayValueCommand$1<TValue>;

			UpdateValue(): void;

			GetValue(parameter: unknown): TValue;

			SetValue(
				parameter: unknown,
				value: TValue,
			): void;

			CanExecute(parameter: unknown): boolean;

			Execute(parameter: unknown): void;

			UpdateCanExecute(): void;
		}
	}

	export namespace Eto.Forms {
		/**
		 * [Generic type factory] A {@link Eto.Forms.IValueCommand<>} class that uses delegates
		 * for getting and setting the value of the command with the command parameter.
		 *
		 * This can be used to delegate the getting/setting of the value to separate methods.
		 * Call {@link Eto.Forms.RelayValueCommand`2.UpdateValue} to signal that the value has
		 * changed.
		 */
		export function RelayValueCommand$(TParameter: IType, TValue: IType): typeof RelayValueCommand$2<any, any>;

		/**
		 * A {@link Eto.Forms.IValueCommand<>} class that uses delegates for getting and setting
		 * the value of the command with the command parameter.
		 *
		 * This can be used to delegate the getting/setting of the value to separate methods.
		 * Call {@link Eto.Forms.RelayValueCommand`2.UpdateValue} to signal that the value has
		 * changed.
		 */
		export class RelayValueCommand$2<TParameter, TValue> implements Eto.Forms.IValueCommand$1<TValue> {
			/** Initializes a new instance of the {@link Eto.Forms.RelayValueCommand<,>} class. */
			new(
				getValue: (arg1: TParameter) => TValue,
				setValue: (arg1: TParameter, arg2: TValue) => void,
				execute?: (arg1: TParameter) => void,
				canExecute?: (value: TParameter) => boolean,
			): RelayValueCommand$2<TParameter, TValue>;

			/**
			 * Signals that the value has been updated and the delegate to get the value should be
			 * called.
			 */
			UpdateValue(): void;

			/** Gets the value. */
			GetValue(parameter: unknown): TValue;

			/** Sets the value. */
			SetValue(
				parameter: unknown,
				value: TValue,
			): void;

			CanExecute(parameter: unknown): boolean;

			Execute(parameter: unknown): void;

			UpdateCanExecute(): void;
		}
	}

	export namespace Eto.Forms {
		/** Dialog for the user to select a file to save */
		export class SaveFileDialog implements
			Eto.IHandlerSource {
			constructor();

			/** Gets or sets the full name and path of the file that is selected */
			FileName: string;

			/**
			 * Gets the collection of available file filters the user can select from.
			 *
			 * Add entries to this collection to set the filters the user can select when the file
			 * dialog is shown.  Some platforms may either disable (OS X) or hide (GTK/WinForms/WPF)
			 * files that do not match the currently selected filter.
			 */
			readonly Filters: unknown;

			/**
			 * Gets or sets the index of the current filter in the
			 * {@link Eto.Forms.FileDialog.Filters} collection
			 */
			CurrentFilterIndex: number;

			/**
			 * Gets or sets the currently selected filter from the
			 * {@link Eto.Forms.FileDialog.Filters} collection.
			 *
			 * This should always match an instance of a filter in the
			 * {@link Eto.Forms.FileDialog.Filters} collection, otherwise the current filter will be
			 * set to null.
			 */
			CurrentFilter: Eto.Forms.FileFilter;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Forms.FileDialog} checks if
			 * the file exists  before the user can close the dialog.
			 */
			CheckFileExists: boolean;

			/** Gets or sets the title of the dialog. */
			Title: string;

			/**
			 * Gets or sets the directory the file dialog will show files.
			 *
			 * You can use {@link Eto.EtoEnvironment.GetFolderPath(Eto.EtoSpecialFolder)} to set the
			 * initial value of the directory, though the user should be able to change the folder
			 * and keep it
			 */
			Directory: unknown;

			/**
			 * Gets the platform that was used to create the {@link Eto.Widget.Handler} for this
			 * widget
			 *
			 * This gets set to the current {@link Eto.Platform.Instance} during the construction of
			 * the object
			 */
			readonly Platform: Eto.Platform;

			/** Gets the platform-specific handler for this widget */
			Handler: unknown;

			/** Gets the native platform-specific handle for integration purposes */
			readonly NativeHandle: unknown;

			/** Gets the dictionary of properties for this widget */
			readonly Properties: Eto.PropertyStore;

			/** Gets or sets the ID of this widget */
			ID: string;

			/**
			 * Gets or sets the style of this widget
			 *
			 * Styles allow you to attach custom platform-specific logic to a widget. In your
			 * platform-specific assembly, use {@link Style.Add{H}(string, StyleHandler{H})} to add
			 * the style logic with the same id.
			 */
			Style: string;

			/**
			 * Gets the instance of the platform-specific object
			 *
			 * This can sometimes be useful to get the platform-specific object. Some handlers may
			 * not have any backing object for its functionality, so this may be null.  It is more
			 * preferred to use the {@link Eto.Widget.Handler} and cast that to the platform-specific
			 * handler class which can give you additional methods and helpers to do common tasks.
			 * For example, the {@link Eto.Forms.Application} object's handler for OS X has a
			 * AddFullScreenMenuItem property to specify if you want full screen support in your app.
			 */
			readonly ControlObject: unknown;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Widget} has been disposed.
			 *
			 * When the widget is disposed, it can no longer be used.
			 */
			IsDisposed: boolean;

			/** Shows the dialog with the specified parent, blocking until a result is returned. */
			ShowDialog(parent: Eto.Forms.Control): Eto.Forms.DialogResult;

			/**
			 * Shows the dialog with the specified parent window, blocking until a result is
			 * returned.
			 */
			ShowDialog(parent: Eto.Forms.Window): Eto.Forms.DialogResult;

			/** Disposes of this widget, supressing the finalizer */
			dispose(): void;

			/** Gets a string that represents the current object with its ID if specified. */
			ToString(): string;
		}
	}

	export namespace Eto.Forms.SaveFileDialog {
		export interface IHandler extends
			Eto.Forms.FileDialog.IHandler,
			Eto.Forms.CommonDialog.IHandler,
			Eto.Widget.IHandler {
		}
	}

	export namespace Eto.Forms {
		/** Represents a display on the system. */
		export class Screen implements
			Eto.IHandlerSource {
			/** Initializes a new instance of the {@link Eto.Forms.Screen} class. */
			constructor();

			constructor(handler: Eto.Forms.Screen.IHandler);

			/** Gets an enumerable of display screens available on the current system. */
			static readonly Screens: Iterable<Eto.Forms.Screen>;

			/** Gets the display bounds of all screens on the current system. */
			static readonly DisplayBounds: Eto.Drawing.RectangleF;

			/**
			 * Gets the primary screen of the current system.
			 *
			 * This is typically the user's main screen.
			 */
			static readonly PrimaryScreen: Eto.Forms.Screen;

			/** Gets the logical Dots/Pixels Per Inch of the screen. */
			readonly DPI: number;

			/**
			 * Gets the logical scale of the pixels of the screen vs. points.
			 *
			 * The scale can be used to translate points to pixels.  E.g. var pixels = points *
			 * screen.Scale; This is useful when creating fonts that need to be a certain pixel size.
			 *  Since this is a logical scale, this will give you the 'recommended' pixel size that
			 * will appear to be the same physical size, even on retina displays.
			 */
			readonly Scale: number;

			/**
			 * Gets the real Dots/Pixels Per Inch of the screen, accounting for retina displays.
			 *
			 * This is similar to {@link Eto.Forms.Screen.DPI}, however will give you the 'real' DPI
			 * of the screen. For example, a Retina display on OS X will have the RealDPI twice the
			 * DPI reported.
			 */
			readonly RealDPI: number;

			/**
			 * Gets the real scale of the pixels of the screen vs. points.
			 *
			 * The scale can be used to translate points to 'real' pixels.  E.g. var pixels = points
			 * * screen.Scale; This is useful when creating fonts that need to be a certain pixel
			 * size.  Since this is a real scale, this will give you the actual pixel size.  This
			 * means on retina displays on OS X will appear to be half the physical size as regular
			 * displays.
			 */
			readonly RealScale: number;

			/**
			 * Gets the bounds of the display in the {@link Eto.Forms.Screen.DisplayBounds} area.
			 *
			 * The primary screen's upper left corner is always located at 0,0. A negative X/Y
			 * indicates that the screen location is to the left or top of the primary screen. A
			 * positive X/Y indicates that the screen location is to the right or bottom of the
			 * primary screen.
			 */
			readonly Bounds: Eto.Drawing.RectangleF;

			/**
			 * Gets the working area of the display, excluding any menu/task bars, docks, etc.
			 *
			 * This is useful to position your window in the usable area of the screen.
			 */
			readonly WorkingArea: Eto.Drawing.RectangleF;

			/** Gets the number of bits each pixel uses to represent its color value. */
			readonly BitsPerPixel: number;

			/** Gets a value indicating whether this screen is the primary/main screen. */
			readonly IsPrimary: boolean;

			/**
			 * Gets the number of physical pixels per logical pixel of this display.
			 *
			 * On Retina/HighDPI displays, this will usually return 2.0, but can also be a fraction
			 * of pixels.   Non-retina will return 1.0.  This essentially returns the value of
			 * {@link Eto.Forms.Screen.RealScale} divided by {@link Eto.Forms.Screen.Scale}.
			 */
			readonly LogicalPixelSize: number;

			/**
			 * Gets the platform that was used to create the {@link Eto.Widget.Handler} for this
			 * widget
			 *
			 * This gets set to the current {@link Eto.Platform.Instance} during the construction of
			 * the object
			 */
			readonly Platform: Eto.Platform;

			/** Gets the platform-specific handler for this widget */
			Handler: unknown;

			/** Gets the native platform-specific handle for integration purposes */
			readonly NativeHandle: unknown;

			/** Gets the dictionary of properties for this widget */
			readonly Properties: Eto.PropertyStore;

			/** Gets or sets the ID of this widget */
			ID: string;

			/**
			 * Gets or sets the style of this widget
			 *
			 * Styles allow you to attach custom platform-specific logic to a widget. In your
			 * platform-specific assembly, use {@link Style.Add{H}(string, StyleHandler{H})} to add
			 * the style logic with the same id.
			 */
			Style: string;

			/**
			 * Gets the instance of the platform-specific object
			 *
			 * This can sometimes be useful to get the platform-specific object. Some handlers may
			 * not have any backing object for its functionality, so this may be null.  It is more
			 * preferred to use the {@link Eto.Widget.Handler} and cast that to the platform-specific
			 * handler class which can give you additional methods and helpers to do common tasks.
			 * For example, the {@link Eto.Forms.Application} object's handler for OS X has a
			 * AddFullScreenMenuItem property to specify if you want full screen support in your app.
			 */
			readonly ControlObject: unknown;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Widget} has been disposed.
			 *
			 * When the widget is disposed, it can no longer be used.
			 */
			IsDisposed: boolean;

			/** Gets a copy of a portion of the screen as an image */
			GetImage(rect: Eto.Drawing.RectangleF): Eto.Drawing.Image;

			/**
			 * Gets the screen that contains the specified `point`, or the closest screen to the
			 * point if it is outside the bounds of all screens.
			 */
			static FromPoint(point: Eto.Drawing.PointF): Eto.Forms.Screen;

			/**
			 * Gets the screen that encompases the biggest part of the specified `rectangle`, or the
			 * closest screen to the rectangle if it is outside the bounds of all screens..
			 */
			static FromRectangle(rectangle: Eto.Drawing.RectangleF): Eto.Forms.Screen;

			/** Disposes of this widget, supressing the finalizer */
			dispose(): void;

			/** Gets a string that represents the current object with its ID if specified. */
			ToString(): string;
		}
	}

	export namespace Eto.Forms.Screen {
		export interface IHandler extends Eto.Widget.IHandler {
			readonly Scale: number;

			readonly RealScale: number;

			readonly BitsPerPixel: number;

			readonly Bounds: Eto.Drawing.RectangleF;

			readonly WorkingArea: Eto.Drawing.RectangleF;

			readonly IsPrimary: boolean;

			GetImage(rect: Eto.Drawing.RectangleF): Eto.Drawing.Image;
		}
	}

	export namespace Eto.Forms.Screen {
		export interface IScreensHandler {
			readonly Screens: Iterable<Eto.Forms.Screen>;

			readonly PrimaryScreen: Eto.Forms.Screen;
		}
	}

	export namespace Eto.Forms {
		/** Segmented item that can be clicked. */
		export class ButtonSegmentedItem implements
			Eto.IHandlerSource,
			Eto.Forms.IBindable {
			/** Initializes a new instance of the {@link Eto.Forms.ButtonSegmentedItem} class. */
			constructor();

			/**
			 * Initializes a new instance of the {@link Eto.Forms.ButtonSegmentedItem} class with the
			 * specified command.
			 */
			constructor(command: Eto.Forms.Command);

			/**
			 * Gets the parent button this item belongs to.
			 *
			 * Note this is only set after adding your item to the
			 * {@link Eto.Forms.SegmentedButton.Items} collection.
			 */
			Parent: Eto.Forms.SegmentedButton;

			/** Gets or sets the text to display for this segment. */
			Text: string;

			/** Gets or sets the ToolTip to display for this segment */
			ToolTip: string;

			/** Gets or sets the image to display in this segment. */
			Image: Eto.Drawing.Image;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Forms.SegmentedItem} is
			 * enabled.
			 */
			Enabled: boolean;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Forms.SegmentedItem} is
			 * visible.
			 */
			Visible: boolean;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Forms.SegmentedItem} is
			 * selected.
			 */
			Selected: boolean;

			/** Gets or sets the width of this segment, or -1 to auto size. */
			Width: number;

			/**
			 * Gets or sets the command to invoke when the segmented item is pressed.
			 *
			 * This will invoke the specified command when the segmented item is pressed. The
			 * {@link System.Windows.Input.ICommand.CanExecute(System.Object)} will also used to set
			 * the enabled/disabled state of the segmented item.
			 */
			Command: unknown;

			/**
			 * Gets or sets the parameter to pass to the {@link Eto.Forms.SegmentedItem.Command} when
			 * executing or determining its CanExecute state.
			 */
			CommandParameter: unknown;

			/**
			 * Gets or sets the parent widget which this widget has been added to, if any
			 *
			 * When implementing child widgets that can participate in the context based binding
			 * (MVVM), You can set this to the parent widget when it is added or removed to it
			 * (usually via a collection).  Note that you should typically provide a public new
			 * [ParentWidget] Parent { get; } property  so that consumers of your API cannot set the
			 * parent to an invalid value.
			 */
			Parent: Eto.Widget;

			/**
			 * Gets an enumeration of all parent widgets in the heirarchy by traversing the
			 * {@link Eto.Forms.BindableWidget.Parent} property.
			 */
			readonly Parents: Iterable<Eto.Widget>;

			/**
			 * Gets or sets the data context for this widget for binding
			 *
			 * Subclasses may override the standard behaviour so that hierarchy of widgets can be
			 * taken into account.  For example, a Control may return the data context of a parent,
			 * if it is not set explicitly.
			 */
			DataContext: unknown;

			/** Gets the collection of bindings that are attached to this widget */
			readonly Bindings: Eto.Forms.BindingCollection;

			/**
			 * Gets a value indicating that the {@link Eto.Forms.BindableWidget.DataContext} property
			 * is changing.
			 *
			 * This can be used to determine when to allow certain logic during the update of the
			 * data context.  It is used to disable binding setters on the model when the data
			 * context changes so that a binding does not cause the view model to be updated when the
			 * state hasn't been fully set yet.
			 */
			IsDataContextChanging: boolean;

			/**
			 * Gets the platform that was used to create the {@link Eto.Widget.Handler} for this
			 * widget
			 *
			 * This gets set to the current {@link Eto.Platform.Instance} during the construction of
			 * the object
			 */
			readonly Platform: Eto.Platform;

			/** Gets the platform-specific handler for this widget */
			Handler: unknown;

			/** Gets the native platform-specific handle for integration purposes */
			readonly NativeHandle: unknown;

			/** Gets the dictionary of properties for this widget */
			readonly Properties: Eto.PropertyStore;

			/** Gets or sets the ID of this widget */
			ID: string;

			/**
			 * Gets or sets the style of this widget
			 *
			 * Styles allow you to attach custom platform-specific logic to a widget. In your
			 * platform-specific assembly, use {@link Style.Add{H}(string, StyleHandler{H})} to add
			 * the style logic with the same id.
			 */
			Style: string;

			/**
			 * Gets the instance of the platform-specific object
			 *
			 * This can sometimes be useful to get the platform-specific object. Some handlers may
			 * not have any backing object for its functionality, so this may be null.  It is more
			 * preferred to use the {@link Eto.Widget.Handler} and cast that to the platform-specific
			 * handler class which can give you additional methods and helpers to do common tasks.
			 * For example, the {@link Eto.Forms.Application} object's handler for OS X has a
			 * AddFullScreenMenuItem property to specify if you want full screen support in your app.
			 */
			readonly ControlObject: unknown;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Widget} has been disposed.
			 *
			 * When the widget is disposed, it can no longer be used.
			 */
			IsDisposed: boolean;

			/**
			 * Finds a control in the parent hierarchy with the specified type and
			 * {@link Eto.Widget.ID} if specified
			 */
			FindParent<T>(id?: string): T;

			/**
			 * Finds a control in the parent hierarchy with the specified type and
			 * {@link Eto.Widget.ID} if specified
			 */
			FindParent(
				type: unknown,
				id?: string,
			): Eto.Widget;

			/** Finds a control in the parent hierarchy with the specified `id` */
			FindParent(id: string): Eto.Widget;

			/**
			 * Unbinds any bindings in the {@link Eto.Forms.BindableWidget.Bindings} collection and
			 * removes the bindings
			 *
			 * When you implement {@link Eto.Forms.IBindableWidgetContainer}, this will also unbind
			 * any of its children.
			 */
			Unbind(): void;

			/**
			 * Updates all bindings in this widget
			 *
			 * When you implement {@link Eto.Forms.IBindableWidgetContainer}, this will also update
			 * bindings for all of its children.
			 */
			UpdateBindings(mode?: Eto.Forms.BindingUpdateMode): void;

			/** Disposes of this widget, supressing the finalizer */
			dispose(): void;

			/** Gets a string that represents the current object with its ID if specified. */
			ToString(): string;
		}
	}

	export namespace Eto.Forms.ButtonSegmentedItem {
		export interface IHandler extends
			Eto.Forms.SegmentedItem.IHandler,
			Eto.Widget.IHandler {
		}
	}

	export namespace Eto.Forms {
		/** Segmented item that can have a drop down menu, and optionally be selected. */
		export class MenuSegmentedItem implements
			Eto.IHandlerSource,
			Eto.Forms.IBindable {
			/** Initializes a new instance of the {@link Eto.Forms.MenuSegmentedItem} class. */
			constructor();

			/**
			 * Initializes a new instance of the {@link Eto.Forms.MenuSegmentedItem} class with the
			 * specified command.
			 */
			constructor(command: Eto.Forms.Command);

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Forms.MenuSegmentedItem} can
			 * be selected.
			 *
			 * When this is true , the user will typically have to hold the button down to bring up
			 * the menu, otherwise a single click will bring up the menu and the item will never be
			 * selected/clicked.
			 */
			CanSelect: boolean;

			/** Gets or sets the menu to display when the user clicks the item. */
			Menu: Eto.Forms.ContextMenu;

			/**
			 * Gets the parent button this item belongs to.
			 *
			 * Note this is only set after adding your item to the
			 * {@link Eto.Forms.SegmentedButton.Items} collection.
			 */
			Parent: Eto.Forms.SegmentedButton;

			/** Gets or sets the text to display for this segment. */
			Text: string;

			/** Gets or sets the ToolTip to display for this segment */
			ToolTip: string;

			/** Gets or sets the image to display in this segment. */
			Image: Eto.Drawing.Image;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Forms.SegmentedItem} is
			 * enabled.
			 */
			Enabled: boolean;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Forms.SegmentedItem} is
			 * visible.
			 */
			Visible: boolean;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Forms.SegmentedItem} is
			 * selected.
			 */
			Selected: boolean;

			/** Gets or sets the width of this segment, or -1 to auto size. */
			Width: number;

			/**
			 * Gets or sets the command to invoke when the segmented item is pressed.
			 *
			 * This will invoke the specified command when the segmented item is pressed. The
			 * {@link System.Windows.Input.ICommand.CanExecute(System.Object)} will also used to set
			 * the enabled/disabled state of the segmented item.
			 */
			Command: unknown;

			/**
			 * Gets or sets the parameter to pass to the {@link Eto.Forms.SegmentedItem.Command} when
			 * executing or determining its CanExecute state.
			 */
			CommandParameter: unknown;

			/**
			 * Gets or sets the parent widget which this widget has been added to, if any
			 *
			 * When implementing child widgets that can participate in the context based binding
			 * (MVVM), You can set this to the parent widget when it is added or removed to it
			 * (usually via a collection).  Note that you should typically provide a public new
			 * [ParentWidget] Parent { get; } property  so that consumers of your API cannot set the
			 * parent to an invalid value.
			 */
			Parent: Eto.Widget;

			/**
			 * Gets an enumeration of all parent widgets in the heirarchy by traversing the
			 * {@link Eto.Forms.BindableWidget.Parent} property.
			 */
			readonly Parents: Iterable<Eto.Widget>;

			/**
			 * Gets or sets the data context for this widget for binding
			 *
			 * Subclasses may override the standard behaviour so that hierarchy of widgets can be
			 * taken into account.  For example, a Control may return the data context of a parent,
			 * if it is not set explicitly.
			 */
			DataContext: unknown;

			/** Gets the collection of bindings that are attached to this widget */
			readonly Bindings: Eto.Forms.BindingCollection;

			/**
			 * Gets a value indicating that the {@link Eto.Forms.BindableWidget.DataContext} property
			 * is changing.
			 *
			 * This can be used to determine when to allow certain logic during the update of the
			 * data context.  It is used to disable binding setters on the model when the data
			 * context changes so that a binding does not cause the view model to be updated when the
			 * state hasn't been fully set yet.
			 */
			IsDataContextChanging: boolean;

			/**
			 * Gets the platform that was used to create the {@link Eto.Widget.Handler} for this
			 * widget
			 *
			 * This gets set to the current {@link Eto.Platform.Instance} during the construction of
			 * the object
			 */
			readonly Platform: Eto.Platform;

			/** Gets the platform-specific handler for this widget */
			Handler: unknown;

			/** Gets the native platform-specific handle for integration purposes */
			readonly NativeHandle: unknown;

			/** Gets the dictionary of properties for this widget */
			readonly Properties: Eto.PropertyStore;

			/** Gets or sets the ID of this widget */
			ID: string;

			/**
			 * Gets or sets the style of this widget
			 *
			 * Styles allow you to attach custom platform-specific logic to a widget. In your
			 * platform-specific assembly, use {@link Style.Add{H}(string, StyleHandler{H})} to add
			 * the style logic with the same id.
			 */
			Style: string;

			/**
			 * Gets the instance of the platform-specific object
			 *
			 * This can sometimes be useful to get the platform-specific object. Some handlers may
			 * not have any backing object for its functionality, so this may be null.  It is more
			 * preferred to use the {@link Eto.Widget.Handler} and cast that to the platform-specific
			 * handler class which can give you additional methods and helpers to do common tasks.
			 * For example, the {@link Eto.Forms.Application} object's handler for OS X has a
			 * AddFullScreenMenuItem property to specify if you want full screen support in your app.
			 */
			readonly ControlObject: unknown;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Widget} has been disposed.
			 *
			 * When the widget is disposed, it can no longer be used.
			 */
			IsDisposed: boolean;

			/**
			 * Finds a control in the parent hierarchy with the specified type and
			 * {@link Eto.Widget.ID} if specified
			 */
			FindParent<T>(id?: string): T;

			/**
			 * Finds a control in the parent hierarchy with the specified type and
			 * {@link Eto.Widget.ID} if specified
			 */
			FindParent(
				type: unknown,
				id?: string,
			): Eto.Widget;

			/** Finds a control in the parent hierarchy with the specified `id` */
			FindParent(id: string): Eto.Widget;

			/**
			 * Unbinds any bindings in the {@link Eto.Forms.BindableWidget.Bindings} collection and
			 * removes the bindings
			 *
			 * When you implement {@link Eto.Forms.IBindableWidgetContainer}, this will also unbind
			 * any of its children.
			 */
			Unbind(): void;

			/**
			 * Updates all bindings in this widget
			 *
			 * When you implement {@link Eto.Forms.IBindableWidgetContainer}, this will also update
			 * bindings for all of its children.
			 */
			UpdateBindings(mode?: Eto.Forms.BindingUpdateMode): void;

			/** Disposes of this widget, supressing the finalizer */
			dispose(): void;

			/** Gets a string that represents the current object with its ID if specified. */
			ToString(): string;
		}
	}

	export namespace Eto.Forms.MenuSegmentedItem {
		export interface IHandler extends
			Eto.Forms.SegmentedItem.IHandler,
			Eto.Widget.IHandler {
			Menu: Eto.Forms.ContextMenu;

			CanSelect: boolean;
		}
	}

	export namespace Eto.Forms {
		/** Enumeration of the selection modes for the {@link Eto.Forms.SegmentedButton}. */
		export enum SegmentedSelectionMode {
			/**
			 * No selection is possible, but you can click on each segment to trigger its click
			 * event.
			 */
			None = 0,

			/**
			 * Only a single segment can be selected at a time
			 *
			 * When clicking on a selected segment in this mode it will remain selected.
			 */
			Single = 1,

			/**
			 * Multiple segments can be selected
			 *
			 * Clicking a segment will toggle its selection on or off.
			 */
			Multiple = 2,
		}
	}

	export namespace Eto.Forms {
		/**
		 * Button with multiple segments that can be clicked.
		 *
		 * The SegmentedButton allows you to group multiple buttons together visually.
		 */
		export class SegmentedButton implements
			Eto.IHandlerSource,
			Eto.Forms.IBindable,
			Eto.Forms.IMouseInputSource,
			Eto.Forms.IKeyboardInputSource {
			/** Initializes a new instance of the {@link Eto.Forms.SegmentedButton} class. */
			constructor();

			/** Gets the collection of segmented items */
			readonly Items: Eto.Forms.SegmentedItemCollection;

			/** Gets or sets the selection mode. */
			SelectionMode: Eto.Forms.SegmentedSelectionMode;

			/**
			 * Gets or sets the selected items.
			 *
			 * You can only set selected item based on the current value of
			 * {@link Eto.Forms.SegmentedButton.SelectionMode}.  For
			 * {@link Eto.Forms.SegmentedSelectionMode.Multiple}, any combination of items can be
			 * selected. For {@link Eto.Forms.SegmentedSelectionMode.Single}, only a single item will
			 * be selected. Setting multiple items in this mode will only result in a single item
			 * being selected. For {@link Eto.Forms.SegmentedSelectionMode.None}, no items can be
			 * selected.
			 */
			SelectedItems: Iterable<Eto.Forms.SegmentedItem>;

			/**
			 * Gets or sets the selected item, or null for no selection.
			 *
			 * This works when {@link Eto.Forms.SegmentedButton.SelectionMode} is either single or
			 * multiple.  When setting this value in multiple selection mode, all other selected
			 * items will be cleared.
			 */
			SelectedItem: Eto.Forms.SegmentedItem;

			/**
			 * Gets or sets the selected indexes.
			 *
			 * You can only set selected indexes based on the current value of
			 * {@link Eto.Forms.SegmentedButton.SelectionMode}.  For
			 * {@link Eto.Forms.SegmentedSelectionMode.Multiple}, any combination of indexes can be
			 * selected. For {@link Eto.Forms.SegmentedSelectionMode.Single}, only a single index
			 * will be selected. Setting multiple indexes in this mode will only result in a single
			 * index being selected. For {@link Eto.Forms.SegmentedSelectionMode.None}, no indexes
			 * can be selected.
			 */
			SelectedIndexes: Iterable<number>;

			/**
			 * Gets or sets the index of the selected item, or -1 for no selection.
			 *
			 * This works when {@link Eto.Forms.SegmentedButton.SelectionMode} is either single or
			 * multiple.  When setting this value in multiple selection mode, all other selected
			 * items will be cleared.
			 */
			SelectedIndex: number;

			/**
			 * Gets a value indicating that the control is loaded onto a form, that is it has been
			 * created, added to a parent, and shown
			 *
			 * The {@link Eto.Forms.Control.OnLoad(System.EventArgs)} method sets this value to true
			 * after cascading to all children (for a {@link Eto.Forms.Container} ) and calling the
			 * platform handler's implementation.  It is called after adding to a loaded form, or
			 * when showing a new form.  The {@link Eto.Forms.Control.OnUnLoad(System.EventArgs)}
			 * method will set this value to false when the control is removed from its parent
			 */
			readonly Loaded: boolean;

			/**
			 * Gets an enumeration of controls that are in the visual tree.
			 *
			 * This is used to specify which controls are contained by this instance that are part of
			 * the visual tree. This should include all controls including non-logical Eto controls
			 * used for layout.
			 */
			readonly VisualControls: Iterable<Eto.Forms.Control>;

			/**
			 * Gets or sets a user-defined object that contains data about the control
			 *
			 * A common use of the tag property is to store data that is associated with the control
			 * that you can later retrieve.
			 */
			Tag: unknown;

			/**
			 * Gets the logical parent control.
			 *
			 * When the control is part of the visual tree (
				 * {@link Eto.Forms.Control.IsVisualControl} is true), this returns the logical parent
				 * that contains this control. Otherwise this is the same as
				 * {@link Eto.Forms.Control.Parent}.
				 */
				readonly LogicalParent: Eto.Forms.Container;

			/** Gets a value indicating this {@link Eto.Forms.Control} is part of the visual tree. */
			IsVisualControl: boolean;

			/**
			 * Gets or sets the size of the control. Use -1 to specify auto sizing for either the
			 * width and/or height.
			 *
			 * Setting the size of controls is entirely optional as most controls will size
			 * themselves appropriately. When specifying a size, it will be used as the desired size
			 * of the control.  The container will reposition and resize the control depending on the
			 * available size.  For a {@link Eto.Forms.Window}, it is preferred to set the
			 * {@link Eto.Forms.Container.ClientSize} instead, as various platforms have different
			 * sizes of window decorations, toolbars, etc.
			 */
			Size: Eto.Drawing.Size;

			/**
			 * Gets a value indicating this control currently has mouse capture
			 *
			 * Mouse capture can happen during a handled MouseDown event until MouseUp, or it can be
			 * captured explicitly via {@link Eto.Forms.Control.CaptureMouse}.
			 */
			readonly IsMouseCaptured: boolean;

			/** Gets or sets the width of the control size. */
			Width: number;

			/** Gets or sets the height of the control size. */
			Height: number;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Forms.Control} (or its
			 * children) are enabled and accept user input.
			 *
			 * Typically when a control is disabled, the user cannot do anything with the control or
			 * any of its children. Including for example, selecting text in a text control. Certain
			 * controls can have a 'Read Only' mode, such as {@link Eto.Forms.TextBox.ReadOnly} which
			 * allow the user to  select text, but not change its contents.
			 */
			Enabled: boolean;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Forms.Control} is visible to
			 * the user.
			 *
			 * When the visibility of a control is set to false, it will not occupy space in the
			 * layout.
			 */
			Visible: boolean;

			/** Gets the container which this control has been added to, if any */
			readonly Parent: Eto.Forms.Container;

			/**
			 * Gets the visual container of this control, if any.
			 *
			 * Some containers may use other Eto controls to layout its children, such as the
			 * {@link Eto.Forms.StackLayout}. This will return the parent control that visually
			 * contains this control as opposed to {@link Eto.Forms.Control.Parent} which will return
			 * the logical parent.
			 */
			VisualParent: Eto.Forms.Container;

			/** Gets a value indicating this control has been attached to a native container */
			readonly IsAttached: boolean;

			/**
			 * Gets or sets the color for the background of the control
			 *
			 * Note that on some platforms (e.g. Mac), setting the background color of a control can
			 * change the performance characteristics of the control and its children, since it must
			 * enable layers to do so.
			 */
			BackgroundColor: Eto.Drawing.Color;

			/** Gets a value indicating whether this instance has the keyboard input focus. */
			readonly HasFocus: boolean;

			/** Gets a value indicating whether the layout of child controls is suspended. */
			readonly IsSuspended: boolean;

			/** Gets the window this control is contained in */
			readonly ParentWindow: Eto.Forms.Window;

			/**
			 * Gets the supported platform commands that can be used to hook up system functions to
			 * user defined logic
			 *
			 * This lists all available commands that can be mapped using the
			 * {@link Eto.Forms.Control.MapPlatformCommand(System.String,Eto.Forms.Command)} method
			 * of the control.
			 */
			readonly SupportedPlatformCommands: Iterable<string>;

			/** Gets the bounding rectangle of this control relative to its container */
			readonly Bounds: Eto.Drawing.Rectangle;

			/**
			 * Gets the location of the control as positioned by the container
			 *
			 * A control's location is set by the container. This can be used to determine where the
			 * control is for overlaying floating windows, menus, etc.
			 */
			readonly Location: Eto.Drawing.Point;

			/** Gets or sets the type of cursor to use when the mouse is hovering over the control */
			Cursor: Eto.Forms.Cursor;

			/** Gets or sets the tool tip to show when the mouse is hovered over the control */
			ToolTip: string;

			/**
			 * Gets or sets the tab index order for this control within its container.
			 *
			 * This sets the order when using the tab key to cycle through controls  Note that some
			 * platforms (Gtk and WinForms) may not support setting the context of the tab order to
			 * StackLayout  or DynamicLayout containers and may not behave exactly as expected. Use
			 * the {@link Eto.PlatformFeatures.TabIndexWithCustomContainers} flag to determine if it
			 * is supported.
			 */
			TabIndex: number;

			/** Gets or sets a value indicating whether this control can serve as drop target. */
			AllowDrop: boolean;

			/**
			 * Gets or sets the parent widget which this widget has been added to, if any
			 *
			 * When implementing child widgets that can participate in the context based binding
			 * (MVVM), You can set this to the parent widget when it is added or removed to it
			 * (usually via a collection).  Note that you should typically provide a public new
			 * [ParentWidget] Parent { get; } property  so that consumers of your API cannot set the
			 * parent to an invalid value.
			 */
			Parent: Eto.Widget;

			/**
			 * Gets an enumeration of all parent widgets in the heirarchy by traversing the
			 * {@link Eto.Forms.BindableWidget.Parent} property.
			 */
			readonly Parents: Iterable<Eto.Widget>;

			/**
			 * Gets or sets the data context for this widget for binding
			 *
			 * Subclasses may override the standard behaviour so that hierarchy of widgets can be
			 * taken into account.  For example, a Control may return the data context of a parent,
			 * if it is not set explicitly.
			 */
			DataContext: unknown;

			/** Gets the collection of bindings that are attached to this widget */
			readonly Bindings: Eto.Forms.BindingCollection;

			/**
			 * Gets a value indicating that the {@link Eto.Forms.BindableWidget.DataContext} property
			 * is changing.
			 *
			 * This can be used to determine when to allow certain logic during the update of the
			 * data context.  It is used to disable binding setters on the model when the data
			 * context changes so that a binding does not cause the view model to be updated when the
			 * state hasn't been fully set yet.
			 */
			IsDataContextChanging: boolean;

			/**
			 * Gets the platform that was used to create the {@link Eto.Widget.Handler} for this
			 * widget
			 *
			 * This gets set to the current {@link Eto.Platform.Instance} during the construction of
			 * the object
			 */
			readonly Platform: Eto.Platform;

			/** Gets the platform-specific handler for this widget */
			Handler: unknown;

			/** Gets the native platform-specific handle for integration purposes */
			readonly NativeHandle: unknown;

			/** Gets the dictionary of properties for this widget */
			readonly Properties: Eto.PropertyStore;

			/** Gets or sets the ID of this widget */
			ID: string;

			/**
			 * Gets or sets the style of this widget
			 *
			 * Styles allow you to attach custom platform-specific logic to a widget. In your
			 * platform-specific assembly, use {@link Style.Add{H}(string, StyleHandler{H})} to add
			 * the style logic with the same id.
			 */
			Style: string;

			/**
			 * Gets the instance of the platform-specific object
			 *
			 * This can sometimes be useful to get the platform-specific object. Some handlers may
			 * not have any backing object for its functionality, so this may be null.  It is more
			 * preferred to use the {@link Eto.Widget.Handler} and cast that to the platform-specific
			 * handler class which can give you additional methods and helpers to do common tasks.
			 * For example, the {@link Eto.Forms.Application} object's handler for OS X has a
			 * AddFullScreenMenuItem property to specify if you want full screen support in your app.
			 */
			readonly ControlObject: unknown;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Widget} has been disposed.
			 *
			 * When the widget is disposed, it can no longer be used.
			 */
			IsDisposed: boolean;

			/**
			 * Selects all items when {@link Eto.Forms.SegmentedButton.SelectionMode} is set to
			 * Multiple.
			 */
			SelectAll(): void;

			/** Clears all selected items. */
			ClearSelection(): void;

			/**
			 * Queues a repaint of the entire control on the screen and any of its children.
			 *
			 * This is only useful when the control is visible.
			 */
			Invalidate(): void;

			/**
			 * Queues a repaint of the entire control on the screen
			 *
			 * This is only useful when the control is visible.
			 */
			Invalidate(invalidateChildren: boolean): void;

			/**
			 * Queues a repaint of the specified `rect` of the control and any children.
			 *
			 * This is only useful when the control is visible.
			 */
			Invalidate(rect: Eto.Drawing.Rectangle): void;

			/**
			 * Queues a repaint of the specified `rect` of the control
			 *
			 * This is only useful when the control is visible.
			 */
			Invalidate(
				rect: Eto.Drawing.Rectangle,
				invalidateChildren: boolean,
			): void;

			/**
			 * Updates the layout of this control if necessary.
			 *
			 * This will ensure the control has had all of its layout applied so you can use its
			 * position and size right after this call. Most platforms (except WinForms) use a
			 * deferred layout system so that after adding your control to the form dynamically it
			 * won't get laid out until the next idle loop. This is useful when you need to know the
			 * dimensions of the control immediately. Note that this can be an expensive operation,
			 * so it is recommended to only call this method when necessary and after all of the
			 * controls have been added/updated.
			 */
			UpdateLayout(): void;

			/** Gets the preferred size of this control given infinite space available. */
			GetPreferredSize(): Eto.Drawing.SizeF;

			/** Gets the preferred size of this control given the specified `availableSize`. */
			GetPreferredSize(availableSize: Eto.Drawing.SizeF): Eto.Drawing.SizeF;

			/**
			 * Captures all mouse events to this control.
			 *
			 * This captures all mouse events until {@link Eto.Forms.Control.ReleaseMouseCapture} is
			 * called.  Note that not all platforms will allow a mouse capture unless the mouse is
			 * currently down.
			 */
			CaptureMouse(): boolean;

			/** Releases the mouse capture after a call to {@link Eto.Forms.Control.CaptureMouse}. */
			ReleaseMouseCapture(): void;

			/**
			 * Finds a control in the parent hierarchy with the specified type and
			 * {@link Eto.Widget.ID} if specified
			 */
			FindParent(
				type: unknown,
				id?: string,
			): Eto.Forms.Container;

			/** Finds a control in the parent hierarchy with the specified `id` */
			FindParent(id: string): Eto.Forms.Container;

			/**
			 * Detaches the control by removing it from its parent
			 *
			 * This is essentially a shortcut to myControl.Parent.Remove(myControl);
			 */
			Detach(): void;

			/**
			 * Attaches the control for direct use in a native application
			 *
			 * Use this to use a control directly in a native application.  Note that the native
			 * application must be running the same framework as the current platform.  E.g. a
			 * WinForms application can use an Eto.Forms control when using the Eto.WinForms
			 * platform.  This prepares the control by firing the {@link Eto.Forms.Control.PreLoad},
			 * {@link Eto.Forms.Control.Load}, etc. events.
			 */
			AttachNative(): void;

			/**
			 * Detaches the control when it is used in a native application, when you want to reuse
			 * the control.
			 *
			 * This should only be called after {@link Eto.Forms.Control.AttachNative} has been
			 * called, which is usually done by calling to ToNative(true) .
			 */
			DetachNative(): void;

			/**
			 * Attempts to set the keyboard input focus to this control, or the first child that
			 * accepts focus. For Windows, this will bring it to front and activate it.
			 */
			Focus(): void;

			/**
			 * Suspends the layout of child controls
			 *
			 * This can be used to optimize some platforms while adding, removing, or changing many
			 * child controls at once. It disables the calculation of control positioning until
			 * {@link Eto.Forms.Control.ResumeLayout} is called. Each call to SuspendLayout() must be
			 * balanced with a call to {@link Eto.Forms.Control.ResumeLayout}.
			 */
			SuspendLayout(): void;

			/**
			 * Resumes the layout after it has been suspended, and performs a layout
			 *
			 * This can be used to optimize some platforms while adding, removing, or changing many
			 * child controls at once. Each call to ResumeLayout() must be balanced with a call to
			 * {@link Eto.Forms.Control.SuspendLayout} before it.
			 */
			ResumeLayout(): void;

			/**
			 * Specifies a command to execute for a platform-specific command
			 *
			 * Some platforms have specific system-defined commands that can be associated with a
			 * control. For example, the Mac platform's cut/copy/paste functionality is defined by
			 * the system, and if you want to hook into it, you can use this to map it to your own
			 * defined logic. The valid values of the `systemCommand` parameter are defined by each
			 * platform, and a list can be retrieved using
			 * {@link Eto.Forms.Control.SupportedPlatformCommands}
			 */
			MapPlatformCommand(
				systemCommand: string,
				command: Eto.Forms.Command,
			): void;

			/** Converts a point from screen space to control space. */
			PointFromScreen(point: Eto.Drawing.PointF): Eto.Drawing.PointF;

			/** Converts a point from control space to screen space */
			PointToScreen(point: Eto.Drawing.PointF): Eto.Drawing.PointF;

			/** Converts a rectangle from screen space to control space. */
			RectangleToScreen(rect: Eto.Drawing.RectangleF): Eto.Drawing.RectangleF;

			/** Converts a rectangle from control space to screen space */
			RectangleFromScreen(rect: Eto.Drawing.RectangleF): Eto.Drawing.RectangleF;

			/**
			 * Starts drag operation using this control as drag source.
			 *
			 * This method can be blocking on some platforms (Wpf, WinForms), and non-blocking on
			 * others (Mac, Gtk). Use the {@link Eto.Forms.Control.DragEnd} event to determine when
			 * the drag operation is completed and get its resulting DragEffects.
			 */
			DoDragDrop(
				data: Eto.Forms.DataObject,
				allowedEffects: Eto.Forms.DragEffects,
			): void;

			/**
			 * Starts drag operation using this control as drag source.
			 *
			 * This method can be blocking on some platforms (Wpf, WinForms), and non-blocking on
			 * others (Mac, Gtk). Use the {@link Eto.Forms.Control.DragEnd} event to determine when
			 * the drag operation is completed and get its resulting DragEffects.
			 */
			DoDragDrop(
				data: Eto.Forms.DataObject,
				allowedEffects: Eto.Forms.DragEffects,
				image: Eto.Drawing.Image,
				cursorOffset: Eto.Drawing.PointF,
			): void;

			/**
			 * Triggers the StyleChanged event and re-applies the styles to this control and its
			 * children.
			 */
			TriggerStyleChanged(): void;

			/** Shows a print dialog to print the specified control */
			Print(): void;

			/**
			 * Finds a control in the parent hierarchy with the specified type and
			 * {@link Eto.Widget.ID} if specified
			 */
			FindParent<T>(id?: string): T;

			/**
			 * Finds a control in the parent hierarchy with the specified type and
			 * {@link Eto.Widget.ID} if specified
			 */
			FindParent(
				type: unknown,
				id?: string,
			): Eto.Widget;

			/** Finds a control in the parent hierarchy with the specified `id` */
			FindParent(id: string): Eto.Widget;

			/**
			 * Unbinds any bindings in the {@link Eto.Forms.BindableWidget.Bindings} collection and
			 * removes the bindings
			 *
			 * When you implement {@link Eto.Forms.IBindableWidgetContainer}, this will also unbind
			 * any of its children.
			 */
			Unbind(): void;

			/**
			 * Updates all bindings in this widget
			 *
			 * When you implement {@link Eto.Forms.IBindableWidgetContainer}, this will also update
			 * bindings for all of its children.
			 */
			UpdateBindings(mode?: Eto.Forms.BindingUpdateMode): void;

			/** Disposes of this widget, supressing the finalizer */
			dispose(): void;

			/** Gets a string that represents the current object with its ID if specified. */
			ToString(): string;
		}
	}

	export namespace Eto.Forms.SegmentedButton {
		export interface ICallback extends
			Eto.Forms.Control.ICallback,
			Eto.Widget.ICallback {
			OnItemClicked(
				widget: Eto.Forms.SegmentedButton,
				e: Eto.Forms.SegmentedItemClickEventArgs,
			): void;

			OnSelectedIndexesChanged(
				widget: Eto.Forms.SegmentedButton,
				e: unknown,
			): void;
		}
	}

	export namespace Eto.Forms.SegmentedButton {
		export interface IHandler extends
			Eto.Forms.Control.IHandler,
			Eto.Widget.IHandler {
			SelectedIndex: number;

			SelectedIndexes: Iterable<number>;

			SelectionMode: Eto.Forms.SegmentedSelectionMode;

			SelectAll(): void;

			ClearSelection(): void;

			ClearItems(): void;

			InsertItem(
				index: number,
				item: Eto.Forms.SegmentedItem,
			): void;

			RemoveItem(
				index: number,
				item: Eto.Forms.SegmentedItem,
			): void;

			SetItem(
				index: number,
				item: Eto.Forms.SegmentedItem,
			): void;
		}
	}

	export namespace Eto.Forms {
		/** Base class for items of the {@link Eto.Forms.SegmentedButton} control. */
		export class SegmentedItem implements
			Eto.IHandlerSource,
			Eto.Forms.IBindable {
			/**
			 * Gets the parent button this item belongs to.
			 *
			 * Note this is only set after adding your item to the
			 * {@link Eto.Forms.SegmentedButton.Items} collection.
			 */
			Parent: Eto.Forms.SegmentedButton;

			/** Gets or sets the text to display for this segment. */
			Text: string;

			/** Gets or sets the ToolTip to display for this segment */
			ToolTip: string;

			/** Gets or sets the image to display in this segment. */
			Image: Eto.Drawing.Image;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Forms.SegmentedItem} is
			 * enabled.
			 */
			Enabled: boolean;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Forms.SegmentedItem} is
			 * visible.
			 */
			Visible: boolean;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Forms.SegmentedItem} is
			 * selected.
			 */
			Selected: boolean;

			/** Gets or sets the width of this segment, or -1 to auto size. */
			Width: number;

			/**
			 * Gets or sets the command to invoke when the segmented item is pressed.
			 *
			 * This will invoke the specified command when the segmented item is pressed. The
			 * {@link System.Windows.Input.ICommand.CanExecute(System.Object)} will also used to set
			 * the enabled/disabled state of the segmented item.
			 */
			Command: unknown;

			/**
			 * Gets or sets the parameter to pass to the {@link Eto.Forms.SegmentedItem.Command} when
			 * executing or determining its CanExecute state.
			 */
			CommandParameter: unknown;

			/**
			 * Gets or sets the parent widget which this widget has been added to, if any
			 *
			 * When implementing child widgets that can participate in the context based binding
			 * (MVVM), You can set this to the parent widget when it is added or removed to it
			 * (usually via a collection).  Note that you should typically provide a public new
			 * [ParentWidget] Parent { get; } property  so that consumers of your API cannot set the
			 * parent to an invalid value.
			 */
			Parent: Eto.Widget;

			/**
			 * Gets an enumeration of all parent widgets in the heirarchy by traversing the
			 * {@link Eto.Forms.BindableWidget.Parent} property.
			 */
			readonly Parents: Iterable<Eto.Widget>;

			/**
			 * Gets or sets the data context for this widget for binding
			 *
			 * Subclasses may override the standard behaviour so that hierarchy of widgets can be
			 * taken into account.  For example, a Control may return the data context of a parent,
			 * if it is not set explicitly.
			 */
			DataContext: unknown;

			/** Gets the collection of bindings that are attached to this widget */
			readonly Bindings: Eto.Forms.BindingCollection;

			/**
			 * Gets a value indicating that the {@link Eto.Forms.BindableWidget.DataContext} property
			 * is changing.
			 *
			 * This can be used to determine when to allow certain logic during the update of the
			 * data context.  It is used to disable binding setters on the model when the data
			 * context changes so that a binding does not cause the view model to be updated when the
			 * state hasn't been fully set yet.
			 */
			IsDataContextChanging: boolean;

			/**
			 * Gets the platform that was used to create the {@link Eto.Widget.Handler} for this
			 * widget
			 *
			 * This gets set to the current {@link Eto.Platform.Instance} during the construction of
			 * the object
			 */
			readonly Platform: Eto.Platform;

			/** Gets the platform-specific handler for this widget */
			Handler: unknown;

			/** Gets the native platform-specific handle for integration purposes */
			readonly NativeHandle: unknown;

			/** Gets the dictionary of properties for this widget */
			readonly Properties: Eto.PropertyStore;

			/** Gets or sets the ID of this widget */
			ID: string;

			/**
			 * Gets or sets the style of this widget
			 *
			 * Styles allow you to attach custom platform-specific logic to a widget. In your
			 * platform-specific assembly, use {@link Style.Add{H}(string, StyleHandler{H})} to add
			 * the style logic with the same id.
			 */
			Style: string;

			/**
			 * Gets the instance of the platform-specific object
			 *
			 * This can sometimes be useful to get the platform-specific object. Some handlers may
			 * not have any backing object for its functionality, so this may be null.  It is more
			 * preferred to use the {@link Eto.Widget.Handler} and cast that to the platform-specific
			 * handler class which can give you additional methods and helpers to do common tasks.
			 * For example, the {@link Eto.Forms.Application} object's handler for OS X has a
			 * AddFullScreenMenuItem property to specify if you want full screen support in your app.
			 */
			readonly ControlObject: unknown;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Widget} has been disposed.
			 *
			 * When the widget is disposed, it can no longer be used.
			 */
			IsDisposed: boolean;

			/**
			 * Finds a control in the parent hierarchy with the specified type and
			 * {@link Eto.Widget.ID} if specified
			 */
			FindParent<T>(id?: string): T;

			/**
			 * Finds a control in the parent hierarchy with the specified type and
			 * {@link Eto.Widget.ID} if specified
			 */
			FindParent(
				type: unknown,
				id?: string,
			): Eto.Widget;

			/** Finds a control in the parent hierarchy with the specified `id` */
			FindParent(id: string): Eto.Widget;

			/**
			 * Unbinds any bindings in the {@link Eto.Forms.BindableWidget.Bindings} collection and
			 * removes the bindings
			 *
			 * When you implement {@link Eto.Forms.IBindableWidgetContainer}, this will also unbind
			 * any of its children.
			 */
			Unbind(): void;

			/**
			 * Updates all bindings in this widget
			 *
			 * When you implement {@link Eto.Forms.IBindableWidgetContainer}, this will also update
			 * bindings for all of its children.
			 */
			UpdateBindings(mode?: Eto.Forms.BindingUpdateMode): void;

			/** Disposes of this widget, supressing the finalizer */
			dispose(): void;

			/** Gets a string that represents the current object with its ID if specified. */
			ToString(): string;
		}
	}

	export namespace Eto.Forms.SegmentedItem {
		export interface ICallback extends Eto.Widget.ICallback {
			OnClick(
				widget: Eto.Forms.SegmentedItem,
				e: unknown,
			): void;

			OnSelectedChanged(
				widget: Eto.Forms.SegmentedItem,
				e: unknown,
			): void;
		}
	}

	export namespace Eto.Forms.SegmentedItem {
		export interface IHandler extends Eto.Widget.IHandler {
			Text: string;

			ToolTip: string;

			Image: Eto.Drawing.Image;

			Enabled: boolean;

			Visible: boolean;

			Selected: boolean;

			Width: number;
		}
	}

	export namespace Eto.Forms {
		/** Event arguments when clicking a segment in the {@link Eto.Forms.SegmentedButton}. */
		export class SegmentedItemClickEventArgs {
			/**
			 * Initializes a new instance of the {@link Eto.Forms.SegmentedItemClickEventArgs} class.
			 */
			constructor(
				item: Eto.Forms.SegmentedItem,
				index: number,
			);

			/** Gets the item that was clicked */
			readonly Item: Eto.Forms.SegmentedItem;

			/** Gets the index of the item that was clicked. */
			readonly Index: number;
		}
	}

	export namespace Eto.Forms {
		/**
		 * Collection of {@link Eto.Forms.SegmentedItem} objects for the
		 * {@link Eto.Forms.SegmentedButton}.
		 */
		export class SegmentedItemCollection {
			/** Adds an enumerable of items to the collection */
			AddRange(items: Iterable<Eto.Forms.SegmentedItem>): void;
		}
	}

	export namespace Eto.Forms {
		/** Dialog for the user to select a folder in the filesystem */
		export class SelectFolderDialog implements
			Eto.IHandlerSource {
			constructor();

			/** Gets or sets the title of dialog */
			Title: string;

			/** Gets or sets the selected directory. */
			Directory: string;

			/**
			 * Gets the platform that was used to create the {@link Eto.Widget.Handler} for this
			 * widget
			 *
			 * This gets set to the current {@link Eto.Platform.Instance} during the construction of
			 * the object
			 */
			readonly Platform: Eto.Platform;

			/** Gets the platform-specific handler for this widget */
			Handler: unknown;

			/** Gets the native platform-specific handle for integration purposes */
			readonly NativeHandle: unknown;

			/** Gets the dictionary of properties for this widget */
			readonly Properties: Eto.PropertyStore;

			/** Gets or sets the ID of this widget */
			ID: string;

			/**
			 * Gets or sets the style of this widget
			 *
			 * Styles allow you to attach custom platform-specific logic to a widget. In your
			 * platform-specific assembly, use {@link Style.Add{H}(string, StyleHandler{H})} to add
			 * the style logic with the same id.
			 */
			Style: string;

			/**
			 * Gets the instance of the platform-specific object
			 *
			 * This can sometimes be useful to get the platform-specific object. Some handlers may
			 * not have any backing object for its functionality, so this may be null.  It is more
			 * preferred to use the {@link Eto.Widget.Handler} and cast that to the platform-specific
			 * handler class which can give you additional methods and helpers to do common tasks.
			 * For example, the {@link Eto.Forms.Application} object's handler for OS X has a
			 * AddFullScreenMenuItem property to specify if you want full screen support in your app.
			 */
			readonly ControlObject: unknown;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Widget} has been disposed.
			 *
			 * When the widget is disposed, it can no longer be used.
			 */
			IsDisposed: boolean;

			/** Shows the dialog with the specified parent, blocking until a result is returned. */
			ShowDialog(parent: Eto.Forms.Control): Eto.Forms.DialogResult;

			/**
			 * Shows the dialog with the specified parent window, blocking until a result is
			 * returned.
			 */
			ShowDialog(parent: Eto.Forms.Window): Eto.Forms.DialogResult;

			/** Disposes of this widget, supressing the finalizer */
			dispose(): void;

			/** Gets a string that represents the current object with its ID if specified. */
			ToString(): string;
		}
	}

	export namespace Eto.Forms.SelectFolderDialog {
		export interface IHandler extends
			Eto.Forms.CommonDialog.IHandler,
			Eto.Widget.IHandler {
			Title: string;

			Directory: string;
		}
	}

	export namespace Eto.Forms {
		/** Methods to interact with application taskbar button. */
		export namespace Taskbar {
			/** Sets the state and progress of the application. */
			export function SetProgress(
				state: Eto.Forms.TaskbarProgressState,
				progress?: number,
			): void;
		}
	}

	export namespace Eto.Forms.Taskbar {
		export interface IHandler {
			SetProgress(
				state: Eto.Forms.TaskbarProgressState,
				progress: number,
			): void;
		}
	}

	export namespace Eto.Forms {
		/** Taskbar state for {@link Eto.Forms.Taskbar}. */
		export enum TaskbarProgressState {
			/** The default state with no progress or indication. */
			None = 0,

			/** Standard state with visible progress. */
			Progress = 1,

			/** Indeterminate state where the progressbar value will be ignored. */
			Indeterminate = 2,

			/**
			 * Error state where the taskbar will try to signal to the end user that an error
			 * occured.
			 */
			Error = 3,

			/** The paused state. */
			Paused = 4,
		}
	}

	export namespace Eto.Forms {
		/** Tool item to execute an action */
		export class ButtonToolItem implements
			Eto.IHandlerSource,
			Eto.Forms.IBindable,
			Eto.Forms.ICommandItem {
			/** Initializes a new instance of the {@link Eto.Forms.ButtonToolItem} class. */
			constructor();

			/**
			 * Initializes a new instance of the {@link Eto.Forms.ButtonToolItem} class with the
			 * specified `click` handler.
			 *
			 * This is a convenience constructor to set up the click event.
			 */
			constructor(click: unknown);

			/**
			 * Initializes a new instance of the {@link Eto.Forms.ButtonToolItem} class with the
			 * specified `command`.
			 */
			constructor(command: Eto.Forms.Command);

			/**
			 * Gets or sets the command to invoke when the tool item is pressed.
			 *
			 * This will invoke the specified command when the tool item is pressed. The
			 * {@link System.Windows.Input.ICommand.CanExecute(System.Object)} will also used to set
			 * the enabled/disabled state of the tool item.
			 */
			Command: unknown;

			/**
			 * Gets or sets the parameter to pass to the {@link Eto.Forms.ToolItem.Command} when
			 * executing or determining its CanExecute state.
			 */
			CommandParameter: unknown;

			/**
			 * Gets or sets the order of the tool item when adding to the
			 * {@link Eto.Forms.ToolItemCollection}.
			 */
			Order: number;

			/** Gets or sets the text of the item, with mnemonic. */
			Text: string;

			/** Gets or sets the tool tip to show when hovering the mouse over the item. */
			ToolTip: string;

			/** Gets or sets the image for the tool item. */
			Image: Eto.Drawing.Image;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Forms.ToolItem} is enabled.
			 */
			Enabled: boolean;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Forms.ToolItem} is visible.
			 */
			Visible: boolean;

			/** Gets or sets a user-defined tag for the tool item. */
			Tag: unknown;

			/**
			 * Gets or sets the parent widget which this widget has been added to, if any
			 *
			 * When implementing child widgets that can participate in the context based binding
			 * (MVVM), You can set this to the parent widget when it is added or removed to it
			 * (usually via a collection).  Note that you should typically provide a public new
			 * [ParentWidget] Parent { get; } property  so that consumers of your API cannot set the
			 * parent to an invalid value.
			 */
			Parent: Eto.Widget;

			/**
			 * Gets an enumeration of all parent widgets in the heirarchy by traversing the
			 * {@link Eto.Forms.BindableWidget.Parent} property.
			 */
			readonly Parents: Iterable<Eto.Widget>;

			/**
			 * Gets or sets the data context for this widget for binding
			 *
			 * Subclasses may override the standard behaviour so that hierarchy of widgets can be
			 * taken into account.  For example, a Control may return the data context of a parent,
			 * if it is not set explicitly.
			 */
			DataContext: unknown;

			/** Gets the collection of bindings that are attached to this widget */
			readonly Bindings: Eto.Forms.BindingCollection;

			/**
			 * Gets a value indicating that the {@link Eto.Forms.BindableWidget.DataContext} property
			 * is changing.
			 *
			 * This can be used to determine when to allow certain logic during the update of the
			 * data context.  It is used to disable binding setters on the model when the data
			 * context changes so that a binding does not cause the view model to be updated when the
			 * state hasn't been fully set yet.
			 */
			IsDataContextChanging: boolean;

			/**
			 * Gets the platform that was used to create the {@link Eto.Widget.Handler} for this
			 * widget
			 *
			 * This gets set to the current {@link Eto.Platform.Instance} during the construction of
			 * the object
			 */
			readonly Platform: Eto.Platform;

			/** Gets the platform-specific handler for this widget */
			Handler: unknown;

			/** Gets the native platform-specific handle for integration purposes */
			readonly NativeHandle: unknown;

			/** Gets the dictionary of properties for this widget */
			readonly Properties: Eto.PropertyStore;

			/** Gets or sets the ID of this widget */
			ID: string;

			/**
			 * Gets or sets the style of this widget
			 *
			 * Styles allow you to attach custom platform-specific logic to a widget. In your
			 * platform-specific assembly, use {@link Style.Add{H}(string, StyleHandler{H})} to add
			 * the style logic with the same id.
			 */
			Style: string;

			/**
			 * Gets the instance of the platform-specific object
			 *
			 * This can sometimes be useful to get the platform-specific object. Some handlers may
			 * not have any backing object for its functionality, so this may be null.  It is more
			 * preferred to use the {@link Eto.Widget.Handler} and cast that to the platform-specific
			 * handler class which can give you additional methods and helpers to do common tasks.
			 * For example, the {@link Eto.Forms.Application} object's handler for OS X has a
			 * AddFullScreenMenuItem property to specify if you want full screen support in your app.
			 */
			readonly ControlObject: unknown;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Widget} has been disposed.
			 *
			 * When the widget is disposed, it can no longer be used.
			 */
			IsDisposed: boolean;

			/** Raises the {@link Eto.Forms.ToolItem.Click} event. */
			OnClick(e: unknown): void;

			/**
			 * Finds a control in the parent hierarchy with the specified type and
			 * {@link Eto.Widget.ID} if specified
			 */
			FindParent<T>(id?: string): T;

			/**
			 * Finds a control in the parent hierarchy with the specified type and
			 * {@link Eto.Widget.ID} if specified
			 */
			FindParent(
				type: unknown,
				id?: string,
			): Eto.Widget;

			/** Finds a control in the parent hierarchy with the specified `id` */
			FindParent(id: string): Eto.Widget;

			/**
			 * Unbinds any bindings in the {@link Eto.Forms.BindableWidget.Bindings} collection and
			 * removes the bindings
			 *
			 * When you implement {@link Eto.Forms.IBindableWidgetContainer}, this will also unbind
			 * any of its children.
			 */
			Unbind(): void;

			/**
			 * Updates all bindings in this widget
			 *
			 * When you implement {@link Eto.Forms.IBindableWidgetContainer}, this will also update
			 * bindings for all of its children.
			 */
			UpdateBindings(mode?: Eto.Forms.BindingUpdateMode): void;

			/** Disposes of this widget, supressing the finalizer */
			dispose(): void;

			/** Gets a string that represents the current object with its ID if specified. */
			ToString(): string;
		}
	}

	export namespace Eto.Forms.ButtonToolItem {
		export interface IHandler extends
			Eto.Forms.ToolItem.IHandler,
			Eto.Forms.Tool.IHandler,
			Eto.Widget.IHandler {
		}
	}

	export namespace Eto.Forms {
		/** Tool item that can be toggled on or off. */
		export class CheckToolItem implements
			Eto.IHandlerSource,
			Eto.Forms.IBindable,
			Eto.Forms.ICommandItem {
			/** Initializes a new instance of the {@link Eto.Forms.CheckToolItem} class. */
			constructor();

			/**
			 * Initializes a new instance of the {@link Eto.Forms.CheckToolItem} class with the
			 * specified `command`.
			 */
			constructor(command: Eto.Forms.CheckCommand);

			/** Gets or sets a value indicating whether this item is checked. */
			Checked: boolean;

			/**
			 * Gets or sets the command to invoke when the tool item is pressed.
			 *
			 * This will invoke the specified command when the tool item is pressed. The
			 * {@link System.Windows.Input.ICommand.CanExecute(System.Object)} will also used to set
			 * the enabled/disabled state of the tool item.
			 */
			Command: unknown;

			/**
			 * Gets or sets the parameter to pass to the {@link Eto.Forms.ToolItem.Command} when
			 * executing or determining its CanExecute state.
			 */
			CommandParameter: unknown;

			/**
			 * Gets or sets the order of the tool item when adding to the
			 * {@link Eto.Forms.ToolItemCollection}.
			 */
			Order: number;

			/** Gets or sets the text of the item, with mnemonic. */
			Text: string;

			/** Gets or sets the tool tip to show when hovering the mouse over the item. */
			ToolTip: string;

			/** Gets or sets the image for the tool item. */
			Image: Eto.Drawing.Image;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Forms.ToolItem} is enabled.
			 */
			Enabled: boolean;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Forms.ToolItem} is visible.
			 */
			Visible: boolean;

			/** Gets or sets a user-defined tag for the tool item. */
			Tag: unknown;

			/**
			 * Gets or sets the parent widget which this widget has been added to, if any
			 *
			 * When implementing child widgets that can participate in the context based binding
			 * (MVVM), You can set this to the parent widget when it is added or removed to it
			 * (usually via a collection).  Note that you should typically provide a public new
			 * [ParentWidget] Parent { get; } property  so that consumers of your API cannot set the
			 * parent to an invalid value.
			 */
			Parent: Eto.Widget;

			/**
			 * Gets an enumeration of all parent widgets in the heirarchy by traversing the
			 * {@link Eto.Forms.BindableWidget.Parent} property.
			 */
			readonly Parents: Iterable<Eto.Widget>;

			/**
			 * Gets or sets the data context for this widget for binding
			 *
			 * Subclasses may override the standard behaviour so that hierarchy of widgets can be
			 * taken into account.  For example, a Control may return the data context of a parent,
			 * if it is not set explicitly.
			 */
			DataContext: unknown;

			/** Gets the collection of bindings that are attached to this widget */
			readonly Bindings: Eto.Forms.BindingCollection;

			/**
			 * Gets a value indicating that the {@link Eto.Forms.BindableWidget.DataContext} property
			 * is changing.
			 *
			 * This can be used to determine when to allow certain logic during the update of the
			 * data context.  It is used to disable binding setters on the model when the data
			 * context changes so that a binding does not cause the view model to be updated when the
			 * state hasn't been fully set yet.
			 */
			IsDataContextChanging: boolean;

			/**
			 * Gets the platform that was used to create the {@link Eto.Widget.Handler} for this
			 * widget
			 *
			 * This gets set to the current {@link Eto.Platform.Instance} during the construction of
			 * the object
			 */
			readonly Platform: Eto.Platform;

			/** Gets the platform-specific handler for this widget */
			Handler: unknown;

			/** Gets the native platform-specific handle for integration purposes */
			readonly NativeHandle: unknown;

			/** Gets the dictionary of properties for this widget */
			readonly Properties: Eto.PropertyStore;

			/** Gets or sets the ID of this widget */
			ID: string;

			/**
			 * Gets or sets the style of this widget
			 *
			 * Styles allow you to attach custom platform-specific logic to a widget. In your
			 * platform-specific assembly, use {@link Style.Add{H}(string, StyleHandler{H})} to add
			 * the style logic with the same id.
			 */
			Style: string;

			/**
			 * Gets the instance of the platform-specific object
			 *
			 * This can sometimes be useful to get the platform-specific object. Some handlers may
			 * not have any backing object for its functionality, so this may be null.  It is more
			 * preferred to use the {@link Eto.Widget.Handler} and cast that to the platform-specific
			 * handler class which can give you additional methods and helpers to do common tasks.
			 * For example, the {@link Eto.Forms.Application} object's handler for OS X has a
			 * AddFullScreenMenuItem property to specify if you want full screen support in your app.
			 */
			readonly ControlObject: unknown;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Widget} has been disposed.
			 *
			 * When the widget is disposed, it can no longer be used.
			 */
			IsDisposed: boolean;

			/** Raises the {@link Eto.Forms.CheckToolItem.CheckedChanged} event. */
			OnCheckedChanged(e: unknown): void;

			/** Raises the {@link Eto.Forms.ToolItem.Click} event. */
			OnClick(e: unknown): void;

			/**
			 * Finds a control in the parent hierarchy with the specified type and
			 * {@link Eto.Widget.ID} if specified
			 */
			FindParent<T>(id?: string): T;

			/**
			 * Finds a control in the parent hierarchy with the specified type and
			 * {@link Eto.Widget.ID} if specified
			 */
			FindParent(
				type: unknown,
				id?: string,
			): Eto.Widget;

			/** Finds a control in the parent hierarchy with the specified `id` */
			FindParent(id: string): Eto.Widget;

			/**
			 * Unbinds any bindings in the {@link Eto.Forms.BindableWidget.Bindings} collection and
			 * removes the bindings
			 *
			 * When you implement {@link Eto.Forms.IBindableWidgetContainer}, this will also unbind
			 * any of its children.
			 */
			Unbind(): void;

			/**
			 * Updates all bindings in this widget
			 *
			 * When you implement {@link Eto.Forms.IBindableWidgetContainer}, this will also update
			 * bindings for all of its children.
			 */
			UpdateBindings(mode?: Eto.Forms.BindingUpdateMode): void;

			/** Disposes of this widget, supressing the finalizer */
			dispose(): void;

			/** Gets a string that represents the current object with its ID if specified. */
			ToString(): string;
		}
	}

	export namespace Eto.Forms.CheckToolItem {
		export interface IHandler extends
			Eto.Forms.ToolItem.IHandler,
			Eto.Forms.Tool.IHandler,
			Eto.Widget.IHandler {
			Checked: boolean;
		}
	}

	export namespace Eto.Forms {
		/** Tool item to display a drop-down menu */
		export class DropDownToolItem implements
			Eto.IHandlerSource,
			Eto.Forms.IBindable,
			Eto.Forms.ICommandItem {
			/** Initializes a new instance of the {@link Eto.Forms.DropDownToolItem} class. */
			constructor();

			/** Gets or sets a value indicating that the drop arrow should be shown */
			ShowDropArrow: boolean;

			/** Gets the collection of menu items */
			readonly Items: Eto.Forms.MenuItemCollection;

			/**
			 * Gets or sets the command to invoke when the tool item is pressed.
			 *
			 * This will invoke the specified command when the tool item is pressed. The
			 * {@link System.Windows.Input.ICommand.CanExecute(System.Object)} will also used to set
			 * the enabled/disabled state of the tool item.
			 */
			Command: unknown;

			/**
			 * Gets or sets the parameter to pass to the {@link Eto.Forms.ToolItem.Command} when
			 * executing or determining its CanExecute state.
			 */
			CommandParameter: unknown;

			/**
			 * Gets or sets the order of the tool item when adding to the
			 * {@link Eto.Forms.ToolItemCollection}.
			 */
			Order: number;

			/** Gets or sets the text of the item, with mnemonic. */
			Text: string;

			/** Gets or sets the tool tip to show when hovering the mouse over the item. */
			ToolTip: string;

			/** Gets or sets the image for the tool item. */
			Image: Eto.Drawing.Image;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Forms.ToolItem} is enabled.
			 */
			Enabled: boolean;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Forms.ToolItem} is visible.
			 */
			Visible: boolean;

			/** Gets or sets a user-defined tag for the tool item. */
			Tag: unknown;

			/**
			 * Gets or sets the parent widget which this widget has been added to, if any
			 *
			 * When implementing child widgets that can participate in the context based binding
			 * (MVVM), You can set this to the parent widget when it is added or removed to it
			 * (usually via a collection).  Note that you should typically provide a public new
			 * [ParentWidget] Parent { get; } property  so that consumers of your API cannot set the
			 * parent to an invalid value.
			 */
			Parent: Eto.Widget;

			/**
			 * Gets an enumeration of all parent widgets in the heirarchy by traversing the
			 * {@link Eto.Forms.BindableWidget.Parent} property.
			 */
			readonly Parents: Iterable<Eto.Widget>;

			/**
			 * Gets or sets the data context for this widget for binding
			 *
			 * Subclasses may override the standard behaviour so that hierarchy of widgets can be
			 * taken into account.  For example, a Control may return the data context of a parent,
			 * if it is not set explicitly.
			 */
			DataContext: unknown;

			/** Gets the collection of bindings that are attached to this widget */
			readonly Bindings: Eto.Forms.BindingCollection;

			/**
			 * Gets a value indicating that the {@link Eto.Forms.BindableWidget.DataContext} property
			 * is changing.
			 *
			 * This can be used to determine when to allow certain logic during the update of the
			 * data context.  It is used to disable binding setters on the model when the data
			 * context changes so that a binding does not cause the view model to be updated when the
			 * state hasn't been fully set yet.
			 */
			IsDataContextChanging: boolean;

			/**
			 * Gets the platform that was used to create the {@link Eto.Widget.Handler} for this
			 * widget
			 *
			 * This gets set to the current {@link Eto.Platform.Instance} during the construction of
			 * the object
			 */
			readonly Platform: Eto.Platform;

			/** Gets the platform-specific handler for this widget */
			Handler: unknown;

			/** Gets the native platform-specific handle for integration purposes */
			readonly NativeHandle: unknown;

			/** Gets the dictionary of properties for this widget */
			readonly Properties: Eto.PropertyStore;

			/** Gets or sets the ID of this widget */
			ID: string;

			/**
			 * Gets or sets the style of this widget
			 *
			 * Styles allow you to attach custom platform-specific logic to a widget. In your
			 * platform-specific assembly, use {@link Style.Add{H}(string, StyleHandler{H})} to add
			 * the style logic with the same id.
			 */
			Style: string;

			/**
			 * Gets the instance of the platform-specific object
			 *
			 * This can sometimes be useful to get the platform-specific object. Some handlers may
			 * not have any backing object for its functionality, so this may be null.  It is more
			 * preferred to use the {@link Eto.Widget.Handler} and cast that to the platform-specific
			 * handler class which can give you additional methods and helpers to do common tasks.
			 * For example, the {@link Eto.Forms.Application} object's handler for OS X has a
			 * AddFullScreenMenuItem property to specify if you want full screen support in your app.
			 */
			readonly ControlObject: unknown;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Widget} has been disposed.
			 *
			 * When the widget is disposed, it can no longer be used.
			 */
			IsDisposed: boolean;

			/** Raises the {@link Eto.Forms.ToolItem.Click} event. */
			OnClick(e: unknown): void;

			/**
			 * Finds a control in the parent hierarchy with the specified type and
			 * {@link Eto.Widget.ID} if specified
			 */
			FindParent<T>(id?: string): T;

			/**
			 * Finds a control in the parent hierarchy with the specified type and
			 * {@link Eto.Widget.ID} if specified
			 */
			FindParent(
				type: unknown,
				id?: string,
			): Eto.Widget;

			/** Finds a control in the parent hierarchy with the specified `id` */
			FindParent(id: string): Eto.Widget;

			/**
			 * Unbinds any bindings in the {@link Eto.Forms.BindableWidget.Bindings} collection and
			 * removes the bindings
			 *
			 * When you implement {@link Eto.Forms.IBindableWidgetContainer}, this will also unbind
			 * any of its children.
			 */
			Unbind(): void;

			/**
			 * Updates all bindings in this widget
			 *
			 * When you implement {@link Eto.Forms.IBindableWidgetContainer}, this will also update
			 * bindings for all of its children.
			 */
			UpdateBindings(mode?: Eto.Forms.BindingUpdateMode): void;

			/** Disposes of this widget, supressing the finalizer */
			dispose(): void;

			/** Gets a string that represents the current object with its ID if specified. */
			ToString(): string;
		}
	}

	export namespace Eto.Forms.DropDownToolItem {
		export interface IHandler extends
			Eto.Forms.ToolItem.IHandler,
			Eto.Forms.Tool.IHandler,
			Eto.Widget.IHandler,
			Eto.Forms.Menu.ISubmenuHandler {
			ShowDropArrow: boolean;
		}
	}

	export namespace Eto.Forms {
		/**
		 * Tool item that can be toggled on or off.
		 *
		 * Note that there is only a single group of radio buttons allowed on a toolbar.
		 */
		export class RadioToolItem implements
			Eto.IHandlerSource,
			Eto.Forms.IBindable,
			Eto.Forms.ICommandItem {
			/** Initializes a new instance of the {@link Eto.Forms.RadioToolItem} class. */
			constructor();

			/**
			 * Initializes a new instance of the {@link Eto.Forms.RadioToolItem} class with the
			 * specified `command`.
			 */
			constructor(command: Eto.Forms.CheckCommand);

			/** Gets or sets a value indicating whether this item is checked. */
			Checked: boolean;

			/**
			 * Gets or sets the command to invoke when the tool item is pressed.
			 *
			 * This will invoke the specified command when the tool item is pressed. The
			 * {@link System.Windows.Input.ICommand.CanExecute(System.Object)} will also used to set
			 * the enabled/disabled state of the tool item.
			 */
			Command: unknown;

			/**
			 * Gets or sets the parameter to pass to the {@link Eto.Forms.ToolItem.Command} when
			 * executing or determining its CanExecute state.
			 */
			CommandParameter: unknown;

			/**
			 * Gets or sets the order of the tool item when adding to the
			 * {@link Eto.Forms.ToolItemCollection}.
			 */
			Order: number;

			/** Gets or sets the text of the item, with mnemonic. */
			Text: string;

			/** Gets or sets the tool tip to show when hovering the mouse over the item. */
			ToolTip: string;

			/** Gets or sets the image for the tool item. */
			Image: Eto.Drawing.Image;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Forms.ToolItem} is enabled.
			 */
			Enabled: boolean;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Forms.ToolItem} is visible.
			 */
			Visible: boolean;

			/** Gets or sets a user-defined tag for the tool item. */
			Tag: unknown;

			/**
			 * Gets or sets the parent widget which this widget has been added to, if any
			 *
			 * When implementing child widgets that can participate in the context based binding
			 * (MVVM), You can set this to the parent widget when it is added or removed to it
			 * (usually via a collection).  Note that you should typically provide a public new
			 * [ParentWidget] Parent { get; } property  so that consumers of your API cannot set the
			 * parent to an invalid value.
			 */
			Parent: Eto.Widget;

			/**
			 * Gets an enumeration of all parent widgets in the heirarchy by traversing the
			 * {@link Eto.Forms.BindableWidget.Parent} property.
			 */
			readonly Parents: Iterable<Eto.Widget>;

			/**
			 * Gets or sets the data context for this widget for binding
			 *
			 * Subclasses may override the standard behaviour so that hierarchy of widgets can be
			 * taken into account.  For example, a Control may return the data context of a parent,
			 * if it is not set explicitly.
			 */
			DataContext: unknown;

			/** Gets the collection of bindings that are attached to this widget */
			readonly Bindings: Eto.Forms.BindingCollection;

			/**
			 * Gets a value indicating that the {@link Eto.Forms.BindableWidget.DataContext} property
			 * is changing.
			 *
			 * This can be used to determine when to allow certain logic during the update of the
			 * data context.  It is used to disable binding setters on the model when the data
			 * context changes so that a binding does not cause the view model to be updated when the
			 * state hasn't been fully set yet.
			 */
			IsDataContextChanging: boolean;

			/**
			 * Gets the platform that was used to create the {@link Eto.Widget.Handler} for this
			 * widget
			 *
			 * This gets set to the current {@link Eto.Platform.Instance} during the construction of
			 * the object
			 */
			readonly Platform: Eto.Platform;

			/** Gets the platform-specific handler for this widget */
			Handler: unknown;

			/** Gets the native platform-specific handle for integration purposes */
			readonly NativeHandle: unknown;

			/** Gets the dictionary of properties for this widget */
			readonly Properties: Eto.PropertyStore;

			/** Gets or sets the ID of this widget */
			ID: string;

			/**
			 * Gets or sets the style of this widget
			 *
			 * Styles allow you to attach custom platform-specific logic to a widget. In your
			 * platform-specific assembly, use {@link Style.Add{H}(string, StyleHandler{H})} to add
			 * the style logic with the same id.
			 */
			Style: string;

			/**
			 * Gets the instance of the platform-specific object
			 *
			 * This can sometimes be useful to get the platform-specific object. Some handlers may
			 * not have any backing object for its functionality, so this may be null.  It is more
			 * preferred to use the {@link Eto.Widget.Handler} and cast that to the platform-specific
			 * handler class which can give you additional methods and helpers to do common tasks.
			 * For example, the {@link Eto.Forms.Application} object's handler for OS X has a
			 * AddFullScreenMenuItem property to specify if you want full screen support in your app.
			 */
			readonly ControlObject: unknown;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Widget} has been disposed.
			 *
			 * When the widget is disposed, it can no longer be used.
			 */
			IsDisposed: boolean;

			/** Raises the {@link Eto.Forms.RadioToolItem.CheckedChanged} event. */
			OnCheckedChanged(e: unknown): void;

			/** Raises the {@link Eto.Forms.ToolItem.Click} event. */
			OnClick(e: unknown): void;

			/**
			 * Finds a control in the parent hierarchy with the specified type and
			 * {@link Eto.Widget.ID} if specified
			 */
			FindParent<T>(id?: string): T;

			/**
			 * Finds a control in the parent hierarchy with the specified type and
			 * {@link Eto.Widget.ID} if specified
			 */
			FindParent(
				type: unknown,
				id?: string,
			): Eto.Widget;

			/** Finds a control in the parent hierarchy with the specified `id` */
			FindParent(id: string): Eto.Widget;

			/**
			 * Unbinds any bindings in the {@link Eto.Forms.BindableWidget.Bindings} collection and
			 * removes the bindings
			 *
			 * When you implement {@link Eto.Forms.IBindableWidgetContainer}, this will also unbind
			 * any of its children.
			 */
			Unbind(): void;

			/**
			 * Updates all bindings in this widget
			 *
			 * When you implement {@link Eto.Forms.IBindableWidgetContainer}, this will also update
			 * bindings for all of its children.
			 */
			UpdateBindings(mode?: Eto.Forms.BindingUpdateMode): void;

			/** Disposes of this widget, supressing the finalizer */
			dispose(): void;

			/** Gets a string that represents the current object with its ID if specified. */
			ToString(): string;
		}
	}

	export namespace Eto.Forms.RadioToolItem {
		export interface IHandler extends
			Eto.Forms.ToolItem.IHandler,
			Eto.Forms.Tool.IHandler,
			Eto.Widget.IHandler {
			Checked: boolean;
		}
	}

	export namespace Eto.Forms {
		/** Enumeration of the types of separators for the {@link Eto.Forms.SeparatorToolItem} */
		export enum SeparatorToolItemType {
			/** Line divider */
			Divider = 0,

			/** Fixed space divider */
			Space = 1,

			/**
			 * Flexible space divider (not available on all platforms)
			 *
			 * This is (currently) only available for OS X applications as other platforms left-align
			 * their toolbars.
			 */
			FlexibleSpace = 2,
		}
	}

	export namespace Eto.Forms {
		/** Tool item to separate groups of items using a divider, space, etc. */
		export class SeparatorToolItem implements
			Eto.IHandlerSource,
			Eto.Forms.IBindable,
			Eto.Forms.ICommandItem {
			constructor();

			/** Gets or sets the type of the separator. */
			Type: Eto.Forms.SeparatorToolItemType;

			/**
			 * Gets or sets the command to invoke when the tool item is pressed.
			 *
			 * This will invoke the specified command when the tool item is pressed. The
			 * {@link System.Windows.Input.ICommand.CanExecute(System.Object)} will also used to set
			 * the enabled/disabled state of the tool item.
			 */
			Command: unknown;

			/**
			 * Gets or sets the parameter to pass to the {@link Eto.Forms.ToolItem.Command} when
			 * executing or determining its CanExecute state.
			 */
			CommandParameter: unknown;

			/**
			 * Gets or sets the order of the tool item when adding to the
			 * {@link Eto.Forms.ToolItemCollection}.
			 */
			Order: number;

			/** Gets or sets the text of the item, with mnemonic. */
			Text: string;

			/** Gets or sets the tool tip to show when hovering the mouse over the item. */
			ToolTip: string;

			/** Gets or sets the image for the tool item. */
			Image: Eto.Drawing.Image;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Forms.ToolItem} is enabled.
			 */
			Enabled: boolean;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Forms.ToolItem} is visible.
			 */
			Visible: boolean;

			/** Gets or sets a user-defined tag for the tool item. */
			Tag: unknown;

			/**
			 * Gets or sets the parent widget which this widget has been added to, if any
			 *
			 * When implementing child widgets that can participate in the context based binding
			 * (MVVM), You can set this to the parent widget when it is added or removed to it
			 * (usually via a collection).  Note that you should typically provide a public new
			 * [ParentWidget] Parent { get; } property  so that consumers of your API cannot set the
			 * parent to an invalid value.
			 */
			Parent: Eto.Widget;

			/**
			 * Gets an enumeration of all parent widgets in the heirarchy by traversing the
			 * {@link Eto.Forms.BindableWidget.Parent} property.
			 */
			readonly Parents: Iterable<Eto.Widget>;

			/**
			 * Gets or sets the data context for this widget for binding
			 *
			 * Subclasses may override the standard behaviour so that hierarchy of widgets can be
			 * taken into account.  For example, a Control may return the data context of a parent,
			 * if it is not set explicitly.
			 */
			DataContext: unknown;

			/** Gets the collection of bindings that are attached to this widget */
			readonly Bindings: Eto.Forms.BindingCollection;

			/**
			 * Gets a value indicating that the {@link Eto.Forms.BindableWidget.DataContext} property
			 * is changing.
			 *
			 * This can be used to determine when to allow certain logic during the update of the
			 * data context.  It is used to disable binding setters on the model when the data
			 * context changes so that a binding does not cause the view model to be updated when the
			 * state hasn't been fully set yet.
			 */
			IsDataContextChanging: boolean;

			/**
			 * Gets the platform that was used to create the {@link Eto.Widget.Handler} for this
			 * widget
			 *
			 * This gets set to the current {@link Eto.Platform.Instance} during the construction of
			 * the object
			 */
			readonly Platform: Eto.Platform;

			/** Gets the platform-specific handler for this widget */
			Handler: unknown;

			/** Gets the native platform-specific handle for integration purposes */
			readonly NativeHandle: unknown;

			/** Gets the dictionary of properties for this widget */
			readonly Properties: Eto.PropertyStore;

			/** Gets or sets the ID of this widget */
			ID: string;

			/**
			 * Gets or sets the style of this widget
			 *
			 * Styles allow you to attach custom platform-specific logic to a widget. In your
			 * platform-specific assembly, use {@link Style.Add{H}(string, StyleHandler{H})} to add
			 * the style logic with the same id.
			 */
			Style: string;

			/**
			 * Gets the instance of the platform-specific object
			 *
			 * This can sometimes be useful to get the platform-specific object. Some handlers may
			 * not have any backing object for its functionality, so this may be null.  It is more
			 * preferred to use the {@link Eto.Widget.Handler} and cast that to the platform-specific
			 * handler class which can give you additional methods and helpers to do common tasks.
			 * For example, the {@link Eto.Forms.Application} object's handler for OS X has a
			 * AddFullScreenMenuItem property to specify if you want full screen support in your app.
			 */
			readonly ControlObject: unknown;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Widget} has been disposed.
			 *
			 * When the widget is disposed, it can no longer be used.
			 */
			IsDisposed: boolean;

			/** Raises the {@link Eto.Forms.ToolItem.Click} event. */
			OnClick(e: unknown): void;

			/**
			 * Finds a control in the parent hierarchy with the specified type and
			 * {@link Eto.Widget.ID} if specified
			 */
			FindParent<T>(id?: string): T;

			/**
			 * Finds a control in the parent hierarchy with the specified type and
			 * {@link Eto.Widget.ID} if specified
			 */
			FindParent(
				type: unknown,
				id?: string,
			): Eto.Widget;

			/** Finds a control in the parent hierarchy with the specified `id` */
			FindParent(id: string): Eto.Widget;

			/**
			 * Unbinds any bindings in the {@link Eto.Forms.BindableWidget.Bindings} collection and
			 * removes the bindings
			 *
			 * When you implement {@link Eto.Forms.IBindableWidgetContainer}, this will also unbind
			 * any of its children.
			 */
			Unbind(): void;

			/**
			 * Updates all bindings in this widget
			 *
			 * When you implement {@link Eto.Forms.IBindableWidgetContainer}, this will also update
			 * bindings for all of its children.
			 */
			UpdateBindings(mode?: Eto.Forms.BindingUpdateMode): void;

			/** Disposes of this widget, supressing the finalizer */
			dispose(): void;

			/** Gets a string that represents the current object with its ID if specified. */
			ToString(): string;
		}
	}

	export namespace Eto.Forms.SeparatorToolItem {
		export interface IHandler extends
			Eto.Forms.ToolItem.IHandler,
			Eto.Forms.Tool.IHandler,
			Eto.Widget.IHandler {
			Type: Eto.Forms.SeparatorToolItemType;
		}
	}

	export namespace Eto.Forms {
		/** Base class for tool items on a {@link Eto.Forms.ToolBar} */
		export class Tool implements
			Eto.IHandlerSource,
			Eto.Forms.IBindable {
			constructor();

			/**
			 * Gets or sets the parent widget which this widget has been added to, if any
			 *
			 * When implementing child widgets that can participate in the context based binding
			 * (MVVM), You can set this to the parent widget when it is added or removed to it
			 * (usually via a collection).  Note that you should typically provide a public new
			 * [ParentWidget] Parent { get; } property  so that consumers of your API cannot set the
			 * parent to an invalid value.
			 */
			Parent: Eto.Widget;

			/**
			 * Gets an enumeration of all parent widgets in the heirarchy by traversing the
			 * {@link Eto.Forms.BindableWidget.Parent} property.
			 */
			readonly Parents: Iterable<Eto.Widget>;

			/**
			 * Gets or sets the data context for this widget for binding
			 *
			 * Subclasses may override the standard behaviour so that hierarchy of widgets can be
			 * taken into account.  For example, a Control may return the data context of a parent,
			 * if it is not set explicitly.
			 */
			DataContext: unknown;

			/** Gets the collection of bindings that are attached to this widget */
			readonly Bindings: Eto.Forms.BindingCollection;

			/**
			 * Gets a value indicating that the {@link Eto.Forms.BindableWidget.DataContext} property
			 * is changing.
			 *
			 * This can be used to determine when to allow certain logic during the update of the
			 * data context.  It is used to disable binding setters on the model when the data
			 * context changes so that a binding does not cause the view model to be updated when the
			 * state hasn't been fully set yet.
			 */
			IsDataContextChanging: boolean;

			/**
			 * Gets the platform that was used to create the {@link Eto.Widget.Handler} for this
			 * widget
			 *
			 * This gets set to the current {@link Eto.Platform.Instance} during the construction of
			 * the object
			 */
			readonly Platform: Eto.Platform;

			/** Gets the platform-specific handler for this widget */
			Handler: unknown;

			/** Gets the native platform-specific handle for integration purposes */
			readonly NativeHandle: unknown;

			/** Gets the dictionary of properties for this widget */
			readonly Properties: Eto.PropertyStore;

			/** Gets or sets the ID of this widget */
			ID: string;

			/**
			 * Gets or sets the style of this widget
			 *
			 * Styles allow you to attach custom platform-specific logic to a widget. In your
			 * platform-specific assembly, use {@link Style.Add{H}(string, StyleHandler{H})} to add
			 * the style logic with the same id.
			 */
			Style: string;

			/**
			 * Gets the instance of the platform-specific object
			 *
			 * This can sometimes be useful to get the platform-specific object. Some handlers may
			 * not have any backing object for its functionality, so this may be null.  It is more
			 * preferred to use the {@link Eto.Widget.Handler} and cast that to the platform-specific
			 * handler class which can give you additional methods and helpers to do common tasks.
			 * For example, the {@link Eto.Forms.Application} object's handler for OS X has a
			 * AddFullScreenMenuItem property to specify if you want full screen support in your app.
			 */
			readonly ControlObject: unknown;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Widget} has been disposed.
			 *
			 * When the widget is disposed, it can no longer be used.
			 */
			IsDisposed: boolean;

			/**
			 * Finds a control in the parent hierarchy with the specified type and
			 * {@link Eto.Widget.ID} if specified
			 */
			FindParent<T>(id?: string): T;

			/**
			 * Finds a control in the parent hierarchy with the specified type and
			 * {@link Eto.Widget.ID} if specified
			 */
			FindParent(
				type: unknown,
				id?: string,
			): Eto.Widget;

			/** Finds a control in the parent hierarchy with the specified `id` */
			FindParent(id: string): Eto.Widget;

			/**
			 * Unbinds any bindings in the {@link Eto.Forms.BindableWidget.Bindings} collection and
			 * removes the bindings
			 *
			 * When you implement {@link Eto.Forms.IBindableWidgetContainer}, this will also unbind
			 * any of its children.
			 */
			Unbind(): void;

			/**
			 * Updates all bindings in this widget
			 *
			 * When you implement {@link Eto.Forms.IBindableWidgetContainer}, this will also update
			 * bindings for all of its children.
			 */
			UpdateBindings(mode?: Eto.Forms.BindingUpdateMode): void;

			/** Disposes of this widget, supressing the finalizer */
			dispose(): void;

			/** Gets a string that represents the current object with its ID if specified. */
			ToString(): string;
		}
	}

	export namespace Eto.Forms.Tool {
		export interface IHandler extends Eto.Widget.IHandler {
			OnLoad(e: unknown): void;

			OnPreLoad(e: unknown): void;

			OnUnLoad(e: unknown): void;
		}
	}

	export namespace Eto.Forms {
		/**
		 * Text alignment hint for items in a {@link Eto.Forms.ToolBar}
		 *
		 * Note that some platforms may define the visual style of toolbar items and this just
		 * serves as a hint for platforms that support such features (e.g. windows).
		 */
		export enum ToolBarTextAlign {
			/** Text will be shown to the right of the toolbar item, if available */
			Right = 0,

			/** Text will be shown below the toolbar items */
			Underneath = 1,
		}
	}

	export namespace Eto.Forms {
		/**
		 * Docking mode hint for a {@link Eto.Forms.ToolBar}
		 *
		 * Most platforms will not respect this, and is usually only necessary for constrained
		 * devices like iOS and Android. Each platform may have a different default docking mode,
		 * depending on the type of device. E.g. iPhone will by default show the toolbar on the
		 * bottom, whereas iPad and dekstop platforms will show it at the top by default.
		 * Additionally, some platforms may choose to show the toolbar in a different way, e.g.
		 * the Navigation control on iPhone has a standard toolbar available, so if you are using
		 * one it will attempt to use its toolbar to provide  the best native experience.
		 */
		export enum ToolBarDock {
			/** Toolbar will be shown at the top of the form */
			Top = 0,

			/** Toolbar will be shown at the bottom of the form. */
			Bottom = 1,
		}
	}

	export namespace Eto.Forms {
		/**
		 * Toolbar widget for use on a {@link Eto.Forms.Window}.
		 *
		 * Only a single toolbar is currently supported for each window.
		 */
		export class ToolBar implements
			Eto.IHandlerSource,
			Eto.Forms.IBindable {
			constructor();

			/**
			 * Gets or sets the docking hint for the toolbar.
			 *
			 * Most platforms will not respect this, and is usually only necessary for constrained
			 * devices like iOS and Android. Each platform may have a different default docking mode,
			 * depending on the type of device. E.g. iPhone will by default show the toolbar on the
			 * bottom, whereas iPad and dekstop platforms will show it at the top by default.
			 * Additionally, some platforms may choose to show the toolbar in a different way, e.g.
			 * the Navigation control on iPhone has a standard toolbar available, so if you are using
			 * one it will attempt to use its toolbar to provide  the best native experience.
			 */
			Dock: Eto.Forms.ToolBarDock;

			/** Gets the collection of items in the toolbar. */
			readonly Items: Eto.Forms.ToolItemCollection;

			/**
			 * Gets or sets the text alignment hint.
			 *
			 * Note that some platforms may define the visual style of toolbar items and this just
			 * serves as a hint for platforms that support such features (e.g. windows).
			 */
			TextAlign: Eto.Forms.ToolBarTextAlign;

			/**
			 * Gets or sets the parent widget which this widget has been added to, if any
			 *
			 * When implementing child widgets that can participate in the context based binding
			 * (MVVM), You can set this to the parent widget when it is added or removed to it
			 * (usually via a collection).  Note that you should typically provide a public new
			 * [ParentWidget] Parent { get; } property  so that consumers of your API cannot set the
			 * parent to an invalid value.
			 */
			Parent: Eto.Widget;

			/**
			 * Gets an enumeration of all parent widgets in the heirarchy by traversing the
			 * {@link Eto.Forms.BindableWidget.Parent} property.
			 */
			readonly Parents: Iterable<Eto.Widget>;

			/**
			 * Gets or sets the data context for this widget for binding
			 *
			 * Subclasses may override the standard behaviour so that hierarchy of widgets can be
			 * taken into account.  For example, a Control may return the data context of a parent,
			 * if it is not set explicitly.
			 */
			DataContext: unknown;

			/** Gets the collection of bindings that are attached to this widget */
			readonly Bindings: Eto.Forms.BindingCollection;

			/**
			 * Gets a value indicating that the {@link Eto.Forms.BindableWidget.DataContext} property
			 * is changing.
			 *
			 * This can be used to determine when to allow certain logic during the update of the
			 * data context.  It is used to disable binding setters on the model when the data
			 * context changes so that a binding does not cause the view model to be updated when the
			 * state hasn't been fully set yet.
			 */
			IsDataContextChanging: boolean;

			/**
			 * Gets the platform that was used to create the {@link Eto.Widget.Handler} for this
			 * widget
			 *
			 * This gets set to the current {@link Eto.Platform.Instance} during the construction of
			 * the object
			 */
			readonly Platform: Eto.Platform;

			/** Gets the platform-specific handler for this widget */
			Handler: unknown;

			/** Gets the native platform-specific handle for integration purposes */
			readonly NativeHandle: unknown;

			/** Gets the dictionary of properties for this widget */
			readonly Properties: Eto.PropertyStore;

			/** Gets or sets the ID of this widget */
			ID: string;

			/**
			 * Gets or sets the style of this widget
			 *
			 * Styles allow you to attach custom platform-specific logic to a widget. In your
			 * platform-specific assembly, use {@link Style.Add{H}(string, StyleHandler{H})} to add
			 * the style logic with the same id.
			 */
			Style: string;

			/**
			 * Gets the instance of the platform-specific object
			 *
			 * This can sometimes be useful to get the platform-specific object. Some handlers may
			 * not have any backing object for its functionality, so this may be null.  It is more
			 * preferred to use the {@link Eto.Widget.Handler} and cast that to the platform-specific
			 * handler class which can give you additional methods and helpers to do common tasks.
			 * For example, the {@link Eto.Forms.Application} object's handler for OS X has a
			 * AddFullScreenMenuItem property to specify if you want full screen support in your app.
			 */
			readonly ControlObject: unknown;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Widget} has been disposed.
			 *
			 * When the widget is disposed, it can no longer be used.
			 */
			IsDisposed: boolean;

			/**
			 * Finds a control in the parent hierarchy with the specified type and
			 * {@link Eto.Widget.ID} if specified
			 */
			FindParent<T>(id?: string): T;

			/**
			 * Finds a control in the parent hierarchy with the specified type and
			 * {@link Eto.Widget.ID} if specified
			 */
			FindParent(
				type: unknown,
				id?: string,
			): Eto.Widget;

			/** Finds a control in the parent hierarchy with the specified `id` */
			FindParent(id: string): Eto.Widget;

			/**
			 * Unbinds any bindings in the {@link Eto.Forms.BindableWidget.Bindings} collection and
			 * removes the bindings
			 *
			 * When you implement {@link Eto.Forms.IBindableWidgetContainer}, this will also unbind
			 * any of its children.
			 */
			Unbind(): void;

			/**
			 * Updates all bindings in this widget
			 *
			 * When you implement {@link Eto.Forms.IBindableWidgetContainer}, this will also update
			 * bindings for all of its children.
			 */
			UpdateBindings(mode?: Eto.Forms.BindingUpdateMode): void;

			/** Disposes of this widget, supressing the finalizer */
			dispose(): void;

			/** Gets a string that represents the current object with its ID if specified. */
			ToString(): string;
		}
	}

	export namespace Eto.Forms.ToolBar {
		export interface IHandler extends Eto.Widget.IHandler {
			TextAlign: Eto.Forms.ToolBarTextAlign;

			Dock: Eto.Forms.ToolBarDock;

			AddButton(
				button: Eto.Forms.ToolItem,
				index: number,
			): void;

			RemoveButton(
				button: Eto.Forms.ToolItem,
				index: number,
			): void;

			Clear(): void;
		}
	}

	export namespace Eto.Forms {
		/** Base tool item class for a {@link Eto.Forms.ToolBar}. */
		export class ToolItem implements
			Eto.IHandlerSource,
			Eto.Forms.IBindable,
			Eto.Forms.ICommandItem {
			/**
			 * Gets or sets the command to invoke when the tool item is pressed.
			 *
			 * This will invoke the specified command when the tool item is pressed. The
			 * {@link System.Windows.Input.ICommand.CanExecute(System.Object)} will also used to set
			 * the enabled/disabled state of the tool item.
			 */
			Command: unknown;

			/**
			 * Gets or sets the parameter to pass to the {@link Eto.Forms.ToolItem.Command} when
			 * executing or determining its CanExecute state.
			 */
			CommandParameter: unknown;

			/**
			 * Gets or sets the order of the tool item when adding to the
			 * {@link Eto.Forms.ToolItemCollection}.
			 */
			Order: number;

			/** Gets or sets the text of the item, with mnemonic. */
			Text: string;

			/** Gets or sets the tool tip to show when hovering the mouse over the item. */
			ToolTip: string;

			/** Gets or sets the image for the tool item. */
			Image: Eto.Drawing.Image;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Forms.ToolItem} is enabled.
			 */
			Enabled: boolean;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Forms.ToolItem} is visible.
			 */
			Visible: boolean;

			/** Gets or sets a user-defined tag for the tool item. */
			Tag: unknown;

			/**
			 * Gets or sets the parent widget which this widget has been added to, if any
			 *
			 * When implementing child widgets that can participate in the context based binding
			 * (MVVM), You can set this to the parent widget when it is added or removed to it
			 * (usually via a collection).  Note that you should typically provide a public new
			 * [ParentWidget] Parent { get; } property  so that consumers of your API cannot set the
			 * parent to an invalid value.
			 */
			Parent: Eto.Widget;

			/**
			 * Gets an enumeration of all parent widgets in the heirarchy by traversing the
			 * {@link Eto.Forms.BindableWidget.Parent} property.
			 */
			readonly Parents: Iterable<Eto.Widget>;

			/**
			 * Gets or sets the data context for this widget for binding
			 *
			 * Subclasses may override the standard behaviour so that hierarchy of widgets can be
			 * taken into account.  For example, a Control may return the data context of a parent,
			 * if it is not set explicitly.
			 */
			DataContext: unknown;

			/** Gets the collection of bindings that are attached to this widget */
			readonly Bindings: Eto.Forms.BindingCollection;

			/**
			 * Gets a value indicating that the {@link Eto.Forms.BindableWidget.DataContext} property
			 * is changing.
			 *
			 * This can be used to determine when to allow certain logic during the update of the
			 * data context.  It is used to disable binding setters on the model when the data
			 * context changes so that a binding does not cause the view model to be updated when the
			 * state hasn't been fully set yet.
			 */
			IsDataContextChanging: boolean;

			/**
			 * Gets the platform that was used to create the {@link Eto.Widget.Handler} for this
			 * widget
			 *
			 * This gets set to the current {@link Eto.Platform.Instance} during the construction of
			 * the object
			 */
			readonly Platform: Eto.Platform;

			/** Gets the platform-specific handler for this widget */
			Handler: unknown;

			/** Gets the native platform-specific handle for integration purposes */
			readonly NativeHandle: unknown;

			/** Gets the dictionary of properties for this widget */
			readonly Properties: Eto.PropertyStore;

			/** Gets or sets the ID of this widget */
			ID: string;

			/**
			 * Gets or sets the style of this widget
			 *
			 * Styles allow you to attach custom platform-specific logic to a widget. In your
			 * platform-specific assembly, use {@link Style.Add{H}(string, StyleHandler{H})} to add
			 * the style logic with the same id.
			 */
			Style: string;

			/**
			 * Gets the instance of the platform-specific object
			 *
			 * This can sometimes be useful to get the platform-specific object. Some handlers may
			 * not have any backing object for its functionality, so this may be null.  It is more
			 * preferred to use the {@link Eto.Widget.Handler} and cast that to the platform-specific
			 * handler class which can give you additional methods and helpers to do common tasks.
			 * For example, the {@link Eto.Forms.Application} object's handler for OS X has a
			 * AddFullScreenMenuItem property to specify if you want full screen support in your app.
			 */
			readonly ControlObject: unknown;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Widget} has been disposed.
			 *
			 * When the widget is disposed, it can no longer be used.
			 */
			IsDisposed: boolean;

			/** Raises the {@link Eto.Forms.ToolItem.Click} event. */
			OnClick(e: unknown): void;

			/**
			 * Finds a control in the parent hierarchy with the specified type and
			 * {@link Eto.Widget.ID} if specified
			 */
			FindParent<T>(id?: string): T;

			/**
			 * Finds a control in the parent hierarchy with the specified type and
			 * {@link Eto.Widget.ID} if specified
			 */
			FindParent(
				type: unknown,
				id?: string,
			): Eto.Widget;

			/** Finds a control in the parent hierarchy with the specified `id` */
			FindParent(id: string): Eto.Widget;

			/**
			 * Unbinds any bindings in the {@link Eto.Forms.BindableWidget.Bindings} collection and
			 * removes the bindings
			 *
			 * When you implement {@link Eto.Forms.IBindableWidgetContainer}, this will also unbind
			 * any of its children.
			 */
			Unbind(): void;

			/**
			 * Updates all bindings in this widget
			 *
			 * When you implement {@link Eto.Forms.IBindableWidgetContainer}, this will also update
			 * bindings for all of its children.
			 */
			UpdateBindings(mode?: Eto.Forms.BindingUpdateMode): void;

			/** Disposes of this widget, supressing the finalizer */
			dispose(): void;

			/** Gets a string that represents the current object with its ID if specified. */
			ToString(): string;
		}
	}

	export namespace Eto.Forms.ToolItem {
		export interface IHandler extends
			Eto.Forms.Tool.IHandler,
			Eto.Widget.IHandler {
			Image: Eto.Drawing.Image;

			Text: string;

			ToolTip: string;

			Enabled: boolean;

			Visible: boolean;

			CreateFromCommand(command: Eto.Forms.Command): void;
		}
	}

	export namespace Eto.Forms {
		/** ToolBar item collection. */
		export class ToolItemCollection {
			/**
			 * Adds the specified item given its order.
			 *
			 * This will add the item into the collection based on its
			 * {@link Eto.Forms.ToolItem.Order}, keeping all items in their order.
			 */
			Add(item: Eto.Forms.ToolItem): void;

			/** Add a `command` with the specified `order`. */
			Add(
				command: Eto.Forms.Command,
				order?: number,
			): void;

			/** Adds a separator item with the specified `order` or `type` */
			AddSeparator(
				order?: number,
				type?: Eto.Forms.SeparatorToolItemType,
			): void;

			/** Adds the specified tool items to the collection. */
			AddRange(items: Iterable<Eto.Forms.ToolItem>): void;

			/** Adds the specified commands to the collection starting at the specified order. */
			AddRange(
				commands: Iterable<Eto.Forms.Command>,
				order?: number,
			): void;
		}
	}

	export namespace Eto.Forms {
		/** A system tray indicator. */
		export class TrayIndicator implements
			Eto.IHandlerSource {
			constructor();

			/** Gets or sets the icon for the {@link Eto.Forms.TrayIndicator}. */
			Icon: Eto.Drawing.Icon;

			/** Gets or sets the image to display in the tray */
			Image: Eto.Drawing.Image;

			/** Gets or sets the title/tooltip for the {@link Eto.Forms.TrayIndicator}. */
			Title: string;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Forms.TrayIndicator} is
			 * visible.
			 */
			Visible: boolean;

			/** Gets or sets the menu shown when the user clicks on the tray icon. */
			Menu: Eto.Forms.ContextMenu;

			/**
			 * Gets the platform that was used to create the {@link Eto.Widget.Handler} for this
			 * widget
			 *
			 * This gets set to the current {@link Eto.Platform.Instance} during the construction of
			 * the object
			 */
			readonly Platform: Eto.Platform;

			/** Gets the platform-specific handler for this widget */
			Handler: unknown;

			/** Gets the native platform-specific handle for integration purposes */
			readonly NativeHandle: unknown;

			/** Gets the dictionary of properties for this widget */
			readonly Properties: Eto.PropertyStore;

			/** Gets or sets the ID of this widget */
			ID: string;

			/**
			 * Gets or sets the style of this widget
			 *
			 * Styles allow you to attach custom platform-specific logic to a widget. In your
			 * platform-specific assembly, use {@link Style.Add{H}(string, StyleHandler{H})} to add
			 * the style logic with the same id.
			 */
			Style: string;

			/**
			 * Gets the instance of the platform-specific object
			 *
			 * This can sometimes be useful to get the platform-specific object. Some handlers may
			 * not have any backing object for its functionality, so this may be null.  It is more
			 * preferred to use the {@link Eto.Widget.Handler} and cast that to the platform-specific
			 * handler class which can give you additional methods and helpers to do common tasks.
			 * For example, the {@link Eto.Forms.Application} object's handler for OS X has a
			 * AddFullScreenMenuItem property to specify if you want full screen support in your app.
			 */
			readonly ControlObject: unknown;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Widget} has been disposed.
			 *
			 * When the widget is disposed, it can no longer be used.
			 */
			IsDisposed: boolean;

			/**
			 * Hide this instance of {@link Eto.Forms.TrayIndicator}.
			 *
			 * Make sure to call this method before closing the application.
			 */
			Hide(): void;

			/**
			 * Sets the indicator menu.
			 *
			 * Make sure to call this method every time you make changes to the context menu.
			 */
			SetMenu(menu: Eto.Forms.ContextMenu): void;

			/** Show this instance of {@link Eto.Forms.TrayIndicator}. */
			Show(): void;

			/** Disposes of this widget, supressing the finalizer */
			dispose(): void;

			/** Gets a string that represents the current object with its ID if specified. */
			ToString(): string;
		}
	}

	export namespace Eto.Forms.TrayIndicator {
		export interface IHandler extends Eto.Widget.IHandler {
			Title: string;

			Visible: boolean;

			Image: Eto.Drawing.Image;

			Menu: Eto.Forms.ContextMenu;
		}
	}

	export namespace Eto.Forms.TrayIndicator {
		export interface ICallback extends Eto.Widget.ICallback {
			OnActivated(
				widget: Eto.Forms.TrayIndicator,
				e: unknown,
			): void;
		}
	}

	export namespace Eto.Forms {
		/**
		 * Provides a timer that executes code at a specified interval on the UI thread
		 *
		 * This provides a way to execute UI code at a specified
		 * {@link Eto.Forms.UITimer.Interval}. Note that this is not a high-resolution timer, and
		 * you should avoid setting a small interval otherwise the UI may become unresponsive
		 * depending on the logic in the executed code.  This typically executes the code on the
		 * UI main loop, thus the accuracy of the timer is dependent on the other UI code
		 * executing.
		 */
		export class UITimer implements
			Eto.IHandlerSource {
			/** Initializes a new instance of the {@link Eto.Forms.UITimer} class. */
			constructor();

			/**
			 * Initializes a new instance of the {@link Eto.Forms.UITimer} class with the specified
			 * `elapsedHandler`.
			 */
			constructor(elapsedHandler: unknown);

			/**
			 * Gets or sets the interval, in seconds
			 *
			 * Note that this is not a high-resolution timer, and you should avoid setting a small
			 * interval otherwise the UI may become unresponsive depending on the logic in the
			 * executed code.
			 */
			Interval: number;

			/** Gets a value indicating whether this {@link Eto.Forms.UITimer} is started. */
			Started: boolean;

			/**
			 * Gets the platform that was used to create the {@link Eto.Widget.Handler} for this
			 * widget
			 *
			 * This gets set to the current {@link Eto.Platform.Instance} during the construction of
			 * the object
			 */
			readonly Platform: Eto.Platform;

			/** Gets the platform-specific handler for this widget */
			Handler: unknown;

			/** Gets the native platform-specific handle for integration purposes */
			readonly NativeHandle: unknown;

			/** Gets the dictionary of properties for this widget */
			readonly Properties: Eto.PropertyStore;

			/** Gets or sets the ID of this widget */
			ID: string;

			/**
			 * Gets or sets the style of this widget
			 *
			 * Styles allow you to attach custom platform-specific logic to a widget. In your
			 * platform-specific assembly, use {@link Style.Add{H}(string, StyleHandler{H})} to add
			 * the style logic with the same id.
			 */
			Style: string;

			/**
			 * Gets the instance of the platform-specific object
			 *
			 * This can sometimes be useful to get the platform-specific object. Some handlers may
			 * not have any backing object for its functionality, so this may be null.  It is more
			 * preferred to use the {@link Eto.Widget.Handler} and cast that to the platform-specific
			 * handler class which can give you additional methods and helpers to do common tasks.
			 * For example, the {@link Eto.Forms.Application} object's handler for OS X has a
			 * AddFullScreenMenuItem property to specify if you want full screen support in your app.
			 */
			readonly ControlObject: unknown;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Widget} has been disposed.
			 *
			 * When the widget is disposed, it can no longer be used.
			 */
			IsDisposed: boolean;

			/** Starts the timer */
			Start(): void;

			/** Stops a running timer */
			Stop(): void;

			/** Disposes of this widget, supressing the finalizer */
			dispose(): void;

			/** Gets a string that represents the current object with its ID if specified. */
			ToString(): string;
		}
	}

	export namespace Eto.Forms.UITimer {
		export interface ICallback extends Eto.Widget.ICallback {
			OnElapsed(
				widget: Eto.Forms.UITimer,
				e: unknown,
			): void;
		}
	}

	export namespace Eto.Forms.UITimer {
		export interface IHandler extends Eto.Widget.IHandler {
			Interval: number;

			Start(): void;

			Stop(): void;
		}
	}

	export namespace Eto.Forms {
		/**
		 * [Generic type factory] Interface for a command that can provide a value
		 *
		 * Some controls can provide a value, which can be difficult to get via the command when
		 * the value changes. This inteface allows you to extend your command to allow getting
		 * and setting a value of any type and have an event when the value changes
		 * programatically.
		 */
		export function IValueCommand$(T: IType): IType;

		/**
		 * Interface for a command that can provide a value
		 *
		 * Some controls can provide a value, which can be difficult to get via the command when
		 * the value changes. This inteface allows you to extend your command to allow getting
		 * and setting a value of any type and have an event when the value changes
		 * programatically.
		 */
		export interface IValueCommand$1<T> {
			/**
			 * Gets the current value in the command.
			 *
			 * This is typically called by the control when the
			 * {@link Eto.Forms.IValueCommand`1.ValueChanged} event is raised.
			 */
			GetValue(parameter: unknown): T;

			/**
			 * Sets the value in the command from the control.
			 *
			 * This is typically invoked when the control has updated its value.
			 */
			SetValue(
				parameter: unknown,
				value: T,
			): void;
		}
	}

	export namespace Eto.Forms {
		/** [Generic type factory] Command that provides a specific value. */
		export function ValueCommand$(T: IType): typeof ValueCommand$1<any>;

		/** Command that provides a specific value. */
		export class ValueCommand$1<T> implements
			Eto.Forms.IBindable {
			new(): ValueCommand$1<T>;

			/** Gets or sets the value for the command. */
			Value: T;

			/**
			 * Gets or sets the ID of the command
			 *
			 * This can be used to identify a command.
			 */
			ID: string;

			/** Gets or sets a value indicating whether this {@link Eto.Forms.Command} is enabled. */
			Enabled: boolean;

			/** Gets or sets a user-defined tag value for this instance. */
			Tag: unknown;

			/** Gets or sets the text when shown on the menu. */
			MenuText: string;

			/** Gets or sets the tool bar text. */
			ToolBarText: string;

			/** Gets or sets the tool tip on both the menu and toolbar. */
			ToolTip: string;

			/**
			 * Gets or sets the image for the menu or tool item.
			 *
			 * On some platforms, the menu bar does not show the image by default (e.g. OS X). You
			 * can override this behaviour using a style on the handler.
			 */
			Image: Eto.Drawing.Image;

			/** Gets or sets the shortcut to trigger this command. */
			Shortcut: Eto.Forms.Keys;

			/** Gets the dictionary of properties for this widget */
			readonly Properties: Eto.PropertyStore;

			/**
			 * Gets or sets a command to delegate to when the command is invoked.
			 *
			 * This allows you to use a command to define menu/toolbar items or other functionality,
			 * and use a delegated command to chain to when invoked. This is especially useful when
			 * binding to a view model, you can do something like the following: var myCommand = new
			 * Command { MenuText = "My Command", Parent = myForm }; myCommand.BindDataContext(c
			 * =&gt; c.DelegatedCommand, (MyModel m) =&gt; m.MyModelCommand);  //...
			 * myForm.DataContext = new MyModel { MyModelCommand = ... }; The
			 * {@link System.Windows.Input.ICommand.CanExecute(System.Object)} will also used to set
			 * the enabled/disabled state of the current command.
			 */
			DelegatedCommand: unknown;

			/**
			 * Gets or sets the parameter to pass to the {@link Eto.Forms.Command} when executing or
			 * determining its CanExecute state.
			 */
			CommandParameter: unknown;

			/** Gets the parent widget which this widget has been added to, if any */
			Parent: Eto.Forms.IBindable;

			/**
			 * Gets or sets the data context for this widget for binding
			 *
			 * Subclasses may override the standard behaviour so that hierarchy of widgets can be
			 * taken into account.  For example, a Control may return the data context of a parent,
			 * if it is not set explicitly.
			 */
			DataContext: unknown;

			/**
			 * Gets a value indicating that the {@link Eto.Forms.Command.DataContext} property is
			 * changing.
			 *
			 * This can be used to determine when to allow certain logic during the update of the
			 * data context.  It is used to disable binding setters on the model when the data
			 * context changes so that a binding does not cause the view model to be updated when the
			 * state hasn't been fully set yet.
			 */
			IsDataContextChanging: boolean;

			/** Gets the collection of bindings that are attached to this widget */
			readonly Bindings: Eto.Forms.BindingCollection;

			/** Execute the command programatically. */
			Execute(): void;

			/** Creates a new tool item attached to this command. */
			CreateToolItem(): Eto.Forms.ToolItem;

			/** Creates a new menu item attached to this command. */
			CreateMenuItem(): Eto.Forms.MenuItem;
		}
	}

	export namespace Eto.Forms {
		/** Extensions for widget objects */
		export namespace WidgetExtensions {
			/** Allows execution of extra code on a widget in a declarative manner. */
			export function With<T>(
				widget: T,
				action: (arg1: T) => void,
			): T;
		}
	}

	export namespace Eto.Forms.WidgetExtensions {
		/** Extension methods from {@link Eto.Forms.WidgetExtensions} */
		export interface T {
			/** Allows execution of extra code on a widget in a declarative manner. */
			With<T>(action: (arg1: T) => void): T;
		}
	}

	export namespace Eto.Forms {
		/** State of a {@link Eto.Forms.Window} */
		export enum WindowState {
			/** Normal, windowed state */
			Normal = 0,

			/** Window is maximized, taking the entire screen space */
			Maximized = 1,

			/** Window is minimized to the dock/taskbar/etc. */
			Minimized = 2,
		}
	}

	export namespace Eto.Forms {
		/** Style of a {@link Eto.Forms.Window} */
		export enum WindowStyle {
			/** Default, bordered style */
			Default = 0,

			/** Window with no border */
			None = 1,

			/**
			 * Utility window, usually with a smaller border
			 *
			 * Note that this is only a hint; some platforms may show it as a default window. E.g. on
			 * macOS, only a {@link Eto.Forms.FloatingForm} supports this mode.
			 */
			Utility = 2,
		}
	}

	export namespace Eto.Forms {
		/** Base window */
		export class Window implements
			Eto.IHandlerSource,
			Eto.Forms.IBindable,
			Eto.Forms.IMouseInputSource,
			Eto.Forms.IKeyboardInputSource {
			/**
			 * Gets or sets the title of the window
			 *
			 * The title of the window is displayed to the user usually at the top of the window, but
			 * in cases where you show a window in a mobile environment, this may be the title shown
			 * in a navigation controller.
			 */
			Title: string;

			/**
			 * Gets or sets the location of the window
			 *
			 * Note that in multi-monitor setups, the origin of the location is at the upper-left of
			 * {@link Eto.Forms.Screen.PrimaryScreen}.  Also note, that on Linux systems running GTK
			 * via Wayland, this will always point to 0, 0 , and setting it to different values will
			 * have no effect.
			 */
			Location: Eto.Drawing.Point;

			/** Gets or sets the size and location of the window */
			Bounds: Eto.Drawing.Rectangle;

			/**
			 * Gets or sets the tool bar for the window.
			 *
			 * Note that each window can only have a single tool bar
			 */
			ToolBar: Eto.Forms.ToolBar;

			/** Gets or sets the opacity of the window */
			Opacity: number;

			/**
			 * Gets or sets the owner of this window.
			 *
			 * This sets the parent window that has ownership over this window. For a
			 * {@link Eto.Forms.Dialog}, this will be the window that will be disabled while the
			 * modal dialog is shown. With a {@link Eto.Forms.Form}, the specified owner will always
			 * be below the current window when shown, and will  still be responsive to user input.
			 * Typically, but not always, the window will move along with the owner.
			 */
			Owner: Eto.Forms.Window;

			/**
			 * Gets the screen this window is mostly contained in. Typically defined by the screen
			 * center of the window is visible.
			 */
			readonly Screen: Eto.Forms.Screen;

			/**
			 * Gets or sets the menu bar for this window
			 *
			 * Some platforms have a global menu bar (e.g. Ubuntu, OS X). When the window is in
			 * focus, the global menu bar will be changed to reflect the menu assigned.
			 */
			Menu: Eto.Forms.MenuBar;

			/**
			 * Gets or sets the icon for the window to show in the menu bar.
			 *
			 * The icon should have many variations, such as 16x16, 24x24, 32x32, 48x48, 64x64, etc.
			 * This ensures that the many places it is used (title bar, task bar, switch window, etc)
			 * all have optimized icon sizes.  For OS X, the application icon is specified in the
			 * .app bundle, not by this value.
			 */
			Icon: Eto.Drawing.Icon;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Forms.Window} is resizable.
			 */
			Resizable: boolean;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Forms.Window} can be
			 * maximized.
			 *
			 * This may hide or disable the minimize button on the title bar.
			 */
			Maximizable: boolean;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Forms.Window} can be
			 * minimized.
			 *
			 * This may hide or disable the maximize button on the title bar.
			 */
			Minimizable: boolean;

			/**
			 * Gets or sets a value indicating whether the close button should be shown. Defaults to
			 * true
			 *
			 * Note that on some platforms (e.g. Windows) this also hides the system menu and
			 * minimize/maximize buttons. Note that this does not prevent the window from being
			 * closed, to do that use the {@link Eto.Forms.Window.Closing} event.
			 */
			Closeable: boolean;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Forms.Window} will show in the
			 * taskbar.
			 *
			 * Some platforms, e.g. macOS do not show a separate icon for each running window.  You
			 * may also have to add  the LSUIElement key to your app's Info.plist to make your app
			 * hidden in the dock.   See
			 * https://developer.apple.com/library/archive/documentation/General/Reference/InfoPlistKeyReference/Articles/LaunchServicesKeys.html#//apple_ref/doc/uid/TP40009250-108256-TPXREF136
			 */
			ShowInTaskbar: boolean;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Forms.Window} is above all
			 * other windows.
			 *
			 * The window should be above all other windows when this is true.  In some platforms,
			 * this will show above all other windows only when the application has focus.
			 */
			Topmost: boolean;

			/** Gets or sets the state of the window. */
			WindowState: Eto.Forms.WindowState;

			/**
			 * Gets the bounds of the window before it was minimized or maximized, or the current
			 * bounds if {@link Eto.Forms.Window.WindowState} is Normal.
			 *
			 * This is useful to retrieve the desired size and position of the window even though it
			 * is currently maximized or minimized.
			 */
			readonly RestoreBounds: Eto.Drawing.Rectangle;

			/** Gets or sets the style of this window. */
			WindowStyle: Eto.Forms.WindowStyle;

			/**
			 * Gets the number of pixels per logical pixel when on a high DPI display.
			 *
			 * This indicates the number of pixels per logical pixel.   All units in Eto.Forms such
			 * as control size, drawing operations, etc are in logical pixels. When not in high DPI,
			 * this will be 1.0;  Retina displays in OS X will return 2; and in windows this matches
			 * the scale set in the monitor settings.  Use the
			 * {@link Eto.Forms.Window.LogicalPixelSizeChanged} to detect when the window is moved to
			 *  a display with a different DPI.
			 */
			readonly LogicalPixelSize: number;

			/**
			 * Gets or sets a value indicating that the window can be moved by click+dragging the
			 * window background
			 */
			MovableByWindowBackground: boolean;

			/**
			 * Gets or sets a value indicating that the window will automatically resize when its
			 * content changes
			 *
			 * Note that if you set both dimensions of the {@link Eto.Drawing.Size} and/or
			 * {@link Eto.Forms.Container.ClientSize}, this will be set to false.
			 */
			AutoSize: boolean;

			/** Gets an enumeration of controls that are directly contained by this container */
			readonly Controls: Iterable<Eto.Forms.Control>;

			/** Gets or sets the padding around the {@link Eto.Forms.Panel.Content} of the panel. */
			Padding: Eto.Drawing.Padding;

			/** Gets or sets the minimum size of the panel. */
			MinimumSize: Eto.Drawing.Size;

			/**
			 * Gets or sets the context menu for the panel.
			 *
			 * The context menu is usually shown when the user right clicks the control, or in mobile
			 * platforms when the user taps and holds their finger down on the control.
			 */
			ContextMenu: Eto.Forms.ContextMenu;

			/**
			 * Gets or sets the main content of the panel.
			 *
			 * The main content will be offset by the {@link Eto.Forms.Panel.Padding} value
			 * specified, and will take up the entire content area of the control. Some controls may
			 * have decorations that will surround the content, such as a {@link Eto.Forms.GroupBox},
			 * {@link Eto.Forms.TabControl}, or {@link Eto.Forms.Window}
			 */
			Content: Eto.Forms.Control;

			/**
			 * Gets or sets the size for the client area of the control
			 *
			 * The client size differs from the {@link Eto.Forms.Control.Size} in that it excludes
			 * the decorations of the container, such as the title bar and border around a
			 * {@link Eto.Forms.Window}, or the title and line  around a {@link Eto.Forms.GroupBox}.
			 */
			ClientSize: Eto.Drawing.Size;

			/**
			 * Gets an enumeration of all contained child controls, including controls within child
			 * containers
			 */
			readonly Children: Iterable<Eto.Forms.Control>;

			/**
			 * Gets an enumeration of all contained child controls in the visual tree, including
			 * controls within child containers.
			 */
			readonly VisualChildren: Iterable<Eto.Forms.Control>;

			/**
			 * Gets or sets the style provider for this container.
			 *
			 * The style provider is used to style this container and its children.
			 */
			StyleProvider: Eto.IStyleProvider;

			/**
			 * Gets the default style provider for this container.
			 *
			 * Use this to apply styles to any child controls of this container. By default, styles
			 * will apply to all children, including children of children unless
			 * {@link Eto.DefaultStyleProvider.Inherit} is set to false .  Typically, you would set
			 * Inherit to false when creating composite controls that already have all their styles
			 * applied and you don't want any other styles to be inherited.
			 */
			readonly Styles: Eto.DefaultStyleProvider;

			/**
			 * Gets a value indicating that the control is loaded onto a form, that is it has been
			 * created, added to a parent, and shown
			 *
			 * The {@link Eto.Forms.Control.OnLoad(System.EventArgs)} method sets this value to true
			 * after cascading to all children (for a {@link Eto.Forms.Container} ) and calling the
			 * platform handler's implementation.  It is called after adding to a loaded form, or
			 * when showing a new form.  The {@link Eto.Forms.Control.OnUnLoad(System.EventArgs)}
			 * method will set this value to false when the control is removed from its parent
			 */
			readonly Loaded: boolean;

			/**
			 * Gets an enumeration of controls that are in the visual tree.
			 *
			 * This is used to specify which controls are contained by this instance that are part of
			 * the visual tree. This should include all controls including non-logical Eto controls
			 * used for layout.
			 */
			readonly VisualControls: Iterable<Eto.Forms.Control>;

			/**
			 * Gets or sets a user-defined object that contains data about the control
			 *
			 * A common use of the tag property is to store data that is associated with the control
			 * that you can later retrieve.
			 */
			Tag: unknown;

			/**
			 * Gets the logical parent control.
			 *
			 * When the control is part of the visual tree (
				 * {@link Eto.Forms.Control.IsVisualControl} is true), this returns the logical parent
				 * that contains this control. Otherwise this is the same as
				 * {@link Eto.Forms.Control.Parent}.
				 */
				readonly LogicalParent: Eto.Forms.Container;

			/** Gets a value indicating this {@link Eto.Forms.Control} is part of the visual tree. */
			IsVisualControl: boolean;

			/**
			 * Gets or sets the size of the control. Use -1 to specify auto sizing for either the
			 * width and/or height.
			 *
			 * Setting the size of controls is entirely optional as most controls will size
			 * themselves appropriately. When specifying a size, it will be used as the desired size
			 * of the control.  The container will reposition and resize the control depending on the
			 * available size.  For a {@link Eto.Forms.Window}, it is preferred to set the
			 * {@link Eto.Forms.Container.ClientSize} instead, as various platforms have different
			 * sizes of window decorations, toolbars, etc.
			 */
			Size: Eto.Drawing.Size;

			/**
			 * Gets a value indicating this control currently has mouse capture
			 *
			 * Mouse capture can happen during a handled MouseDown event until MouseUp, or it can be
			 * captured explicitly via {@link Eto.Forms.Control.CaptureMouse}.
			 */
			readonly IsMouseCaptured: boolean;

			/** Gets or sets the width of the control size. */
			Width: number;

			/** Gets or sets the height of the control size. */
			Height: number;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Forms.Control} (or its
			 * children) are enabled and accept user input.
			 *
			 * Typically when a control is disabled, the user cannot do anything with the control or
			 * any of its children. Including for example, selecting text in a text control. Certain
			 * controls can have a 'Read Only' mode, such as {@link Eto.Forms.TextBox.ReadOnly} which
			 * allow the user to  select text, but not change its contents.
			 */
			Enabled: boolean;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Forms.Control} is visible to
			 * the user.
			 *
			 * When the visibility of a control is set to false, it will not occupy space in the
			 * layout.
			 */
			Visible: boolean;

			/** Gets the container which this control has been added to, if any */
			readonly Parent: Eto.Forms.Container;

			/**
			 * Gets the visual container of this control, if any.
			 *
			 * Some containers may use other Eto controls to layout its children, such as the
			 * {@link Eto.Forms.StackLayout}. This will return the parent control that visually
			 * contains this control as opposed to {@link Eto.Forms.Control.Parent} which will return
			 * the logical parent.
			 */
			VisualParent: Eto.Forms.Container;

			/** Gets a value indicating this control has been attached to a native container */
			readonly IsAttached: boolean;

			/**
			 * Gets or sets the color for the background of the control
			 *
			 * Note that on some platforms (e.g. Mac), setting the background color of a control can
			 * change the performance characteristics of the control and its children, since it must
			 * enable layers to do so.
			 */
			BackgroundColor: Eto.Drawing.Color;

			/** Gets a value indicating whether this instance has the keyboard input focus. */
			readonly HasFocus: boolean;

			/** Gets a value indicating whether the layout of child controls is suspended. */
			readonly IsSuspended: boolean;

			/** Gets the window this control is contained in */
			readonly ParentWindow: Eto.Forms.Window;

			/**
			 * Gets the supported platform commands that can be used to hook up system functions to
			 * user defined logic
			 *
			 * This lists all available commands that can be mapped using the
			 * {@link Eto.Forms.Control.MapPlatformCommand(System.String,Eto.Forms.Command)} method
			 * of the control.
			 */
			readonly SupportedPlatformCommands: Iterable<string>;

			/** Gets or sets the type of cursor to use when the mouse is hovering over the control */
			Cursor: Eto.Forms.Cursor;

			/** Gets or sets the tool tip to show when the mouse is hovered over the control */
			ToolTip: string;

			/**
			 * Gets or sets the tab index order for this control within its container.
			 *
			 * This sets the order when using the tab key to cycle through controls  Note that some
			 * platforms (Gtk and WinForms) may not support setting the context of the tab order to
			 * StackLayout  or DynamicLayout containers and may not behave exactly as expected. Use
			 * the {@link Eto.PlatformFeatures.TabIndexWithCustomContainers} flag to determine if it
			 * is supported.
			 */
			TabIndex: number;

			/** Gets or sets a value indicating whether this control can serve as drop target. */
			AllowDrop: boolean;

			/**
			 * Gets or sets the parent widget which this widget has been added to, if any
			 *
			 * When implementing child widgets that can participate in the context based binding
			 * (MVVM), You can set this to the parent widget when it is added or removed to it
			 * (usually via a collection).  Note that you should typically provide a public new
			 * [ParentWidget] Parent { get; } property  so that consumers of your API cannot set the
			 * parent to an invalid value.
			 */
			Parent: Eto.Widget;

			/**
			 * Gets an enumeration of all parent widgets in the heirarchy by traversing the
			 * {@link Eto.Forms.BindableWidget.Parent} property.
			 */
			readonly Parents: Iterable<Eto.Widget>;

			/**
			 * Gets or sets the data context for this widget for binding
			 *
			 * Subclasses may override the standard behaviour so that hierarchy of widgets can be
			 * taken into account.  For example, a Control may return the data context of a parent,
			 * if it is not set explicitly.
			 */
			DataContext: unknown;

			/** Gets the collection of bindings that are attached to this widget */
			readonly Bindings: Eto.Forms.BindingCollection;

			/**
			 * Gets a value indicating that the {@link Eto.Forms.BindableWidget.DataContext} property
			 * is changing.
			 *
			 * This can be used to determine when to allow certain logic during the update of the
			 * data context.  It is used to disable binding setters on the model when the data
			 * context changes so that a binding does not cause the view model to be updated when the
			 * state hasn't been fully set yet.
			 */
			IsDataContextChanging: boolean;

			/**
			 * Gets the platform that was used to create the {@link Eto.Widget.Handler} for this
			 * widget
			 *
			 * This gets set to the current {@link Eto.Platform.Instance} during the construction of
			 * the object
			 */
			readonly Platform: Eto.Platform;

			/** Gets the platform-specific handler for this widget */
			Handler: unknown;

			/** Gets the native platform-specific handle for integration purposes */
			readonly NativeHandle: unknown;

			/** Gets the dictionary of properties for this widget */
			readonly Properties: Eto.PropertyStore;

			/** Gets or sets the ID of this widget */
			ID: string;

			/**
			 * Gets or sets the style of this widget
			 *
			 * Styles allow you to attach custom platform-specific logic to a widget. In your
			 * platform-specific assembly, use {@link Style.Add{H}(string, StyleHandler{H})} to add
			 * the style logic with the same id.
			 */
			Style: string;

			/**
			 * Gets the instance of the platform-specific object
			 *
			 * This can sometimes be useful to get the platform-specific object. Some handlers may
			 * not have any backing object for its functionality, so this may be null.  It is more
			 * preferred to use the {@link Eto.Widget.Handler} and cast that to the platform-specific
			 * handler class which can give you additional methods and helpers to do common tasks.
			 * For example, the {@link Eto.Forms.Application} object's handler for OS X has a
			 * AddFullScreenMenuItem property to specify if you want full screen support in your app.
			 */
			readonly ControlObject: unknown;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Widget} has been disposed.
			 *
			 * When the widget is disposed, it can no longer be used.
			 */
			IsDisposed: boolean;

			/**
			 * Gets the window at the specified logical screen point.
			 *
			 * This should get the first Eto window directly underneath the specified point.
			 */
			static FromPoint(point: Eto.Drawing.PointF): Eto.Forms.Window;

			/**
			 * Closes the window
			 *
			 * Note that once a window is closed, it cannot be shown again in most platforms.
			 */
			Close(): void;

			/**
			 * Sets {@link Eto.Forms.Window.WindowState} to {@link Eto.Forms.WindowState.Minimized}
			 */
			Minimize(): void;

			/**
			 * Sets {@link Eto.Forms.Window.WindowState} to {@link Eto.Forms.WindowState.Maximized}
			 */
			Maximize(): void;

			/**
			 * Brings the window in front of all other windows in the z-order.  This should not
			 * activate/focus the window.
			 */
			BringToFront(): void;

			/**
			 * Sends the window behind all other windows in the z-order, and will remain active if it
			 * has focus.
			 */
			SendToBack(): void;

			/** Removes the specified child from the container */
			Remove(child: Eto.Forms.Control): void;

			/** Remove the specified `controls` from this container */
			Remove(controls: Iterable<Eto.Forms.Control>): void;

			/** Removes all controls from this container */
			RemoveAll(): void;

			/**
			 * Finds a child control in this container or any of its child containers with the
			 * specified `id`
			 */
			FindChild<T>(id?: string): T;

			/**
			 * Finds a child control in this container or any of its child containers with the
			 * specified `type`
			 */
			FindChild(
				type: unknown,
				id?: string,
			): Eto.Forms.Control;

			/**
			 * Finds a child control in this container or any of its child containers with the
			 * specified `id`.
			 */
			FindChild(id: string): Eto.Forms.Control;

			/**
			 * Queues a repaint of the entire control on the screen and any of its children.
			 *
			 * This is only useful when the control is visible.
			 */
			Invalidate(): void;

			/**
			 * Queues a repaint of the entire control on the screen
			 *
			 * This is only useful when the control is visible.
			 */
			Invalidate(invalidateChildren: boolean): void;

			/**
			 * Queues a repaint of the specified `rect` of the control and any children.
			 *
			 * This is only useful when the control is visible.
			 */
			Invalidate(rect: Eto.Drawing.Rectangle): void;

			/**
			 * Queues a repaint of the specified `rect` of the control
			 *
			 * This is only useful when the control is visible.
			 */
			Invalidate(
				rect: Eto.Drawing.Rectangle,
				invalidateChildren: boolean,
			): void;

			/**
			 * Updates the layout of this control if necessary.
			 *
			 * This will ensure the control has had all of its layout applied so you can use its
			 * position and size right after this call. Most platforms (except WinForms) use a
			 * deferred layout system so that after adding your control to the form dynamically it
			 * won't get laid out until the next idle loop. This is useful when you need to know the
			 * dimensions of the control immediately. Note that this can be an expensive operation,
			 * so it is recommended to only call this method when necessary and after all of the
			 * controls have been added/updated.
			 */
			UpdateLayout(): void;

			/** Gets the preferred size of this control given infinite space available. */
			GetPreferredSize(): Eto.Drawing.SizeF;

			/** Gets the preferred size of this control given the specified `availableSize`. */
			GetPreferredSize(availableSize: Eto.Drawing.SizeF): Eto.Drawing.SizeF;

			/**
			 * Captures all mouse events to this control.
			 *
			 * This captures all mouse events until {@link Eto.Forms.Control.ReleaseMouseCapture} is
			 * called.  Note that not all platforms will allow a mouse capture unless the mouse is
			 * currently down.
			 */
			CaptureMouse(): boolean;

			/** Releases the mouse capture after a call to {@link Eto.Forms.Control.CaptureMouse}. */
			ReleaseMouseCapture(): void;

			/**
			 * Finds a control in the parent hierarchy with the specified type and
			 * {@link Eto.Widget.ID} if specified
			 */
			FindParent(
				type: unknown,
				id?: string,
			): Eto.Forms.Container;

			/** Finds a control in the parent hierarchy with the specified `id` */
			FindParent(id: string): Eto.Forms.Container;

			/**
			 * Detaches the control by removing it from its parent
			 *
			 * This is essentially a shortcut to myControl.Parent.Remove(myControl);
			 */
			Detach(): void;

			/**
			 * Attaches the control for direct use in a native application
			 *
			 * Use this to use a control directly in a native application.  Note that the native
			 * application must be running the same framework as the current platform.  E.g. a
			 * WinForms application can use an Eto.Forms control when using the Eto.WinForms
			 * platform.  This prepares the control by firing the {@link Eto.Forms.Control.PreLoad},
			 * {@link Eto.Forms.Control.Load}, etc. events.
			 */
			AttachNative(): void;

			/**
			 * Detaches the control when it is used in a native application, when you want to reuse
			 * the control.
			 *
			 * This should only be called after {@link Eto.Forms.Control.AttachNative} has been
			 * called, which is usually done by calling to ToNative(true) .
			 */
			DetachNative(): void;

			/**
			 * Attempts to set the keyboard input focus to this control, or the first child that
			 * accepts focus. For Windows, this will bring it to front and activate it.
			 */
			Focus(): void;

			/**
			 * Suspends the layout of child controls
			 *
			 * This can be used to optimize some platforms while adding, removing, or changing many
			 * child controls at once. It disables the calculation of control positioning until
			 * {@link Eto.Forms.Control.ResumeLayout} is called. Each call to SuspendLayout() must be
			 * balanced with a call to {@link Eto.Forms.Control.ResumeLayout}.
			 */
			SuspendLayout(): void;

			/**
			 * Resumes the layout after it has been suspended, and performs a layout
			 *
			 * This can be used to optimize some platforms while adding, removing, or changing many
			 * child controls at once. Each call to ResumeLayout() must be balanced with a call to
			 * {@link Eto.Forms.Control.SuspendLayout} before it.
			 */
			ResumeLayout(): void;

			/**
			 * Specifies a command to execute for a platform-specific command
			 *
			 * Some platforms have specific system-defined commands that can be associated with a
			 * control. For example, the Mac platform's cut/copy/paste functionality is defined by
			 * the system, and if you want to hook into it, you can use this to map it to your own
			 * defined logic. The valid values of the `systemCommand` parameter are defined by each
			 * platform, and a list can be retrieved using
			 * {@link Eto.Forms.Control.SupportedPlatformCommands}
			 */
			MapPlatformCommand(
				systemCommand: string,
				command: Eto.Forms.Command,
			): void;

			/** Converts a point from screen space to control space. */
			PointFromScreen(point: Eto.Drawing.PointF): Eto.Drawing.PointF;

			/** Converts a point from control space to screen space */
			PointToScreen(point: Eto.Drawing.PointF): Eto.Drawing.PointF;

			/** Converts a rectangle from screen space to control space. */
			RectangleToScreen(rect: Eto.Drawing.RectangleF): Eto.Drawing.RectangleF;

			/** Converts a rectangle from control space to screen space */
			RectangleFromScreen(rect: Eto.Drawing.RectangleF): Eto.Drawing.RectangleF;

			/**
			 * Starts drag operation using this control as drag source.
			 *
			 * This method can be blocking on some platforms (Wpf, WinForms), and non-blocking on
			 * others (Mac, Gtk). Use the {@link Eto.Forms.Control.DragEnd} event to determine when
			 * the drag operation is completed and get its resulting DragEffects.
			 */
			DoDragDrop(
				data: Eto.Forms.DataObject,
				allowedEffects: Eto.Forms.DragEffects,
			): void;

			/**
			 * Starts drag operation using this control as drag source.
			 *
			 * This method can be blocking on some platforms (Wpf, WinForms), and non-blocking on
			 * others (Mac, Gtk). Use the {@link Eto.Forms.Control.DragEnd} event to determine when
			 * the drag operation is completed and get its resulting DragEffects.
			 */
			DoDragDrop(
				data: Eto.Forms.DataObject,
				allowedEffects: Eto.Forms.DragEffects,
				image: Eto.Drawing.Image,
				cursorOffset: Eto.Drawing.PointF,
			): void;

			/**
			 * Triggers the StyleChanged event and re-applies the styles to this control and its
			 * children.
			 */
			TriggerStyleChanged(): void;

			/** Shows a print dialog to print the specified control */
			Print(): void;

			/**
			 * Finds a control in the parent hierarchy with the specified type and
			 * {@link Eto.Widget.ID} if specified
			 */
			FindParent<T>(id?: string): T;

			/**
			 * Finds a control in the parent hierarchy with the specified type and
			 * {@link Eto.Widget.ID} if specified
			 */
			FindParent(
				type: unknown,
				id?: string,
			): Eto.Widget;

			/** Finds a control in the parent hierarchy with the specified `id` */
			FindParent(id: string): Eto.Widget;

			/**
			 * Unbinds any bindings in the {@link Eto.Forms.BindableWidget.Bindings} collection and
			 * removes the bindings
			 *
			 * When you implement {@link Eto.Forms.IBindableWidgetContainer}, this will also unbind
			 * any of its children.
			 */
			Unbind(): void;

			/**
			 * Updates all bindings in this widget
			 *
			 * When you implement {@link Eto.Forms.IBindableWidgetContainer}, this will also update
			 * bindings for all of its children.
			 */
			UpdateBindings(mode?: Eto.Forms.BindingUpdateMode): void;

			/** Disposes of this widget, supressing the finalizer */
			dispose(): void;

			/** Gets a string that represents the current object with its ID if specified. */
			ToString(): string;
		}
	}

	export namespace Eto.Forms.Window {
		export interface ICallback extends
			Eto.Forms.Control.ICallback,
			Eto.Widget.ICallback {
			OnClosed(
				widget: Eto.Forms.Window,
				e: unknown,
			): void;

			OnClosing(
				widget: Eto.Forms.Window,
				e: unknown,
			): void;

			OnLocationChanged(
				widget: Eto.Forms.Window,
				e: unknown,
			): void;

			OnWindowStateChanged(
				widget: Eto.Forms.Window,
				e: unknown,
			): void;

			OnLogicalPixelSizeChanged(
				widget: Eto.Forms.Window,
				e: unknown,
			): void;
		}
	}

	export namespace Eto.Forms.Window {
		export interface IHandler extends
			Eto.Forms.Panel.IHandler,
			Eto.Forms.Container.IHandler,
			Eto.Forms.Control.IHandler,
			Eto.Widget.IHandler,
			Eto.Forms.IContextMenuHost {
			ToolBar: Eto.Forms.ToolBar;

			Location: Eto.Drawing.Point;

			Opacity: number;

			Title: string;

			readonly Screen: Eto.Forms.Screen;

			Menu: Eto.Forms.MenuBar;

			Icon: Eto.Drawing.Icon;

			Resizable: boolean;

			Maximizable: boolean;

			Minimizable: boolean;

			Closeable: boolean;

			ShowInTaskbar: boolean;

			Topmost: boolean;

			WindowState: Eto.Forms.WindowState;

			readonly RestoreBounds: Eto.Drawing.Rectangle;

			WindowStyle: Eto.Forms.WindowStyle;

			readonly LogicalPixelSize: number;

			MovableByWindowBackground: boolean;

			AutoSize: boolean;

			Close(): void;

			BringToFront(): void;

			SendToBack(): void;

			SetOwner(owner: Eto.Forms.Window): void;
		}
	}

	export namespace Eto.Forms.Window {
		export interface IWindowHandler {
			FromPoint(point: Eto.Drawing.PointF): Eto.Forms.Window;
		}
	}

	export namespace Eto.Forms.ThemedControls {
		/** A themed handler for the {@link Eto.Forms.AboutDialog} dialog. */
		export class ThemedAboutDialogHandler implements
			Eto.Widget.IHandler,
			Eto.Forms.AboutDialog.IHandler,
			Eto.Forms.CommonDialog.IHandler {
			/**
			 * Initializes a new instance of the {@link Eto.Forms.ThemedControls.AboutDialogHandler}
			 * class.
			 */
			constructor();

			/** Gets or sets the copyright text. */
			Copyright: string;

			/** Gets or sets the list of graphical designers. */
			Designers: string[];

			/** Gets or sets the list of developers. */
			Developers: string[];

			/** Gets or sets the list of documenters. */
			Documenters: string[];

			/** Gets or sets the license. */
			License: string;

			/** Gets or sets the application logo. */
			Logo: Eto.Drawing.Image;

			/** Gets or sets the program description. */
			ProgramDescription: string;

			/** Gets or sets the name of the program. */
			ProgramName: string;

			/** Gets or sets the window title. */
			Title: string;

			/** Gets or sets the application version. */
			Version: string;

			/** Gets or sets the application website. */
			Website: unknown;

			/** Gets or sets the application website label. */
			WebsiteLabel: string;

			readonly Callback: Eto.Widget.ICallback;

			Control: Eto.Forms.Dialog;

			readonly HasControl: boolean;

			readonly Widget: Eto.Forms.AboutDialog;

			ID: string;

			readonly NativeHandle: unknown;

			/** Shows the dialog. */
			ShowDialog(parent: Eto.Forms.Window): Eto.Forms.DialogResult;

			IsEventHandled(id: string): boolean;

			HandleEvent(
				id: string,
				defaultEvent?: boolean,
			): void;

			AttachEvent(id: string): void;

			dispose(): void;
		}
	}

	export namespace Eto.Forms.ThemedControls {
		/** Handler for the {@link Eto.Forms.CollectionEditor} control. */
		export class ThemedCollectionEditorHandler implements
			Eto.Widget.IHandler,
			Eto.Forms.Control.IHandler,
			Eto.Forms.CollectionEditor.IHandler {
			constructor();

			/** Data store of the items to edit */
			DataStore: Iterable<unknown>;

			/**
			 * Gets or sets the type of element to create when adding new elements to the data store
			 */
			ElementType: unknown;

			BackgroundColor: Eto.Drawing.Color;

			readonly VisualControls: Iterable<Eto.Forms.Control>;

			readonly PropagateLoadEvents: boolean;

			Size: Eto.Drawing.Size;

			Width: number;

			Height: number;

			Enabled: boolean;

			readonly HasFocus: boolean;

			Visible: boolean;

			readonly SupportedPlatformCommands: Iterable<string>;

			readonly Location: Eto.Drawing.Point;

			ToolTip: string;

			Cursor: Eto.Forms.Cursor;

			readonly ControlObject: unknown;

			TabIndex: number;

			AllowDrop: boolean;

			readonly IsMouseCaptured: boolean;

			readonly Callback: Eto.Forms.Control.ICallback;

			Control: Eto.Forms.ThemedControls.ThemedCollectionEditor;

			readonly HasControl: boolean;

			readonly Widget: Eto.Forms.CollectionEditor;

			ID: string;

			readonly NativeHandle: unknown;

			GetPreferredSize(availableSize: Eto.Drawing.SizeF): Eto.Drawing.SizeF;

			Invalidate(invalidateChildren: boolean): void;

			Invalidate(
				rect: Eto.Drawing.Rectangle,
				invalidateChildren: boolean,
			): void;

			SuspendLayout(): void;

			ResumeLayout(): void;

			Focus(): void;

			OnPreLoad(e: unknown): void;

			OnLoad(e: unknown): void;

			OnLoadComplete(e: unknown): void;

			OnUnLoad(e: unknown): void;

			SetParent(
				oldParent: Eto.Forms.Container,
				newParent: Eto.Forms.Container,
			): void;

			PointFromScreen(point: Eto.Drawing.PointF): Eto.Drawing.PointF;

			PointToScreen(point: Eto.Drawing.PointF): Eto.Drawing.PointF;

			MapPlatformCommand(
				systemAction: string,
				action: Eto.Forms.Command,
			): void;

			DoDragDrop(
				data: Eto.Forms.DataObject,
				allowedAction: Eto.Forms.DragEffects,
				image: Eto.Drawing.Image,
				cursorOffset: Eto.Drawing.PointF,
			): void;

			AttachEvent(id: string): void;

			GetNativeParentWindow(): Eto.Forms.Window;

			Print(): void;

			UpdateLayout(): void;

			CaptureMouse(): boolean;

			ReleaseMouseCapture(): void;

			IsEventHandled(id: string): boolean;

			HandleEvent(
				id: string,
				defaultEvent?: boolean,
			): void;

			dispose(): void;
		}
	}

	export namespace Eto.Forms.ThemedControls {
		/** Implementation of the CollectionEditor using a GridView and PropertyGrid. */
		export class ThemedCollectionEditor implements
			Eto.IHandlerSource,
			Eto.Forms.IBindable,
			Eto.Forms.IMouseInputSource,
			Eto.Forms.IKeyboardInputSource {
			/** Initializes a new instance of the ThemedCollectionEditor */
			constructor();

			/** Data store of the items to edit */
			DataStore: Iterable<unknown>;

			/**
			 * Gets or sets the type of element to create when adding new elements to the data store
			 */
			ElementType: unknown;

			/**
			 * Gets or sets a control for extra content in this control.  This appears below the
			 * property grid in the same line as the add/remove buttons.
			 */
			ExtraContent: Eto.Forms.Control;

			/** Gets an enumeration of controls that are directly contained by this container */
			readonly Controls: Iterable<Eto.Forms.Control>;

			/** Gets or sets the padding around the {@link Eto.Forms.Panel.Content} of the panel. */
			Padding: Eto.Drawing.Padding;

			/** Gets or sets the minimum size of the panel. */
			MinimumSize: Eto.Drawing.Size;

			/**
			 * Gets or sets the context menu for the panel.
			 *
			 * The context menu is usually shown when the user right clicks the control, or in mobile
			 * platforms when the user taps and holds their finger down on the control.
			 */
			ContextMenu: Eto.Forms.ContextMenu;

			/**
			 * Gets or sets the main content of the panel.
			 *
			 * The main content will be offset by the {@link Eto.Forms.Panel.Padding} value
			 * specified, and will take up the entire content area of the control. Some controls may
			 * have decorations that will surround the content, such as a {@link Eto.Forms.GroupBox},
			 * {@link Eto.Forms.TabControl}, or {@link Eto.Forms.Window}
			 */
			Content: Eto.Forms.Control;

			/**
			 * Gets or sets the size for the client area of the control
			 *
			 * The client size differs from the {@link Eto.Forms.Control.Size} in that it excludes
			 * the decorations of the container, such as the title bar and border around a
			 * {@link Eto.Forms.Window}, or the title and line  around a {@link Eto.Forms.GroupBox}.
			 */
			ClientSize: Eto.Drawing.Size;

			/**
			 * Gets an enumeration of all contained child controls, including controls within child
			 * containers
			 */
			readonly Children: Iterable<Eto.Forms.Control>;

			/**
			 * Gets an enumeration of all contained child controls in the visual tree, including
			 * controls within child containers.
			 */
			readonly VisualChildren: Iterable<Eto.Forms.Control>;

			/**
			 * Gets or sets the style provider for this container.
			 *
			 * The style provider is used to style this container and its children.
			 */
			StyleProvider: Eto.IStyleProvider;

			/**
			 * Gets the default style provider for this container.
			 *
			 * Use this to apply styles to any child controls of this container. By default, styles
			 * will apply to all children, including children of children unless
			 * {@link Eto.DefaultStyleProvider.Inherit} is set to false .  Typically, you would set
			 * Inherit to false when creating composite controls that already have all their styles
			 * applied and you don't want any other styles to be inherited.
			 */
			readonly Styles: Eto.DefaultStyleProvider;

			/**
			 * Gets a value indicating that the control is loaded onto a form, that is it has been
			 * created, added to a parent, and shown
			 *
			 * The {@link Eto.Forms.Control.OnLoad(System.EventArgs)} method sets this value to true
			 * after cascading to all children (for a {@link Eto.Forms.Container} ) and calling the
			 * platform handler's implementation.  It is called after adding to a loaded form, or
			 * when showing a new form.  The {@link Eto.Forms.Control.OnUnLoad(System.EventArgs)}
			 * method will set this value to false when the control is removed from its parent
			 */
			readonly Loaded: boolean;

			/**
			 * Gets an enumeration of controls that are in the visual tree.
			 *
			 * This is used to specify which controls are contained by this instance that are part of
			 * the visual tree. This should include all controls including non-logical Eto controls
			 * used for layout.
			 */
			readonly VisualControls: Iterable<Eto.Forms.Control>;

			/**
			 * Gets or sets a user-defined object that contains data about the control
			 *
			 * A common use of the tag property is to store data that is associated with the control
			 * that you can later retrieve.
			 */
			Tag: unknown;

			/**
			 * Gets the logical parent control.
			 *
			 * When the control is part of the visual tree (
				 * {@link Eto.Forms.Control.IsVisualControl} is true), this returns the logical parent
				 * that contains this control. Otherwise this is the same as
				 * {@link Eto.Forms.Control.Parent}.
				 */
				readonly LogicalParent: Eto.Forms.Container;

			/** Gets a value indicating this {@link Eto.Forms.Control} is part of the visual tree. */
			IsVisualControl: boolean;

			/**
			 * Gets or sets the size of the control. Use -1 to specify auto sizing for either the
			 * width and/or height.
			 *
			 * Setting the size of controls is entirely optional as most controls will size
			 * themselves appropriately. When specifying a size, it will be used as the desired size
			 * of the control.  The container will reposition and resize the control depending on the
			 * available size.  For a {@link Eto.Forms.Window}, it is preferred to set the
			 * {@link Eto.Forms.Container.ClientSize} instead, as various platforms have different
			 * sizes of window decorations, toolbars, etc.
			 */
			Size: Eto.Drawing.Size;

			/**
			 * Gets a value indicating this control currently has mouse capture
			 *
			 * Mouse capture can happen during a handled MouseDown event until MouseUp, or it can be
			 * captured explicitly via {@link Eto.Forms.Control.CaptureMouse}.
			 */
			readonly IsMouseCaptured: boolean;

			/** Gets or sets the width of the control size. */
			Width: number;

			/** Gets or sets the height of the control size. */
			Height: number;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Forms.Control} (or its
			 * children) are enabled and accept user input.
			 *
			 * Typically when a control is disabled, the user cannot do anything with the control or
			 * any of its children. Including for example, selecting text in a text control. Certain
			 * controls can have a 'Read Only' mode, such as {@link Eto.Forms.TextBox.ReadOnly} which
			 * allow the user to  select text, but not change its contents.
			 */
			Enabled: boolean;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Forms.Control} is visible to
			 * the user.
			 *
			 * When the visibility of a control is set to false, it will not occupy space in the
			 * layout.
			 */
			Visible: boolean;

			/** Gets the container which this control has been added to, if any */
			readonly Parent: Eto.Forms.Container;

			/**
			 * Gets the visual container of this control, if any.
			 *
			 * Some containers may use other Eto controls to layout its children, such as the
			 * {@link Eto.Forms.StackLayout}. This will return the parent control that visually
			 * contains this control as opposed to {@link Eto.Forms.Control.Parent} which will return
			 * the logical parent.
			 */
			VisualParent: Eto.Forms.Container;

			/** Gets a value indicating this control has been attached to a native container */
			readonly IsAttached: boolean;

			/**
			 * Gets or sets the color for the background of the control
			 *
			 * Note that on some platforms (e.g. Mac), setting the background color of a control can
			 * change the performance characteristics of the control and its children, since it must
			 * enable layers to do so.
			 */
			BackgroundColor: Eto.Drawing.Color;

			/** Gets a value indicating whether this instance has the keyboard input focus. */
			readonly HasFocus: boolean;

			/** Gets a value indicating whether the layout of child controls is suspended. */
			readonly IsSuspended: boolean;

			/** Gets the window this control is contained in */
			readonly ParentWindow: Eto.Forms.Window;

			/**
			 * Gets the supported platform commands that can be used to hook up system functions to
			 * user defined logic
			 *
			 * This lists all available commands that can be mapped using the
			 * {@link Eto.Forms.Control.MapPlatformCommand(System.String,Eto.Forms.Command)} method
			 * of the control.
			 */
			readonly SupportedPlatformCommands: Iterable<string>;

			/** Gets the bounding rectangle of this control relative to its container */
			readonly Bounds: Eto.Drawing.Rectangle;

			/**
			 * Gets the location of the control as positioned by the container
			 *
			 * A control's location is set by the container. This can be used to determine where the
			 * control is for overlaying floating windows, menus, etc.
			 */
			readonly Location: Eto.Drawing.Point;

			/** Gets or sets the type of cursor to use when the mouse is hovering over the control */
			Cursor: Eto.Forms.Cursor;

			/** Gets or sets the tool tip to show when the mouse is hovered over the control */
			ToolTip: string;

			/**
			 * Gets or sets the tab index order for this control within its container.
			 *
			 * This sets the order when using the tab key to cycle through controls  Note that some
			 * platforms (Gtk and WinForms) may not support setting the context of the tab order to
			 * StackLayout  or DynamicLayout containers and may not behave exactly as expected. Use
			 * the {@link Eto.PlatformFeatures.TabIndexWithCustomContainers} flag to determine if it
			 * is supported.
			 */
			TabIndex: number;

			/** Gets or sets a value indicating whether this control can serve as drop target. */
			AllowDrop: boolean;

			/**
			 * Gets or sets the parent widget which this widget has been added to, if any
			 *
			 * When implementing child widgets that can participate in the context based binding
			 * (MVVM), You can set this to the parent widget when it is added or removed to it
			 * (usually via a collection).  Note that you should typically provide a public new
			 * [ParentWidget] Parent { get; } property  so that consumers of your API cannot set the
			 * parent to an invalid value.
			 */
			Parent: Eto.Widget;

			/**
			 * Gets an enumeration of all parent widgets in the heirarchy by traversing the
			 * {@link Eto.Forms.BindableWidget.Parent} property.
			 */
			readonly Parents: Iterable<Eto.Widget>;

			/**
			 * Gets or sets the data context for this widget for binding
			 *
			 * Subclasses may override the standard behaviour so that hierarchy of widgets can be
			 * taken into account.  For example, a Control may return the data context of a parent,
			 * if it is not set explicitly.
			 */
			DataContext: unknown;

			/** Gets the collection of bindings that are attached to this widget */
			readonly Bindings: Eto.Forms.BindingCollection;

			/**
			 * Gets a value indicating that the {@link Eto.Forms.BindableWidget.DataContext} property
			 * is changing.
			 *
			 * This can be used to determine when to allow certain logic during the update of the
			 * data context.  It is used to disable binding setters on the model when the data
			 * context changes so that a binding does not cause the view model to be updated when the
			 * state hasn't been fully set yet.
			 */
			IsDataContextChanging: boolean;

			/**
			 * Gets the platform that was used to create the {@link Eto.Widget.Handler} for this
			 * widget
			 *
			 * This gets set to the current {@link Eto.Platform.Instance} during the construction of
			 * the object
			 */
			readonly Platform: Eto.Platform;

			/** Gets the platform-specific handler for this widget */
			Handler: unknown;

			/** Gets the native platform-specific handle for integration purposes */
			readonly NativeHandle: unknown;

			/** Gets the dictionary of properties for this widget */
			readonly Properties: Eto.PropertyStore;

			/** Gets or sets the ID of this widget */
			ID: string;

			/**
			 * Gets or sets the style of this widget
			 *
			 * Styles allow you to attach custom platform-specific logic to a widget. In your
			 * platform-specific assembly, use {@link Style.Add{H}(string, StyleHandler{H})} to add
			 * the style logic with the same id.
			 */
			Style: string;

			/**
			 * Gets the instance of the platform-specific object
			 *
			 * This can sometimes be useful to get the platform-specific object. Some handlers may
			 * not have any backing object for its functionality, so this may be null.  It is more
			 * preferred to use the {@link Eto.Widget.Handler} and cast that to the platform-specific
			 * handler class which can give you additional methods and helpers to do common tasks.
			 * For example, the {@link Eto.Forms.Application} object's handler for OS X has a
			 * AddFullScreenMenuItem property to specify if you want full screen support in your app.
			 */
			readonly ControlObject: unknown;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Widget} has been disposed.
			 *
			 * When the widget is disposed, it can no longer be used.
			 */
			IsDisposed: boolean;

			/** Removes the specified child from the container */
			Remove(child: Eto.Forms.Control): void;

			/** Remove the specified `controls` from this container */
			Remove(controls: Iterable<Eto.Forms.Control>): void;

			/** Removes all controls from this container */
			RemoveAll(): void;

			/**
			 * Finds a child control in this container or any of its child containers with the
			 * specified `id`
			 */
			FindChild<T>(id?: string): T;

			/**
			 * Finds a child control in this container or any of its child containers with the
			 * specified `type`
			 */
			FindChild(
				type: unknown,
				id?: string,
			): Eto.Forms.Control;

			/**
			 * Finds a child control in this container or any of its child containers with the
			 * specified `id`.
			 */
			FindChild(id: string): Eto.Forms.Control;

			/**
			 * Queues a repaint of the entire control on the screen and any of its children.
			 *
			 * This is only useful when the control is visible.
			 */
			Invalidate(): void;

			/**
			 * Queues a repaint of the entire control on the screen
			 *
			 * This is only useful when the control is visible.
			 */
			Invalidate(invalidateChildren: boolean): void;

			/**
			 * Queues a repaint of the specified `rect` of the control and any children.
			 *
			 * This is only useful when the control is visible.
			 */
			Invalidate(rect: Eto.Drawing.Rectangle): void;

			/**
			 * Queues a repaint of the specified `rect` of the control
			 *
			 * This is only useful when the control is visible.
			 */
			Invalidate(
				rect: Eto.Drawing.Rectangle,
				invalidateChildren: boolean,
			): void;

			/**
			 * Updates the layout of this control if necessary.
			 *
			 * This will ensure the control has had all of its layout applied so you can use its
			 * position and size right after this call. Most platforms (except WinForms) use a
			 * deferred layout system so that after adding your control to the form dynamically it
			 * won't get laid out until the next idle loop. This is useful when you need to know the
			 * dimensions of the control immediately. Note that this can be an expensive operation,
			 * so it is recommended to only call this method when necessary and after all of the
			 * controls have been added/updated.
			 */
			UpdateLayout(): void;

			/** Gets the preferred size of this control given infinite space available. */
			GetPreferredSize(): Eto.Drawing.SizeF;

			/** Gets the preferred size of this control given the specified `availableSize`. */
			GetPreferredSize(availableSize: Eto.Drawing.SizeF): Eto.Drawing.SizeF;

			/**
			 * Captures all mouse events to this control.
			 *
			 * This captures all mouse events until {@link Eto.Forms.Control.ReleaseMouseCapture} is
			 * called.  Note that not all platforms will allow a mouse capture unless the mouse is
			 * currently down.
			 */
			CaptureMouse(): boolean;

			/** Releases the mouse capture after a call to {@link Eto.Forms.Control.CaptureMouse}. */
			ReleaseMouseCapture(): void;

			/**
			 * Finds a control in the parent hierarchy with the specified type and
			 * {@link Eto.Widget.ID} if specified
			 */
			FindParent(
				type: unknown,
				id?: string,
			): Eto.Forms.Container;

			/** Finds a control in the parent hierarchy with the specified `id` */
			FindParent(id: string): Eto.Forms.Container;

			/**
			 * Detaches the control by removing it from its parent
			 *
			 * This is essentially a shortcut to myControl.Parent.Remove(myControl);
			 */
			Detach(): void;

			/**
			 * Attaches the control for direct use in a native application
			 *
			 * Use this to use a control directly in a native application.  Note that the native
			 * application must be running the same framework as the current platform.  E.g. a
			 * WinForms application can use an Eto.Forms control when using the Eto.WinForms
			 * platform.  This prepares the control by firing the {@link Eto.Forms.Control.PreLoad},
			 * {@link Eto.Forms.Control.Load}, etc. events.
			 */
			AttachNative(): void;

			/**
			 * Detaches the control when it is used in a native application, when you want to reuse
			 * the control.
			 *
			 * This should only be called after {@link Eto.Forms.Control.AttachNative} has been
			 * called, which is usually done by calling to ToNative(true) .
			 */
			DetachNative(): void;

			/**
			 * Attempts to set the keyboard input focus to this control, or the first child that
			 * accepts focus. For Windows, this will bring it to front and activate it.
			 */
			Focus(): void;

			/**
			 * Suspends the layout of child controls
			 *
			 * This can be used to optimize some platforms while adding, removing, or changing many
			 * child controls at once. It disables the calculation of control positioning until
			 * {@link Eto.Forms.Control.ResumeLayout} is called. Each call to SuspendLayout() must be
			 * balanced with a call to {@link Eto.Forms.Control.ResumeLayout}.
			 */
			SuspendLayout(): void;

			/**
			 * Resumes the layout after it has been suspended, and performs a layout
			 *
			 * This can be used to optimize some platforms while adding, removing, or changing many
			 * child controls at once. Each call to ResumeLayout() must be balanced with a call to
			 * {@link Eto.Forms.Control.SuspendLayout} before it.
			 */
			ResumeLayout(): void;

			/**
			 * Specifies a command to execute for a platform-specific command
			 *
			 * Some platforms have specific system-defined commands that can be associated with a
			 * control. For example, the Mac platform's cut/copy/paste functionality is defined by
			 * the system, and if you want to hook into it, you can use this to map it to your own
			 * defined logic. The valid values of the `systemCommand` parameter are defined by each
			 * platform, and a list can be retrieved using
			 * {@link Eto.Forms.Control.SupportedPlatformCommands}
			 */
			MapPlatformCommand(
				systemCommand: string,
				command: Eto.Forms.Command,
			): void;

			/** Converts a point from screen space to control space. */
			PointFromScreen(point: Eto.Drawing.PointF): Eto.Drawing.PointF;

			/** Converts a point from control space to screen space */
			PointToScreen(point: Eto.Drawing.PointF): Eto.Drawing.PointF;

			/** Converts a rectangle from screen space to control space. */
			RectangleToScreen(rect: Eto.Drawing.RectangleF): Eto.Drawing.RectangleF;

			/** Converts a rectangle from control space to screen space */
			RectangleFromScreen(rect: Eto.Drawing.RectangleF): Eto.Drawing.RectangleF;

			/**
			 * Starts drag operation using this control as drag source.
			 *
			 * This method can be blocking on some platforms (Wpf, WinForms), and non-blocking on
			 * others (Mac, Gtk). Use the {@link Eto.Forms.Control.DragEnd} event to determine when
			 * the drag operation is completed and get its resulting DragEffects.
			 */
			DoDragDrop(
				data: Eto.Forms.DataObject,
				allowedEffects: Eto.Forms.DragEffects,
			): void;

			/**
			 * Starts drag operation using this control as drag source.
			 *
			 * This method can be blocking on some platforms (Wpf, WinForms), and non-blocking on
			 * others (Mac, Gtk). Use the {@link Eto.Forms.Control.DragEnd} event to determine when
			 * the drag operation is completed and get its resulting DragEffects.
			 */
			DoDragDrop(
				data: Eto.Forms.DataObject,
				allowedEffects: Eto.Forms.DragEffects,
				image: Eto.Drawing.Image,
				cursorOffset: Eto.Drawing.PointF,
			): void;

			/**
			 * Triggers the StyleChanged event and re-applies the styles to this control and its
			 * children.
			 */
			TriggerStyleChanged(): void;

			/** Shows a print dialog to print the specified control */
			Print(): void;

			/**
			 * Finds a control in the parent hierarchy with the specified type and
			 * {@link Eto.Widget.ID} if specified
			 */
			FindParent<T>(id?: string): T;

			/**
			 * Finds a control in the parent hierarchy with the specified type and
			 * {@link Eto.Widget.ID} if specified
			 */
			FindParent(
				type: unknown,
				id?: string,
			): Eto.Widget;

			/** Finds a control in the parent hierarchy with the specified `id` */
			FindParent(id: string): Eto.Widget;

			/**
			 * Unbinds any bindings in the {@link Eto.Forms.BindableWidget.Bindings} collection and
			 * removes the bindings
			 *
			 * When you implement {@link Eto.Forms.IBindableWidgetContainer}, this will also unbind
			 * any of its children.
			 */
			Unbind(): void;

			/**
			 * Updates all bindings in this widget
			 *
			 * When you implement {@link Eto.Forms.IBindableWidgetContainer}, this will also update
			 * bindings for all of its children.
			 */
			UpdateBindings(mode?: Eto.Forms.BindingUpdateMode): void;

			/** Disposes of this widget, supressing the finalizer */
			dispose(): void;

			/** Gets a string that represents the current object with its ID if specified. */
			ToString(): string;
		}
	}

	export namespace Eto.Forms.ThemedControls {
		/**
		 * Themed handler for the {@link Eto.Forms.ColorPicker} using a Drawable and the
		 * ColorDialog.
		 *
		 * This is useful if for example you have changed out the ColorDialog to a non-standard
		 * dialog and want to use that on all platforms using a consistent interface.
		 */
		export class ThemedColorPickerHandler implements
			Eto.Widget.IHandler,
			Eto.Forms.Control.IHandler,
			Eto.Forms.ColorPicker.IHandler {
			/** Initializes a new instance of ThemedColorPickerHandler */
			constructor();

			Color: Eto.Drawing.Color;

			AllowAlpha: boolean;

			readonly SupportsAllowAlpha: boolean;

			BackgroundColor: Eto.Drawing.Color;

			readonly VisualControls: Iterable<Eto.Forms.Control>;

			readonly PropagateLoadEvents: boolean;

			Size: Eto.Drawing.Size;

			Width: number;

			Height: number;

			Enabled: boolean;

			readonly HasFocus: boolean;

			Visible: boolean;

			readonly SupportedPlatformCommands: Iterable<string>;

			readonly Location: Eto.Drawing.Point;

			ToolTip: string;

			Cursor: Eto.Forms.Cursor;

			readonly ControlObject: unknown;

			TabIndex: number;

			AllowDrop: boolean;

			readonly IsMouseCaptured: boolean;

			readonly Callback: Eto.Forms.ColorPicker.ICallback;

			Control: Eto.Forms.Control;

			readonly HasControl: boolean;

			readonly Widget: Eto.Forms.ColorPicker;

			ID: string;

			readonly NativeHandle: unknown;

			AttachEvent(id: string): void;

			GetPreferredSize(availableSize: Eto.Drawing.SizeF): Eto.Drawing.SizeF;

			Invalidate(invalidateChildren: boolean): void;

			Invalidate(
				rect: Eto.Drawing.Rectangle,
				invalidateChildren: boolean,
			): void;

			SuspendLayout(): void;

			ResumeLayout(): void;

			Focus(): void;

			OnPreLoad(e: unknown): void;

			OnLoad(e: unknown): void;

			OnLoadComplete(e: unknown): void;

			OnUnLoad(e: unknown): void;

			SetParent(
				oldParent: Eto.Forms.Container,
				newParent: Eto.Forms.Container,
			): void;

			PointFromScreen(point: Eto.Drawing.PointF): Eto.Drawing.PointF;

			PointToScreen(point: Eto.Drawing.PointF): Eto.Drawing.PointF;

			MapPlatformCommand(
				systemAction: string,
				action: Eto.Forms.Command,
			): void;

			DoDragDrop(
				data: Eto.Forms.DataObject,
				allowedAction: Eto.Forms.DragEffects,
				image: Eto.Drawing.Image,
				cursorOffset: Eto.Drawing.PointF,
			): void;

			GetNativeParentWindow(): Eto.Forms.Window;

			Print(): void;

			UpdateLayout(): void;

			CaptureMouse(): boolean;

			ReleaseMouseCapture(): void;

			IsEventHandled(id: string): boolean;

			HandleEvent(
				id: string,
				defaultEvent?: boolean,
			): void;

			dispose(): void;
		}
	}

	export namespace Eto.Forms.ThemedControls {
		/** A themed handler for the {@link Eto.Forms.DocumentControl} control. */
		export class ThemedDocumentControlHandler implements
			Eto.Widget.IHandler,
			Eto.Forms.Control.IHandler,
			Eto.Forms.Container.IHandler,
			Eto.Forms.DocumentControl.IHandler {
			/**
			 * Initializes a new instance of the
			 * {@link Eto.Forms.ThemedControls.ThemedDocumentControlHandler} class.
			 */
			constructor();

			/** Gets or sets the padding inside each tab around the text. */
			TabPadding: Eto.Drawing.Padding;

			/**
			 * Gets or sets a value indicating the tabs can be navigated by next and previous
			 * buttons.
			 */
			AllowNavigationButtons: boolean;

			/** Gets or sets the font for the tab text. */
			Font: Eto.Drawing.Font;

			BackgroundColor: Eto.Drawing.Color;

			/** Gets or sets the disabled foreground color. */
			DisabledForegroundColor: Eto.Drawing.Color;

			/** Gets or sets the background color for the close button. */
			CloseBackgroundColor: Eto.Drawing.Color;

			/** Gets or sets the highlight background color for the close button. */
			CloseHighlightBackgroundColor: Eto.Drawing.Color;

			/** Gets or sets the corner radius of the close button. */
			CloseCornerRadius: number;

			/** Gets or sets the foreground color for the close button. */
			CloseForegroundColor: Eto.Drawing.Color;

			/** Gets or sets the highlight foreground color for the close button. */
			CloseHighlightForegroundColor: Eto.Drawing.Color;

			/** Gets or sets the background color for the tab. */
			TabBackgroundColor: Eto.Drawing.Color;

			/** Gets or sets the highlight background color for the highlighted or selected tab. */
			TabHighlightBackgroundColor: Eto.Drawing.Color;

			/** Gets or sets the background color for the tab under mouse. */
			TabHoverBackgroundColor: Eto.Drawing.Color;

			/** Gets or sets the foreground color for the tab. */
			TabForegroundColor: Eto.Drawing.Color;

			/** Gets or sets the highlight foreground color for the highlighted or selected tab. */
			TabHighlightForegroundColor: Eto.Drawing.Color;

			/** Gets or sets the foreground color for the tab under mouse. */
			TabHoverForegroundColor: Eto.Drawing.Color;

			/** Gets or sets the background color for the unsaved changes indicator. */
			UnsavedBackgroundColor: Eto.Drawing.Color;

			/** Gets or sets a value indicating whether to use a fixed tab height. */
			UseFixedTabHeight: boolean;

			/** Gets or sets the index of the selected. */
			SelectedIndex: number;

			/** Gets or sets a value indicating whether to allow page reordering. */
			AllowReordering: boolean;

			/** Gets or sets a value indicating whether this control is enabled */
			Enabled: boolean;

			ClientSize: Eto.Drawing.Size;

			readonly RecurseToChildren: boolean;

			readonly VisualControls: Iterable<Eto.Forms.Control>;

			readonly PropagateLoadEvents: boolean;

			Size: Eto.Drawing.Size;

			Width: number;

			Height: number;

			readonly HasFocus: boolean;

			Visible: boolean;

			readonly SupportedPlatformCommands: Iterable<string>;

			readonly Location: Eto.Drawing.Point;

			ToolTip: string;

			Cursor: Eto.Forms.Cursor;

			readonly ControlObject: unknown;

			TabIndex: number;

			AllowDrop: boolean;

			readonly IsMouseCaptured: boolean;

			readonly Callback: Eto.Forms.DocumentControl.ICallback;

			Control: Eto.Forms.TableLayout;

			readonly HasControl: boolean;

			readonly Widget: Eto.Forms.DocumentControl;

			ID: string;

			readonly NativeHandle: unknown;

			/** Performs calculations when loaded. */
			OnLoad(e: unknown): void;

			/** Gets the page. */
			GetPage(index: number): Eto.Forms.DocumentPage;

			/** Gets the page count. */
			GetPageCount(): number;

			/** Inserts the page. */
			InsertPage(
				index: number,
				page: Eto.Forms.DocumentPage,
			): void;

			/** Removes a page. */
			RemovePage(index: number): void;

			/** Attaches the specified event. */
			AttachEvent(id: string): void;

			GetPreferredSize(availableSize: Eto.Drawing.SizeF): Eto.Drawing.SizeF;

			Invalidate(invalidateChildren: boolean): void;

			Invalidate(
				rect: Eto.Drawing.Rectangle,
				invalidateChildren: boolean,
			): void;

			SuspendLayout(): void;

			ResumeLayout(): void;

			Focus(): void;

			OnPreLoad(e: unknown): void;

			OnLoadComplete(e: unknown): void;

			OnUnLoad(e: unknown): void;

			SetParent(
				oldParent: Eto.Forms.Container,
				newParent: Eto.Forms.Container,
			): void;

			PointFromScreen(point: Eto.Drawing.PointF): Eto.Drawing.PointF;

			PointToScreen(point: Eto.Drawing.PointF): Eto.Drawing.PointF;

			MapPlatformCommand(
				systemAction: string,
				action: Eto.Forms.Command,
			): void;

			DoDragDrop(
				data: Eto.Forms.DataObject,
				allowedAction: Eto.Forms.DragEffects,
				image: Eto.Drawing.Image,
				cursorOffset: Eto.Drawing.PointF,
			): void;

			GetNativeParentWindow(): Eto.Forms.Window;

			Print(): void;

			UpdateLayout(): void;

			CaptureMouse(): boolean;

			ReleaseMouseCapture(): void;

			IsEventHandled(id: string): boolean;

			HandleEvent(
				id: string,
				defaultEvent?: boolean,
			): void;

			dispose(): void;
		}
	}

	export namespace Eto.Forms.ThemedControls {
		/** A themed handler for the {@link Eto.Forms.DocumentPage} control. */
		export class ThemedDocumentPageHandler implements
			Eto.Widget.IHandler,
			Eto.Forms.Control.IHandler,
			Eto.Forms.Container.IHandler,
			Eto.Forms.DocumentPage.IHandler,
			Eto.Forms.Panel.IHandler,
			Eto.Forms.IContextMenuHost {
			/**
			 * Initializes a new instance of the
			 * {@link Eto.Forms.ThemedControls.ThemedDocumentPageHandler} class.
			 */
			constructor();

			/**
			 * Gets or sets a value indicating whether this
			 * {@link Eto.Forms.ThemedControls.ThemedDocumentPageHandler} is closable.
			 */
			Closable: boolean;

			/** Gets or sets the content. */
			Content: Eto.Forms.Control;

			/** Gets or sets the context menu. */
			ContextMenu: Eto.Forms.ContextMenu;

			/** Gets or sets the tab image. */
			Image: Eto.Drawing.Image;

			/** Gets or sets the minimum size. */
			MinimumSize: Eto.Drawing.Size;

			/** Gets or sets the padding. */
			Padding: Eto.Drawing.Padding;

			/** Gets or sets the text. */
			Text: string;

			/**
			 * Gets or sets a value indicating whether this
			 * {@link Eto.Forms.ThemedControls.ThemedDocumentPageHandler} has unsaved changes.
			 */
			HasUnsavedChanges: boolean;

			/**
			 * Gets a value indicating whether {@link Eto.Forms.Control.PreLoad} /
			 * {@link Eto.Forms.Control.Load} / {@link Eto.Forms.Control.LoadComplete} /
			 * {@link Eto.Forms.Control.UnLoad} events are propagated to the inner control
			 */
			readonly PropagateLoadEvents: boolean;

			ClientSize: Eto.Drawing.Size;

			readonly RecurseToChildren: boolean;

			BackgroundColor: Eto.Drawing.Color;

			readonly VisualControls: Iterable<Eto.Forms.Control>;

			Size: Eto.Drawing.Size;

			Width: number;

			Height: number;

			Enabled: boolean;

			readonly HasFocus: boolean;

			Visible: boolean;

			readonly SupportedPlatformCommands: Iterable<string>;

			readonly Location: Eto.Drawing.Point;

			ToolTip: string;

			Cursor: Eto.Forms.Cursor;

			readonly ControlObject: unknown;

			TabIndex: number;

			AllowDrop: boolean;

			readonly IsMouseCaptured: boolean;

			readonly Callback: Eto.Forms.Control.ICallback;

			Control: Eto.Forms.Panel;

			readonly HasControl: boolean;

			readonly Widget: Eto.Forms.DocumentPage;

			ID: string;

			readonly NativeHandle: unknown;

			GetPreferredSize(availableSize: Eto.Drawing.SizeF): Eto.Drawing.SizeF;

			Invalidate(invalidateChildren: boolean): void;

			Invalidate(
				rect: Eto.Drawing.Rectangle,
				invalidateChildren: boolean,
			): void;

			SuspendLayout(): void;

			ResumeLayout(): void;

			Focus(): void;

			OnPreLoad(e: unknown): void;

			OnLoad(e: unknown): void;

			OnLoadComplete(e: unknown): void;

			OnUnLoad(e: unknown): void;

			SetParent(
				oldParent: Eto.Forms.Container,
				newParent: Eto.Forms.Container,
			): void;

			PointFromScreen(point: Eto.Drawing.PointF): Eto.Drawing.PointF;

			PointToScreen(point: Eto.Drawing.PointF): Eto.Drawing.PointF;

			MapPlatformCommand(
				systemAction: string,
				action: Eto.Forms.Command,
			): void;

			DoDragDrop(
				data: Eto.Forms.DataObject,
				allowedAction: Eto.Forms.DragEffects,
				image: Eto.Drawing.Image,
				cursorOffset: Eto.Drawing.PointF,
			): void;

			AttachEvent(id: string): void;

			GetNativeParentWindow(): Eto.Forms.Window;

			Print(): void;

			UpdateLayout(): void;

			CaptureMouse(): boolean;

			ReleaseMouseCapture(): void;

			IsEventHandled(id: string): boolean;

			HandleEvent(
				id: string,
				defaultEvent?: boolean,
			): void;

			dispose(): void;
		}
	}

	export namespace Eto.Forms.ThemedControls {
		/** A themed handler for the {@link Eto.Forms.Expander} control. */
		export class ThemedExpanderHandler implements
			Eto.Widget.IHandler,
			Eto.Forms.Control.IHandler,
			Eto.Forms.Container.IHandler,
			Eto.Forms.Expander.IHandler,
			Eto.Forms.Panel.IHandler,
			Eto.Forms.IContextMenuHost {
			/** Initializes a new instance of the ThemedExpanderHandler. */
			constructor();

			/**
			 * Gets or sets the text of the button when
			 * {@link Eto.Forms.ThemedControls.ThemedExpanderHandler.Expanded} is true .
			 */
			ExpandedButtonText: string;

			/**
			 * Gets or sets the text of the button when
			 * {@link Eto.Forms.ThemedControls.ThemedExpanderHandler.Expanded} is false .
			 */
			CollapsedButtonText: string;

			/** Gets or sets whether the expander content is visible (expanded). */
			Expanded: boolean;

			/** Gets or sets the content of the header */
			Header: Eto.Forms.Control;

			/** Gets or sets the content of the control when expanded. */
			Content: Eto.Forms.Control;

			/**
			 * Gets or sets the padding around the
			 * {@link Eto.Forms.ThemedControls.ThemedExpanderHandler.Content}.
			 */
			Padding: Eto.Drawing.Padding;

			/** Gets or sets the minimum size of this control. */
			MinimumSize: Eto.Drawing.Size;

			/** Gets or sets the context menu of the expander. */
			ContextMenu: Eto.Forms.ContextMenu;

			ClientSize: Eto.Drawing.Size;

			readonly RecurseToChildren: boolean;

			BackgroundColor: Eto.Drawing.Color;

			readonly VisualControls: Iterable<Eto.Forms.Control>;

			readonly PropagateLoadEvents: boolean;

			Size: Eto.Drawing.Size;

			Width: number;

			Height: number;

			Enabled: boolean;

			readonly HasFocus: boolean;

			Visible: boolean;

			readonly SupportedPlatformCommands: Iterable<string>;

			readonly Location: Eto.Drawing.Point;

			ToolTip: string;

			Cursor: Eto.Forms.Cursor;

			readonly ControlObject: unknown;

			TabIndex: number;

			AllowDrop: boolean;

			readonly IsMouseCaptured: boolean;

			readonly Callback: Eto.Forms.Expander.ICallback;

			Control: Eto.Forms.StackLayout;

			readonly HasControl: boolean;

			readonly Widget: Eto.Forms.Expander;

			ID: string;

			readonly NativeHandle: unknown;

			/** Attaches the handler events. */
			AttachEvent(id: string): void;

			GetPreferredSize(availableSize: Eto.Drawing.SizeF): Eto.Drawing.SizeF;

			Invalidate(invalidateChildren: boolean): void;

			Invalidate(
				rect: Eto.Drawing.Rectangle,
				invalidateChildren: boolean,
			): void;

			SuspendLayout(): void;

			ResumeLayout(): void;

			Focus(): void;

			OnPreLoad(e: unknown): void;

			OnLoad(e: unknown): void;

			OnLoadComplete(e: unknown): void;

			OnUnLoad(e: unknown): void;

			SetParent(
				oldParent: Eto.Forms.Container,
				newParent: Eto.Forms.Container,
			): void;

			PointFromScreen(point: Eto.Drawing.PointF): Eto.Drawing.PointF;

			PointToScreen(point: Eto.Drawing.PointF): Eto.Drawing.PointF;

			MapPlatformCommand(
				systemAction: string,
				action: Eto.Forms.Command,
			): void;

			DoDragDrop(
				data: Eto.Forms.DataObject,
				allowedAction: Eto.Forms.DragEffects,
				image: Eto.Drawing.Image,
				cursorOffset: Eto.Drawing.PointF,
			): void;

			GetNativeParentWindow(): Eto.Forms.Window;

			Print(): void;

			UpdateLayout(): void;

			CaptureMouse(): boolean;

			ReleaseMouseCapture(): void;

			IsEventHandled(id: string): boolean;

			HandleEvent(
				id: string,
				defaultEvent?: boolean,
			): void;

			dispose(): void;
		}
	}

	export namespace Eto.Forms.ThemedControls {
		/** A themed handler for the {@link Eto.Forms.FilePicker} control. */
		export class ThemedFilePickerHandler implements
			Eto.Widget.IHandler,
			Eto.Forms.Control.IHandler,
			Eto.Forms.FilePicker.IHandler {
			/**
			 * Initializes a new instance of the
			 * {@link Eto.Forms.ThemedControls.ThemedFilePickerHandler} class.
			 */
			constructor();

			/**
			 * Gets or sets {@link Eto.Forms.ThemedControls.ThemedFilePickerHandler.FileAction} that
			 * is used when the user is selecting the file.
			 */
			FileAction: Eto.FileAction;

			/** Gets or sets the full path of the file that is selected. */
			FilePath: string;

			/**
			 * Gets or sets the index of the current filter in the
			 * {@link Eto.Forms.FilePicker.Filters} collection
			 */
			CurrentFilterIndex: number;

			/** Gets or sets the title of the dialog that the control will show. */
			Title: string;

			BackgroundColor: Eto.Drawing.Color;

			readonly VisualControls: Iterable<Eto.Forms.Control>;

			readonly PropagateLoadEvents: boolean;

			Size: Eto.Drawing.Size;

			Width: number;

			Height: number;

			Enabled: boolean;

			readonly HasFocus: boolean;

			Visible: boolean;

			readonly SupportedPlatformCommands: Iterable<string>;

			readonly Location: Eto.Drawing.Point;

			ToolTip: string;

			Cursor: Eto.Forms.Cursor;

			readonly ControlObject: unknown;

			TabIndex: number;

			AllowDrop: boolean;

			readonly IsMouseCaptured: boolean;

			readonly Callback: Eto.Forms.FilePicker.ICallback;

			Control: Eto.Forms.StackLayout;

			readonly HasControl: boolean;

			readonly Widget: Eto.Forms.FilePicker;

			ID: string;

			readonly NativeHandle: unknown;

			/** Clears all filters */
			ClearFilters(): void;

			/** Inserts a filter at the specified index */
			InsertFilter(
				index: number,
				filter: Eto.Forms.FileFilter,
			): void;

			/** Removes a filter at the specified index */
			RemoveFilter(index: number): void;

			/** Attaches control events. */
			AttachEvent(id: string): void;

			GetPreferredSize(availableSize: Eto.Drawing.SizeF): Eto.Drawing.SizeF;

			Invalidate(invalidateChildren: boolean): void;

			Invalidate(
				rect: Eto.Drawing.Rectangle,
				invalidateChildren: boolean,
			): void;

			SuspendLayout(): void;

			ResumeLayout(): void;

			Focus(): void;

			OnPreLoad(e: unknown): void;

			OnLoad(e: unknown): void;

			OnLoadComplete(e: unknown): void;

			OnUnLoad(e: unknown): void;

			SetParent(
				oldParent: Eto.Forms.Container,
				newParent: Eto.Forms.Container,
			): void;

			PointFromScreen(point: Eto.Drawing.PointF): Eto.Drawing.PointF;

			PointToScreen(point: Eto.Drawing.PointF): Eto.Drawing.PointF;

			MapPlatformCommand(
				systemAction: string,
				action: Eto.Forms.Command,
			): void;

			DoDragDrop(
				data: Eto.Forms.DataObject,
				allowedAction: Eto.Forms.DragEffects,
				image: Eto.Drawing.Image,
				cursorOffset: Eto.Drawing.PointF,
			): void;

			GetNativeParentWindow(): Eto.Forms.Window;

			Print(): void;

			UpdateLayout(): void;

			CaptureMouse(): boolean;

			ReleaseMouseCapture(): void;

			IsEventHandled(id: string): boolean;

			HandleEvent(
				id: string,
				defaultEvent?: boolean,
			): void;

			dispose(): void;
		}
	}

	export namespace Eto.Forms.ThemedControls {
		/** A themed handler for the {@link Eto.Forms.FontPicker} control. */
		export class ThemedFontPickerHandler implements
			Eto.Widget.IHandler,
			Eto.Forms.Control.IHandler,
			Eto.Forms.FontPicker.IHandler {
			/**
			 * Initializes a new instance of the
			 * {@link Eto.Forms.ThemedControls.ThemedFontPickerHandler} class.
			 */
			constructor();

			/** Gets or sets the currently selected font. */
			Value: Eto.Drawing.Font;

			BackgroundColor: Eto.Drawing.Color;

			readonly VisualControls: Iterable<Eto.Forms.Control>;

			readonly PropagateLoadEvents: boolean;

			Size: Eto.Drawing.Size;

			Width: number;

			Height: number;

			Enabled: boolean;

			readonly HasFocus: boolean;

			Visible: boolean;

			readonly SupportedPlatformCommands: Iterable<string>;

			readonly Location: Eto.Drawing.Point;

			ToolTip: string;

			Cursor: Eto.Forms.Cursor;

			readonly ControlObject: unknown;

			TabIndex: number;

			AllowDrop: boolean;

			readonly IsMouseCaptured: boolean;

			readonly Callback: Eto.Forms.FontPicker.ICallback;

			Control: Eto.Forms.Button;

			readonly HasControl: boolean;

			readonly Widget: Eto.Forms.FontPicker;

			ID: string;

			readonly NativeHandle: unknown;

			/** Attaches control events. */
			AttachEvent(id: string): void;

			GetPreferredSize(availableSize: Eto.Drawing.SizeF): Eto.Drawing.SizeF;

			Invalidate(invalidateChildren: boolean): void;

			Invalidate(
				rect: Eto.Drawing.Rectangle,
				invalidateChildren: boolean,
			): void;

			SuspendLayout(): void;

			ResumeLayout(): void;

			Focus(): void;

			OnPreLoad(e: unknown): void;

			OnLoad(e: unknown): void;

			OnLoadComplete(e: unknown): void;

			OnUnLoad(e: unknown): void;

			SetParent(
				oldParent: Eto.Forms.Container,
				newParent: Eto.Forms.Container,
			): void;

			PointFromScreen(point: Eto.Drawing.PointF): Eto.Drawing.PointF;

			PointToScreen(point: Eto.Drawing.PointF): Eto.Drawing.PointF;

			MapPlatformCommand(
				systemAction: string,
				action: Eto.Forms.Command,
			): void;

			DoDragDrop(
				data: Eto.Forms.DataObject,
				allowedAction: Eto.Forms.DragEffects,
				image: Eto.Drawing.Image,
				cursorOffset: Eto.Drawing.PointF,
			): void;

			GetNativeParentWindow(): Eto.Forms.Window;

			Print(): void;

			UpdateLayout(): void;

			CaptureMouse(): boolean;

			ReleaseMouseCapture(): void;

			IsEventHandled(id: string): boolean;

			HandleEvent(
				id: string,
				defaultEvent?: boolean,
			): void;

			dispose(): void;
		}
	}

	export namespace Eto.Forms.ThemedControls {
		/** A themed message box handler to allow more customization and theming */
		export class ThemedMessageBoxHandler implements
			Eto.Widget.IHandler,
			Eto.Forms.MessageBox.IHandler {
			constructor();

			Text: string;

			Caption: string;

			Type: Eto.Forms.MessageBoxType;

			Buttons: Eto.Forms.MessageBoxButtons;

			DefaultButton: Eto.Forms.MessageBoxDefaultButton;

			readonly Widget: Eto.Widget;

			ID: string;

			readonly NativeHandle: unknown;

			ShowDialog(parent: Eto.Forms.Control): Eto.Forms.DialogResult;

			IsEventHandled(id: string): boolean;

			HandleEvent(
				id: string,
				defaultEvent?: boolean,
			): void;

			AttachEvent(id: string): void;

			dispose(): void;
		}
	}

	export namespace Eto.Forms.ThemedControls {
		/** Message box implementation */
		export class ThemedMessageBox implements
			Eto.IHandlerSource,
			Eto.Forms.IBindable,
			Eto.Forms.IMouseInputSource,
			Eto.Forms.IKeyboardInputSource {
			/** Initializes a new instance of the ThemedMessageBox class */
			constructor();

			/** Gets or sets the result of the dialog */
			Result: unknown;

			/** Gets or sets the text of the message box */
			Text: string;

			/** Gets or sets the alignment of the text */
			TextAlignment: Eto.Forms.TextAlignment;

			/** Gets or sets the image to show */
			Image: Eto.Drawing.Image;

			/** Gets or sets the display mode hint */
			DisplayMode: Eto.Forms.DialogDisplayMode;

			/**
			 * Gets or sets the abort button.
			 *
			 * On some platforms, the abort button would be called automatically if the user presses
			 * the escape key
			 */
			AbortButton: Eto.Forms.Button;

			/**
			 * Gets or sets the default button.
			 *
			 * On some platforms, the abort button would be called automatically if the user presses
			 * the return key on the form
			 */
			DefaultButton: Eto.Forms.Button;

			/**
			 * Gets the positive buttons list, these buttons are automatically added to the dialog.
			 *
			 * Depending on the platform these buttons can be added on the left side or the right
			 * side. The lower the index the closer the button is to the edge.
			 */
			readonly PositiveButtons: unknown;

			/**
			 * Gets the negative buttons list, these buttons are automatically added to the dialog.
			 *
			 * Depending on the platform these buttons can be added on the left side or the right
			 * side. The lower the index the closer the button is to the edge.
			 */
			readonly NegativeButtons: unknown;

			/**
			 * Gets or sets the title of the window
			 *
			 * The title of the window is displayed to the user usually at the top of the window, but
			 * in cases where you show a window in a mobile environment, this may be the title shown
			 * in a navigation controller.
			 */
			Title: string;

			/**
			 * Gets or sets the location of the window
			 *
			 * Note that in multi-monitor setups, the origin of the location is at the upper-left of
			 * {@link Eto.Forms.Screen.PrimaryScreen}.  Also note, that on Linux systems running GTK
			 * via Wayland, this will always point to 0, 0 , and setting it to different values will
			 * have no effect.
			 */
			Location: Eto.Drawing.Point;

			/** Gets or sets the size and location of the window */
			Bounds: Eto.Drawing.Rectangle;

			/**
			 * Gets or sets the tool bar for the window.
			 *
			 * Note that each window can only have a single tool bar
			 */
			ToolBar: Eto.Forms.ToolBar;

			/** Gets or sets the opacity of the window */
			Opacity: number;

			/**
			 * Gets or sets the owner of this window.
			 *
			 * This sets the parent window that has ownership over this window. For a
			 * {@link Eto.Forms.Dialog}, this will be the window that will be disabled while the
			 * modal dialog is shown. With a {@link Eto.Forms.Form}, the specified owner will always
			 * be below the current window when shown, and will  still be responsive to user input.
			 * Typically, but not always, the window will move along with the owner.
			 */
			Owner: Eto.Forms.Window;

			/**
			 * Gets the screen this window is mostly contained in. Typically defined by the screen
			 * center of the window is visible.
			 */
			readonly Screen: Eto.Forms.Screen;

			/**
			 * Gets or sets the menu bar for this window
			 *
			 * Some platforms have a global menu bar (e.g. Ubuntu, OS X). When the window is in
			 * focus, the global menu bar will be changed to reflect the menu assigned.
			 */
			Menu: Eto.Forms.MenuBar;

			/**
			 * Gets or sets the icon for the window to show in the menu bar.
			 *
			 * The icon should have many variations, such as 16x16, 24x24, 32x32, 48x48, 64x64, etc.
			 * This ensures that the many places it is used (title bar, task bar, switch window, etc)
			 * all have optimized icon sizes.  For OS X, the application icon is specified in the
			 * .app bundle, not by this value.
			 */
			Icon: Eto.Drawing.Icon;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Forms.Window} is resizable.
			 */
			Resizable: boolean;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Forms.Window} can be
			 * maximized.
			 *
			 * This may hide or disable the minimize button on the title bar.
			 */
			Maximizable: boolean;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Forms.Window} can be
			 * minimized.
			 *
			 * This may hide or disable the maximize button on the title bar.
			 */
			Minimizable: boolean;

			/**
			 * Gets or sets a value indicating whether the close button should be shown. Defaults to
			 * true
			 *
			 * Note that on some platforms (e.g. Windows) this also hides the system menu and
			 * minimize/maximize buttons. Note that this does not prevent the window from being
			 * closed, to do that use the {@link Eto.Forms.Window.Closing} event.
			 */
			Closeable: boolean;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Forms.Window} will show in the
			 * taskbar.
			 *
			 * Some platforms, e.g. macOS do not show a separate icon for each running window.  You
			 * may also have to add  the LSUIElement key to your app's Info.plist to make your app
			 * hidden in the dock.   See
			 * https://developer.apple.com/library/archive/documentation/General/Reference/InfoPlistKeyReference/Articles/LaunchServicesKeys.html#//apple_ref/doc/uid/TP40009250-108256-TPXREF136
			 */
			ShowInTaskbar: boolean;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Forms.Window} is above all
			 * other windows.
			 *
			 * The window should be above all other windows when this is true.  In some platforms,
			 * this will show above all other windows only when the application has focus.
			 */
			Topmost: boolean;

			/** Gets or sets the state of the window. */
			WindowState: Eto.Forms.WindowState;

			/**
			 * Gets the bounds of the window before it was minimized or maximized, or the current
			 * bounds if {@link Eto.Forms.Window.WindowState} is Normal.
			 *
			 * This is useful to retrieve the desired size and position of the window even though it
			 * is currently maximized or minimized.
			 */
			readonly RestoreBounds: Eto.Drawing.Rectangle;

			/** Gets or sets the style of this window. */
			WindowStyle: Eto.Forms.WindowStyle;

			/**
			 * Gets the number of pixels per logical pixel when on a high DPI display.
			 *
			 * This indicates the number of pixels per logical pixel.   All units in Eto.Forms such
			 * as control size, drawing operations, etc are in logical pixels. When not in high DPI,
			 * this will be 1.0;  Retina displays in OS X will return 2; and in windows this matches
			 * the scale set in the monitor settings.  Use the
			 * {@link Eto.Forms.Window.LogicalPixelSizeChanged} to detect when the window is moved to
			 *  a display with a different DPI.
			 */
			readonly LogicalPixelSize: number;

			/**
			 * Gets or sets a value indicating that the window can be moved by click+dragging the
			 * window background
			 */
			MovableByWindowBackground: boolean;

			/**
			 * Gets or sets a value indicating that the window will automatically resize when its
			 * content changes
			 *
			 * Note that if you set both dimensions of the {@link Eto.Drawing.Size} and/or
			 * {@link Eto.Forms.Container.ClientSize}, this will be set to false.
			 */
			AutoSize: boolean;

			/** Gets an enumeration of controls that are directly contained by this container */
			readonly Controls: Iterable<Eto.Forms.Control>;

			/** Gets or sets the padding around the {@link Eto.Forms.Panel.Content} of the panel. */
			Padding: Eto.Drawing.Padding;

			/** Gets or sets the minimum size of the panel. */
			MinimumSize: Eto.Drawing.Size;

			/**
			 * Gets or sets the context menu for the panel.
			 *
			 * The context menu is usually shown when the user right clicks the control, or in mobile
			 * platforms when the user taps and holds their finger down on the control.
			 */
			ContextMenu: Eto.Forms.ContextMenu;

			/**
			 * Gets or sets the main content of the panel.
			 *
			 * The main content will be offset by the {@link Eto.Forms.Panel.Padding} value
			 * specified, and will take up the entire content area of the control. Some controls may
			 * have decorations that will surround the content, such as a {@link Eto.Forms.GroupBox},
			 * {@link Eto.Forms.TabControl}, or {@link Eto.Forms.Window}
			 */
			Content: Eto.Forms.Control;

			/**
			 * Gets or sets the size for the client area of the control
			 *
			 * The client size differs from the {@link Eto.Forms.Control.Size} in that it excludes
			 * the decorations of the container, such as the title bar and border around a
			 * {@link Eto.Forms.Window}, or the title and line  around a {@link Eto.Forms.GroupBox}.
			 */
			ClientSize: Eto.Drawing.Size;

			/**
			 * Gets an enumeration of all contained child controls, including controls within child
			 * containers
			 */
			readonly Children: Iterable<Eto.Forms.Control>;

			/**
			 * Gets an enumeration of all contained child controls in the visual tree, including
			 * controls within child containers.
			 */
			readonly VisualChildren: Iterable<Eto.Forms.Control>;

			/**
			 * Gets or sets the style provider for this container.
			 *
			 * The style provider is used to style this container and its children.
			 */
			StyleProvider: Eto.IStyleProvider;

			/**
			 * Gets the default style provider for this container.
			 *
			 * Use this to apply styles to any child controls of this container. By default, styles
			 * will apply to all children, including children of children unless
			 * {@link Eto.DefaultStyleProvider.Inherit} is set to false .  Typically, you would set
			 * Inherit to false when creating composite controls that already have all their styles
			 * applied and you don't want any other styles to be inherited.
			 */
			readonly Styles: Eto.DefaultStyleProvider;

			/**
			 * Gets a value indicating that the control is loaded onto a form, that is it has been
			 * created, added to a parent, and shown
			 *
			 * The {@link Eto.Forms.Control.OnLoad(System.EventArgs)} method sets this value to true
			 * after cascading to all children (for a {@link Eto.Forms.Container} ) and calling the
			 * platform handler's implementation.  It is called after adding to a loaded form, or
			 * when showing a new form.  The {@link Eto.Forms.Control.OnUnLoad(System.EventArgs)}
			 * method will set this value to false when the control is removed from its parent
			 */
			readonly Loaded: boolean;

			/**
			 * Gets an enumeration of controls that are in the visual tree.
			 *
			 * This is used to specify which controls are contained by this instance that are part of
			 * the visual tree. This should include all controls including non-logical Eto controls
			 * used for layout.
			 */
			readonly VisualControls: Iterable<Eto.Forms.Control>;

			/**
			 * Gets or sets a user-defined object that contains data about the control
			 *
			 * A common use of the tag property is to store data that is associated with the control
			 * that you can later retrieve.
			 */
			Tag: unknown;

			/**
			 * Gets the logical parent control.
			 *
			 * When the control is part of the visual tree (
				 * {@link Eto.Forms.Control.IsVisualControl} is true), this returns the logical parent
				 * that contains this control. Otherwise this is the same as
				 * {@link Eto.Forms.Control.Parent}.
				 */
				readonly LogicalParent: Eto.Forms.Container;

			/** Gets a value indicating this {@link Eto.Forms.Control} is part of the visual tree. */
			IsVisualControl: boolean;

			/**
			 * Gets or sets the size of the control. Use -1 to specify auto sizing for either the
			 * width and/or height.
			 *
			 * Setting the size of controls is entirely optional as most controls will size
			 * themselves appropriately. When specifying a size, it will be used as the desired size
			 * of the control.  The container will reposition and resize the control depending on the
			 * available size.  For a {@link Eto.Forms.Window}, it is preferred to set the
			 * {@link Eto.Forms.Container.ClientSize} instead, as various platforms have different
			 * sizes of window decorations, toolbars, etc.
			 */
			Size: Eto.Drawing.Size;

			/**
			 * Gets a value indicating this control currently has mouse capture
			 *
			 * Mouse capture can happen during a handled MouseDown event until MouseUp, or it can be
			 * captured explicitly via {@link Eto.Forms.Control.CaptureMouse}.
			 */
			readonly IsMouseCaptured: boolean;

			/** Gets or sets the width of the control size. */
			Width: number;

			/** Gets or sets the height of the control size. */
			Height: number;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Forms.Control} (or its
			 * children) are enabled and accept user input.
			 *
			 * Typically when a control is disabled, the user cannot do anything with the control or
			 * any of its children. Including for example, selecting text in a text control. Certain
			 * controls can have a 'Read Only' mode, such as {@link Eto.Forms.TextBox.ReadOnly} which
			 * allow the user to  select text, but not change its contents.
			 */
			Enabled: boolean;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Forms.Control} is visible to
			 * the user.
			 *
			 * When the visibility of a control is set to false, it will not occupy space in the
			 * layout.
			 */
			Visible: boolean;

			/** Gets the container which this control has been added to, if any */
			readonly Parent: Eto.Forms.Container;

			/**
			 * Gets the visual container of this control, if any.
			 *
			 * Some containers may use other Eto controls to layout its children, such as the
			 * {@link Eto.Forms.StackLayout}. This will return the parent control that visually
			 * contains this control as opposed to {@link Eto.Forms.Control.Parent} which will return
			 * the logical parent.
			 */
			VisualParent: Eto.Forms.Container;

			/** Gets a value indicating this control has been attached to a native container */
			readonly IsAttached: boolean;

			/**
			 * Gets or sets the color for the background of the control
			 *
			 * Note that on some platforms (e.g. Mac), setting the background color of a control can
			 * change the performance characteristics of the control and its children, since it must
			 * enable layers to do so.
			 */
			BackgroundColor: Eto.Drawing.Color;

			/** Gets a value indicating whether this instance has the keyboard input focus. */
			readonly HasFocus: boolean;

			/** Gets a value indicating whether the layout of child controls is suspended. */
			readonly IsSuspended: boolean;

			/** Gets the window this control is contained in */
			readonly ParentWindow: Eto.Forms.Window;

			/**
			 * Gets the supported platform commands that can be used to hook up system functions to
			 * user defined logic
			 *
			 * This lists all available commands that can be mapped using the
			 * {@link Eto.Forms.Control.MapPlatformCommand(System.String,Eto.Forms.Command)} method
			 * of the control.
			 */
			readonly SupportedPlatformCommands: Iterable<string>;

			/** Gets or sets the type of cursor to use when the mouse is hovering over the control */
			Cursor: Eto.Forms.Cursor;

			/** Gets or sets the tool tip to show when the mouse is hovered over the control */
			ToolTip: string;

			/**
			 * Gets or sets the tab index order for this control within its container.
			 *
			 * This sets the order when using the tab key to cycle through controls  Note that some
			 * platforms (Gtk and WinForms) may not support setting the context of the tab order to
			 * StackLayout  or DynamicLayout containers and may not behave exactly as expected. Use
			 * the {@link Eto.PlatformFeatures.TabIndexWithCustomContainers} flag to determine if it
			 * is supported.
			 */
			TabIndex: number;

			/** Gets or sets a value indicating whether this control can serve as drop target. */
			AllowDrop: boolean;

			/**
			 * Gets or sets the parent widget which this widget has been added to, if any
			 *
			 * When implementing child widgets that can participate in the context based binding
			 * (MVVM), You can set this to the parent widget when it is added or removed to it
			 * (usually via a collection).  Note that you should typically provide a public new
			 * [ParentWidget] Parent { get; } property  so that consumers of your API cannot set the
			 * parent to an invalid value.
			 */
			Parent: Eto.Widget;

			/**
			 * Gets an enumeration of all parent widgets in the heirarchy by traversing the
			 * {@link Eto.Forms.BindableWidget.Parent} property.
			 */
			readonly Parents: Iterable<Eto.Widget>;

			/**
			 * Gets or sets the data context for this widget for binding
			 *
			 * Subclasses may override the standard behaviour so that hierarchy of widgets can be
			 * taken into account.  For example, a Control may return the data context of a parent,
			 * if it is not set explicitly.
			 */
			DataContext: unknown;

			/** Gets the collection of bindings that are attached to this widget */
			readonly Bindings: Eto.Forms.BindingCollection;

			/**
			 * Gets a value indicating that the {@link Eto.Forms.BindableWidget.DataContext} property
			 * is changing.
			 *
			 * This can be used to determine when to allow certain logic during the update of the
			 * data context.  It is used to disable binding setters on the model when the data
			 * context changes so that a binding does not cause the view model to be updated when the
			 * state hasn't been fully set yet.
			 */
			IsDataContextChanging: boolean;

			/**
			 * Gets the platform that was used to create the {@link Eto.Widget.Handler} for this
			 * widget
			 *
			 * This gets set to the current {@link Eto.Platform.Instance} during the construction of
			 * the object
			 */
			readonly Platform: Eto.Platform;

			/** Gets the platform-specific handler for this widget */
			Handler: unknown;

			/** Gets the native platform-specific handle for integration purposes */
			readonly NativeHandle: unknown;

			/** Gets the dictionary of properties for this widget */
			readonly Properties: Eto.PropertyStore;

			/** Gets or sets the ID of this widget */
			ID: string;

			/**
			 * Gets or sets the style of this widget
			 *
			 * Styles allow you to attach custom platform-specific logic to a widget. In your
			 * platform-specific assembly, use {@link Style.Add{H}(string, StyleHandler{H})} to add
			 * the style logic with the same id.
			 */
			Style: string;

			/**
			 * Gets the instance of the platform-specific object
			 *
			 * This can sometimes be useful to get the platform-specific object. Some handlers may
			 * not have any backing object for its functionality, so this may be null.  It is more
			 * preferred to use the {@link Eto.Widget.Handler} and cast that to the platform-specific
			 * handler class which can give you additional methods and helpers to do common tasks.
			 * For example, the {@link Eto.Forms.Application} object's handler for OS X has a
			 * AddFullScreenMenuItem property to specify if you want full screen support in your app.
			 */
			readonly ControlObject: unknown;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Widget} has been disposed.
			 *
			 * When the widget is disposed, it can no longer be used.
			 */
			IsDisposed: boolean;

			/** Adds a button to the message box */
			AddButton(
				text: string,
				result: unknown,
				isDefault?: boolean,
				isAbort?: boolean,
			): void;

			/**
			 * Shows the dialog modally, blocking the current thread until it is closed.
			 *
			 * The `owner` specifies the control on the window that will be blocked from user input
			 * until the dialog is closed. Calling this method is identical to setting the
			 * {@link Eto.Forms.Window.Owner} property and calling
			 * {@link Eto.Forms.Dialog.ShowModal}.
			 */
			ShowModal(owner: Eto.Forms.Control): void;

			/** Shows the dialog modally, blocking the current thread until it is closed. */
			ShowModal(): void;

			/**
			 * Shows the dialog modally asynchronously
			 *
			 * The `owner` specifies the control on the window that will be blocked from user input
			 * until the dialog is closed. Calling this method is identical to setting the
			 * {@link Eto.Forms.Window.Owner} property and calling
			 * {@link Eto.Forms.Dialog.ShowModalAsync}.
			 */
			ShowModalAsync(owner: Eto.Forms.Control): Promise<void>;

			/** Shows the dialog modally asynchronously */
			ShowModalAsync(): Promise<void>;

			/**
			 * Closes the window
			 *
			 * Note that once a window is closed, it cannot be shown again in most platforms.
			 */
			Close(): void;

			/**
			 * Sets {@link Eto.Forms.Window.WindowState} to {@link Eto.Forms.WindowState.Minimized}
			 */
			Minimize(): void;

			/**
			 * Sets {@link Eto.Forms.Window.WindowState} to {@link Eto.Forms.WindowState.Maximized}
			 */
			Maximize(): void;

			/**
			 * Brings the window in front of all other windows in the z-order.  This should not
			 * activate/focus the window.
			 */
			BringToFront(): void;

			/**
			 * Sends the window behind all other windows in the z-order, and will remain active if it
			 * has focus.
			 */
			SendToBack(): void;

			/** Removes the specified child from the container */
			Remove(child: Eto.Forms.Control): void;

			/** Remove the specified `controls` from this container */
			Remove(controls: Iterable<Eto.Forms.Control>): void;

			/** Removes all controls from this container */
			RemoveAll(): void;

			/**
			 * Finds a child control in this container or any of its child containers with the
			 * specified `id`
			 */
			FindChild<T>(id?: string): T;

			/**
			 * Finds a child control in this container or any of its child containers with the
			 * specified `type`
			 */
			FindChild(
				type: unknown,
				id?: string,
			): Eto.Forms.Control;

			/**
			 * Finds a child control in this container or any of its child containers with the
			 * specified `id`.
			 */
			FindChild(id: string): Eto.Forms.Control;

			/**
			 * Queues a repaint of the entire control on the screen and any of its children.
			 *
			 * This is only useful when the control is visible.
			 */
			Invalidate(): void;

			/**
			 * Queues a repaint of the entire control on the screen
			 *
			 * This is only useful when the control is visible.
			 */
			Invalidate(invalidateChildren: boolean): void;

			/**
			 * Queues a repaint of the specified `rect` of the control and any children.
			 *
			 * This is only useful when the control is visible.
			 */
			Invalidate(rect: Eto.Drawing.Rectangle): void;

			/**
			 * Queues a repaint of the specified `rect` of the control
			 *
			 * This is only useful when the control is visible.
			 */
			Invalidate(
				rect: Eto.Drawing.Rectangle,
				invalidateChildren: boolean,
			): void;

			/**
			 * Updates the layout of this control if necessary.
			 *
			 * This will ensure the control has had all of its layout applied so you can use its
			 * position and size right after this call. Most platforms (except WinForms) use a
			 * deferred layout system so that after adding your control to the form dynamically it
			 * won't get laid out until the next idle loop. This is useful when you need to know the
			 * dimensions of the control immediately. Note that this can be an expensive operation,
			 * so it is recommended to only call this method when necessary and after all of the
			 * controls have been added/updated.
			 */
			UpdateLayout(): void;

			/** Gets the preferred size of this control given infinite space available. */
			GetPreferredSize(): Eto.Drawing.SizeF;

			/** Gets the preferred size of this control given the specified `availableSize`. */
			GetPreferredSize(availableSize: Eto.Drawing.SizeF): Eto.Drawing.SizeF;

			/**
			 * Captures all mouse events to this control.
			 *
			 * This captures all mouse events until {@link Eto.Forms.Control.ReleaseMouseCapture} is
			 * called.  Note that not all platforms will allow a mouse capture unless the mouse is
			 * currently down.
			 */
			CaptureMouse(): boolean;

			/** Releases the mouse capture after a call to {@link Eto.Forms.Control.CaptureMouse}. */
			ReleaseMouseCapture(): void;

			/**
			 * Finds a control in the parent hierarchy with the specified type and
			 * {@link Eto.Widget.ID} if specified
			 */
			FindParent(
				type: unknown,
				id?: string,
			): Eto.Forms.Container;

			/** Finds a control in the parent hierarchy with the specified `id` */
			FindParent(id: string): Eto.Forms.Container;

			/**
			 * Detaches the control by removing it from its parent
			 *
			 * This is essentially a shortcut to myControl.Parent.Remove(myControl);
			 */
			Detach(): void;

			/**
			 * Attaches the control for direct use in a native application
			 *
			 * Use this to use a control directly in a native application.  Note that the native
			 * application must be running the same framework as the current platform.  E.g. a
			 * WinForms application can use an Eto.Forms control when using the Eto.WinForms
			 * platform.  This prepares the control by firing the {@link Eto.Forms.Control.PreLoad},
			 * {@link Eto.Forms.Control.Load}, etc. events.
			 */
			AttachNative(): void;

			/**
			 * Detaches the control when it is used in a native application, when you want to reuse
			 * the control.
			 *
			 * This should only be called after {@link Eto.Forms.Control.AttachNative} has been
			 * called, which is usually done by calling to ToNative(true) .
			 */
			DetachNative(): void;

			/**
			 * Attempts to set the keyboard input focus to this control, or the first child that
			 * accepts focus. For Windows, this will bring it to front and activate it.
			 */
			Focus(): void;

			/**
			 * Suspends the layout of child controls
			 *
			 * This can be used to optimize some platforms while adding, removing, or changing many
			 * child controls at once. It disables the calculation of control positioning until
			 * {@link Eto.Forms.Control.ResumeLayout} is called. Each call to SuspendLayout() must be
			 * balanced with a call to {@link Eto.Forms.Control.ResumeLayout}.
			 */
			SuspendLayout(): void;

			/**
			 * Resumes the layout after it has been suspended, and performs a layout
			 *
			 * This can be used to optimize some platforms while adding, removing, or changing many
			 * child controls at once. Each call to ResumeLayout() must be balanced with a call to
			 * {@link Eto.Forms.Control.SuspendLayout} before it.
			 */
			ResumeLayout(): void;

			/**
			 * Specifies a command to execute for a platform-specific command
			 *
			 * Some platforms have specific system-defined commands that can be associated with a
			 * control. For example, the Mac platform's cut/copy/paste functionality is defined by
			 * the system, and if you want to hook into it, you can use this to map it to your own
			 * defined logic. The valid values of the `systemCommand` parameter are defined by each
			 * platform, and a list can be retrieved using
			 * {@link Eto.Forms.Control.SupportedPlatformCommands}
			 */
			MapPlatformCommand(
				systemCommand: string,
				command: Eto.Forms.Command,
			): void;

			/** Converts a point from screen space to control space. */
			PointFromScreen(point: Eto.Drawing.PointF): Eto.Drawing.PointF;

			/** Converts a point from control space to screen space */
			PointToScreen(point: Eto.Drawing.PointF): Eto.Drawing.PointF;

			/** Converts a rectangle from screen space to control space. */
			RectangleToScreen(rect: Eto.Drawing.RectangleF): Eto.Drawing.RectangleF;

			/** Converts a rectangle from control space to screen space */
			RectangleFromScreen(rect: Eto.Drawing.RectangleF): Eto.Drawing.RectangleF;

			/**
			 * Starts drag operation using this control as drag source.
			 *
			 * This method can be blocking on some platforms (Wpf, WinForms), and non-blocking on
			 * others (Mac, Gtk). Use the {@link Eto.Forms.Control.DragEnd} event to determine when
			 * the drag operation is completed and get its resulting DragEffects.
			 */
			DoDragDrop(
				data: Eto.Forms.DataObject,
				allowedEffects: Eto.Forms.DragEffects,
			): void;

			/**
			 * Starts drag operation using this control as drag source.
			 *
			 * This method can be blocking on some platforms (Wpf, WinForms), and non-blocking on
			 * others (Mac, Gtk). Use the {@link Eto.Forms.Control.DragEnd} event to determine when
			 * the drag operation is completed and get its resulting DragEffects.
			 */
			DoDragDrop(
				data: Eto.Forms.DataObject,
				allowedEffects: Eto.Forms.DragEffects,
				image: Eto.Drawing.Image,
				cursorOffset: Eto.Drawing.PointF,
			): void;

			/**
			 * Triggers the StyleChanged event and re-applies the styles to this control and its
			 * children.
			 */
			TriggerStyleChanged(): void;

			/** Shows a print dialog to print the specified control */
			Print(): void;

			/**
			 * Finds a control in the parent hierarchy with the specified type and
			 * {@link Eto.Widget.ID} if specified
			 */
			FindParent<T>(id?: string): T;

			/**
			 * Finds a control in the parent hierarchy with the specified type and
			 * {@link Eto.Widget.ID} if specified
			 */
			FindParent(
				type: unknown,
				id?: string,
			): Eto.Widget;

			/** Finds a control in the parent hierarchy with the specified `id` */
			FindParent(id: string): Eto.Widget;

			/**
			 * Unbinds any bindings in the {@link Eto.Forms.BindableWidget.Bindings} collection and
			 * removes the bindings
			 *
			 * When you implement {@link Eto.Forms.IBindableWidgetContainer}, this will also unbind
			 * any of its children.
			 */
			Unbind(): void;

			/**
			 * Updates all bindings in this widget
			 *
			 * When you implement {@link Eto.Forms.IBindableWidgetContainer}, this will also update
			 * bindings for all of its children.
			 */
			UpdateBindings(mode?: Eto.Forms.BindingUpdateMode): void;

			/** Disposes of this widget, supressing the finalizer */
			dispose(): void;

			/** Gets a string that represents the current object with its ID if specified. */
			ToString(): string;
		}
	}

	export namespace Eto.Forms.ThemedControls {
		/** Themed handler for the {@link Eto.Forms.PropertyGrid} control. */
		export class ThemedPropertyGridHandler implements
			Eto.Widget.IHandler,
			Eto.Forms.Control.IHandler,
			Eto.Forms.PropertyGrid.IHandler {
			constructor();

			/** Gets or sets the selected object for the grid to edit */
			SelectedObject: unknown;

			/**
			 * Gets or sets the selected objects for the grid to edit
			 *
			 * Only common properties (with the same name and type) will be shown.
			 */
			SelectedObjects: Iterable<unknown>;

			/** Gets or sets a value indicating that the categories should be shown */
			ShowCategories: boolean;

			/**
			 * Gets or sets a value indicating that the description panel should be shown
			 *
			 * The description panel shows the name and description of the selected property
			 */
			ShowDescription: boolean;

			BackgroundColor: Eto.Drawing.Color;

			readonly VisualControls: Iterable<Eto.Forms.Control>;

			readonly PropagateLoadEvents: boolean;

			Size: Eto.Drawing.Size;

			Width: number;

			Height: number;

			Enabled: boolean;

			readonly HasFocus: boolean;

			Visible: boolean;

			readonly SupportedPlatformCommands: Iterable<string>;

			readonly Location: Eto.Drawing.Point;

			ToolTip: string;

			Cursor: Eto.Forms.Cursor;

			readonly ControlObject: unknown;

			TabIndex: number;

			AllowDrop: boolean;

			readonly IsMouseCaptured: boolean;

			readonly Callback: Eto.Forms.PropertyGrid.ICallback;

			Control: Eto.Forms.ThemedControls.ThemedPropertyGrid;

			readonly HasControl: boolean;

			readonly Widget: Eto.Forms.PropertyGrid;

			ID: string;

			readonly NativeHandle: unknown;

			/** Refreshes the grid with new values from the selected object(s) */
			Refresh(): void;

			/**
			 * Attaches the specified event to the platform-specific control
			 *
			 * Implementors should override this method to handle any events that the widget
			 * supports. Ensure to call the base class' implementation if the event is not one the
			 * specific widget supports, so the base class' events can be handled as well.
			 */
			AttachEvent(id: string): void;

			GetPreferredSize(availableSize: Eto.Drawing.SizeF): Eto.Drawing.SizeF;

			Invalidate(invalidateChildren: boolean): void;

			Invalidate(
				rect: Eto.Drawing.Rectangle,
				invalidateChildren: boolean,
			): void;

			SuspendLayout(): void;

			ResumeLayout(): void;

			Focus(): void;

			OnPreLoad(e: unknown): void;

			OnLoad(e: unknown): void;

			OnLoadComplete(e: unknown): void;

			OnUnLoad(e: unknown): void;

			SetParent(
				oldParent: Eto.Forms.Container,
				newParent: Eto.Forms.Container,
			): void;

			PointFromScreen(point: Eto.Drawing.PointF): Eto.Drawing.PointF;

			PointToScreen(point: Eto.Drawing.PointF): Eto.Drawing.PointF;

			MapPlatformCommand(
				systemAction: string,
				action: Eto.Forms.Command,
			): void;

			DoDragDrop(
				data: Eto.Forms.DataObject,
				allowedAction: Eto.Forms.DragEffects,
				image: Eto.Drawing.Image,
				cursorOffset: Eto.Drawing.PointF,
			): void;

			GetNativeParentWindow(): Eto.Forms.Window;

			Print(): void;

			UpdateLayout(): void;

			CaptureMouse(): boolean;

			ReleaseMouseCapture(): void;

			IsEventHandled(id: string): boolean;

			HandleEvent(
				id: string,
				defaultEvent?: boolean,
			): void;

			dispose(): void;
		}
	}

	export namespace Eto.Forms.ThemedControls {
		/** Implementation of the PropertyGrid using the TreeGridView and PropertyCell */
		export class ThemedPropertyGrid implements
			Eto.IHandlerSource,
			Eto.Forms.IBindable,
			Eto.Forms.IMouseInputSource,
			Eto.Forms.IKeyboardInputSource {
			/** Initializes a new instance of the ThemedPropertyGrid */
			constructor();

			/**
			 * Gets a collection of custom property cell types to use as well as the built-in types.
			 */
			readonly PropertyCellTypes: Eto.Forms.PropertyCellType[];

			/**
			 * Gets or sets the selected objects for the grid to edit
			 *
			 * Only common properties (with the same name and type) will be shown.
			 */
			SelectedObjects: Iterable<unknown>;

			/**
			 * Gets or sets a value indicating that value types should use their default to determine
			 * if the property is changed (shown as bold)
			 */
			UseValueTypeDefaults: boolean;

			/** Gets or sets the selected object */
			SelectedObject: unknown;

			/** Gets or sets a value indicating that the categories should be shown */
			ShowCategories: boolean;

			/**
			 * Gets or sets a value indicating that the description panel should be shown
			 *
			 * The description panel shows the name and description of the selected property
			 */
			ShowDescription: boolean;

			/** Gets an enumeration of controls that are directly contained by this container */
			readonly Controls: Iterable<Eto.Forms.Control>;

			/** Gets or sets the padding around the {@link Eto.Forms.Panel.Content} of the panel. */
			Padding: Eto.Drawing.Padding;

			/** Gets or sets the minimum size of the panel. */
			MinimumSize: Eto.Drawing.Size;

			/**
			 * Gets or sets the context menu for the panel.
			 *
			 * The context menu is usually shown when the user right clicks the control, or in mobile
			 * platforms when the user taps and holds their finger down on the control.
			 */
			ContextMenu: Eto.Forms.ContextMenu;

			/**
			 * Gets or sets the main content of the panel.
			 *
			 * The main content will be offset by the {@link Eto.Forms.Panel.Padding} value
			 * specified, and will take up the entire content area of the control. Some controls may
			 * have decorations that will surround the content, such as a {@link Eto.Forms.GroupBox},
			 * {@link Eto.Forms.TabControl}, or {@link Eto.Forms.Window}
			 */
			Content: Eto.Forms.Control;

			/**
			 * Gets or sets the size for the client area of the control
			 *
			 * The client size differs from the {@link Eto.Forms.Control.Size} in that it excludes
			 * the decorations of the container, such as the title bar and border around a
			 * {@link Eto.Forms.Window}, or the title and line  around a {@link Eto.Forms.GroupBox}.
			 */
			ClientSize: Eto.Drawing.Size;

			/**
			 * Gets an enumeration of all contained child controls, including controls within child
			 * containers
			 */
			readonly Children: Iterable<Eto.Forms.Control>;

			/**
			 * Gets an enumeration of all contained child controls in the visual tree, including
			 * controls within child containers.
			 */
			readonly VisualChildren: Iterable<Eto.Forms.Control>;

			/**
			 * Gets or sets the style provider for this container.
			 *
			 * The style provider is used to style this container and its children.
			 */
			StyleProvider: Eto.IStyleProvider;

			/**
			 * Gets the default style provider for this container.
			 *
			 * Use this to apply styles to any child controls of this container. By default, styles
			 * will apply to all children, including children of children unless
			 * {@link Eto.DefaultStyleProvider.Inherit} is set to false .  Typically, you would set
			 * Inherit to false when creating composite controls that already have all their styles
			 * applied and you don't want any other styles to be inherited.
			 */
			readonly Styles: Eto.DefaultStyleProvider;

			/**
			 * Gets a value indicating that the control is loaded onto a form, that is it has been
			 * created, added to a parent, and shown
			 *
			 * The {@link Eto.Forms.Control.OnLoad(System.EventArgs)} method sets this value to true
			 * after cascading to all children (for a {@link Eto.Forms.Container} ) and calling the
			 * platform handler's implementation.  It is called after adding to a loaded form, or
			 * when showing a new form.  The {@link Eto.Forms.Control.OnUnLoad(System.EventArgs)}
			 * method will set this value to false when the control is removed from its parent
			 */
			readonly Loaded: boolean;

			/**
			 * Gets an enumeration of controls that are in the visual tree.
			 *
			 * This is used to specify which controls are contained by this instance that are part of
			 * the visual tree. This should include all controls including non-logical Eto controls
			 * used for layout.
			 */
			readonly VisualControls: Iterable<Eto.Forms.Control>;

			/**
			 * Gets or sets a user-defined object that contains data about the control
			 *
			 * A common use of the tag property is to store data that is associated with the control
			 * that you can later retrieve.
			 */
			Tag: unknown;

			/**
			 * Gets the logical parent control.
			 *
			 * When the control is part of the visual tree (
				 * {@link Eto.Forms.Control.IsVisualControl} is true), this returns the logical parent
				 * that contains this control. Otherwise this is the same as
				 * {@link Eto.Forms.Control.Parent}.
				 */
				readonly LogicalParent: Eto.Forms.Container;

			/** Gets a value indicating this {@link Eto.Forms.Control} is part of the visual tree. */
			IsVisualControl: boolean;

			/**
			 * Gets or sets the size of the control. Use -1 to specify auto sizing for either the
			 * width and/or height.
			 *
			 * Setting the size of controls is entirely optional as most controls will size
			 * themselves appropriately. When specifying a size, it will be used as the desired size
			 * of the control.  The container will reposition and resize the control depending on the
			 * available size.  For a {@link Eto.Forms.Window}, it is preferred to set the
			 * {@link Eto.Forms.Container.ClientSize} instead, as various platforms have different
			 * sizes of window decorations, toolbars, etc.
			 */
			Size: Eto.Drawing.Size;

			/**
			 * Gets a value indicating this control currently has mouse capture
			 *
			 * Mouse capture can happen during a handled MouseDown event until MouseUp, or it can be
			 * captured explicitly via {@link Eto.Forms.Control.CaptureMouse}.
			 */
			readonly IsMouseCaptured: boolean;

			/** Gets or sets the width of the control size. */
			Width: number;

			/** Gets or sets the height of the control size. */
			Height: number;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Forms.Control} (or its
			 * children) are enabled and accept user input.
			 *
			 * Typically when a control is disabled, the user cannot do anything with the control or
			 * any of its children. Including for example, selecting text in a text control. Certain
			 * controls can have a 'Read Only' mode, such as {@link Eto.Forms.TextBox.ReadOnly} which
			 * allow the user to  select text, but not change its contents.
			 */
			Enabled: boolean;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Forms.Control} is visible to
			 * the user.
			 *
			 * When the visibility of a control is set to false, it will not occupy space in the
			 * layout.
			 */
			Visible: boolean;

			/** Gets the container which this control has been added to, if any */
			readonly Parent: Eto.Forms.Container;

			/**
			 * Gets the visual container of this control, if any.
			 *
			 * Some containers may use other Eto controls to layout its children, such as the
			 * {@link Eto.Forms.StackLayout}. This will return the parent control that visually
			 * contains this control as opposed to {@link Eto.Forms.Control.Parent} which will return
			 * the logical parent.
			 */
			VisualParent: Eto.Forms.Container;

			/** Gets a value indicating this control has been attached to a native container */
			readonly IsAttached: boolean;

			/**
			 * Gets or sets the color for the background of the control
			 *
			 * Note that on some platforms (e.g. Mac), setting the background color of a control can
			 * change the performance characteristics of the control and its children, since it must
			 * enable layers to do so.
			 */
			BackgroundColor: Eto.Drawing.Color;

			/** Gets a value indicating whether this instance has the keyboard input focus. */
			readonly HasFocus: boolean;

			/** Gets a value indicating whether the layout of child controls is suspended. */
			readonly IsSuspended: boolean;

			/** Gets the window this control is contained in */
			readonly ParentWindow: Eto.Forms.Window;

			/**
			 * Gets the supported platform commands that can be used to hook up system functions to
			 * user defined logic
			 *
			 * This lists all available commands that can be mapped using the
			 * {@link Eto.Forms.Control.MapPlatformCommand(System.String,Eto.Forms.Command)} method
			 * of the control.
			 */
			readonly SupportedPlatformCommands: Iterable<string>;

			/** Gets the bounding rectangle of this control relative to its container */
			readonly Bounds: Eto.Drawing.Rectangle;

			/**
			 * Gets the location of the control as positioned by the container
			 *
			 * A control's location is set by the container. This can be used to determine where the
			 * control is for overlaying floating windows, menus, etc.
			 */
			readonly Location: Eto.Drawing.Point;

			/** Gets or sets the type of cursor to use when the mouse is hovering over the control */
			Cursor: Eto.Forms.Cursor;

			/** Gets or sets the tool tip to show when the mouse is hovered over the control */
			ToolTip: string;

			/**
			 * Gets or sets the tab index order for this control within its container.
			 *
			 * This sets the order when using the tab key to cycle through controls  Note that some
			 * platforms (Gtk and WinForms) may not support setting the context of the tab order to
			 * StackLayout  or DynamicLayout containers and may not behave exactly as expected. Use
			 * the {@link Eto.PlatformFeatures.TabIndexWithCustomContainers} flag to determine if it
			 * is supported.
			 */
			TabIndex: number;

			/** Gets or sets a value indicating whether this control can serve as drop target. */
			AllowDrop: boolean;

			/**
			 * Gets or sets the parent widget which this widget has been added to, if any
			 *
			 * When implementing child widgets that can participate in the context based binding
			 * (MVVM), You can set this to the parent widget when it is added or removed to it
			 * (usually via a collection).  Note that you should typically provide a public new
			 * [ParentWidget] Parent { get; } property  so that consumers of your API cannot set the
			 * parent to an invalid value.
			 */
			Parent: Eto.Widget;

			/**
			 * Gets an enumeration of all parent widgets in the heirarchy by traversing the
			 * {@link Eto.Forms.BindableWidget.Parent} property.
			 */
			readonly Parents: Iterable<Eto.Widget>;

			/**
			 * Gets or sets the data context for this widget for binding
			 *
			 * Subclasses may override the standard behaviour so that hierarchy of widgets can be
			 * taken into account.  For example, a Control may return the data context of a parent,
			 * if it is not set explicitly.
			 */
			DataContext: unknown;

			/** Gets the collection of bindings that are attached to this widget */
			readonly Bindings: Eto.Forms.BindingCollection;

			/**
			 * Gets a value indicating that the {@link Eto.Forms.BindableWidget.DataContext} property
			 * is changing.
			 *
			 * This can be used to determine when to allow certain logic during the update of the
			 * data context.  It is used to disable binding setters on the model when the data
			 * context changes so that a binding does not cause the view model to be updated when the
			 * state hasn't been fully set yet.
			 */
			IsDataContextChanging: boolean;

			/**
			 * Gets the platform that was used to create the {@link Eto.Widget.Handler} for this
			 * widget
			 *
			 * This gets set to the current {@link Eto.Platform.Instance} during the construction of
			 * the object
			 */
			readonly Platform: Eto.Platform;

			/** Gets the platform-specific handler for this widget */
			Handler: unknown;

			/** Gets the native platform-specific handle for integration purposes */
			readonly NativeHandle: unknown;

			/** Gets the dictionary of properties for this widget */
			readonly Properties: Eto.PropertyStore;

			/** Gets or sets the ID of this widget */
			ID: string;

			/**
			 * Gets or sets the style of this widget
			 *
			 * Styles allow you to attach custom platform-specific logic to a widget. In your
			 * platform-specific assembly, use {@link Style.Add{H}(string, StyleHandler{H})} to add
			 * the style logic with the same id.
			 */
			Style: string;

			/**
			 * Gets the instance of the platform-specific object
			 *
			 * This can sometimes be useful to get the platform-specific object. Some handlers may
			 * not have any backing object for its functionality, so this may be null.  It is more
			 * preferred to use the {@link Eto.Widget.Handler} and cast that to the platform-specific
			 * handler class which can give you additional methods and helpers to do common tasks.
			 * For example, the {@link Eto.Forms.Application} object's handler for OS X has a
			 * AddFullScreenMenuItem property to specify if you want full screen support in your app.
			 */
			readonly ControlObject: unknown;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Widget} has been disposed.
			 *
			 * When the widget is disposed, it can no longer be used.
			 */
			IsDisposed: boolean;

			/**
			 * Creates a cell value binding for a particular type when you want to add your own cell
			 * types to {@link Eto.Forms.ThemedControls.ThemedPropertyGrid.PropertyCellTypes}
			 */
			CreateCellValueBinding<T>(): Eto.Forms.IndirectBinding$1<T>;

			/** Refreshes the properties of the grid */
			Refresh(): void;

			/** Removes the specified child from the container */
			Remove(child: Eto.Forms.Control): void;

			/** Remove the specified `controls` from this container */
			Remove(controls: Iterable<Eto.Forms.Control>): void;

			/** Removes all controls from this container */
			RemoveAll(): void;

			/**
			 * Finds a child control in this container or any of its child containers with the
			 * specified `id`
			 */
			FindChild<T>(id?: string): T;

			/**
			 * Finds a child control in this container or any of its child containers with the
			 * specified `type`
			 */
			FindChild(
				type: unknown,
				id?: string,
			): Eto.Forms.Control;

			/**
			 * Finds a child control in this container or any of its child containers with the
			 * specified `id`.
			 */
			FindChild(id: string): Eto.Forms.Control;

			/**
			 * Queues a repaint of the entire control on the screen and any of its children.
			 *
			 * This is only useful when the control is visible.
			 */
			Invalidate(): void;

			/**
			 * Queues a repaint of the entire control on the screen
			 *
			 * This is only useful when the control is visible.
			 */
			Invalidate(invalidateChildren: boolean): void;

			/**
			 * Queues a repaint of the specified `rect` of the control and any children.
			 *
			 * This is only useful when the control is visible.
			 */
			Invalidate(rect: Eto.Drawing.Rectangle): void;

			/**
			 * Queues a repaint of the specified `rect` of the control
			 *
			 * This is only useful when the control is visible.
			 */
			Invalidate(
				rect: Eto.Drawing.Rectangle,
				invalidateChildren: boolean,
			): void;

			/**
			 * Updates the layout of this control if necessary.
			 *
			 * This will ensure the control has had all of its layout applied so you can use its
			 * position and size right after this call. Most platforms (except WinForms) use a
			 * deferred layout system so that after adding your control to the form dynamically it
			 * won't get laid out until the next idle loop. This is useful when you need to know the
			 * dimensions of the control immediately. Note that this can be an expensive operation,
			 * so it is recommended to only call this method when necessary and after all of the
			 * controls have been added/updated.
			 */
			UpdateLayout(): void;

			/** Gets the preferred size of this control given infinite space available. */
			GetPreferredSize(): Eto.Drawing.SizeF;

			/** Gets the preferred size of this control given the specified `availableSize`. */
			GetPreferredSize(availableSize: Eto.Drawing.SizeF): Eto.Drawing.SizeF;

			/**
			 * Captures all mouse events to this control.
			 *
			 * This captures all mouse events until {@link Eto.Forms.Control.ReleaseMouseCapture} is
			 * called.  Note that not all platforms will allow a mouse capture unless the mouse is
			 * currently down.
			 */
			CaptureMouse(): boolean;

			/** Releases the mouse capture after a call to {@link Eto.Forms.Control.CaptureMouse}. */
			ReleaseMouseCapture(): void;

			/**
			 * Finds a control in the parent hierarchy with the specified type and
			 * {@link Eto.Widget.ID} if specified
			 */
			FindParent(
				type: unknown,
				id?: string,
			): Eto.Forms.Container;

			/** Finds a control in the parent hierarchy with the specified `id` */
			FindParent(id: string): Eto.Forms.Container;

			/**
			 * Detaches the control by removing it from its parent
			 *
			 * This is essentially a shortcut to myControl.Parent.Remove(myControl);
			 */
			Detach(): void;

			/**
			 * Attaches the control for direct use in a native application
			 *
			 * Use this to use a control directly in a native application.  Note that the native
			 * application must be running the same framework as the current platform.  E.g. a
			 * WinForms application can use an Eto.Forms control when using the Eto.WinForms
			 * platform.  This prepares the control by firing the {@link Eto.Forms.Control.PreLoad},
			 * {@link Eto.Forms.Control.Load}, etc. events.
			 */
			AttachNative(): void;

			/**
			 * Detaches the control when it is used in a native application, when you want to reuse
			 * the control.
			 *
			 * This should only be called after {@link Eto.Forms.Control.AttachNative} has been
			 * called, which is usually done by calling to ToNative(true) .
			 */
			DetachNative(): void;

			/**
			 * Attempts to set the keyboard input focus to this control, or the first child that
			 * accepts focus. For Windows, this will bring it to front and activate it.
			 */
			Focus(): void;

			/**
			 * Suspends the layout of child controls
			 *
			 * This can be used to optimize some platforms while adding, removing, or changing many
			 * child controls at once. It disables the calculation of control positioning until
			 * {@link Eto.Forms.Control.ResumeLayout} is called. Each call to SuspendLayout() must be
			 * balanced with a call to {@link Eto.Forms.Control.ResumeLayout}.
			 */
			SuspendLayout(): void;

			/**
			 * Resumes the layout after it has been suspended, and performs a layout
			 *
			 * This can be used to optimize some platforms while adding, removing, or changing many
			 * child controls at once. Each call to ResumeLayout() must be balanced with a call to
			 * {@link Eto.Forms.Control.SuspendLayout} before it.
			 */
			ResumeLayout(): void;

			/**
			 * Specifies a command to execute for a platform-specific command
			 *
			 * Some platforms have specific system-defined commands that can be associated with a
			 * control. For example, the Mac platform's cut/copy/paste functionality is defined by
			 * the system, and if you want to hook into it, you can use this to map it to your own
			 * defined logic. The valid values of the `systemCommand` parameter are defined by each
			 * platform, and a list can be retrieved using
			 * {@link Eto.Forms.Control.SupportedPlatformCommands}
			 */
			MapPlatformCommand(
				systemCommand: string,
				command: Eto.Forms.Command,
			): void;

			/** Converts a point from screen space to control space. */
			PointFromScreen(point: Eto.Drawing.PointF): Eto.Drawing.PointF;

			/** Converts a point from control space to screen space */
			PointToScreen(point: Eto.Drawing.PointF): Eto.Drawing.PointF;

			/** Converts a rectangle from screen space to control space. */
			RectangleToScreen(rect: Eto.Drawing.RectangleF): Eto.Drawing.RectangleF;

			/** Converts a rectangle from control space to screen space */
			RectangleFromScreen(rect: Eto.Drawing.RectangleF): Eto.Drawing.RectangleF;

			/**
			 * Starts drag operation using this control as drag source.
			 *
			 * This method can be blocking on some platforms (Wpf, WinForms), and non-blocking on
			 * others (Mac, Gtk). Use the {@link Eto.Forms.Control.DragEnd} event to determine when
			 * the drag operation is completed and get its resulting DragEffects.
			 */
			DoDragDrop(
				data: Eto.Forms.DataObject,
				allowedEffects: Eto.Forms.DragEffects,
			): void;

			/**
			 * Starts drag operation using this control as drag source.
			 *
			 * This method can be blocking on some platforms (Wpf, WinForms), and non-blocking on
			 * others (Mac, Gtk). Use the {@link Eto.Forms.Control.DragEnd} event to determine when
			 * the drag operation is completed and get its resulting DragEffects.
			 */
			DoDragDrop(
				data: Eto.Forms.DataObject,
				allowedEffects: Eto.Forms.DragEffects,
				image: Eto.Drawing.Image,
				cursorOffset: Eto.Drawing.PointF,
			): void;

			/**
			 * Triggers the StyleChanged event and re-applies the styles to this control and its
			 * children.
			 */
			TriggerStyleChanged(): void;

			/** Shows a print dialog to print the specified control */
			Print(): void;

			/**
			 * Finds a control in the parent hierarchy with the specified type and
			 * {@link Eto.Widget.ID} if specified
			 */
			FindParent<T>(id?: string): T;

			/**
			 * Finds a control in the parent hierarchy with the specified type and
			 * {@link Eto.Widget.ID} if specified
			 */
			FindParent(
				type: unknown,
				id?: string,
			): Eto.Widget;

			/** Finds a control in the parent hierarchy with the specified `id` */
			FindParent(id: string): Eto.Widget;

			/**
			 * Unbinds any bindings in the {@link Eto.Forms.BindableWidget.Bindings} collection and
			 * removes the bindings
			 *
			 * When you implement {@link Eto.Forms.IBindableWidgetContainer}, this will also unbind
			 * any of its children.
			 */
			Unbind(): void;

			/**
			 * Updates all bindings in this widget
			 *
			 * When you implement {@link Eto.Forms.IBindableWidgetContainer}, this will also update
			 * bindings for all of its children.
			 */
			UpdateBindings(mode?: Eto.Forms.BindingUpdateMode): void;

			/** Disposes of this widget, supressing the finalizer */
			dispose(): void;

			/** Gets a string that represents the current object with its ID if specified. */
			ToString(): string;
		}
	}

	export namespace Eto.Forms.ThemedControls {
		/** Themed {@link Eto.Forms.MenuSegmentedItem} handler */
		export class ThemedMenuSegmentedItemHandler implements
			Eto.Widget.IHandler,
			Eto.Forms.SegmentedItem.IHandler,
			Eto.Forms.MenuSegmentedItem.IHandler {
			constructor();

			/**
			 * Delay for the menu to show when the mouse is down and
			 * {@link Eto.Forms.ThemedControls.ThemedMenuSegmentedItemHandler.CanSelect} is true .
			 */
			MenuDelay: number;

			/** Gets or sets the indicator to show to the right of the text. */
			MenuIndicator: string;

			Menu: Eto.Forms.ContextMenu;

			CanSelect: boolean;

			Text: string;

			Enabled: boolean;

			Visible: boolean;

			ToolTip: string;

			Width: number;

			Image: Eto.Drawing.Image;

			Selected: boolean;

			readonly Callback: Eto.Forms.SegmentedItem.ICallback;

			Control: Eto.Forms.ToggleButton;

			readonly HasControl: boolean;

			readonly Widget: Eto.Forms.MenuSegmentedItem;

			ID: string;

			readonly NativeHandle: unknown;

			AttachEvent(id: string): void;

			IsEventHandled(id: string): boolean;

			HandleEvent(
				id: string,
				defaultEvent?: boolean,
			): void;

			dispose(): void;
		}
	}

	export namespace Eto.Forms.ThemedControls {
		/** Themed {@link Eto.Forms.ButtonSegmentedItem} handler. */
		export class ThemedButtonSegmentedItemHandler implements
			Eto.Widget.IHandler,
			Eto.Forms.SegmentedItem.IHandler,
			Eto.Forms.ButtonSegmentedItem.IHandler {
			constructor();

			Enabled: boolean;

			Visible: boolean;

			ToolTip: string;

			Width: number;

			Text: string;

			Image: Eto.Drawing.Image;

			Selected: boolean;

			readonly Callback: Eto.Forms.SegmentedItem.ICallback;

			Control: Eto.Forms.ToggleButton;

			readonly HasControl: boolean;

			readonly Widget: Eto.Forms.ButtonSegmentedItem;

			ID: string;

			readonly NativeHandle: unknown;

			AttachEvent(id: string): void;

			IsEventHandled(id: string): boolean;

			HandleEvent(
				id: string,
				defaultEvent?: boolean,
			): void;

			dispose(): void;
		}
	}

	export namespace Eto.Forms.ThemedControls {
		/**
		 * [Generic type factory] Themed {@link Eto.Forms.SegmentedItem} handler which uses a
		 * {@link Eto.Forms.ToggleButton} for its display.
		 */
		export function ThemedSegmentedItemHandler$(TWidget: IType, TCallback: IType): typeof ThemedSegmentedItemHandler$2<any, any>;

		/**
		 * Themed {@link Eto.Forms.SegmentedItem} handler which uses a
		 * {@link Eto.Forms.ToggleButton} for its display.
		 */
		export class ThemedSegmentedItemHandler$2<TWidget, TCallback> implements
			Eto.Widget.IHandler,
			Eto.Forms.SegmentedItem.IHandler {
			Enabled: boolean;

			Visible: boolean;

			ToolTip: string;

			Width: number;

			Text: string;

			Image: Eto.Drawing.Image;

			Selected: boolean;

			readonly Callback: TCallback;

			Control: Eto.Forms.ToggleButton;

			readonly HasControl: boolean;

			readonly Widget: TWidget;

			ID: string;

			readonly NativeHandle: unknown;

			AttachEvent(id: string): void;

			IsEventHandled(id: string): boolean;

			HandleEvent(
				id: string,
				defaultEvent?: boolean,
			): void;

			dispose(): void;
		}
	}

	export namespace Eto.Forms.ThemedControls {
		/**
		 * Themed {@link Eto.Forms.SegmentedButton} handler which uses a series of
		 * {@link Eto.Forms.ToggleButton} controls in a table.
		 */
		export class ThemedSegmentedButtonHandler implements
			Eto.Widget.IHandler,
			Eto.Forms.Control.IHandler,
			Eto.Forms.SegmentedButton.IHandler {
			constructor();

			SelectionMode: Eto.Forms.SegmentedSelectionMode;

			/** Gets or sets the spacing between the buttons */
			Spacing: number;

			SelectedIndex: number;

			SelectedIndexes: Iterable<number>;

			BackgroundColor: Eto.Drawing.Color;

			readonly VisualControls: Iterable<Eto.Forms.Control>;

			readonly PropagateLoadEvents: boolean;

			Size: Eto.Drawing.Size;

			Width: number;

			Height: number;

			Enabled: boolean;

			readonly HasFocus: boolean;

			Visible: boolean;

			readonly SupportedPlatformCommands: Iterable<string>;

			readonly Location: Eto.Drawing.Point;

			ToolTip: string;

			Cursor: Eto.Forms.Cursor;

			readonly ControlObject: unknown;

			TabIndex: number;

			AllowDrop: boolean;

			readonly IsMouseCaptured: boolean;

			readonly Callback: Eto.Forms.SegmentedButton.ICallback;

			Control: Eto.Forms.Panel;

			readonly HasControl: boolean;

			readonly Widget: Eto.Forms.SegmentedButton;

			ID: string;

			readonly NativeHandle: unknown;

			ClearItems(): void;

			ClearSelection(): void;

			InsertItem(
				index: number,
				item: Eto.Forms.SegmentedItem,
			): void;

			RemoveItem(
				index: number,
				item: Eto.Forms.SegmentedItem,
			): void;

			SelectAll(): void;

			SetItem(
				index: number,
				item: Eto.Forms.SegmentedItem,
			): void;

			AttachEvent(id: string): void;

			OnPreLoad(e: unknown): void;

			OnLoad(e: unknown): void;

			/** Gets the preferred size of this control given the specified `availableSize`. */
			GetPreferredSize(availableSize: Eto.Drawing.SizeF): Eto.Drawing.SizeF;

			Invalidate(invalidateChildren: boolean): void;

			Invalidate(
				rect: Eto.Drawing.Rectangle,
				invalidateChildren: boolean,
			): void;

			SuspendLayout(): void;

			ResumeLayout(): void;

			Focus(): void;

			OnLoadComplete(e: unknown): void;

			OnUnLoad(e: unknown): void;

			SetParent(
				oldParent: Eto.Forms.Container,
				newParent: Eto.Forms.Container,
			): void;

			PointFromScreen(point: Eto.Drawing.PointF): Eto.Drawing.PointF;

			PointToScreen(point: Eto.Drawing.PointF): Eto.Drawing.PointF;

			MapPlatformCommand(
				systemAction: string,
				action: Eto.Forms.Command,
			): void;

			DoDragDrop(
				data: Eto.Forms.DataObject,
				allowedAction: Eto.Forms.DragEffects,
				image: Eto.Drawing.Image,
				cursorOffset: Eto.Drawing.PointF,
			): void;

			GetNativeParentWindow(): Eto.Forms.Window;

			Print(): void;

			UpdateLayout(): void;

			CaptureMouse(): boolean;

			ReleaseMouseCapture(): void;

			IsEventHandled(id: string): boolean;

			HandleEvent(
				id: string,
				defaultEvent?: boolean,
			): void;

			dispose(): void;
		}
	}

	export namespace Eto.Forms.ThemedControls {
		/** Display Mode of the {@link Eto.Forms.ThemedControls.ThemedSpinnerHandler} */
		export enum ThemedSpinnerMode {
			/** Shows lines for each element in the spinner */
			Line = 0,

			/** Shows dots for each element in the spinner */
			Circle = 1,
		}
	}

	export namespace Eto.Forms.ThemedControls {
		/** Direction to spin the {@link Eto.Forms.ThemedControls.ThemedSpinnerHandler} */
		export enum ThemedSpinnerDirection {
			/** Spins clockwise */
			Clockwise = 1,

			/** Spins counter-clockwise */
			CounterClockwise = -1,
		}
	}

	export namespace Eto.Forms.ThemedControls {
		/** Themed spinner handler for the {@link Eto.Forms.Spinner} control */
		export class ThemedSpinnerHandler implements
			Eto.Widget.IHandler,
			Eto.Forms.Control.IHandler,
			Eto.Forms.Spinner.IHandler {
			constructor();

			/**
			 * Gets or sets the increment for each step when the spinner is animating, where 1 is
			 * equal to the distance from one element to the other
			 */
			Increment: number;

			/** Gets or sets the direction to spin */
			Direction: Eto.Forms.ThemedControls.ThemedSpinnerDirection;

			/** Gets or sets the alpha of the marks when the spinner is not spinning (disabled) */
			DisabledAlpha: number;

			/** Gets or sets the main color of each element */
			ElementColor: Eto.Drawing.Color;

			/**
			 * Gets or sets the line thickness relative to the control size, when the
			 * {@link Eto.Forms.ThemedControls.ThemedSpinnerHandler.Mode} is a Line
			 */
			LineThickness: number;

			/**
			 * Gets or sets the line cap when the
			 * {@link Eto.Forms.ThemedControls.ThemedSpinnerHandler.Mode} is set to line
			 */
			LineCap: Eto.Drawing.PenLineCap;

			/** Gets or sets the size of each element, relative to the control size */
			ElementSize: number;

			/** Gets or sets the display mode of the spinner (e.g. Line/Circle) */
			Mode: Eto.Forms.ThemedControls.ThemedSpinnerMode;

			/** Gets or sets the number of elements to display */
			NumberOfElements: number;

			/**
			 * Gets or sets the number of visible elements while animating. This must be less than or
			 * equal to {@link Eto.Forms.ThemedControls.ThemedSpinnerHandler.NumberOfElements}
			 */
			NumberOfVisibleElements: number;

			/** Gets or sets the speed of the spinner, in seconds for each tick. */
			Speed: number;

			/**
			 * Gets or sets a value indicating whether this
			 * {@link Eto.Forms.ThemedControls.ThemedSpinnerHandler} is enabled (spinning)
			 */
			Enabled: boolean;

			BackgroundColor: Eto.Drawing.Color;

			readonly VisualControls: Iterable<Eto.Forms.Control>;

			readonly PropagateLoadEvents: boolean;

			Size: Eto.Drawing.Size;

			Width: number;

			Height: number;

			readonly HasFocus: boolean;

			Visible: boolean;

			readonly SupportedPlatformCommands: Iterable<string>;

			readonly Location: Eto.Drawing.Point;

			ToolTip: string;

			Cursor: Eto.Forms.Cursor;

			readonly ControlObject: unknown;

			TabIndex: number;

			AllowDrop: boolean;

			readonly IsMouseCaptured: boolean;

			readonly Callback: Eto.Forms.Control.ICallback;

			Control: Eto.Forms.Drawable;

			readonly HasControl: boolean;

			readonly Widget: Eto.Forms.Spinner;

			ID: string;

			readonly NativeHandle: unknown;

			/** Called after all other controls have been loaded */
			OnLoadComplete(e: unknown): void;

			/**
			 * Called when the control is unloaded, which is when it is not currently on a displayed
			 * window
			 */
			OnUnLoad(e: unknown): void;

			GetPreferredSize(availableSize: Eto.Drawing.SizeF): Eto.Drawing.SizeF;

			Invalidate(invalidateChildren: boolean): void;

			Invalidate(
				rect: Eto.Drawing.Rectangle,
				invalidateChildren: boolean,
			): void;

			SuspendLayout(): void;

			ResumeLayout(): void;

			Focus(): void;

			OnPreLoad(e: unknown): void;

			OnLoad(e: unknown): void;

			SetParent(
				oldParent: Eto.Forms.Container,
				newParent: Eto.Forms.Container,
			): void;

			PointFromScreen(point: Eto.Drawing.PointF): Eto.Drawing.PointF;

			PointToScreen(point: Eto.Drawing.PointF): Eto.Drawing.PointF;

			MapPlatformCommand(
				systemAction: string,
				action: Eto.Forms.Command,
			): void;

			DoDragDrop(
				data: Eto.Forms.DataObject,
				allowedAction: Eto.Forms.DragEffects,
				image: Eto.Drawing.Image,
				cursorOffset: Eto.Drawing.PointF,
			): void;

			AttachEvent(id: string): void;

			GetNativeParentWindow(): Eto.Forms.Window;

			Print(): void;

			UpdateLayout(): void;

			CaptureMouse(): boolean;

			ReleaseMouseCapture(): void;

			IsEventHandled(id: string): boolean;

			HandleEvent(
				id: string,
				defaultEvent?: boolean,
			): void;

			dispose(): void;
		}
	}

	export namespace Eto.Forms.ThemedControls {
		/**
		 * ! UNDER CONSTRUCTION ! Themed splitter handler for the
		 * {@link Eto.Forms.ThemedControls.ThemedSplitterHandler.Splitter} control
		 */
		export class ThemedSplitterHandler implements
			Eto.Widget.IHandler,
			Eto.Forms.Control.IHandler,
			Eto.Forms.Container.IHandler,
			Eto.Forms.Splitter.IHandler {
			constructor();

			/** Gets or sets the orientation of the panels in the splitter. */
			Orientation: Eto.Forms.Orientation;

			/** Gets or sets the panel with fixed size. */
			FixedPanel: Eto.Forms.SplitterFixedPanel;

			/** Gets or sets the position of the splitter from the left or top, in pixels. */
			Position: number;

			/**
			 * Gets or sets the relative position of the splitter which is based on
			 * {@link Eto.Forms.ThemedControls.ThemedSplitterHandler.FixedPanel}.
			 */
			RelativePosition: number;

			/** Gets or sets size of the splitter/gutter */
			SplitterWidth: number;

			/** Gets or sets the top or left panel of the splitter. */
			Panel1: Eto.Forms.Control;

			/** Gets or sets the bottom or right panel of the splitter. */
			Panel2: Eto.Forms.Control;

			/** Gets the panel used as the splitter between the two panes. */
			readonly Splitter: Eto.Forms.Panel;

			/** Gets or sets the minimal size of the first panel. */
			Panel1MinimumSize: number;

			/** Gets or sets the minimal size of the second panel. */
			Panel2MinimumSize: number;

			ClientSize: Eto.Drawing.Size;

			readonly RecurseToChildren: boolean;

			BackgroundColor: Eto.Drawing.Color;

			readonly VisualControls: Iterable<Eto.Forms.Control>;

			readonly PropagateLoadEvents: boolean;

			Size: Eto.Drawing.Size;

			Width: number;

			Height: number;

			Enabled: boolean;

			readonly HasFocus: boolean;

			Visible: boolean;

			readonly SupportedPlatformCommands: Iterable<string>;

			readonly Location: Eto.Drawing.Point;

			ToolTip: string;

			Cursor: Eto.Forms.Cursor;

			readonly ControlObject: unknown;

			TabIndex: number;

			AllowDrop: boolean;

			readonly IsMouseCaptured: boolean;

			readonly Callback: Eto.Forms.Splitter.ICallback;

			Control: Eto.Forms.TableLayout;

			readonly HasControl: boolean;

			readonly Widget: Eto.Forms.Splitter;

			ID: string;

			readonly NativeHandle: unknown;

			GetPreferredSize(availableSize: Eto.Drawing.SizeF): Eto.Drawing.SizeF;

			Invalidate(invalidateChildren: boolean): void;

			Invalidate(
				rect: Eto.Drawing.Rectangle,
				invalidateChildren: boolean,
			): void;

			SuspendLayout(): void;

			ResumeLayout(): void;

			Focus(): void;

			OnPreLoad(e: unknown): void;

			OnLoad(e: unknown): void;

			OnLoadComplete(e: unknown): void;

			OnUnLoad(e: unknown): void;

			SetParent(
				oldParent: Eto.Forms.Container,
				newParent: Eto.Forms.Container,
			): void;

			PointFromScreen(point: Eto.Drawing.PointF): Eto.Drawing.PointF;

			PointToScreen(point: Eto.Drawing.PointF): Eto.Drawing.PointF;

			MapPlatformCommand(
				systemAction: string,
				action: Eto.Forms.Command,
			): void;

			DoDragDrop(
				data: Eto.Forms.DataObject,
				allowedAction: Eto.Forms.DragEffects,
				image: Eto.Drawing.Image,
				cursorOffset: Eto.Drawing.PointF,
			): void;

			AttachEvent(id: string): void;

			GetNativeParentWindow(): Eto.Forms.Window;

			Print(): void;

			UpdateLayout(): void;

			CaptureMouse(): boolean;

			ReleaseMouseCapture(): void;

			IsEventHandled(id: string): boolean;

			HandleEvent(
				id: string,
				defaultEvent?: boolean,
			): void;

			dispose(): void;
		}
	}

	export namespace Eto.Forms.ThemedControls {
		/**
		 * Themed version of the {@link Eto.Forms.Stepper} control for platforms that have no
		 * support for such a control.
		 *
		 * Currently used for Gtk and WinForms.  Mac and Wpf Toolkit have controls that have this
		 * functionality.  To use this implementation for all platforms, add this before you
		 * start your app: Platform.Detect.Add&gt;Stepper.IHandler&lt;(() =&gt; new
		 * Eto.Forms.ThemedControls.ThemedStepperHandler());
		 */
		export class ThemedStepperHandler implements
			Eto.Widget.IHandler,
			Eto.Forms.Control.IHandler,
			Eto.Forms.Stepper.IHandler {
			/** Initializes a new instance of the ThemedStepperHandler */
			constructor();

			/** Gets or sets the text for the up/increase button */
			UpText: string;

			/** Gets or sets the text for the down/decrease button */
			DownText: string;

			/** Gets or sets the font for the text in the buttons */
			Font: Eto.Drawing.Font;

			/** Gets or sets the orientation of the stepper */
			Orientation: Eto.Forms.Orientation;

			/** Gets or sets the valid directions for the stepper */
			ValidDirection: Eto.Forms.StepperValidDirections;

			/** Gets or sets a value indicating that the control is enabled */
			Enabled: boolean;

			BackgroundColor: Eto.Drawing.Color;

			readonly VisualControls: Iterable<Eto.Forms.Control>;

			readonly PropagateLoadEvents: boolean;

			Size: Eto.Drawing.Size;

			Width: number;

			Height: number;

			readonly HasFocus: boolean;

			Visible: boolean;

			readonly SupportedPlatformCommands: Iterable<string>;

			readonly Location: Eto.Drawing.Point;

			ToolTip: string;

			Cursor: Eto.Forms.Cursor;

			readonly ControlObject: unknown;

			TabIndex: number;

			AllowDrop: boolean;

			readonly IsMouseCaptured: boolean;

			readonly Callback: Eto.Forms.Stepper.ICallback;

			Control: Eto.Forms.Panel;

			readonly HasControl: boolean;

			readonly Widget: Eto.Forms.Stepper;

			ID: string;

			readonly NativeHandle: unknown;

			/** Attaches control events */
			AttachEvent(id: string): void;

			GetPreferredSize(availableSize: Eto.Drawing.SizeF): Eto.Drawing.SizeF;

			Invalidate(invalidateChildren: boolean): void;

			Invalidate(
				rect: Eto.Drawing.Rectangle,
				invalidateChildren: boolean,
			): void;

			SuspendLayout(): void;

			ResumeLayout(): void;

			Focus(): void;

			OnPreLoad(e: unknown): void;

			OnLoad(e: unknown): void;

			OnLoadComplete(e: unknown): void;

			OnUnLoad(e: unknown): void;

			SetParent(
				oldParent: Eto.Forms.Container,
				newParent: Eto.Forms.Container,
			): void;

			PointFromScreen(point: Eto.Drawing.PointF): Eto.Drawing.PointF;

			PointToScreen(point: Eto.Drawing.PointF): Eto.Drawing.PointF;

			MapPlatformCommand(
				systemAction: string,
				action: Eto.Forms.Command,
			): void;

			DoDragDrop(
				data: Eto.Forms.DataObject,
				allowedAction: Eto.Forms.DragEffects,
				image: Eto.Drawing.Image,
				cursorOffset: Eto.Drawing.PointF,
			): void;

			GetNativeParentWindow(): Eto.Forms.Window;

			Print(): void;

			UpdateLayout(): void;

			CaptureMouse(): boolean;

			ReleaseMouseCapture(): void;

			IsEventHandled(id: string): boolean;

			HandleEvent(
				id: string,
				defaultEvent?: boolean,
			): void;

			dispose(): void;
		}
	}

	export namespace Eto.Forms.ThemedControls {
		/**
		 * Themed implementation of the {@link Eto.Forms.TextStepper} control composed of a
		 * {@link Eto.Forms.ThemedControls.ThemedTextStepperHandler.TextBox} and
		 * {@link Eto.Forms.ThemedControls.ThemedTextStepperHandler.Stepper}.
		 */
		export class ThemedTextStepperHandler implements
			Eto.Widget.IHandler,
			Eto.Forms.Control.IHandler,
			Eto.Forms.TextStepper.IHandler,
			Eto.Forms.TextBox.IHandler,
			Eto.Forms.TextControl.IHandler,
			Eto.Forms.CommonControl.IHandler {
			/**
			 * Initializes a new instance of the
			 * {@link Eto.Forms.ThemedControls.ThemedTextStepperHandler} class.
			 */
			constructor();

			/** Gets the TextBox part of the themed text stepper */
			TextBox: Eto.Forms.TextBox;

			/** Gets the Stepper part of the themed text stepper */
			Stepper: Eto.Forms.Stepper;

			/**
			 * Gets or sets the index of the current insertion point.
			 *
			 * When there is selected text, this is usually the start of the selection.
			 */
			CaretIndex: number;

			/** Gets or sets the font for the text of the control */
			Font: Eto.Drawing.Font;

			/**
			 * Gets or sets the maximum length of the text that can be entered in the control.
			 *
			 * This typically does not affect the value set using {@link Eto.Forms.TextControl.Text},
			 * only the limit of what the user can  enter into the control.
			 */
			MaxLength: number;

			/**
			 * Gets or sets the placeholder text to show as a hint of what the user should enter.
			 *
			 * Typically this will be shown when the control is blank, and will dissappear when the
			 * user enters text or if it has an existing value.
			 */
			PlaceholderText: string;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Forms.TextBox} is read only.
			 *
			 * A user can selected and copied text when the read only, however the user will not be
			 * able to change any of the text. This differs from the
			 * {@link Eto.Forms.Control.Enabled} property, which disables all user interaction.
			 */
			ReadOnly: boolean;

			/** Gets or sets the current text selection. */
			Selection: Eto.Forms.Range$1<number>;

			/**
			 * Gets or sets a value indicating whether to show the control's border.
			 *
			 * This is a hint to omit the border of the control and show it as plainly as possible.
			 * Typically used when you want to show the control within a cell of the
			 * {@link Eto.Forms.GridView}.
			 */
			ShowBorder: boolean;

			/** Gets or sets the text of the control. */
			Text: string;

			/**
			 * Gets or sets the color of the text.
			 *
			 * By default, the text will get a color based on the user's theme. However, this is
			 * usually black.
			 */
			TextColor: Eto.Drawing.Color;

			/**
			 * Gets or sets the valid directions the stepper will allow the user to click.
			 *
			 * On some platforms, the up and/or down buttons will not appear disabled, but will not
			 * trigger any events when they are  not set as a valid direction.
			 */
			ValidDirection: Eto.Forms.StepperValidDirections;

			/** Gets or sets the alignment of the text in the entry box. */
			TextAlignment: Eto.Forms.TextAlignment;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Forms.Control} is visible to
			 * the user.
			 *
			 * When the visibility of a control is set to false, it will still occupy space in the
			 * layout, but not be shown. The only exception is for controls like the
			 * {@link Eto.Forms.Splitter}, which will hide a pane if the visibility of one of the
			 * panels is changed.
			 */
			ShowStepper: boolean;

			/**
			 * Gets or sets the color for the background of the control
			 *
			 * Note that on some platforms (e.g. Mac), setting the background color of a control can
			 * change the performance characteristics of the control and its children, since it must
			 * enable layers to do so.
			 */
			BackgroundColor: Eto.Drawing.Color;

			/** Gets or sets the auto selection mode. */
			AutoSelectMode: Eto.Forms.AutoSelectMode;

			/** Gets a value indicating whether this instance has the keyboard input focus. */
			readonly HasFocus: boolean;

			readonly VisualControls: Iterable<Eto.Forms.Control>;

			readonly PropagateLoadEvents: boolean;

			Size: Eto.Drawing.Size;

			Width: number;

			Height: number;

			Enabled: boolean;

			Visible: boolean;

			readonly SupportedPlatformCommands: Iterable<string>;

			readonly Location: Eto.Drawing.Point;

			ToolTip: string;

			Cursor: Eto.Forms.Cursor;

			readonly ControlObject: unknown;

			TabIndex: number;

			AllowDrop: boolean;

			readonly IsMouseCaptured: boolean;

			readonly Callback: Eto.Forms.TextStepper.ICallback;

			Control: Eto.Forms.TableLayout;

			readonly HasControl: boolean;

			readonly Widget: Eto.Forms.TextStepper;

			ID: string;

			readonly NativeHandle: unknown;

			/**
			 * Selects all of the text in the control.
			 *
			 * When setting the selection, the control will be focussed and the associated keyboard
			 * may appear on mobile platforms.
			 */
			SelectAll(): void;

			/** Set focus to the text box */
			Focus(): void;

			/**
			 * Attaches the specified event to the platform-specific control
			 *
			 * Implementors should override this method to handle any events that the widget
			 * supports. Ensure to call the base class' implementation if the event is not one the
			 * specific widget supports, so the base class' events can be handled as well.
			 */
			AttachEvent(id: string): void;

			GetPreferredSize(availableSize: Eto.Drawing.SizeF): Eto.Drawing.SizeF;

			Invalidate(invalidateChildren: boolean): void;

			Invalidate(
				rect: Eto.Drawing.Rectangle,
				invalidateChildren: boolean,
			): void;

			SuspendLayout(): void;

			ResumeLayout(): void;

			OnPreLoad(e: unknown): void;

			OnLoad(e: unknown): void;

			OnLoadComplete(e: unknown): void;

			OnUnLoad(e: unknown): void;

			SetParent(
				oldParent: Eto.Forms.Container,
				newParent: Eto.Forms.Container,
			): void;

			PointFromScreen(point: Eto.Drawing.PointF): Eto.Drawing.PointF;

			PointToScreen(point: Eto.Drawing.PointF): Eto.Drawing.PointF;

			MapPlatformCommand(
				systemAction: string,
				action: Eto.Forms.Command,
			): void;

			DoDragDrop(
				data: Eto.Forms.DataObject,
				allowedAction: Eto.Forms.DragEffects,
				image: Eto.Drawing.Image,
				cursorOffset: Eto.Drawing.PointF,
			): void;

			GetNativeParentWindow(): Eto.Forms.Window;

			Print(): void;

			UpdateLayout(): void;

			CaptureMouse(): boolean;

			ReleaseMouseCapture(): void;

			IsEventHandled(id: string): boolean;

			HandleEvent(
				id: string,
				defaultEvent?: boolean,
			): void;

			dispose(): void;
		}
	}

	export namespace Eto.Drawing {
		/**
		 * Format of bytes used in a {@link Eto.Drawing.Bitmap}
		 *
		 * The format is important when modifying the bytes directly via
		 * {@link Eto.Drawing.Bitmap.Lock}.
		 */
		export enum PixelFormat {
			/**
			 * 32-bits (4 bytes) per pixel, ordered by an Empty byte in the highest order, followed
			 * by Red, Green, and Blue.
			 */
			Format32bppRgb = 0,

			/**
			 * 24-bits (3 bytes) per pixel, ordered by Red in the highest order, followed by Green,
			 * and Blue.
			 */
			Format24bppRgb = 1,

			/**
			 * 32-bits (4 bytes) per pixel, ordered by an Alpha byte in the highest order, followed
			 * by Red, Green, and Blue.
			 */
			Format32bppRgba = 2,
		}
	}

	export namespace Eto.Drawing {
		/**
		 * Format of the image to use when saving, loading, etc.
		 *
		 * The format is typically used only when saving via {@link Eto.Drawing.Bitmap.Save}
		 */
		export enum ImageFormat {
			/** Jpeg format */
			Jpeg = 0,

			/** Windows BMP format */
			Bitmap = 1,

			/** Tiff format */
			Tiff = 2,

			/** Portable Network Graphics format */
			Png = 3,

			/** Graphics Interchange Format */
			Gif = 4,
		}
	}

	export namespace Eto.Drawing {
		/** Represents an image */
		export class Bitmap implements
			Eto.IHandlerSource {
			/** Initializes a new instance of a Bitmap from a file */
			constructor(fileName: string);

			/** Initializes a new instance of a Bitmap from a stream */
			constructor(stream: Duplex);

			/** Initializes a new instance of a Bitmap with the specified size and format */
			constructor(
				size: Eto.Drawing.Size,
				pixelFormat: Eto.Drawing.PixelFormat,
			);

			/** Initializes a new instance of a Bitmap with the specified size and format */
			constructor(
				width: number,
				height: number,
				pixelFormat: Eto.Drawing.PixelFormat,
			);

			/** Creates a new bitmap optimized for drawing on the specified `graphics` */
			constructor(
				width: number,
				height: number,
				graphics: Eto.Drawing.Graphics,
			);

			/** Create a new scaled bitmap with the specified `width` and `height` */
			constructor(
				image: Eto.Drawing.Image,
				width?: number,
				height?: number,
				interpolation?: Eto.Drawing.ImageInterpolation,
			);

			/** Creates a new bitmap with the specified dimensions, format and pixel data */
			constructor(
				width: number,
				height: number,
				pixelFormat: Eto.Drawing.PixelFormat,
				data: Iterable<Eto.Drawing.Color>,
			);

			/** Creates a new bitmap with the specified dimensions, format, and integer pixel data */
			constructor(
				width: number,
				height: number,
				pixelFormat: Eto.Drawing.PixelFormat,
				data: Iterable<number>,
			);

			/** Initializes a new instance of a Bitmap from a `bytes` array */
			constructor(bytes: number[]);

			constructor(handler: Eto.Drawing.Bitmap.IHandler);

			/** Gets the size of the image, in pixels */
			readonly Size: Eto.Drawing.Size;

			/**
			 * Gets the width of the image, in pixels.
			 *
			 * Use {@link Eto.Drawing.Image.Size} if you wish to get the width and height at the same
			 * time.
			 */
			readonly Width: number;

			/**
			 * Gets the height of the image, in pixels.
			 *
			 * Use {@link Eto.Drawing.Image.Size} if you wish to get the width and height at the same
			 * time.
			 */
			readonly Height: number;

			/**
			 * Gets the platform that was used to create the {@link Eto.Widget.Handler} for this
			 * widget
			 *
			 * This gets set to the current {@link Eto.Platform.Instance} during the construction of
			 * the object
			 */
			readonly Platform: Eto.Platform;

			/** Gets the platform-specific handler for this widget */
			Handler: unknown;

			/** Gets the native platform-specific handle for integration purposes */
			readonly NativeHandle: unknown;

			/** Gets the dictionary of properties for this widget */
			readonly Properties: Eto.PropertyStore;

			/** Gets or sets the ID of this widget */
			ID: string;

			/**
			 * Gets or sets the style of this widget
			 *
			 * Styles allow you to attach custom platform-specific logic to a widget. In your
			 * platform-specific assembly, use {@link Style.Add{H}(string, StyleHandler{H})} to add
			 * the style logic with the same id.
			 */
			Style: string;

			/**
			 * Gets the instance of the platform-specific object
			 *
			 * This can sometimes be useful to get the platform-specific object. Some handlers may
			 * not have any backing object for its functionality, so this may be null.  It is more
			 * preferred to use the {@link Eto.Widget.Handler} and cast that to the platform-specific
			 * handler class which can give you additional methods and helpers to do common tasks.
			 * For example, the {@link Eto.Forms.Application} object's handler for OS X has a
			 * AddFullScreenMenuItem property to specify if you want full screen support in your app.
			 */
			readonly ControlObject: unknown;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Widget} has been disposed.
			 *
			 * When the widget is disposed, it can no longer be used.
			 */
			IsDisposed: boolean;

			/** Loads a bitmap from the resource in the specified or caller's assembly */
			static FromResource(
				resourceName: string,
				assembly?: unknown,
			): Eto.Drawing.Bitmap;

			/** Loads a bitmap from a resource in the same assembly as the specified `type` */
			static FromResource(
				resourceName: string,
				type: unknown,
			): Eto.Drawing.Bitmap;

			/**
			 * Locks the data of the image to directly access the bytes of the image
			 *
			 * This locks the data to read and write to directly using unsafe pointers. After reading
			 * or updating the data, you must call {@link Eto.Drawing.BitmapData.Dispose} to unlock
			 * the data before using the bitmap. e.g.: using (var bd = bitmap.Lock ()) { 	byte* pdata
			 * = bd.Data; 	// access data }
			 */
			Lock(): Eto.Drawing.BitmapData;

			/** Saves the bitmap to a file in the specified format */
			Save(
				fileName: string,
				format: Eto.Drawing.ImageFormat,
			): void;

			/** Saves the bitmap to a stream in the specified format */
			Save(
				stream: Duplex,
				format: Eto.Drawing.ImageFormat,
			): void;

			/**
			 * Saves the bitmap to an image of the specified `imageFormat` into a byte array
			 *
			 * This is merely a helper to save to a byte array instead of a stream.
			 */
			ToByteArray(imageFormat: Eto.Drawing.ImageFormat): number[];

			/** Creates a clone of the bitmap */
			Clone(rectangle?: Eto.Drawing.Rectangle): Eto.Drawing.Bitmap;

			/**
			 * Gets the color of the pixel at the specified `position`
			 *
			 * Note that this method can be extremely slow to go through each pixel of a bitmap. If
			 * you need better performance, use {@link Eto.Drawing.Bitmap.Lock} to get access to the
			 * bitmap's pixel buffer directly,  then optionally use
			 * {@link Eto.Drawing.BitmapData.GetPixel(Eto.Drawing.Point)} to get each pixel value.
			 */
			GetPixel(position: Eto.Drawing.Point): Eto.Drawing.Color;

			/**
			 * Gets the color of the pixel at the specified coordinates.
			 *
			 * Note that this method can be extremely slow to go through each pixel of a bitmap. If
			 * you need better performance, use {@link Eto.Drawing.Bitmap.Lock} to get access to the
			 * bitmap's pixel buffer directly,  then optionally use
			 * {@link Eto.Drawing.BitmapData.GetPixel(System.Int32,System.Int32)} to get each pixel
			 * value.
			 */
			GetPixel(
				x: number,
				y: number,
			): Eto.Drawing.Color;

			/**
			 * Sets the pixel color at the specified `position`.
			 *
			 * Note that this method can be extremely slow to set each pixel of a bitmap. If you need
			 * better performance, use {@link Eto.Drawing.Bitmap.Lock} to get access to the bitmap's
			 * pixel buffer directly,  then optionally use
			 * {@link Eto.Drawing.BitmapData.SetPixel(Eto.Drawing.Point,Eto.Drawing.Color)} to set
			 * each pixel value.
			 */
			SetPixel(
				position: Eto.Drawing.Point,
				color: Eto.Drawing.Color,
			): void;

			/**
			 * Sets the color of the pixel at the specified coordinates.
			 *
			 * Note that this method can be extremely slow to set each pixel of a bitmap. If you need
			 * better performance, use {@link Eto.Drawing.Bitmap.Lock} to get access to the bitmap's
			 * pixel buffer directly,  then optionally use
			 * {@link Eto.Drawing.BitmapData.SetPixel(System.Int32,System.Int32,Eto.Drawing.Color)}
			 * to set each pixel value.
			 */
			SetPixel(
				x: number,
				y: number,
				color: Eto.Drawing.Color,
			): void;

			/**
			 * Gets an Icon representation of this Bitmap scaled to draw within the specified fitting
			 * size.
			 *
			 * This is useful when you want to draw the image at a different size than the default
			 * size without resizing the image. Note that the `width` and `height` specifies the
			 * maxiumum drawing size of the Icon, but will not change the aspect of each frame's
			 * bitmap.  For example, if an existing frame is 128x128, and you specify 16x32, then the
			 * resulting frame will draw at 16x16.
			 */
			WithSize(
				width: number,
				height: number,
			): Eto.Drawing.Icon;

			/**
			 * Gets an Icon representation of this Bitmap scaled to draw within the specified fitting
			 * size.
			 *
			 * This is useful when you want to draw the image at a different size than the default
			 * size without resizing the image. Note that the `fittingSize` specifies the maxiumum
			 * drawing size of the Icon, but will not change the aspect of each frame's bitmap.  For
			 * example, if an existing frame is 128x128, and you specify 16x32, then the resulting
			 * frame will draw at 16x16.
			 */
			WithSize(fittingSize: Eto.Drawing.Size): Eto.Drawing.Icon;

			/** Disposes of this widget, supressing the finalizer */
			dispose(): void;

			/** Gets a string that represents the current object with its ID if specified. */
			ToString(): string;
		}
	}

	export namespace Eto.Drawing.Bitmap {
		export interface IHandler extends
			Eto.Drawing.Image.IHandler,
			Eto.Widget.IHandler,
			Eto.Drawing.ILockableImage {
			Create(fileName: string): void;

			Create(stream: Duplex): void;

			Create(
				width: number,
				height: number,
				pixelFormat: Eto.Drawing.PixelFormat,
			): void;

			Create(
				width: number,
				height: number,
				graphics: Eto.Drawing.Graphics,
			): void;

			Create(
				image: Eto.Drawing.Image,
				width: number,
				height: number,
				interpolation: Eto.Drawing.ImageInterpolation,
			): void;

			Save(
				stream: Duplex,
				format: Eto.Drawing.ImageFormat,
			): void;

			Save(
				fileName: string,
				format: Eto.Drawing.ImageFormat,
			): void;

			Clone(rectangle?: Eto.Drawing.Rectangle): Eto.Drawing.Bitmap;

			GetPixel(
				x: number,
				y: number,
			): Eto.Drawing.Color;
		}
	}

	export namespace Eto.Drawing {
		/**
		 * Bitmap data information when accessing a {@link Eto.Drawing.Bitmap} 's data directly
		 *
		 * The bitmap data is accessed through {@link Eto.Drawing.Bitmap.Lock}, which locks the
		 * data for direct access using the {@link Eto.Drawing.BitmapData.Data} pointer.  Ensure
		 * you call dispose the instance when you are done accessing or writing the data,
		 * otherwise the bitmap may be left in an unusable state.
		 */
		export class BitmapData {
			/** Gets the image this data is for */
			readonly Image: Eto.Drawing.Image;

			/** Gets the bits per pixel */
			readonly BitsPerPixel: number;

			/** Gets the bytes per pixel */
			readonly BytesPerPixel: number;

			/**
			 * Gets the pointer to the data of the bitmap
			 *
			 * This does not include any headers, etc. so it directly points to the beginning of the
			 * data.  Each row may not be on a pixel boundary, so to increment to the next row, use
			 * the {@link Eto.Drawing.BitmapData.ScanWidth} to increment the pointer to the next row.
			 */
			readonly Data: unknown;

			/**
			 * Gets a value indicating that the data is flipped (upside down)
			 *
			 * Some platforms may handle memory bitmaps in a flipped fashion, such that the top of
			 * the image is at the bottom of the data.  If this is true, then the starting row of the
			 * data is the bottom row of the image.
			 */
			readonly Flipped: boolean;

			/**
			 * Gets the width (in bytes) of each scan line (row) of pixel data
			 *
			 * When advancing to the next row, use this to increment the pointer.  The number of
			 * bytes for each row might not be equivalent to the bytes per pixel multiplied by the
			 * width of the image.
			 */
			readonly ScanWidth: number;

			/** Gets the platform-specific control object for the bitmap data */
			readonly ControlObject: unknown;

			/**
			 * Gets a value indicating the RGB components are premultiplied with the alpha component
			 *
			 * Note that the {@link Eto.Drawing.BitmapData.TranslateDataToArgb(System.Int32)} and
			 * {@link Eto.Drawing.BitmapData.TranslateArgbToData(System.Int32)} take this into
			 * account when translating data. Otherwise, you can use this value do determine how to
			 * do your own translation.
			 */
			readonly PremultipliedAlpha: boolean;

			/**
			 * Translates a 32-bit ARGB value to the platform specific pixel format value
			 *
			 * Use this method to translate an ARGB (Alpha in most significant) to the value required
			 * by the bitmap for the pixel.  Each platform can have a different pixel format, and
			 * this allows you to abstract  setting the data directly.  The ARGB value can be easily
			 * retrieved using {@link Eto.Drawing.Color.ToArgb}.  For non-alpha bitmaps, the alpha
			 * component will be ignored
			 */
			TranslateArgbToData(argb: number): number;

			/**
			 * Translates the platform specific pixel format to a 32-bit ARGB value
			 *
			 * Use this method to translate an value from the bitmap data to a 32-bit ARGB (Alpha in
			 * most significant byte).  Each platform can have a different pixel format, and this
			 * allows you to abstract  getting the data into a 32-bit colour.  The ARGB value can be
			 * easily handled using {@link Eto.Drawing.Color(uint)}.  For non-alpha bitmaps, the
			 * alpha component will be ignored
			 */
			TranslateDataToArgb(bitmapData: number): number;

			/** Gets the color of the pixel at the specified `position` */
			GetPixel(position: Eto.Drawing.Point): Eto.Drawing.Color;

			/** Gets the color of the pixel at the specified coordinates. */
			GetPixel(
				x: number,
				y: number,
			): Eto.Drawing.Color;

			/** Sets the pixel color at the specified `position`. */
			SetPixel(
				position: Eto.Drawing.Point,
				color: Eto.Drawing.Color,
			): void;

			/** Sets the pixel color at the specified coordinates. */
			SetPixel(
				x: number,
				y: number,
				color: Eto.Drawing.Color,
			): void;

			/**
			 * Releases all resource used by the {@link Eto.Drawing.BitmapData} object.
			 *
			 * Call {@link Eto.Drawing.BitmapData.Dispose} when you are finished using the
			 * {@link Eto.Drawing.BitmapData}. The {@link Eto.Drawing.BitmapData.Dispose} method
			 * leaves the {@link Eto.Drawing.BitmapData} in an unusable state. After calling
			 * {@link Eto.Drawing.BitmapData.Dispose}, you must release all references to the
			 * {@link Eto.Drawing.BitmapData} so the garbage collector can reclaim the memory that
			 * the {@link Eto.Drawing.BitmapData} was occupying.
			 */
			dispose(): void;

			/**
			 * Gets an enumerable of pixels for each scan line from top to bottom.
			 *
			 * You can use this to translate the pixel data into an array, e.g. int[] argbData =
			 * bitmapData.GetPixels().Select(p =&gt; p.ToArgb()).ToArray();
			 */
			GetPixels(): Iterable<Eto.Drawing.Color>;

			/**
			 * Use this to set the pixels of the bitmap from an array or other source.
			 *
			 * For example, you can use this to set the pixel data from an int array like so: int[]
			 * myData; bitmapData.SetPixels(myData.Select(Color.FromArgb)); This will set all the
			 * pixels up till the end of the enumeration.   If there isn't enough data to fill the
			 * bitmap entirely, it will not set any additional pixels.
			 */
			SetPixels(pixels: Iterable<Eto.Drawing.Color>): void;
		}
	}

	export namespace Eto.Drawing {
		/**
		 * Base brush class to use when calling fill methods of a {@link Eto.Drawing.Graphics}
		 * object
		 */
		export class Brush implements
			Eto.IHandlerSource,
			Eto.IControlObjectSource {
			/** Gets or sets the control object for this widget */
			ControlObject: unknown;

			/** Gets the platform handler object for the widget */
			readonly Handler: unknown;

			/**
			 * Releases all resource used by the {@link Eto.Drawing.Brush} object.
			 *
			 * Call {@link Eto.Drawing.Brush.Dispose} when you are finished using the
			 * {@link Eto.Drawing.Brush}. The {@link Eto.Drawing.Brush.Dispose} method leaves the
			 * {@link Eto.Drawing.Brush} in an unusable state. After calling
			 * {@link Eto.Drawing.Brush.Dispose}, you must release all references to the
			 * {@link Eto.Drawing.Brush} so the garbage collector can reclaim the memory that the
			 * {@link Eto.Drawing.Brush} was occupying.
			 */
			dispose(): void;
		}
	}

	export namespace Eto.Drawing.Brush {
		export interface IHandler {
		}
	}

	export namespace Eto.Drawing {
		/** List of brushes with common colors and brush cache for solid color brushes */
		export namespace Brushes {
			/** Gets a solid brush with an ARGB value of #00000000 */
			export const Transparent: Eto.Drawing.SolidBrush;

			/** Gets a solid brush with a color ARGB value of #FFCD5C5C */
			export const IndianRed: Eto.Drawing.SolidBrush;

			/** Gets a solid brush with a color ARGB value of #FFF08080 */
			export const LightCoral: Eto.Drawing.SolidBrush;

			/** Gets a solid brush with a color ARGB value of #FFFA8072 */
			export const Salmon: Eto.Drawing.SolidBrush;

			/** Gets a solid brush with a color ARGB value of #FFE9967A */
			export const DarkSalmon: Eto.Drawing.SolidBrush;

			/** Gets a solid brush with a color ARGB value of #FFFFA07A */
			export const LightSalmon: Eto.Drawing.SolidBrush;

			/** Gets a solid brush with a color ARGB value of #FFFF0000 */
			export const Red: Eto.Drawing.SolidBrush;

			/** Gets a solid brush with a color ARGB value of #FFDC143C */
			export const Crimson: Eto.Drawing.SolidBrush;

			/** Gets a solid brush with a color ARGB value of #FFB22222 */
			export const Firebrick: Eto.Drawing.SolidBrush;

			/** Gets a solid brush with a color ARGB value of #FF8B0000 */
			export const DarkRed: Eto.Drawing.SolidBrush;

			/** Gets a solid brush with a color ARGB value of #FFFFC0CB */
			export const Pink: Eto.Drawing.SolidBrush;

			/** Gets a solid brush with a color ARGB value of #FFFFB6C1 */
			export const LightPink: Eto.Drawing.SolidBrush;

			/** Gets a solid brush with a color ARGB value of #FFFF69B4 */
			export const HotPink: Eto.Drawing.SolidBrush;

			/** Gets a solid brush with a color ARGB value of #FFFF1493 */
			export const DeepPink: Eto.Drawing.SolidBrush;

			/** Gets a solid brush with a color ARGB value of #FFC71585 */
			export const MediumVioletRed: Eto.Drawing.SolidBrush;

			/** Gets a solid brush with a color ARGB value of #FFDB7093 */
			export const PaleVioletRed: Eto.Drawing.SolidBrush;

			/** Gets a solid brush with a color ARGB value of #FFFF7F50 */
			export const Coral: Eto.Drawing.SolidBrush;

			/** Gets a solid brush with a color ARGB value of #FFFF6347 */
			export const Tomato: Eto.Drawing.SolidBrush;

			/** Gets a solid brush with a color ARGB value of #FFFF4500 */
			export const OrangeRed: Eto.Drawing.SolidBrush;

			/** Gets a solid brush with a color ARGB value of #FFFF8C00 */
			export const DarkOrange: Eto.Drawing.SolidBrush;

			/** Gets a solid brush with a color ARGB value of #FFFFA500 */
			export const Orange: Eto.Drawing.SolidBrush;

			/** Gets a solid brush with a color ARGB value of #FFFFD700 */
			export const Gold: Eto.Drawing.SolidBrush;

			/** Gets a solid brush with a color ARGB value of #FFFFFF00 */
			export const Yellow: Eto.Drawing.SolidBrush;

			/** Gets a solid brush with a color ARGB value of #FFFFFFE0 */
			export const LightYellow: Eto.Drawing.SolidBrush;

			/** Gets a solid brush with a color ARGB value of #FFFFFACD */
			export const LemonChiffon: Eto.Drawing.SolidBrush;

			/** Gets a solid brush with a color ARGB value of #FFFAFAD2 */
			export const LightGoldenrodYellow: Eto.Drawing.SolidBrush;

			/** Gets a solid brush with a color ARGB value of #FFFFEFD5 */
			export const PapayaWhip: Eto.Drawing.SolidBrush;

			/** Gets a solid brush with a color ARGB value of #FFFFE4B5 */
			export const Moccasin: Eto.Drawing.SolidBrush;

			/** Gets a solid brush with a color ARGB value of #FFFFDAB9 */
			export const PeachPuff: Eto.Drawing.SolidBrush;

			/** Gets a solid brush with a color ARGB value of #FFEEE8AA */
			export const PaleGoldenrod: Eto.Drawing.SolidBrush;

			/** Gets a solid brush with a color ARGB value of #FFF0E68C */
			export const Khaki: Eto.Drawing.SolidBrush;

			/** Gets a solid brush with a color ARGB value of #FFBDB76B */
			export const DarkKhaki: Eto.Drawing.SolidBrush;

			/** Gets a solid brush with a color ARGB value of #FFE6E6FA */
			export const Lavender: Eto.Drawing.SolidBrush;

			/** Gets a solid brush with a color ARGB value of #FFD8BFD8 */
			export const Thistle: Eto.Drawing.SolidBrush;

			/** Gets a solid brush with a color ARGB value of #FFDDA0DD */
			export const Plum: Eto.Drawing.SolidBrush;

			/** Gets a solid brush with a color ARGB value of #FFEE82EE */
			export const Violet: Eto.Drawing.SolidBrush;

			/** Gets a solid brush with a color ARGB value of #FFDA70D6 */
			export const Orchid: Eto.Drawing.SolidBrush;

			/** Gets a solid brush with a color ARGB value of #FFFF00FF */
			export const Fuchsia: Eto.Drawing.SolidBrush;

			/** Gets a solid brush with a color ARGB value of #FFFF00FF */
			export const Magenta: Eto.Drawing.SolidBrush;

			/** Gets a solid brush with a color ARGB value of #FFBA55D3 */
			export const MediumOrchid: Eto.Drawing.SolidBrush;

			/** Gets a solid brush with a color ARGB value of #FF9370DB */
			export const MediumPurple: Eto.Drawing.SolidBrush;

			/** Gets a solid brush with a color ARGB value of #FF8A2BE2 */
			export const BlueViolet: Eto.Drawing.SolidBrush;

			/** Gets a solid brush with a color ARGB value of #FF9400D3 */
			export const DarkViolet: Eto.Drawing.SolidBrush;

			/** Gets a solid brush with a color ARGB value of #FF9932CC */
			export const DarkOrchid: Eto.Drawing.SolidBrush;

			/** Gets a solid brush with a color ARGB value of #FF8B008B */
			export const DarkMagenta: Eto.Drawing.SolidBrush;

			/** Gets a solid brush with a color ARGB value of #FF800080 */
			export const Purple: Eto.Drawing.SolidBrush;

			/** Gets a solid brush with a color ARGB value of #FF4B0082 */
			export const Indigo: Eto.Drawing.SolidBrush;

			/** Gets a solid brush with a color ARGB value of #FF483D8B */
			export const DarkSlateBlue: Eto.Drawing.SolidBrush;

			/** Gets a solid brush with a color ARGB value of #FF6A5ACD */
			export const SlateBlue: Eto.Drawing.SolidBrush;

			/** Gets a solid brush with a color ARGB value of #FF7B68EE */
			export const MediumSlateBlue: Eto.Drawing.SolidBrush;

			/** Gets a solid brush with a color ARGB value of #FFADFF2F */
			export const GreenYellow: Eto.Drawing.SolidBrush;

			/** Gets a solid brush with a color ARGB value of #FF7FFF00 */
			export const Chartreuse: Eto.Drawing.SolidBrush;

			/** Gets a solid brush with a color ARGB value of #FF7CFC00 */
			export const LawnGreen: Eto.Drawing.SolidBrush;

			/** Gets a solid brush with a color ARGB value of #FF00FF00 */
			export const Lime: Eto.Drawing.SolidBrush;

			/** Gets a solid brush with a color ARGB value of #FF32CD32 */
			export const LimeGreen: Eto.Drawing.SolidBrush;

			/** Gets a solid brush with a color ARGB value of #FF98FB98 */
			export const PaleGreen: Eto.Drawing.SolidBrush;

			/** Gets a solid brush with a color ARGB value of #FF90EE90 */
			export const LightGreen: Eto.Drawing.SolidBrush;

			/** Gets a solid brush with a color ARGB value of #FF00FA9A */
			export const MediumSpringGreen: Eto.Drawing.SolidBrush;

			/** Gets a solid brush with a color ARGB value of #FF00FF7F */
			export const SpringGreen: Eto.Drawing.SolidBrush;

			/** Gets a solid brush with a color ARGB value of #FF3CB371 */
			export const MediumSeaGreen: Eto.Drawing.SolidBrush;

			/** Gets a solid brush with a color ARGB value of #FF2E8B57 */
			export const SeaGreen: Eto.Drawing.SolidBrush;

			/** Gets a solid brush with a color ARGB value of #FF228B22 */
			export const ForestGreen: Eto.Drawing.SolidBrush;

			/** Gets a solid brush with a color ARGB value of #FF008000 */
			export const Green: Eto.Drawing.SolidBrush;

			/** Gets a solid brush with a color ARGB value of #FF006400 */
			export const DarkGreen: Eto.Drawing.SolidBrush;

			/** Gets a solid brush with a color ARGB value of #FF9ACD32 */
			export const YellowGreen: Eto.Drawing.SolidBrush;

			/** Gets a solid brush with a color ARGB value of #FF6B8E23 */
			export const OliveDrab: Eto.Drawing.SolidBrush;

			/** Gets a solid brush with a color ARGB value of #FF808000 */
			export const Olive: Eto.Drawing.SolidBrush;

			/** Gets a solid brush with a color ARGB value of #FF556B2F */
			export const DarkOliveGreen: Eto.Drawing.SolidBrush;

			/** Gets a solid brush with a color ARGB value of #FF66CDAA */
			export const MediumAquamarine: Eto.Drawing.SolidBrush;

			/** Gets a solid brush with a color ARGB value of #FF8FBC8F */
			export const DarkSeaGreen: Eto.Drawing.SolidBrush;

			/** Gets a solid brush with a color ARGB value of #FF20B2AA */
			export const LightSeaGreen: Eto.Drawing.SolidBrush;

			/** Gets a solid brush with a color ARGB value of #FF008B8B */
			export const DarkCyan: Eto.Drawing.SolidBrush;

			/** Gets a solid brush with a color ARGB value of #FF008080 */
			export const Teal: Eto.Drawing.SolidBrush;

			/** Gets a solid brush with a color ARGB value of #FF00FFFF */
			export const Aqua: Eto.Drawing.SolidBrush;

			/** Gets a solid brush with a color ARGB value of #FF00FFFF */
			export const Cyan: Eto.Drawing.SolidBrush;

			/** Gets a solid brush with a color ARGB value of #FFE0FFFF */
			export const LightCyan: Eto.Drawing.SolidBrush;

			/** Gets a solid brush with a color ARGB value of #FFAFEEEE */
			export const PaleTurquoise: Eto.Drawing.SolidBrush;

			/** Gets a solid brush with a color ARGB value of #FF7FFFD4 */
			export const Aquamarine: Eto.Drawing.SolidBrush;

			/** Gets a solid brush with a color ARGB value of #FF40E0D0 */
			export const Turquoise: Eto.Drawing.SolidBrush;

			/** Gets a solid brush with a color ARGB value of #FF48D1CC */
			export const MediumTurquoise: Eto.Drawing.SolidBrush;

			/** Gets a solid brush with a color ARGB value of #FF00CED1 */
			export const DarkTurquoise: Eto.Drawing.SolidBrush;

			/** Gets a solid brush with a color ARGB value of #FF5F9EA0 */
			export const CadetBlue: Eto.Drawing.SolidBrush;

			/** Gets a solid brush with a color ARGB value of #FF4682B4 */
			export const SteelBlue: Eto.Drawing.SolidBrush;

			/** Gets a solid brush with a color ARGB value of #FFB0C4DE */
			export const LightSteelBlue: Eto.Drawing.SolidBrush;

			/** Gets a solid brush with a color ARGB value of #FFB0E0E6 */
			export const PowderBlue: Eto.Drawing.SolidBrush;

			/** Gets a solid brush with a color ARGB value of #FFADD8E6 */
			export const LightBlue: Eto.Drawing.SolidBrush;

			/** Gets a solid brush with a color ARGB value of #FF87CEEB */
			export const SkyBlue: Eto.Drawing.SolidBrush;

			/** Gets a solid brush with a color ARGB value of #FF87CEFA */
			export const LightSkyBlue: Eto.Drawing.SolidBrush;

			/** Gets a solid brush with a color ARGB value of #FF00BFFF */
			export const DeepSkyBlue: Eto.Drawing.SolidBrush;

			/** Gets a solid brush with a color ARGB value of #FF1E90FF */
			export const DodgerBlue: Eto.Drawing.SolidBrush;

			/** Gets a solid brush with a color ARGB value of #FF6495ED */
			export const CornflowerBlue: Eto.Drawing.SolidBrush;

			/** Gets a solid brush with a color ARGB value of #FF4169E1 */
			export const RoyalBlue: Eto.Drawing.SolidBrush;

			/** Gets a solid brush with a color ARGB value of #FF0000FF */
			export const Blue: Eto.Drawing.SolidBrush;

			/** Gets a solid brush with a color ARGB value of #FF0000CD */
			export const MediumBlue: Eto.Drawing.SolidBrush;

			/** Gets a solid brush with a color ARGB value of #FF00008B */
			export const DarkBlue: Eto.Drawing.SolidBrush;

			/** Gets a solid brush with a color ARGB value of #FF000080 */
			export const Navy: Eto.Drawing.SolidBrush;

			/** Gets a solid brush with a color ARGB value of #FF191970 */
			export const MidnightBlue: Eto.Drawing.SolidBrush;

			/** Gets a solid brush with a color ARGB value of #FFFFF8DC */
			export const Cornsilk: Eto.Drawing.SolidBrush;

			/** Gets a solid brush with a color ARGB value of #FFFFEBCD */
			export const BlanchedAlmond: Eto.Drawing.SolidBrush;

			/** Gets a solid brush with a color ARGB value of #FFFFE4C4 */
			export const Bisque: Eto.Drawing.SolidBrush;

			/** Gets a solid brush with a color ARGB value of #FFFFDEAD */
			export const NavajoWhite: Eto.Drawing.SolidBrush;

			/** Gets a solid brush with a color ARGB value of #FFF5DEB3 */
			export const Wheat: Eto.Drawing.SolidBrush;

			/** Gets a solid brush with a color ARGB value of #FFDEB887 */
			export const BurlyWood: Eto.Drawing.SolidBrush;

			/** Gets a solid brush with a color ARGB value of #FFD2B48C */
			export const Tan: Eto.Drawing.SolidBrush;

			/** Gets a solid brush with a color ARGB value of #FFBC8F8F */
			export const RosyBrown: Eto.Drawing.SolidBrush;

			/** Gets a solid brush with a color ARGB value of #FFF4A460 */
			export const SandyBrown: Eto.Drawing.SolidBrush;

			/** Gets a solid brush with a color ARGB value of #FFDAA520 */
			export const Goldenrod: Eto.Drawing.SolidBrush;

			/** Gets a solid brush with a color ARGB value of #FFB8860B */
			export const DarkGoldenrod: Eto.Drawing.SolidBrush;

			/** Gets a solid brush with a color ARGB value of #FFCD853F */
			export const Peru: Eto.Drawing.SolidBrush;

			/** Gets a solid brush with a color ARGB value of #FFD2691E */
			export const Chocolate: Eto.Drawing.SolidBrush;

			/** Gets a solid brush with a color ARGB value of #FF8B4513 */
			export const SaddleBrown: Eto.Drawing.SolidBrush;

			/** Gets a solid brush with a color ARGB value of #FFA0522D */
			export const Sienna: Eto.Drawing.SolidBrush;

			/** Gets a solid brush with a color ARGB value of #FFA52A2A */
			export const Brown: Eto.Drawing.SolidBrush;

			/** Gets a solid brush with a color ARGB value of #FF800000 */
			export const Maroon: Eto.Drawing.SolidBrush;

			/** Gets a solid brush with a color ARGB value of #FFFFFFFF */
			export const White: Eto.Drawing.SolidBrush;

			/** Gets a solid brush with a color ARGB value of #FFFFFAFA */
			export const Snow: Eto.Drawing.SolidBrush;

			/** Gets a solid brush with a color ARGB value of #FFF0FFF0 */
			export const Honeydew: Eto.Drawing.SolidBrush;

			/** Gets a solid brush with a color ARGB value of #FFF5FFFA */
			export const MintCream: Eto.Drawing.SolidBrush;

			/** Gets a solid brush with a color ARGB value of #FFF0FFFF */
			export const Azure: Eto.Drawing.SolidBrush;

			/** Gets a solid brush with a color ARGB value of #FFF0F8FF */
			export const AliceBlue: Eto.Drawing.SolidBrush;

			/** Gets a solid brush with a color ARGB value of #FFF8F8FF */
			export const GhostWhite: Eto.Drawing.SolidBrush;

			/** Gets a solid brush with a color ARGB value of #FFF5F5F5 */
			export const WhiteSmoke: Eto.Drawing.SolidBrush;

			/** Gets a solid brush with a color ARGB value of #FFFFF5EE */
			export const Seashell: Eto.Drawing.SolidBrush;

			/** Gets a solid brush with a color ARGB value of #FFF5F5DC */
			export const Beige: Eto.Drawing.SolidBrush;

			/** Gets a solid brush with a color ARGB value of #FFFDF5E6 */
			export const OldLace: Eto.Drawing.SolidBrush;

			/** Gets a solid brush with a color ARGB value of #FFFFFAF0 */
			export const FloralWhite: Eto.Drawing.SolidBrush;

			/** Gets a solid brush with a color ARGB value of #FFFFFFF0 */
			export const Ivory: Eto.Drawing.SolidBrush;

			/** Gets a solid brush with a color ARGB value of #FFFAEBD7 */
			export const AntiqueWhite: Eto.Drawing.SolidBrush;

			/** Gets a solid brush with a color ARGB value of #FFFAF0E6 */
			export const Linen: Eto.Drawing.SolidBrush;

			/** Gets a solid brush with a color ARGB value of #FFFFF0F5 */
			export const LavenderBlush: Eto.Drawing.SolidBrush;

			/** Gets a solid brush with a color ARGB value of #FFFFE4E1 */
			export const MistyRose: Eto.Drawing.SolidBrush;

			/** Gets a solid brush with a color ARGB value of #FFDCDCDC */
			export const Gainsboro: Eto.Drawing.SolidBrush;

			/** Gets a solid brush with a color ARGB value of #FFD3D3D3 */
			export const LightGrey: Eto.Drawing.SolidBrush;

			/** Gets a solid brush with a color ARGB value of #FFC0C0C0 */
			export const Silver: Eto.Drawing.SolidBrush;

			/** Gets a solid brush with a color ARGB value of #FFA9A9A9 */
			export const DarkGray: Eto.Drawing.SolidBrush;

			/** Gets a solid brush with a color ARGB value of #FF808080 */
			export const Gray: Eto.Drawing.SolidBrush;

			/** Gets a solid brush with a color ARGB value of #FF696969 */
			export const DimGray: Eto.Drawing.SolidBrush;

			/** Gets a solid brush with a color ARGB value of #FF778899 */
			export const LightSlateGray: Eto.Drawing.SolidBrush;

			/** Gets a solid brush with a color ARGB value of #FF708090 */
			export const SlateGray: Eto.Drawing.SolidBrush;

			/** Gets a solid brush with a color ARGB value of #FF2F4F4F */
			export const DarkSlateGray: Eto.Drawing.SolidBrush;

			/** Gets a solid brush with a color ARGB value of #FF000000 */
			export const Black: Eto.Drawing.SolidBrush;

			/** Gets a cached solid brush with the specified color */
			export function Cached(color: Eto.Drawing.Color): Eto.Drawing.SolidBrush;

			/**
			 * Clears the brush cache
			 *
			 * This is useful if you are using the
			 * {@link Eto.Drawing.Brushes.Cached(Eto.Drawing.Color)} method to cache brushes and want
			 * to clear it to conserve memory or resources.
			 */
			export function ClearCache(): void;
		}
	}

	export namespace Eto.Drawing {
		/** Color styles when parsing or converting the Color struct */
		export enum ColorStyles {
			/** Default style for Eto */
			None = 0,

			/**
			 * Exclude the alpha component when parsing or when converting to hex, omit alpha if
			 * possible (it equals 1.0 / 255)
			 */
			ExcludeAlpha = 1,

			/**
			 * Specifies that the alpha component comes last when in hex (compatible with CSS
			 * format), otherwise alpha is first
			 */
			AlphaLast = 4,

			/**
			 * Use short hex version, if possible.
			 *
			 * This is only used when converting to hex, and only if all component values support the
			 * short version
			 */
			ShortHex = 8,

			/** All color styles */
			All = 13,
		}
	}

	export namespace Eto.Drawing {
		/** Represents a color with RGBA (Red, Green, Blue, and Alpha) components */
		export class Color implements Eto.IControlObjectSource {
			/**
			 * Initializes a new instance of the Color object with the specified red, green, blue,
			 * and alpha components
			 */
			constructor(
				red: number,
				green: number,
				blue: number,
				alpha?: number,
			);

			/** Initializes a new instance of the Color object as a copy of the specified `color` */
			constructor(
				color: Eto.Drawing.Color,
				alpha?: number,
			);

			/**
			 * Initializes a new instance of the {@link Eto.Drawing.Color} struct with the specified
			 * native control object.
			 *
			 * Some platforms (e.g. macOS) have system color objects that change their RGB value
			 * automatically based on the display mode, such as light &amp; dark.
			 */
			constructor(
				controlObject: unknown,
				red: number,
				green: number,
				blue: number,
				alpha: number,
			);

			/** Gets or sets the alpha/opacity (0-1) */
			A: number;

			/** Gets or sets the red component (0-1) */
			R: number;

			/** Gets or sets the green (0-1) */
			G: number;

			/** Gets or sets the blue (0-1) */
			B: number;

			/** Gets or sets the alpha/opacity component as a byte of a 32-bit color (0-255) */
			Ab: number;

			/** Gets or sets the red component as a byte of a 32-bit color (0-255) */
			Rb: number;

			/** Gets or sets the green component as a byte of a 32-bit color (0-255) */
			Gb: number;

			/** Gets or sets the blue component as a byte of a 32-bit color (0-255) */
			Bb: number;

			/**
			 * Gets the native color control object.
			 *
			 * This can be null for platforms that do not have (or need) to store the native object.
			 */
			readonly ControlObject: unknown;

			/** Creates a color from 8-bit ARGB components */
			static FromArgb(
				red: number,
				green: number,
				blue: number,
				alpha?: number,
			): Eto.Drawing.Color;

			/** Creates a color from premultiplied 8-bit ARGB components */
			static FromPremultipliedArgb(
				red: number,
				green: number,
				blue: number,
				alpha?: number,
			): Eto.Drawing.Color;

			/** Creates a Color from a 32-bit ARGB value */
			static FromArgb(argb: number): Eto.Drawing.Color;

			/** Creates a Color from a premultiplied 32-bit ARGB value */
			static FromPremultipliedArgb(argb: number): Eto.Drawing.Color;

			/** Creates a Color from a 24-bit RGB value */
			static FromRgb(argb: number): Eto.Drawing.Color;

			/** Creates a Color with a specified value for the Red, Green, and Blue components */
			static FromGrayscale(
				val: number,
				alpha?: number,
			): Eto.Drawing.Color;

			/** Calculates the distance of the two colors in the RGB scale */
			static Distance(
				value1: Eto.Drawing.Color,
				value2: Eto.Drawing.Color,
			): number;

			/**
			 * Blends the `blendColor` onto the specified `baseColor`. Uses alpha component of
			 * `blendColor` to detemine the blending factor.
			 *
			 * This computes the blended value of two colors.
			 */
			static Blend(
				baseColor: Eto.Drawing.Color,
				blendColor: Eto.Drawing.Color,
			): Eto.Drawing.Color;

			/**
			 * Blends the `blendColor` onto the specified `baseColor`, including the Alpha component.
			 *
			 * This computes the blended value of two colors.
			 */
			static Blend(
				baseColor: Eto.Drawing.Color,
				blendColor: Eto.Drawing.Color,
				blendFactor: number,
			): Eto.Drawing.Color;

			static TryParse(value: string): Eto.Drawing.Color | undefined;

			static TryParse(
				value: string,
				style: Eto.Drawing.ColorStyles,
			): Eto.Drawing.ColorStyles | undefined;

			/**
			 * Converts a string into a new instance of a Color
			 *
			 * Use
			 * {@link Eto.Drawing.Color.TryParse(System.String,Eto.Drawing.Color@,Eto.Drawing.ColorStyles)}
			 * instead of try/catch.
			 */
			static Parse(value: string): Eto.Drawing.Color;

			/** Tests if the specified object has the same value as this Color */
			Equals(obj: unknown): boolean;

			/** Gets the hash code for this Color */
			GetHashCode(): number;

			/**
			 * Inverts the RGB color values
			 *
			 * This inverts the color components (other than the alpha component) by making them
			 * equal to the 1 minus the component's value.  This is useful for when you want to show
			 * a highlighted color but still show the variation in colors.
			 */
			Invert(): void;

			/** Converts this color to a 32-bit ARGB value. */
			ToArgb(): number;

			/**
			 * Converts this color to a premultiplied 32-bit ARGB value, where each of the R, G, B
			 * components are first multiplied by the alpha component
			 */
			ToPremultipliedArgb(): number;

			/** Converts this color to a 32-bit ARGB value given the specified `style` */
			ToArgb(style: Eto.Drawing.ColorStyles): number;

			/**
			 * Converts this color to a hex representation
			 *
			 * This will either return a hex value with 8 digits (two per component), or 6 digits
			 * (two per RGB) if the `includeAlpha` is set to false.
			 */
			ToHex(includeAlpha?: boolean): string;

			/**
			 * Converts this color to a hex representation
			 *
			 * This will either return a hex value with 8 digits (two per component), or 6 digits
			 * (two per RGB) depending on the specified `style`
			 */
			ToHex(style: Eto.Drawing.ColorStyles): string;

			/**
			 * Converts this object to a string
			 *
			 * This just calls {@link Eto.Drawing.Color.ToHex(System.Boolean)}
			 */
			ToString(): string;

			/** Compares the specified color for equality */
			Equals(other: Eto.Drawing.Color): boolean;

			/**
			 * Creates a new color from an Element ID value
			 *
			 * This algorithm is from the SVG# code base: The counter is used to generate IDs in the
			 * range [0,2^24-1] The 24 bits of the counter are interpreted as follows: [red 7 bits |
			 * green 7 bits | blue 7 bits |shuffle term 3 bits] The shuffle term is used to define
			 * how the remaining high bit is set on each color. The colors are generated in the range
			 * [0,127] (7 bits) instead of [0,255]. Then the shuffle term is used to adjust them into
			 * the range [0,255]. This algorithm has the feature that consecutive ids generate
			 * visually distinct colors.
			 */
			static FromElementId(
				id: number,
				alpha?: number,
			): Eto.Drawing.Color;

			/** Converts this color to an Element ID value */
			ToElementId(): number;

			/** Converts this RGB color to the HSB colorspace. */
			ToHSB(): Eto.Drawing.ColorHSB;

			/** Converts this RGB color to the HSL colorspace. */
			ToHSL(): Eto.Drawing.ColorHSL;

			/** Converts this RGB color to the CMYK colorspace. */
			ToCMYK(): Eto.Drawing.ColorCMYK;
		}
	}

	export namespace Eto.Drawing.Color {
		export interface IHandler {
			ModifyComponent(
				controlObject: unknown,
				r: number | undefined,
				g: number | undefined,
				b: number | undefined,
				a: number | undefined,
			): unknown;
		}
	}

	export namespace Eto.Drawing {
		/**
		 * Represents a color in the CMYK color model.
		 *
		 * This is a helper class to handle CMYK colors. Whenever a color is used it must be
		 * converted to a {@link Eto.Drawing.Color} struct first, either by using
		 * {@link Eto.Drawing.ColorCMYK.ToColor} or the implicit conversion.
		 */
		export class ColorCMYK {
			/** Initializes a new instance of the ColorCMYK class */
			constructor(
				cyan: number,
				magenta: number,
				yellow: number,
				black: number,
				alpha?: number,
			);

			/**
			 * Initializes a new instance of the ColorCMYK with the specified RGB
			 * {@link Eto.Drawing.Color}
			 */
			constructor(color: Eto.Drawing.Color);

			/** Cyan component */
			C: number;

			/** Magenta component */
			M: number;

			/** Yellow component */
			Y: number;

			/** Key (black) component */
			K: number;

			/** Alpha component */
			A: number;

			/**
			 * Calculates the 'distance' of two CMYK colors
			 *
			 * This is useful for comparing two different color values to determine if they are
			 * similar.  Typically though,
			 * {@link Eto.Drawing.ColorHSL.Distance(Eto.Drawing.ColorHSL,Eto.Drawing.ColorHSL)} gives
			 * the best result instead of this method.
			 */
			static Distance(
				value1: Eto.Drawing.ColorCMYK,
				value2: Eto.Drawing.ColorCMYK,
			): number;

			/** Gets this object as an ARGB color value */
			ToColor(): Eto.Drawing.Color;

			/** Returns a value indicating that this is equal to the specified object */
			Equals(obj: unknown): boolean;

			/** Gets the hash code for this object */
			GetHashCode(): number;

			/** Returns a value indicating that this is equal to the specified color */
			Equals(other: Eto.Drawing.ColorCMYK): boolean;
		}
	}

	export namespace Eto.Drawing {
		/**
		 * Converts instances of other types to and from a {@link Eto.Drawing.Color}.
		 *
		 * This only supports converting from a string supported by the
		 * {@link Eto.Drawing.Color.TryParse(System.String,Eto.Drawing.Color@)} method.  When
		 * converting to a string, it converts to a Hex format via
		 * {@link Eto.Drawing.Color.ToHex(System.Boolean)}
		 */
		export class ColorConverter {
			constructor();

			/**
			 * Determines if this can convert a {@link Eto.Drawing.Color} to the `destinationType`
			 */
			CanConvertTo(
				context: Eto.ITypeDescriptorContext,
				destinationType: unknown,
			): boolean;

			/**
			 * Determines if this can convert a value with the type of `sourceType` to a
			 * {@link Eto.Drawing.Color}
			 */
			CanConvertFrom(
				context: Eto.ITypeDescriptorContext,
				sourceType: unknown,
			): boolean;

			/** Converts the `value` to an instance of a {@link Eto.Drawing.Color} */
			ConvertFrom(
				context: Eto.ITypeDescriptorContext,
				culture: unknown,
				value: unknown,
			): unknown;

			/** Converts a {@link Eto.Drawing.Color} instance to the specified `destinationType` */
			ConvertTo(
				context: Eto.ITypeDescriptorContext,
				culture: unknown,
				value: unknown,
				destinationType: unknown,
			): unknown;

			/** Determines whether this instance can convert from the specified sourceType. */
			CanConvertFrom(sourceType: unknown): boolean;

			/** Determines whether this instance can convert to the specified destinationType. */
			CanConvertTo(destinationType: unknown): boolean;

			/** Converts from the specified object. */
			ConvertFrom(o: unknown): unknown;

			/** Converts from an invariant string. */
			ConvertFromInvariantString(text: string): unknown;

			/** Converts from an invariant string. */
			ConvertFromInvariantString(
				context: Eto.ITypeDescriptorContext,
				text: string,
			): unknown;

			/** Converts from string. */
			ConvertFromString(text: string): unknown;

			/** Converts from string. */
			ConvertFromString(
				context: Eto.ITypeDescriptorContext,
				text: string,
			): unknown;

			/** Converts from string. */
			ConvertFromString(
				context: Eto.ITypeDescriptorContext,
				culture: unknown,
				text: string,
			): unknown;

			/** Converts to the specified type. */
			ConvertTo(
				value: unknown,
				destinationType: unknown,
			): unknown;

			/** Converts to an invariant string. */
			ConvertToInvariantString(value: unknown): string;

			/** Converts to invariant string. */
			ConvertToInvariantString(
				context: Eto.ITypeDescriptorContext,
				value: unknown,
			): string;

			/** Converts to a string. */
			ConvertToString(value: unknown): string;

			/** Converts to a string. */
			ConvertToString(
				context: Eto.ITypeDescriptorContext,
				value: unknown,
			): string;

			/** Converts to a string. */
			ConvertToString(
				context: Eto.ITypeDescriptorContext,
				culture: unknown,
				value: unknown,
			): string;

			/** Determines whether this instance is valid the specified value. */
			IsValid(value: unknown): boolean;

			/** Determines whether this instance is valid the specified context value. */
			IsValid(
				context: Eto.ITypeDescriptorContext,
				value: unknown,
			): boolean;
		}
	}

	export namespace Eto.Drawing {
		/**
		 * Color representation in HSB color model
		 *
		 * This allows you to manage a color in the HSB (otherwise known as HSV) cylindrical
		 * model.  This is a helper class to handle HSB colors. Whenever a color is used it must
		 * be converted to a {@link Eto.Drawing.Color} struct first, either by using
		 * {@link Eto.Drawing.ColorHSB.ToColor} or the implicit conversion.
		 */
		export class ColorHSB {
			/** Initializes a new instance of the ColorHSB class */
			constructor(
				hue: number,
				saturation: number,
				brightness: number,
				alpha?: number,
			);

			/**
			 * Initializes a new instance of the ColorHSB class with the same color values as `color`
			 */
			constructor(color: Eto.Drawing.Color);

			/** Gets or sets the alpha (0-1) */
			A: number;

			/** Gets or sets the hue (0-360) */
			H: number;

			/** Gets or sets the saturation (0-1) */
			S: number;

			/** Gets or sets the brightness (0-1) */
			B: number;

			/**
			 * Calculates the 'distance' of two HSB colors
			 *
			 * This is useful for comparing two different color values to determine if they are
			 * similar.  Typically though,
			 * {@link Eto.Drawing.ColorHSL.Distance(Eto.Drawing.ColorHSL,Eto.Drawing.ColorHSL)} gives
			 * the best result instead of this method.
			 */
			static Distance(
				value1: Eto.Drawing.ColorHSB,
				value2: Eto.Drawing.ColorHSB,
			): number;

			/** Converts this instance to an equivalent RGB {@link Eto.Drawing.Color} */
			ToColor(): Eto.Drawing.Color;

			/** Compares an object to determine equality with this instance */
			Equals(obj: unknown): boolean;

			/** Gets the hash code for this object */
			GetHashCode(): number;

			/** Compares a ColorHSB for equality */
			Equals(other: Eto.Drawing.ColorHSB): boolean;
		}
	}

	export namespace Eto.Drawing {
		/**
		 * Color representation in the HSL color model
		 *
		 * This allows you to manage a color in the HSL cylindrical model.  This is a helper
		 * class to handle HSL colors. Whenever a color is used it must be converted to a
		 * {@link Eto.Drawing.Color} struct first, either by using
		 * {@link Eto.Drawing.ColorHSL.ToColor} or the implicit conversion.
		 */
		export class ColorHSL {
			/** Initializes a new instance of the ColorHSL class */
			constructor(
				hue: number,
				saturation: number,
				luminance: number,
				alpha?: number,
			);

			/**
			 * Initializes a new instance of the ColorHSL class with converted HSL values from a
			 * {@link Eto.Drawing.Color}
			 */
			constructor(color: Eto.Drawing.Color);

			/** Gets or sets the alpha (0-1) */
			A: number;

			/** Gets or sets the hue (0-360) */
			H: number;

			/** Gets or sets the saturation (0-1) */
			S: number;

			/** Gets or sets the luminance (0-1) */
			L: number;

			/**
			 * Calculates the 'distance' of two HSL colors
			 *
			 * This is useful for comparing two different color values to determine if they are
			 * similar.  The HSL comparison algorithm, while not essentially accurate, gives a good
			 * representation of like-colours to the human eye. This method of calculating distance
			 * is preferred over the other methods (RGB, CMYK, HSB)
			 */
			static Distance(
				value1: Eto.Drawing.ColorHSL,
				value2: Eto.Drawing.ColorHSL,
			): number;

			/** Converts this HSL color to a RGB {@link Eto.Drawing.Color} value */
			ToColor(): Eto.Drawing.Color;

			/** Compares the given object for equality with this object */
			Equals(obj: unknown): boolean;

			/** Gets the hash code for this object */
			GetHashCode(): number;

			/** Compares the given object for equality with this object */
			Equals(other: Eto.Drawing.ColorHSL): boolean;
		}
	}

	export namespace Eto.Drawing {
		/** List of common colors */
		export namespace Colors {
			/** Gets a color with an ARGB value of # */
			export const Transparent: Eto.Drawing.Color;

			/** Gets a color with an ARGB value of #FFCD5C5C */
			export const IndianRed: Eto.Drawing.Color;

			/** Gets a color with an ARGB value of #FFF08080 */
			export const LightCoral: Eto.Drawing.Color;

			/** Gets a color with an ARGB value of #FFFA8072 */
			export const Salmon: Eto.Drawing.Color;

			/** Gets a color with an ARGB value of #FFE9967A */
			export const DarkSalmon: Eto.Drawing.Color;

			/** Gets a color with an ARGB value of #FFFFA07A */
			export const LightSalmon: Eto.Drawing.Color;

			/** Gets a color with an ARGB value of #FFFF0000 */
			export const Red: Eto.Drawing.Color;

			/** Gets a color with an ARGB value of #FFDC143C */
			export const Crimson: Eto.Drawing.Color;

			/** Gets a color with an ARGB value of #FFB22222 */
			export const Firebrick: Eto.Drawing.Color;

			/** Gets a color with an ARGB value of #FF8B0000 */
			export const DarkRed: Eto.Drawing.Color;

			/** Gets a color with an ARGB value of #FFFFC0CB */
			export const Pink: Eto.Drawing.Color;

			/** Gets a color with an ARGB value of #FFFFB6C1 */
			export const LightPink: Eto.Drawing.Color;

			/** Gets a color with an ARGB value of #FFFF69B4 */
			export const HotPink: Eto.Drawing.Color;

			/** Gets a color with an ARGB value of #FFFF1493 */
			export const DeepPink: Eto.Drawing.Color;

			/** Gets a color with an ARGB value of #FFC71585 */
			export const MediumVioletRed: Eto.Drawing.Color;

			/** Gets a color with an ARGB value of #FFDB7093 */
			export const PaleVioletRed: Eto.Drawing.Color;

			/** Gets a color with an ARGB value of #FFFF7F50 */
			export const Coral: Eto.Drawing.Color;

			/** Gets a color with an ARGB value of #FFFF6347 */
			export const Tomato: Eto.Drawing.Color;

			/** Gets a color with an ARGB value of #FFFF4500 */
			export const OrangeRed: Eto.Drawing.Color;

			/** Gets a color with an ARGB value of #FFFF8C00 */
			export const DarkOrange: Eto.Drawing.Color;

			/** Gets a color with an ARGB value of #FFFFA500 */
			export const Orange: Eto.Drawing.Color;

			/** Gets a color with an ARGB value of #FFFFD700 */
			export const Gold: Eto.Drawing.Color;

			/** Gets a color with an ARGB value of #FFFFFF00 */
			export const Yellow: Eto.Drawing.Color;

			/** Gets a color with an ARGB value of #FFFFFFE0 */
			export const LightYellow: Eto.Drawing.Color;

			/** Gets a color with an ARGB value of #FFFFFACD */
			export const LemonChiffon: Eto.Drawing.Color;

			/** Gets a color with an ARGB value of #FFFAFAD2 */
			export const LightGoldenrodYellow: Eto.Drawing.Color;

			/** Gets a color with an ARGB value of #FFFFEFD5 */
			export const PapayaWhip: Eto.Drawing.Color;

			/** Gets a color with an ARGB value of #FFFFE4B5 */
			export const Moccasin: Eto.Drawing.Color;

			/** Gets a color with an ARGB value of #FFFFDAB9 */
			export const PeachPuff: Eto.Drawing.Color;

			/** Gets a color with an ARGB value of #FFEEE8AA */
			export const PaleGoldenrod: Eto.Drawing.Color;

			/** Gets a color with an ARGB value of #FFF0E68C */
			export const Khaki: Eto.Drawing.Color;

			/** Gets a color with an ARGB value of #FFBDB76B */
			export const DarkKhaki: Eto.Drawing.Color;

			/** Gets a color with an ARGB value of #FFE6E6FA */
			export const Lavender: Eto.Drawing.Color;

			/** Gets a color with an ARGB value of #FFD8BFD8 */
			export const Thistle: Eto.Drawing.Color;

			/** Gets a color with an ARGB value of #FFDDA0DD */
			export const Plum: Eto.Drawing.Color;

			/** Gets a color with an ARGB value of #FFEE82EE */
			export const Violet: Eto.Drawing.Color;

			/** Gets a color with an ARGB value of #FFDA70D6 */
			export const Orchid: Eto.Drawing.Color;

			/** Gets a color with an ARGB value of #FFFF00FF */
			export const Fuchsia: Eto.Drawing.Color;

			/** Gets a color with an ARGB value of #FFFF00FF */
			export const Magenta: Eto.Drawing.Color;

			/** Gets a color with an ARGB value of #FFBA55D3 */
			export const MediumOrchid: Eto.Drawing.Color;

			/** Gets a color with an ARGB value of #FF9370DB */
			export const MediumPurple: Eto.Drawing.Color;

			/** Gets a color with an ARGB value of #FF8A2BE2 */
			export const BlueViolet: Eto.Drawing.Color;

			/** Gets a color with an ARGB value of #FF9400D3 */
			export const DarkViolet: Eto.Drawing.Color;

			/** Gets a color with an ARGB value of #FF9932CC */
			export const DarkOrchid: Eto.Drawing.Color;

			/** Gets a color with an ARGB value of #FF8B008B */
			export const DarkMagenta: Eto.Drawing.Color;

			/** Gets a color with an ARGB value of #FF800080 */
			export const Purple: Eto.Drawing.Color;

			/** Gets a color with an ARGB value of #FF4B0082 */
			export const Indigo: Eto.Drawing.Color;

			/** Gets a color with an ARGB value of #FF483D8B */
			export const DarkSlateBlue: Eto.Drawing.Color;

			/** Gets a color with an ARGB value of #FF6A5ACD */
			export const SlateBlue: Eto.Drawing.Color;

			/** Gets a color with an ARGB value of #FF7B68EE */
			export const MediumSlateBlue: Eto.Drawing.Color;

			/** Gets a color with an ARGB value of #FFADFF2F */
			export const GreenYellow: Eto.Drawing.Color;

			/** Gets a color with an ARGB value of #FF7FFF00 */
			export const Chartreuse: Eto.Drawing.Color;

			/** Gets a color with an ARGB value of #FF7CFC00 */
			export const LawnGreen: Eto.Drawing.Color;

			/** Gets a color with an ARGB value of #FF00FF00 */
			export const Lime: Eto.Drawing.Color;

			/** Gets a color with an ARGB value of #FF32CD32 */
			export const LimeGreen: Eto.Drawing.Color;

			/** Gets a color with an ARGB value of #FF98FB98 */
			export const PaleGreen: Eto.Drawing.Color;

			/** Gets a color with an ARGB value of #FF90EE90 */
			export const LightGreen: Eto.Drawing.Color;

			/** Gets a color with an ARGB value of #FF00FA9A */
			export const MediumSpringGreen: Eto.Drawing.Color;

			/** Gets a color with an ARGB value of #FF00FF7F */
			export const SpringGreen: Eto.Drawing.Color;

			/** Gets a color with an ARGB value of #FF3CB371 */
			export const MediumSeaGreen: Eto.Drawing.Color;

			/** Gets a color with an ARGB value of #FF2E8B57 */
			export const SeaGreen: Eto.Drawing.Color;

			/** Gets a color with an ARGB value of #FF228B22 */
			export const ForestGreen: Eto.Drawing.Color;

			/** Gets a color with an ARGB value of #FF008000 */
			export const Green: Eto.Drawing.Color;

			/** Gets a color with an ARGB value of #FF006400 */
			export const DarkGreen: Eto.Drawing.Color;

			/** Gets a color with an ARGB value of #FF9ACD32 */
			export const YellowGreen: Eto.Drawing.Color;

			/** Gets a color with an ARGB value of #FF6B8E23 */
			export const OliveDrab: Eto.Drawing.Color;

			/** Gets a color with an ARGB value of #FF808000 */
			export const Olive: Eto.Drawing.Color;

			/** Gets a color with an ARGB value of #FF556B2F */
			export const DarkOliveGreen: Eto.Drawing.Color;

			/** Gets a color with an ARGB value of #FF66CDAA */
			export const MediumAquamarine: Eto.Drawing.Color;

			/** Gets a color with an ARGB value of #FF8FBC8F */
			export const DarkSeaGreen: Eto.Drawing.Color;

			/** Gets a color with an ARGB value of #FF20B2AA */
			export const LightSeaGreen: Eto.Drawing.Color;

			/** Gets a color with an ARGB value of #FF008B8B */
			export const DarkCyan: Eto.Drawing.Color;

			/** Gets a color with an ARGB value of #FF008080 */
			export const Teal: Eto.Drawing.Color;

			/** Gets a color with an ARGB value of #FF00FFFF */
			export const Aqua: Eto.Drawing.Color;

			/** Gets a color with an ARGB value of #FF00FFFF */
			export const Cyan: Eto.Drawing.Color;

			/** Gets a color with an ARGB value of #FFE0FFFF */
			export const LightCyan: Eto.Drawing.Color;

			/** Gets a color with an ARGB value of #FFAFEEEE */
			export const PaleTurquoise: Eto.Drawing.Color;

			/** Gets a color with an ARGB value of #FF7FFFD4 */
			export const Aquamarine: Eto.Drawing.Color;

			/** Gets a color with an ARGB value of #FF40E0D0 */
			export const Turquoise: Eto.Drawing.Color;

			/** Gets a color with an ARGB value of #FF48D1CC */
			export const MediumTurquoise: Eto.Drawing.Color;

			/** Gets a color with an ARGB value of #FF00CED1 */
			export const DarkTurquoise: Eto.Drawing.Color;

			/** Gets a color with an ARGB value of #FF5F9EA0 */
			export const CadetBlue: Eto.Drawing.Color;

			/** Gets a color with an ARGB value of #FF4682B4 */
			export const SteelBlue: Eto.Drawing.Color;

			/** Gets a color with an ARGB value of #FFB0C4DE */
			export const LightSteelBlue: Eto.Drawing.Color;

			/** Gets a color with an ARGB value of #FFB0E0E6 */
			export const PowderBlue: Eto.Drawing.Color;

			/** Gets a color with an ARGB value of #FFADD8E6 */
			export const LightBlue: Eto.Drawing.Color;

			/** Gets a color with an ARGB value of #FF87CEEB */
			export const SkyBlue: Eto.Drawing.Color;

			/** Gets a color with an ARGB value of #FF87CEFA */
			export const LightSkyBlue: Eto.Drawing.Color;

			/** Gets a color with an ARGB value of #FF00BFFF */
			export const DeepSkyBlue: Eto.Drawing.Color;

			/** Gets a color with an ARGB value of #FF1E90FF */
			export const DodgerBlue: Eto.Drawing.Color;

			/** Gets a color with an ARGB value of #FF6495ED */
			export const CornflowerBlue: Eto.Drawing.Color;

			/** Gets a color with an ARGB value of #FF4169E1 */
			export const RoyalBlue: Eto.Drawing.Color;

			/** Gets a color with an ARGB value of #FF0000FF */
			export const Blue: Eto.Drawing.Color;

			/** Gets a color with an ARGB value of #FF0000CD */
			export const MediumBlue: Eto.Drawing.Color;

			/** Gets a color with an ARGB value of #FF00008B */
			export const DarkBlue: Eto.Drawing.Color;

			/** Gets a color with an ARGB value of #FF000080 */
			export const Navy: Eto.Drawing.Color;

			/** Gets a color with an ARGB value of #FF191970 */
			export const MidnightBlue: Eto.Drawing.Color;

			/** Gets a color with an ARGB value of #FFFFF8DC */
			export const Cornsilk: Eto.Drawing.Color;

			/** Gets a color with an ARGB value of #FFFFEBCD */
			export const BlanchedAlmond: Eto.Drawing.Color;

			/** Gets a color with an ARGB value of #FFFFE4C4 */
			export const Bisque: Eto.Drawing.Color;

			/** Gets a color with an ARGB value of #FFFFDEAD */
			export const NavajoWhite: Eto.Drawing.Color;

			/** Gets a color with an ARGB value of #FFF5DEB3 */
			export const Wheat: Eto.Drawing.Color;

			/** Gets a color with an ARGB value of #FFDEB887 */
			export const BurlyWood: Eto.Drawing.Color;

			/** Gets a color with an ARGB value of #FFD2B48C */
			export const Tan: Eto.Drawing.Color;

			/** Gets a color with an ARGB value of #FFBC8F8F */
			export const RosyBrown: Eto.Drawing.Color;

			/** Gets a color with an ARGB value of #FFF4A460 */
			export const SandyBrown: Eto.Drawing.Color;

			/** Gets a color with an ARGB value of #FFDAA520 */
			export const Goldenrod: Eto.Drawing.Color;

			/** Gets a color with an ARGB value of #FFB8860B */
			export const DarkGoldenrod: Eto.Drawing.Color;

			/** Gets a color with an ARGB value of #FFCD853F */
			export const Peru: Eto.Drawing.Color;

			/** Gets a color with an ARGB value of #FFD2691E */
			export const Chocolate: Eto.Drawing.Color;

			/** Gets a color with an ARGB value of #FF8B4513 */
			export const SaddleBrown: Eto.Drawing.Color;

			/** Gets a color with an ARGB value of #FFA0522D */
			export const Sienna: Eto.Drawing.Color;

			/** Gets a color with an ARGB value of #FFA52A2A */
			export const Brown: Eto.Drawing.Color;

			/** Gets a color with an ARGB value of #FF800000 */
			export const Maroon: Eto.Drawing.Color;

			/** Gets a color with an ARGB value of #FFFFFFFF */
			export const White: Eto.Drawing.Color;

			/** Gets a color with an ARGB value of #FFFFFAFA */
			export const Snow: Eto.Drawing.Color;

			/** Gets a color with an ARGB value of #FFF0FFF0 */
			export const Honeydew: Eto.Drawing.Color;

			/** Gets a color with an ARGB value of #FFF5FFFA */
			export const MintCream: Eto.Drawing.Color;

			/** Gets a color with an ARGB value of #FFF0FFFF */
			export const Azure: Eto.Drawing.Color;

			/** Gets a color with an ARGB value of #FFF0F8FF */
			export const AliceBlue: Eto.Drawing.Color;

			/** Gets a color with an ARGB value of #FFF8F8FF */
			export const GhostWhite: Eto.Drawing.Color;

			/** Gets a color with an ARGB value of #FFF5F5F5 */
			export const WhiteSmoke: Eto.Drawing.Color;

			/** Gets a color with an ARGB value of #FFFFF5EE */
			export const Seashell: Eto.Drawing.Color;

			/** Gets a color with an ARGB value of #FFF5F5DC */
			export const Beige: Eto.Drawing.Color;

			/** Gets a color with an ARGB value of #FFFDF5E6 */
			export const OldLace: Eto.Drawing.Color;

			/** Gets a color with an ARGB value of #FFFFFAF0 */
			export const FloralWhite: Eto.Drawing.Color;

			/** Gets a color with an ARGB value of #FFFFFFF0 */
			export const Ivory: Eto.Drawing.Color;

			/** Gets a color with an ARGB value of #FFFAEBD7 */
			export const AntiqueWhite: Eto.Drawing.Color;

			/** Gets a color with an ARGB value of #FFFAF0E6 */
			export const Linen: Eto.Drawing.Color;

			/** Gets a color with an ARGB value of #FFFFF0F5 */
			export const LavenderBlush: Eto.Drawing.Color;

			/** Gets a color with an ARGB value of #FFFFE4E1 */
			export const MistyRose: Eto.Drawing.Color;

			/** Gets a color with an ARGB value of #FFDCDCDC */
			export const Gainsboro: Eto.Drawing.Color;

			/** Gets a color with an ARGB value of #FFD3D3D3 */
			export const LightGrey: Eto.Drawing.Color;

			/** Gets a color with an ARGB value of #FFC0C0C0 */
			export const Silver: Eto.Drawing.Color;

			/** Gets a color with an ARGB value of #FFA9A9A9 */
			export const DarkGray: Eto.Drawing.Color;

			/** Gets a color with an ARGB value of #FF808080 */
			export const Gray: Eto.Drawing.Color;

			/** Gets a color with an ARGB value of #FF696969 */
			export const DimGray: Eto.Drawing.Color;

			/** Gets a color with an ARGB value of #FF778899 */
			export const LightSlateGray: Eto.Drawing.Color;

			/** Gets a color with an ARGB value of #FF708090 */
			export const SlateGray: Eto.Drawing.Color;

			/** Gets a color with an ARGB value of #FF2F4F4F */
			export const DarkSlateGray: Eto.Drawing.Color;

			/** Gets a color with an ARGB value of #FF000000 */
			export const Black: Eto.Drawing.Color;
		}
	}

	export namespace Eto.Drawing {
		/** Dash style for a {@link Eto.Drawing.Pen} */
		export class DashStyle {
			/** Initializes a new instance of the {@link Eto.Drawing.DashStyle} class. */
			constructor();

			/** Initializes a new instance of the {@link Eto.Drawing.DashStyle} class. */
			constructor(
				offset: number,
				dashes: number[],
			);

			/**
			 * Gets the dashes and gaps for this style
			 *
			 * The values specified are the dash lengths and gap lengths in alternating order. The
			 * lengths are multiplied by the thickness of the pen.  For example, values of 2, 1 would
			 * have a dash of (2 * thickness) followed by a gap of (1 * thickness).
			 */
			readonly Dashes: number[];

			/**
			 * Gets the offset of the first dash
			 *
			 * A value of 1 indicates that the first dash should start at the (1*thickness) of the
			 * pen.
			 */
			readonly Offset: number;

			/** Gets a value indicating whether this dash style is solid */
			readonly IsSolid: boolean;

			static TryParse(value: string): Eto.Drawing.DashStyle | undefined;

			/**
			 * Attempts to parse the specified `value` into a dash style.  This can be one of the
			 * system styles (solid, dash, dot, dashdot, dashdotdot), or a series of numbers
			 * separated by commas  specifying the solid and gap parts (see
			 * {@link Eto.Drawing.DashStyle.Dashes} ).
			 */
			static Parse(value: string): Eto.Drawing.DashStyle;

			/**
			 * Determines whether the specified {@link Eto.Drawing.DashStyle} is equal to the current
			 * {@link Eto.Drawing.DashStyle}.
			 */
			Equals(other: Eto.Drawing.DashStyle): boolean;

			/**
			 * Determines whether the specified {@link System.Object} is equal to the current
			 * {@link Eto.Drawing.DashStyle}.
			 */
			Equals(obj: unknown): boolean;

			/**
			 * Returns a {@link System.String} that represents the current
			 * {@link Eto.Drawing.DashStyle}.
			 */
			ToString(): string;

			/** Serves as a hash function for a {@link Eto.Drawing.DashStyle} object. */
			GetHashCode(): number;
		}
	}

	export namespace Eto.Drawing {
		/** Common dash styles used for {@link Eto.Drawing.DashStyle} */
		export namespace DashStyles {
			/** Gets a solid dash style */
			export const Solid: Eto.Drawing.DashStyle;

			/** Gets a dash style with a single dash */
			export const Dash: Eto.Drawing.DashStyle;

			/** Gets a dot style */
			export const Dot: Eto.Drawing.DashStyle;

			/** Gets the dash dot style */
			export const DashDot: Eto.Drawing.DashStyle;

			/** Gets the dash dot dot style */
			export const DashDotDot: Eto.Drawing.DashStyle;
		}
	}

	export namespace Eto.Drawing {
		/** Mode for how a closed {@link Eto.Drawing.IGraphicsPath} is filled */
		export enum FillMode {
			/** Alternating / Even-Odd fill mode */
			Alternate = 0,

			/** Winding fill mode */
			Winding = 1,
		}
	}

	export namespace Eto.Drawing {
		/**
		 * Enumeration of the different system fonts for a {@link Eto.Drawing.Font}
		 *
		 * This is useful when you want to use a font that is the same as standard UI elements.
		 */
		export enum SystemFont {
			/** Default system font */
			Default = 0,

			/** Default system font in BOLD */
			Bold = 1,

			/** Default label font */
			Label = 2,

			/** Default title bar font (window title) */
			TitleBar = 3,

			/** Default tool top font */
			ToolTip = 4,

			/** Default menu bar font */
			MenuBar = 5,

			/** Default font for items in a menu */
			Menu = 6,

			/** Default font for message boxes */
			Message = 7,

			/** Default font for palette dialogs */
			Palette = 8,

			/** Default font for status bars */
			StatusBar = 9,

			/**
			 * Default font for text that a user can typically change
			 *
			 * On macOS, the system font isn't normally a font that the user would select or use,
			 * other than for user interface elements.
			 */
			User = 10,
		}
	}

	export namespace Eto.Drawing {
		/** Syles for a {@link Eto.Drawing.Font} */
		export enum FontStyle {
			/** No extra font style applied */
			None = 0,

			/** Bold font style */
			Bold = 1,

			/** Italic font style */
			Italic = 2,
		}
	}

	export namespace Eto.Drawing {
		/**
		 * Decorations for a {@link Eto.Drawing.Font}
		 *
		 * These specify the different decorations to apply to a font, and are not related to the
		 * style.
		 */
		export enum FontDecoration {
			/** No decorations */
			None = 0,

			/** Underline font decoration */
			Underline = 1,

			/** Strikethrough font decoration */
			Strikethrough = 2,
		}
	}

	export namespace Eto.Drawing {
		/**
		 * Defines a format for text
		 *
		 * A font is typically defined with a specified font family, with a given typeface.  Each
		 * typeface has certain characteristics that define the variation of the font family, for
		 * example Bold, or Italic.  You can get a list of {@link Eto.Drawing.FontFamily} objects
		 * available in the current system using {@link Eto.Drawing.Fonts.AvailableFontFamilies},
		 * which can then be used to create an instance of a font.
		 */
		export class Font implements
			Eto.IHandlerSource {
			/**
			 * Creates a new instance of the Font class with a specified `family`, `size`, and
			 * `style`
			 */
			constructor(
				family: string,
				size: number,
				style?: Eto.Drawing.FontStyle,
				decoration?: Eto.Drawing.FontDecoration,
			);

			/**
			 * Creates a new instance of the Font class with a specified `family`, `size`, and
			 * `style`
			 */
			constructor(
				family: Eto.Drawing.FontFamily,
				size: number,
				style?: Eto.Drawing.FontStyle,
				decoration?: Eto.Drawing.FontDecoration,
			);

			/**
			 * Creates a new instance of the Font class with a specified `systemFont` and optional
			 * custom `size`
			 *
			 * The system fonts are the same fonts that the standard UI of each platform use for
			 * particular areas given the {@link Eto.Drawing.SystemFont} enumeration.
			 */
			constructor(
				systemFont: Eto.Drawing.SystemFont,
				size?: number,
				decoration?: Eto.Drawing.FontDecoration,
			);

			/**
			 * Initializes a new instance of the Font class with the specified `typeface` and `size`
			 */
			constructor(
				typeface: Eto.Drawing.FontTypeface,
				size: number,
				decoration?: Eto.Drawing.FontDecoration,
			);

			constructor(handler: Eto.Drawing.Font.IHandler);

			/** Gets the name of the family of this font */
			readonly FamilyName: string;

			/**
			 * Gets the style flags for this font
			 *
			 * This does not represent all of the style properties of the font. Each
			 * {@link Eto.Drawing.Font.Typeface} has its own style relative to the font family.
			 */
			readonly FontStyle: Eto.Drawing.FontStyle;

			/**
			 * Gets the decorations applied to the font
			 *
			 * Decorations can be applied to any typeface/style of font.
			 */
			readonly FontDecoration: Eto.Drawing.FontDecoration;

			/** Gets the family information for this font */
			readonly Family: Eto.Drawing.FontFamily;

			/** Gets the typeface information for this font */
			readonly Typeface: Eto.Drawing.FontTypeface;

			/** Gets the height of the lower case 'x' character */
			readonly XHeight: number;

			/** Gets the top y co-ordinate from the baseline to the tallest character ascent */
			readonly Ascent: number;

			/** Gets the bottom y co-ordinate from the baseline to the longest character descent */
			readonly Descent: number;

			/** Gets the height of a single line of the font */
			readonly LineHeight: number;

			/** Gets the leading space between each line */
			readonly Leading: number;

			/** Gets the offset of the baseline from the drawing point */
			readonly Baseline: number;

			/** Gets the size, in points, of this font */
			readonly Size: number;

			/** Gets a value indicating that this font has a bold style */
			readonly Bold: boolean;

			/** Gets a value indicating that this font has an italic style */
			readonly Italic: boolean;

			/** Gets a value indicating that this font has an underline decoration */
			readonly Underline: boolean;

			/** Gets a value indicating that this font has a strikethrough decoration */
			readonly Strikethrough: boolean;

			/**
			 * Gets the platform that was used to create the {@link Eto.Widget.Handler} for this
			 * widget
			 *
			 * This gets set to the current {@link Eto.Platform.Instance} during the construction of
			 * the object
			 */
			readonly Platform: Eto.Platform;

			/** Gets the platform-specific handler for this widget */
			Handler: unknown;

			/** Gets the native platform-specific handle for integration purposes */
			readonly NativeHandle: unknown;

			/** Gets the dictionary of properties for this widget */
			readonly Properties: Eto.PropertyStore;

			/** Gets or sets the ID of this widget */
			ID: string;

			/**
			 * Gets or sets the style of this widget
			 *
			 * Styles allow you to attach custom platform-specific logic to a widget. In your
			 * platform-specific assembly, use {@link Style.Add{H}(string, StyleHandler{H})} to add
			 * the style logic with the same id.
			 */
			Style: string;

			/**
			 * Gets the instance of the platform-specific object
			 *
			 * This can sometimes be useful to get the platform-specific object. Some handlers may
			 * not have any backing object for its functionality, so this may be null.  It is more
			 * preferred to use the {@link Eto.Widget.Handler} and cast that to the platform-specific
			 * handler class which can give you additional methods and helpers to do common tasks.
			 * For example, the {@link Eto.Forms.Application} object's handler for OS X has a
			 * AddFullScreenMenuItem property to specify if you want full screen support in your app.
			 */
			readonly ControlObject: unknown;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Widget} has been disposed.
			 *
			 * When the widget is disposed, it can no longer be used.
			 */
			IsDisposed: boolean;

			/**
			 * Creates a new instance of the Font class with the specified font file on disk.
			 *
			 * Note that calling this multiple times for the same file may cause additional overhead
			 * or unpredictable results,  so you should keep a copy of it in memory when you want to
			 * use it.
			 */
			static FromFile(
				fileName: string,
				size: number,
				decoration?: Eto.Drawing.FontDecoration,
			): Eto.Drawing.Font;

			/**
			 * Creates a new instance of the Font class from the specified stream.
			 *
			 * Note that calling this multiple times for the same stream may cause additional
			 * overhead or unpredictable results,  so you should keep a copy of it in memory when you
			 * want to use it.
			 */
			static FromStream(
				stream: Duplex,
				size: number,
				decoration?: Eto.Drawing.FontDecoration,
			): Eto.Drawing.Font;

			/**
			 * Measures the specified string to get its size in logical pixels.
			 *
			 * This is equivalent to
			 * {@link Eto.Drawing.Graphics.MeasureString(Eto.Drawing.Font,System.String)}.  When you
			 * have a Graphics object, it is recommended to use that to measure the string if
			 * available, as it may be more efficient and take into account the current graphics
			 * state.
			 */
			MeasureString(text: string): Eto.Drawing.SizeF;

			/** Gets a string representation of the font object */
			ToString(): string;

			/**
			 * Determines whether the specified {@link System.Object} is equal to the current
			 * {@link Eto.Drawing.Font}.
			 */
			Equals(obj: unknown): boolean;

			/** Serves as a hash function for a {@link Eto.Drawing.Font} object. */
			GetHashCode(): number;

			/** Disposes of this widget, supressing the finalizer */
			dispose(): void;
		}
	}

	export namespace Eto.Drawing.Font {
		export interface IHandler extends Eto.Widget.IHandler {
			readonly XHeight: number;

			readonly Ascent: number;

			readonly Descent: number;

			readonly LineHeight: number;

			readonly Leading: number;

			readonly Baseline: number;

			readonly Size: number;

			readonly FamilyName: string;

			readonly FontStyle: Eto.Drawing.FontStyle;

			readonly FontDecoration: Eto.Drawing.FontDecoration;

			readonly Family: Eto.Drawing.FontFamily;

			readonly Typeface: Eto.Drawing.FontTypeface;

			Create(
				family: Eto.Drawing.FontFamily,
				size: number,
				style: Eto.Drawing.FontStyle,
				decoration: Eto.Drawing.FontDecoration,
			): void;

			Create(
				systemFont: Eto.Drawing.SystemFont,
				size: number | undefined,
				decoration: Eto.Drawing.FontDecoration,
			): void;

			Create(
				typeface: Eto.Drawing.FontTypeface,
				size: number,
				decoration: Eto.Drawing.FontDecoration,
			): void;

			MeasureString(text: string): Eto.Drawing.SizeF;
		}
	}

	export namespace Eto.Drawing {
		/**
		 * Defines generic font families that can be used on all systems
		 *
		 * The font families here may correspond to certain fonts on each system, depending on
		 * the platform.  These font families are "guaranteed" to be available, mainly by using
		 * pre-installed fonts on each platform.
		 */
		export namespace FontFamilies {
			/** Gets a monospace font family */
			export const Monospace: Eto.Drawing.FontFamily;

			/** Gets a sans-serif font family */
			export const Sans: Eto.Drawing.FontFamily;

			/** Gets a serif font family */
			export const Serif: Eto.Drawing.FontFamily;

			/** Gets a cursive font family */
			export const Cursive: Eto.Drawing.FontFamily;

			/** Gets a fantasy font family */
			export const Fantasy: Eto.Drawing.FontFamily;
		}
	}

	export namespace Eto.Drawing {
		/**
		 * Specifies a family for a {@link Eto.Drawing.Font} object
		 *
		 * A font family defines the overall look of the font, such as "Times New Roman",
		 * "Helvetica", etc.  Each family consists of one or more
		 * {@link Eto.Drawing.FontFamily.Typefaces}, which define the variations of each font
		 * family. The variations can include Light, Bold, Italic, Oblique, etc.  Only the styles
		 * in {@link Eto.Drawing.FontStyle} are  discoverable, other than looking at the
		 * {@link Eto.Drawing.FontTypeface.Name} for hints as to what the variation will look
		 * like.
		 */
		export class FontFamily implements
			Eto.IHandlerSource {
			constructor(handler: Eto.Drawing.FontFamily.IHandler);

			/**
			 * Initializes a new instance of the FontFamily class with the given font `familyName`
			 */
			constructor(familyName: string);

			/**
			 * Gets the name of this font family
			 *
			 * This is a non-localized version of the name, suitable for internal use.
			 */
			readonly Name: string;

			/**
			 * Gets the localized name of the font for the current UI language
			 *
			 * This will return a name suitable to display to the user in their own language, if the
			 * font provides a specific name for their UI language.  For platforms that do not
			 * support localized font names, or for fonts that do not have a specific name for the
			 * current language, the value of {@link Eto.Drawing.FontFamily.Name} will be returned.
			 */
			readonly LocalizedName: string;

			/** Gets an enumeration of the one or more supported typefaces for this font family */
			readonly Typefaces: Iterable<Eto.Drawing.FontTypeface>;

			/**
			 * Gets the platform that was used to create the {@link Eto.Widget.Handler} for this
			 * widget
			 *
			 * This gets set to the current {@link Eto.Platform.Instance} during the construction of
			 * the object
			 */
			readonly Platform: Eto.Platform;

			/** Gets the platform-specific handler for this widget */
			Handler: unknown;

			/** Gets the native platform-specific handle for integration purposes */
			readonly NativeHandle: unknown;

			/** Gets the dictionary of properties for this widget */
			readonly Properties: Eto.PropertyStore;

			/** Gets or sets the ID of this widget */
			ID: string;

			/**
			 * Gets or sets the style of this widget
			 *
			 * Styles allow you to attach custom platform-specific logic to a widget. In your
			 * platform-specific assembly, use {@link Style.Add{H}(string, StyleHandler{H})} to add
			 * the style logic with the same id.
			 */
			Style: string;

			/**
			 * Gets the instance of the platform-specific object
			 *
			 * This can sometimes be useful to get the platform-specific object. Some handlers may
			 * not have any backing object for its functionality, so this may be null.  It is more
			 * preferred to use the {@link Eto.Widget.Handler} and cast that to the platform-specific
			 * handler class which can give you additional methods and helpers to do common tasks.
			 * For example, the {@link Eto.Forms.Application} object's handler for OS X has a
			 * AddFullScreenMenuItem property to specify if you want full screen support in your app.
			 */
			readonly ControlObject: unknown;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Widget} has been disposed.
			 *
			 * When the widget is disposed, it can no longer be used.
			 */
			IsDisposed: boolean;

			/**
			 * Creates a new instance of the FontFamily class with the specified font files.
			 *
			 * All font files specified must be a part of the same typographical font family.  Also,
			 * calling this multiple times for the same streams may cause additional overhead or
			 * unpredictable results,  so you should keep a copy of it in memory when you want to use
			 * it.
			 */
			static FromFiles(fileNames: string[]): Eto.Drawing.FontFamily;

			/**
			 * Creates a new instance of the FontFamily class with the specified font files.
			 *
			 * All font files specified must be a part of the same typographical font family.  Also,
			 * calling this multiple times for the same streams may cause additional overhead or
			 * unpredictable results,  so you should keep a copy of it in memory when you want to use
			 * it.
			 */
			static FromFiles(fileNames: Iterable<string>): Eto.Drawing.FontFamily;

			/**
			 * Creates a new instance of the FontFamily class with the specified font file streams.
			 *
			 * All font files specified must be a part of the same typographical font family.  Also,
			 * calling this multiple times for the same streams may cause additional overhead or
			 * unpredictable results,  so you should keep a copy of it in memory when you want to use
			 * it.
			 */
			static FromStreams(streams: Duplex[]): Eto.Drawing.FontFamily;

			/**
			 * Creates a new instance of the FontFamily class with the specified font file streams.
			 *
			 * All font files specified must be a part of the same typographical font family.  Also,
			 * calling this multiple times for the same streams may cause additional overhead or
			 * unpredictable results,  so you should keep a copy of it in memory when you want to use
			 * it.
			 */
			static FromStreams(streams: Iterable<Duplex>): Eto.Drawing.FontFamily;

			/**
			 * Tests this instance for equality with another font family
			 *
			 * Font families are considered equal if the names are the same
			 */
			Equals(other: Eto.Drawing.FontFamily): boolean;

			/** Gets the hash code for this instance */
			GetHashCode(): number;

			/** Tests if this instance is equal to the specified object */
			Equals(obj: unknown): boolean;

			/** Gets a string representation of this font family */
			ToString(): string;

			/** Disposes of this widget, supressing the finalizer */
			dispose(): void;
		}
	}

	export namespace Eto.Drawing.FontFamily {
		export interface IHandler extends Eto.Widget.IHandler {
			readonly Name: string;

			readonly LocalizedName: string;

			readonly Typefaces: Iterable<Eto.Drawing.FontTypeface>;

			Create(familyName: string): void;

			CreateFromFiles(fileNames: Iterable<string>): void;

			CreateFromStreams(streams: Iterable<Duplex>): void;
		}
	}

	export namespace Eto.Drawing {
		/** Methods to get information about current fonts installed the running system */
		export namespace Fonts {
			/** Gets an enumeration of available font families in the current system */
			export const AvailableFontFamilies: Iterable<Eto.Drawing.FontFamily>;

			/** Gets a cached font */
			export function Cached(
				familyName: string,
				size: number,
				style?: Eto.Drawing.FontStyle,
				decoration?: Eto.Drawing.FontDecoration,
			): Eto.Drawing.Font;

			/** Gets a cached font */
			export function Cached(
				family: Eto.Drawing.FontFamily,
				size: number,
				style?: Eto.Drawing.FontStyle,
				decoration?: Eto.Drawing.FontDecoration,
			): Eto.Drawing.Font;

			/**
			 * Clears the font cache
			 *
			 * This is useful if you are using the
			 * {@link Eto.Drawing.Fonts.Cached(Eto.Drawing.FontFamily,System.Single,Eto.Drawing.FontStyle,Eto.Drawing.FontDecoration)}
			 * method to cache fonts and want to clear it to conserve memory or resources.
			 */
			export function ClearCache(): void;

			/**
			 * Gets a font with the {@link Eto.Drawing.FontFamilies.Monospace} family and the
			 * specified size and style
			 */
			export function Monospace(
				size: number,
				style?: Eto.Drawing.FontStyle,
				decoration?: Eto.Drawing.FontDecoration,
			): Eto.Drawing.Font;

			/**
			 * Gets a font with the {@link Eto.Drawing.FontFamilies.Sans} family and the specified
			 * size and style
			 */
			export function Sans(
				size: number,
				style?: Eto.Drawing.FontStyle,
				decoration?: Eto.Drawing.FontDecoration,
			): Eto.Drawing.Font;

			/**
			 * Gets a font with the {@link Eto.Drawing.FontFamilies.Serif} family and the specified
			 * size and style
			 */
			export function Serif(
				size: number,
				style?: Eto.Drawing.FontStyle,
				decoration?: Eto.Drawing.FontDecoration,
			): Eto.Drawing.Font;

			/**
			 * Gets a font with the {@link Eto.Drawing.FontFamilies.Cursive} family and the specified
			 * size and style
			 */
			export function Cursive(
				size: number,
				style?: Eto.Drawing.FontStyle,
				decoration?: Eto.Drawing.FontDecoration,
			): Eto.Drawing.Font;

			/**
			 * Gets a font with the {@link Eto.Drawing.FontFamilies.Fantasy} family and the specified
			 * size and style
			 */
			export function Fantasy(
				size: number,
				style?: Eto.Drawing.FontStyle,
				decoration?: Eto.Drawing.FontDecoration,
			): Eto.Drawing.Font;
		}
	}

	export namespace Eto.Drawing.Fonts {
		export interface IHandler {
			readonly AvailableFontFamilies: Iterable<Eto.Drawing.FontFamily>;

			FontFamilyAvailable(fontFamily: string): boolean;
		}
	}

	export namespace Eto.Drawing {
		/**
		 * A font type that specifies the characteristics of a {@link Eto.Drawing.FontFamily}
		 * variation
		 *
		 * Each FontFamily can have different variations, such as Bold, Italic, Bold and Italic,
		 * etc.  This class represents each supported typeface of a particular font family, and
		 * can be used to create a {@link Eto.Drawing.Font} instance that uses this typeface,
		 * using the {@link Font(FontTypeface,float,FontDecoration,Generator)} constructor.
		 */
		export class FontTypeface implements
			Eto.IHandlerSource {
			constructor(
				family: Eto.Drawing.FontFamily,
				handler: Eto.Drawing.FontTypeface.IHandler,
			);

			/**
			 * Creates a new instance of the FontTypeface from the specified font file on disk.
			 *
			 * Note that calling this multiple times for the same file may cause additional overhead
			 * or unpredictable results,  so you should keep a copy of it in memory when you want to
			 * use it.
			 */
			constructor(fileName: string);

			/**
			 * Creates a new instance of the FontTypeface from a font in the specified stream.
			 *
			 * Note that calling this multiple times for the same stream may cause additional
			 * overhead or unpredictable results,  so you should keep a copy of it in memory when you
			 * want to use it.
			 */
			constructor(stream: Duplex);

			/** Gets the family of this typeface */
			readonly Family: Eto.Drawing.FontFamily;

			/**
			 * Gets the name of this typeface
			 *
			 * The name of the typeface typically includes hints to the style of the type
			 */
			readonly Name: string;

			/**
			 * Gets the localized name of this typeface
			 *
			 * This will return a name suitable to display to the user in their own language, if the
			 * font provides a specific name for their UI language.  For platforms that do not
			 * support localized font names, or for fonts that do not have a specific name for the
			 * current language, the value of {@link Eto.Drawing.FontTypeface.Name} will be returned.
			 */
			readonly LocalizedName: string;

			/**
			 * Gets the style of this typeface
			 *
			 * This style does not fully describe the characteristics of the typeface, just very
			 * broad characteristics.
			 */
			readonly FontStyle: Eto.Drawing.FontStyle;

			/** Gets a value indicating that this font typeface has a bold style */
			readonly Bold: boolean;

			/** Gets a value indicating that this font typeface has an italic style */
			readonly Italic: boolean;

			/**
			 * Gets a value indicating that this font is a symbol font and not generally used for
			 * text
			 *
			 * Some platforms (e.g. Gtk) might not support this and simply return false for all
			 * fonts.
			 */
			readonly IsSymbol: boolean;

			/**
			 * Gets the platform that was used to create the {@link Eto.Widget.Handler} for this
			 * widget
			 *
			 * This gets set to the current {@link Eto.Platform.Instance} during the construction of
			 * the object
			 */
			readonly Platform: Eto.Platform;

			/** Gets the platform-specific handler for this widget */
			Handler: unknown;

			/** Gets the native platform-specific handle for integration purposes */
			readonly NativeHandle: unknown;

			/** Gets the dictionary of properties for this widget */
			readonly Properties: Eto.PropertyStore;

			/** Gets or sets the ID of this widget */
			ID: string;

			/**
			 * Gets or sets the style of this widget
			 *
			 * Styles allow you to attach custom platform-specific logic to a widget. In your
			 * platform-specific assembly, use {@link Style.Add{H}(string, StyleHandler{H})} to add
			 * the style logic with the same id.
			 */
			Style: string;

			/**
			 * Gets the instance of the platform-specific object
			 *
			 * This can sometimes be useful to get the platform-specific object. Some handlers may
			 * not have any backing object for its functionality, so this may be null.  It is more
			 * preferred to use the {@link Eto.Widget.Handler} and cast that to the platform-specific
			 * handler class which can give you additional methods and helpers to do common tasks.
			 * For example, the {@link Eto.Forms.Application} object's handler for OS X has a
			 * AddFullScreenMenuItem property to specify if you want full screen support in your app.
			 */
			readonly ControlObject: unknown;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Widget} has been disposed.
			 *
			 * When the widget is disposed, it can no longer be used.
			 */
			IsDisposed: boolean;

			/** Gets a string representation of this typeface */
			ToString(): string;

			/**
			 * Tests this instance for equality with another font typeface
			 *
			 * Font typefaces are considered equal if the names are the same
			 */
			Equals(other: Eto.Drawing.FontTypeface): boolean;

			/** Gets the hash code for this instance */
			GetHashCode(): number;

			/** Tests if this instance is equal to the specified object */
			Equals(obj: unknown): boolean;

			/** Gets a value indicating that this font supports the character range specified */
			HasCharacterRange(
				start: number,
				end: number,
			): boolean;

			/** Gets a value indicating that this font supports the character range specified */
			HasCharacterRange(range: Eto.Forms.Range$1<number>): boolean;

			/** Gets a value indicating that this font supports the character ranges specified */
			HasCharacterRanges(ranges: Iterable<Eto.Forms.Range$1<number>>): boolean;

			/** Disposes of this widget, supressing the finalizer */
			dispose(): void;
		}
	}

	export namespace Eto.Drawing.FontTypeface {
		export interface IHandler extends Eto.Widget.IHandler {
			readonly Name: string;

			readonly LocalizedName: string;

			readonly FontStyle: Eto.Drawing.FontStyle;

			readonly IsSymbol: boolean;

			readonly Family: Eto.Drawing.FontFamily;

			Create(family: Eto.Drawing.FontFamily): void;

			Create(stream: Duplex): void;

			Create(fileName: string): void;

			HasCharacterRanges(ranges: Iterable<Eto.Forms.Range$1<number>>): boolean;
		}
	}

	export namespace Eto.Drawing {
		/** Trimming mode for the {@link Eto.Drawing.FormattedText}. */
		export enum FormattedTextTrimming {
			/**
			 * No trimming. Text will be clipped to the
			 * {@link Eto.Drawing.FormattedText.MaximumSize}.
			 */
			None = 0,

			/**
			 * Show an ellipsis after the last visible character, but not extending beyond the
			 * maximum size.
			 */
			CharacterEllipsis = 1,

			/**
			 * Specify that the ellipsis should be shown after the last complete word
			 *
			 * Note that some platforms may not support this and fallback to character ellipsis (E.g.
			 * Mac and Gtk).
			 */
			WordEllipsis = 2,
		}
	}

	export namespace Eto.Drawing {
		/** Wrap mode for the {@link Eto.Drawing.FormattedText}. */
		export enum FormattedTextWrapMode {
			/**
			 * No wrapping.  Text will be clipped to the
			 * {@link Eto.Drawing.FormattedText.MaximumWidth}.
			 */
			None = 0,

			/** Wrap on the word boundaries. */
			Word = 1,

			/**
			 * Wrap text at the character boundaries.
			 *
			 * Note that some platforms may not support this and will fallback to word wrapping (E.g.
			 * Wpf).
			 */
			Character = 2,
		}
	}

	export namespace Eto.Drawing {
		/** Alignment mode for the {@link Eto.Drawing.FormattedText} */
		export enum FormattedTextAlignment {
			/** Left justified text */
			Left = 0,

			/** Right justified text */
			Right = 1,

			/** Center justified text */
			Center = 2,

			/** Justified to both the right and left. */
			Justify = 3,
		}
	}

	export namespace Eto.Drawing {
		/** Low level object that provides drawing text with formatting. */
		export class FormattedText implements
			Eto.IHandlerSource {
			constructor();

			/**
			 * Gets or sets the wrapping mode.
			 *
			 * Note that not all platforms support all modes and may fall back to a different mode.
			 */
			Wrap: Eto.Drawing.FormattedTextWrapMode;

			/**
			 * Gets or sets the trimming mode.
			 *
			 * Note that not all platforms support all modes and may fall back to a different mode.
			 */
			Trimming: Eto.Drawing.FormattedTextTrimming;

			/**
			 * Gets or sets how the text should be aligned to
			 * {@link Eto.Drawing.FormattedText.MaximumSize}
			 */
			Alignment: Eto.Drawing.FormattedTextAlignment;

			/** Gets or sets the font to use to draw the text. */
			Font: Eto.Drawing.Font;

			/** Gets or sets the text to display */
			Text: string;

			/**
			 * Gets or sets the maximum width of the text.
			 *
			 * The width is used when wrapping, trimming, and aligning the text.
			 */
			MaximumWidth: number;

			/**
			 * Gets or sets the maximum height of the text.
			 *
			 * The height is used when trimming the text. Only the last full visible line will be
			 * visible.
			 */
			MaximumHeight: number;

			/**
			 * Gets or sets the maximum size of the text.
			 *
			 * The width is used when wrapping, trimming, and aligning the text. The height is used
			 * when trimming the text. Only the last full visible line will be visible.
			 */
			MaximumSize: Eto.Drawing.SizeF;

			/** Gets or sets the brush to use to draw the text. */
			ForegroundBrush: Eto.Drawing.Brush;

			/**
			 * Gets the platform that was used to create the {@link Eto.Widget.Handler} for this
			 * widget
			 *
			 * This gets set to the current {@link Eto.Platform.Instance} during the construction of
			 * the object
			 */
			readonly Platform: Eto.Platform;

			/** Gets the platform-specific handler for this widget */
			Handler: unknown;

			/** Gets the native platform-specific handle for integration purposes */
			readonly NativeHandle: unknown;

			/** Gets the dictionary of properties for this widget */
			readonly Properties: Eto.PropertyStore;

			/** Gets or sets the ID of this widget */
			ID: string;

			/**
			 * Gets or sets the style of this widget
			 *
			 * Styles allow you to attach custom platform-specific logic to a widget. In your
			 * platform-specific assembly, use {@link Style.Add{H}(string, StyleHandler{H})} to add
			 * the style logic with the same id.
			 */
			Style: string;

			/**
			 * Gets the instance of the platform-specific object
			 *
			 * This can sometimes be useful to get the platform-specific object. Some handlers may
			 * not have any backing object for its functionality, so this may be null.  It is more
			 * preferred to use the {@link Eto.Widget.Handler} and cast that to the platform-specific
			 * handler class which can give you additional methods and helpers to do common tasks.
			 * For example, the {@link Eto.Forms.Application} object's handler for OS X has a
			 * AddFullScreenMenuItem property to specify if you want full screen support in your app.
			 */
			readonly ControlObject: unknown;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Widget} has been disposed.
			 *
			 * When the widget is disposed, it can no longer be used.
			 */
			IsDisposed: boolean;

			/**
			 * Gets the size needed to draw the text.
			 *
			 * This may be smaller than the {@link Eto.Drawing.FormattedText.MaximumSize}.
			 */
			Measure(): Eto.Drawing.SizeF;

			/** Disposes of this widget, supressing the finalizer */
			dispose(): void;

			/** Gets a string that represents the current object with its ID if specified. */
			ToString(): string;
		}
	}

	export namespace Eto.Drawing.FormattedText {
		export interface IHandler extends Eto.Widget.IHandler {
			Wrap: Eto.Drawing.FormattedTextWrapMode;

			Trimming: Eto.Drawing.FormattedTextTrimming;

			Alignment: Eto.Drawing.FormattedTextAlignment;

			Font: Eto.Drawing.Font;

			Text: string;

			MaximumSize: Eto.Drawing.SizeF;

			ForegroundBrush: Eto.Drawing.Brush;

			Measure(): Eto.Drawing.SizeF;
		}
	}

	export namespace Eto.Drawing {
		/**
		 * Graphics context object for drawing operations
		 *
		 * This class allows you to draw on either a {@link Eto.Drawing.Bitmap} or a
		 * {@link Eto.Forms.Drawable} control.
		 */
		export class Graphics implements
			Eto.IHandlerSource {
			constructor(handler: Eto.Drawing.Graphics.IHandler);

			/**
			 * Initializes a new instance of the Generator class to draw on the given `image`
			 *
			 * To commit the changes to the Bitmap, the Graphics object must be disposed or used with
			 * a using block.
			 */
			constructor(image: Eto.Drawing.Bitmap);

			/** Gets or sets a value indicating that drawing operations will use anti-aliasing */
			AntiAlias: boolean;

			/** Gets or sets the interpolation mode for drawing images */
			ImageInterpolation: Eto.Drawing.ImageInterpolation;

			/**
			 * Gets the dots per inch of the current graphics context. Usually 96 for windows and 72
			 * for other systems
			 */
			readonly DPI: number;

			/**
			 * Gets the scale of points per pixel. Multiply by pixel size to get point value (e.g. to
			 * set font size in pixels).
			 *
			 * A value of 1.0 indicates that one point equals one pixel. Windows is usually 0.75 (96
			 * dpi) while other systems are usually 1.0 (e.g. linux, os x)
			 */
			readonly PointsPerPixel: number;

			/**
			 * Gets the scale of points to pixels. Multiply by point value to get pixel size
			 *
			 * A value of 1.0 indicates that one pixel equals one point. Windows is usually 1 1/3 (96
			 * dpi) while other systems are usually 1.0 (e.g. linux, os x)
			 */
			readonly PixelsPerPoint: number;

			/** Gets or sets the pixel offset mode for draw operations */
			PixelOffsetMode: Eto.Drawing.PixelOffsetMode;

			/**
			 * Gets a value indicating the graphics sub-system is a retained system (e.g. WPF)
			 *
			 * Retained mode systems may have different behaviour characteristics, which may impact
			 * how often the screen is updated or other code.
			 */
			readonly IsRetained: boolean;

			/**
			 * Gets a copy of the current transform.
			 *
			 * The current transform is initially an identity matrix. Any transform operations
			 * performed on this object will change this value.
			 */
			readonly CurrentTransform: Eto.Drawing.IMatrix;

			/**
			 * Gets the bounds of the clipping region
			 *
			 * This rectangle will encompass all parts of the clipping region, which may not be
			 * rectangular in shape
			 */
			readonly ClipBounds: Eto.Drawing.RectangleF;

			/**
			 * Gets the platform that was used to create the {@link Eto.Widget.Handler} for this
			 * widget
			 *
			 * This gets set to the current {@link Eto.Platform.Instance} during the construction of
			 * the object
			 */
			readonly Platform: Eto.Platform;

			/** Gets the platform-specific handler for this widget */
			Handler: unknown;

			/** Gets the native platform-specific handle for integration purposes */
			readonly NativeHandle: unknown;

			/** Gets the dictionary of properties for this widget */
			readonly Properties: Eto.PropertyStore;

			/** Gets or sets the ID of this widget */
			ID: string;

			/**
			 * Gets or sets the style of this widget
			 *
			 * Styles allow you to attach custom platform-specific logic to a widget. In your
			 * platform-specific assembly, use {@link Style.Add{H}(string, StyleHandler{H})} to add
			 * the style logic with the same id.
			 */
			Style: string;

			/**
			 * Gets the instance of the platform-specific object
			 *
			 * This can sometimes be useful to get the platform-specific object. Some handlers may
			 * not have any backing object for its functionality, so this may be null.  It is more
			 * preferred to use the {@link Eto.Widget.Handler} and cast that to the platform-specific
			 * handler class which can give you additional methods and helpers to do common tasks.
			 * For example, the {@link Eto.Forms.Application} object's handler for OS X has a
			 * AddFullScreenMenuItem property to specify if you want full screen support in your app.
			 */
			readonly ControlObject: unknown;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Widget} has been disposed.
			 *
			 * When the widget is disposed, it can no longer be used.
			 */
			IsDisposed: boolean;

			/** Draws a 1 pixel wide line with the specified `color` */
			DrawLine(
				color: Eto.Drawing.Color,
				start: Eto.Drawing.PointF,
				end: Eto.Drawing.PointF,
			): void;

			/** Draws a line with the specified `pen` */
			DrawLine(
				pen: Eto.Drawing.Pen,
				start: Eto.Drawing.PointF,
				end: Eto.Drawing.PointF,
			): void;

			/** Draws a 1 pixel wide line with the specified `color` */
			DrawLine(
				color: Eto.Drawing.Color,
				startx: number,
				starty: number,
				endx: number,
				endy: number,
			): void;

			/** Draws a line with the specified `pen` */
			DrawLine(
				pen: Eto.Drawing.Pen,
				startx: number,
				starty: number,
				endx: number,
				endy: number,
			): void;

			/** Draws a rectangle */
			DrawRectangle(
				pen: Eto.Drawing.Pen,
				x: number,
				y: number,
				width: number,
				height: number,
			): void;

			/** Draws a 1 pixel wide outline of a rectangle with the specified `color` */
			DrawRectangle(
				color: Eto.Drawing.Color,
				rectangle: Eto.Drawing.RectangleF,
			): void;

			/** Draws a 1 pixel wide outline of a rectangle with the specified `color` */
			DrawRectangle(
				color: Eto.Drawing.Color,
				x: number,
				y: number,
				width: number,
				height: number,
			): void;

			/** Draws a rectangle */
			DrawRectangle(
				pen: Eto.Drawing.Pen,
				rectangle: Eto.Drawing.RectangleF,
			): void;

			/**
			 * Draws an rectangle with colors on the top/left and bottom/right with the given `width`
			 */
			DrawInsetRectangle(
				topLeftColor: Eto.Drawing.Color,
				bottomRightColor: Eto.Drawing.Color,
				rectangle: Eto.Drawing.RectangleF,
				width?: number,
			): void;

			/** Fills a rectangle with the specified `color` */
			FillRectangle(
				color: Eto.Drawing.Color,
				x: number,
				y: number,
				width: number,
				height: number,
			): void;

			/** Fills a rectangle with the specified `brush` */
			FillRectangle(
				brush: Eto.Drawing.Brush,
				x: number,
				y: number,
				width: number,
				height: number,
			): void;

			/** Fills a rectangle with the specified `color` */
			FillRectangle(
				color: Eto.Drawing.Color,
				rectangle: Eto.Drawing.RectangleF,
			): void;

			/** Fills a rectangle with the specified `brush` */
			FillRectangle(
				brush: Eto.Drawing.Brush,
				rectangle: Eto.Drawing.RectangleF,
			): void;

			/** Fills the specified `rectangles` */
			FillRectangles(
				color: Eto.Drawing.Color,
				rectangles: Iterable<Eto.Drawing.RectangleF>,
			): void;

			/** Fills the specified `rectangles` */
			FillRectangles(
				brush: Eto.Drawing.Brush,
				rectangles: Iterable<Eto.Drawing.RectangleF>,
			): void;

			/** Fills an ellipse with the specified `color` */
			FillEllipse(
				color: Eto.Drawing.Color,
				rectangle: Eto.Drawing.RectangleF,
			): void;

			/** Fills an ellipse with the specified `brush` */
			FillEllipse(
				brush: Eto.Drawing.Brush,
				rectangle: Eto.Drawing.RectangleF,
			): void;

			/** Fills an ellipse with the specified `color` */
			FillEllipse(
				color: Eto.Drawing.Color,
				x: number,
				y: number,
				width: number,
				height: number,
			): void;

			/** Fills an ellipse with the specified `brush` */
			FillEllipse(
				brush: Eto.Drawing.Brush,
				x: number,
				y: number,
				width: number,
				height: number,
			): void;

			/** Draws a 1 pixel wide ellipse outline with the specified `color` */
			DrawEllipse(
				color: Eto.Drawing.Color,
				rectangle: Eto.Drawing.RectangleF,
			): void;

			/** Draws an ellipse outline with the specified `pen` */
			DrawEllipse(
				pen: Eto.Drawing.Pen,
				rectangle: Eto.Drawing.RectangleF,
			): void;

			/** Draws a 1 pixel wide ellipse outline with the specified `color` */
			DrawEllipse(
				color: Eto.Drawing.Color,
				x: number,
				y: number,
				width: number,
				height: number,
			): void;

			/** Draws an ellipse with the specified `pen` */
			DrawEllipse(
				pen: Eto.Drawing.Pen,
				x: number,
				y: number,
				width: number,
				height: number,
			): void;

			/** Draws a 1 pixel wide arc with the specified `color` */
			DrawArc(
				color: Eto.Drawing.Color,
				rectangle: Eto.Drawing.RectangleF,
				startAngle: number,
				sweepAngle: number,
			): void;

			/** Draws an arc with the specified `pen` */
			DrawArc(
				pen: Eto.Drawing.Pen,
				rectangle: Eto.Drawing.RectangleF,
				startAngle: number,
				sweepAngle: number,
			): void;

			/** Draws a 1 pixel wide arc with the specified `color` */
			DrawArc(
				color: Eto.Drawing.Color,
				x: number,
				y: number,
				width: number,
				height: number,
				startAngle: number,
				sweepAngle: number,
			): void;

			/** Draws an arc with the specified `pen` */
			DrawArc(
				pen: Eto.Drawing.Pen,
				x: number,
				y: number,
				width: number,
				height: number,
				startAngle: number,
				sweepAngle: number,
			): void;

			/** Fills a pie with the specified `color` */
			FillPie(
				color: Eto.Drawing.Color,
				rectangle: Eto.Drawing.RectangleF,
				startAngle: number,
				sweepAngle: number,
			): void;

			/** Fills a pie with the specified `brush` */
			FillPie(
				brush: Eto.Drawing.Brush,
				rectangle: Eto.Drawing.RectangleF,
				startAngle: number,
				sweepAngle: number,
			): void;

			/** Fills a pie with the specified `color` */
			FillPie(
				color: Eto.Drawing.Color,
				x: number,
				y: number,
				width: number,
				height: number,
				startAngle: number,
				sweepAngle: number,
			): void;

			/** Fills a pie with the specified `brush` */
			FillPie(
				brush: Eto.Drawing.Brush,
				x: number,
				y: number,
				width: number,
				height: number,
				startAngle: number,
				sweepAngle: number,
			): void;

			/** Fills a polygon defined by `points` with the specified `color` */
			FillPolygon(
				color: Eto.Drawing.Color,
				points: Eto.Drawing.PointF[],
			): void;

			/** Fills a polygon defined by `points` with the specified `brush` */
			FillPolygon(
				brush: Eto.Drawing.Brush,
				points: Eto.Drawing.PointF[],
			): void;

			/** Draws a 1 pixel wide outline of a polygon with the specified `points` */
			DrawPolygon(
				color: Eto.Drawing.Color,
				points: Eto.Drawing.PointF[],
			): void;

			/** Draws an outline of a polygon with the specified `points` */
			DrawPolygon(
				pen: Eto.Drawing.Pen,
				points: Eto.Drawing.PointF[],
			): void;

			/** Draws a 1 pixel wide set of lines with the specified `points` */
			DrawLines(
				color: Eto.Drawing.Color,
				points: Eto.Drawing.PointF[],
			): void;

			/** Draws a 1 pixel wide set of lines with the specified `points` */
			DrawLines(
				color: Eto.Drawing.Color,
				points: Iterable<Eto.Drawing.PointF>,
			): void;

			/** Draws a set of lines with the specified `points` */
			DrawLines(
				pen: Eto.Drawing.Pen,
				points: Eto.Drawing.PointF[],
			): void;

			/** Draws a set of lines with the specified `points` */
			DrawLines(
				pen: Eto.Drawing.Pen,
				points: Iterable<Eto.Drawing.PointF>,
			): void;

			/** Draws a 1 pixel outline of the specified `path` */
			DrawPath(
				color: Eto.Drawing.Color,
				path: Eto.Drawing.IGraphicsPath,
			): void;

			/** Draws the specified `path` */
			DrawPath(
				pen: Eto.Drawing.Pen,
				path: Eto.Drawing.IGraphicsPath,
			): void;

			/** Fills the specified `path` */
			FillPath(
				color: Eto.Drawing.Color,
				path: Eto.Drawing.IGraphicsPath,
			): void;

			/** Fills the specified `path` */
			FillPath(
				brush: Eto.Drawing.Brush,
				path: Eto.Drawing.IGraphicsPath,
			): void;

			/** Draws the specified `image` at a location with no scaling */
			DrawImage(
				image: Eto.Drawing.Image,
				location: Eto.Drawing.PointF,
			): void;

			/** Draws the specified `image` at a location with no scaling */
			DrawImage(
				image: Eto.Drawing.Image,
				x: number,
				y: number,
			): void;

			/**
			 * Draws the specified `image` in a rectangle
			 *
			 * This will scale the image to the specified width and height using the
			 * {@link Eto.Drawing.Graphics.ImageInterpolation} mode
			 */
			DrawImage(
				image: Eto.Drawing.Image,
				x: number,
				y: number,
				width: number,
				height: number,
			): void;

			/**
			 * Draws the specified `image` in a rectangle
			 *
			 * This will scale the image to the specified width and height using the
			 * {@link Eto.Drawing.Graphics.ImageInterpolation} mode
			 */
			DrawImage(
				image: Eto.Drawing.Image,
				rectangle: Eto.Drawing.RectangleF,
			): void;

			/** Draws the `source` portion of an `image`, scaling to the specified `destination` */
			DrawImage(
				image: Eto.Drawing.Image,
				source: Eto.Drawing.RectangleF,
				destination: Eto.Drawing.PointF,
			): void;

			/** Draws the `source` portion of an `image`, scaling to the specified `destination` */
			DrawImage(
				image: Eto.Drawing.Image,
				source: Eto.Drawing.RectangleF,
				destination: Eto.Drawing.RectangleF,
			): void;

			/** Draws text with the specified `font`, `brush` and location */
			DrawText(
				font: Eto.Drawing.Font,
				brush: Eto.Drawing.SolidBrush,
				x: number,
				y: number,
				text: string,
			): void;

			/** Draws text with the specified `font`, `brush` and location */
			DrawText(
				font: Eto.Drawing.Font,
				brush: Eto.Drawing.Brush,
				x: number,
				y: number,
				text: string,
			): void;

			/** Draws text with the specified `font`, `color` and location */
			DrawText(
				font: Eto.Drawing.Font,
				color: Eto.Drawing.Color,
				x: number,
				y: number,
				text: string,
			): void;

			/** Draws text with the specified `font`, `brush` and location */
			DrawText(
				font: Eto.Drawing.Font,
				brush: Eto.Drawing.SolidBrush,
				location: Eto.Drawing.PointF,
				text: string,
			): void;

			/** Draws text with the specified `font`, `brush` and location */
			DrawText(
				font: Eto.Drawing.Font,
				brush: Eto.Drawing.Brush,
				location: Eto.Drawing.PointF,
				text: string,
			): void;

			/** Draws text with the specified `font`, `color` and location */
			DrawText(
				font: Eto.Drawing.Font,
				color: Eto.Drawing.Color,
				location: Eto.Drawing.PointF,
				text: string,
			): void;

			/** Draws text in a rectangle with the specified formatted text trimming */
			DrawText(
				font: Eto.Drawing.Font,
				brush: Eto.Drawing.Brush,
				frame: Eto.Drawing.RectangleF,
				text: string,
				wrap?: Eto.Drawing.FormattedTextWrapMode,
				alignment?: Eto.Drawing.FormattedTextAlignment,
				trimming?: Eto.Drawing.FormattedTextTrimming,
			): void;

			/** Draws formatted text at the specified location */
			DrawText(
				formattedText: Eto.Drawing.FormattedText,
				location: Eto.Drawing.PointF,
			): void;

			/** Measures the string with the given `font` */
			MeasureString(
				font: Eto.Drawing.Font,
				text: string,
			): Eto.Drawing.SizeF;

			/**
			 * Flushes the drawing (for some platforms)
			 *
			 * Flushing the drawing will force any undrawn changes to be shown to the user.
			 * Typically when you are doing a lot of drawing, you may want to flush the changed
			 * periodically so that the user does not think the UI is unresponsive.  Some platforms
			 * may not have the concept of flushing the graphics, so this would do nothing
			 */
			Flush(): void;

			/** Translates the origin of the co-ordinate system by the given offset */
			TranslateTransform(
				offsetX: number,
				offsetY: number,
			): void;

			/** Translates the origin of the co-ordinate system by the given offset */
			TranslateTransform(offset: Eto.Drawing.PointF): void;

			/** Rotates the co-ordinate system by the given `angle` */
			RotateTransform(angle: number): void;

			/** Scales the co-ordinate system by a factor */
			ScaleTransform(scale: Eto.Drawing.SizeF): void;

			/** Scales the co-ordinate system by a factor */
			ScaleTransform(
				scaleX: number,
				scaleY: number,
			): void;

			/** Scales the co-ordinate system by a factor */
			ScaleTransform(scale: number): void;

			/** Multiplies the co-ordinate system with the given `matrix` */
			MultiplyTransform(matrix: Eto.Drawing.IMatrix): void;

			/**
			 * Gets an object that will restore to the current transform state when disposed.
			 *
			 * This saves the current transform state that can be changed by any of the transform
			 * calls.  This is useful when calling into untrusted code that can leave the transform
			 * unbalanced. It also ensures that RestoreTransform() requires a matching
			 * SaveTransform(), until the return value is disposed. Disposing the return value
			 * guarantees that the transform state is restored to when this method was called.
			 */
			SaveTransformState(): IDisposable;

			/**
			 * Saves the current transform state
			 *
			 * This saves the current transform state that can be changed by any of the transform
			 * calls, which can then be restored using {@link Eto.Drawing.Graphics.RestoreTransform}
			 */
			SaveTransform(): void;

			/**
			 * Restores the transform state
			 *
			 * This restores the transform state from a previous
			 * {@link Eto.Drawing.Graphics.SaveTransform} call. You must balance calls to
			 * SaveTransform() with calls to this method.
			 */
			RestoreTransform(): void;

			/**
			 * Sets the clip region to the specified `rectangle`
			 *
			 * The previous clipping region will be cleared after this call. The rectangle specified
			 * is translated by the current transform, but is not affected by subsequent transform
			 * operations.
			 */
			SetClip(rectangle: Eto.Drawing.RectangleF): void;

			/**
			 * Sets the clip region to the specified `path`
			 *
			 * The previous clipping region will be cleared after this call The path specified is
			 * translated by the current transform, but is not affected by subsequent transform
			 * operations.
			 */
			SetClip(path: Eto.Drawing.IGraphicsPath): void;

			/** Resets the clip bounds to encompass the entire drawing area */
			ResetClip(): void;

			/** Returns true if the clip region intersects the specified rectangle. */
			IsVisible(rectangle: Eto.Drawing.RectangleF): boolean;

			/**
			 * Resets all pixels in the {@link Eto.Drawing.Graphics.ClipBounds} region with the
			 * specified `brush`
			 */
			Clear(brush?: Eto.Drawing.SolidBrush): void;

			/**
			 * Resets all pixels in the {@link Eto.Drawing.Graphics.ClipBounds} region with the
			 * specified `color`
			 */
			Clear(color: Eto.Drawing.Color): void;

			/** Disposes of this widget, supressing the finalizer */
			dispose(): void;

			/** Gets a string that represents the current object with its ID if specified. */
			ToString(): string;
		}
	}

	export namespace Eto.Drawing.Graphics {
		export interface IHandler extends Eto.Widget.IHandler {
			readonly PointsPerPixel: number;

			PixelOffsetMode: Eto.Drawing.PixelOffsetMode;

			AntiAlias: boolean;

			ImageInterpolation: Eto.Drawing.ImageInterpolation;

			readonly IsRetained: boolean;

			readonly CurrentTransform: Eto.Drawing.IMatrix;

			readonly ClipBounds: Eto.Drawing.RectangleF;

			CreateFromImage(image: Eto.Drawing.Bitmap): void;

			DrawLine(
				pen: Eto.Drawing.Pen,
				startx: number,
				starty: number,
				endx: number,
				endy: number,
			): void;

			DrawLines(
				pen: Eto.Drawing.Pen,
				points: Iterable<Eto.Drawing.PointF>,
			): void;

			DrawPolygon(
				pen: Eto.Drawing.Pen,
				points: Iterable<Eto.Drawing.PointF>,
			): void;

			DrawRectangle(
				pen: Eto.Drawing.Pen,
				x: number,
				y: number,
				width: number,
				height: number,
			): void;

			FillRectangle(
				brush: Eto.Drawing.Brush,
				x: number,
				y: number,
				width: number,
				height: number,
			): void;

			FillEllipse(
				brush: Eto.Drawing.Brush,
				x: number,
				y: number,
				width: number,
				height: number,
			): void;

			DrawEllipse(
				pen: Eto.Drawing.Pen,
				x: number,
				y: number,
				width: number,
				height: number,
			): void;

			DrawArc(
				pen: Eto.Drawing.Pen,
				x: number,
				y: number,
				width: number,
				height: number,
				startAngle: number,
				sweepAngle: number,
			): void;

			FillPie(
				brush: Eto.Drawing.Brush,
				x: number,
				y: number,
				width: number,
				height: number,
				startAngle: number,
				sweepAngle: number,
			): void;

			FillPath(
				brush: Eto.Drawing.Brush,
				path: Eto.Drawing.IGraphicsPath,
			): void;

			DrawPath(
				pen: Eto.Drawing.Pen,
				path: Eto.Drawing.IGraphicsPath,
			): void;

			DrawImage(
				image: Eto.Drawing.Image,
				x: number,
				y: number,
			): void;

			DrawImage(
				image: Eto.Drawing.Image,
				x: number,
				y: number,
				width: number,
				height: number,
			): void;

			DrawImage(
				image: Eto.Drawing.Image,
				source: Eto.Drawing.RectangleF,
				destination: Eto.Drawing.RectangleF,
			): void;

			DrawText(
				font: Eto.Drawing.Font,
				brush: Eto.Drawing.Brush,
				x: number,
				y: number,
				text: string,
			): void;

			DrawText(
				formattedText: Eto.Drawing.FormattedText,
				location: Eto.Drawing.PointF,
			): void;

			MeasureString(
				font: Eto.Drawing.Font,
				text: string,
			): Eto.Drawing.SizeF;

			Flush(): void;

			TranslateTransform(
				offsetX: number,
				offsetY: number,
			): void;

			RotateTransform(angle: number): void;

			ScaleTransform(
				scaleX: number,
				scaleY: number,
			): void;

			MultiplyTransform(matrix: Eto.Drawing.IMatrix): void;

			SaveTransform(): void;

			RestoreTransform(): void;

			SetClip(rectangle: Eto.Drawing.RectangleF): void;

			SetClip(path: Eto.Drawing.IGraphicsPath): void;

			ResetClip(): void;

			Clear(brush: Eto.Drawing.SolidBrush): void;
		}
	}

	export namespace Eto.Drawing {
		/**
		 * Graphics path to be used for drawing or filling using a {@link Eto.Drawing.Graphics}
		 * object
		 *
		 * A graphics path can contain multiple figures comprised of various components such as
		 * line, arc, curve, etc.
		 */
		export interface IGraphicsPath extends Eto.IControlObjectSource {
			/** Gets the bounding rectangle for this path */
			readonly Bounds: Eto.Drawing.RectangleF;

			/** Gets or sets a value indicating how this graphics path should be filled. */
			FillMode: Eto.Drawing.FillMode;

			/** Gets a value indicating that this graphics path is empty and has no segments */
			readonly IsEmpty: boolean;

			/**
			 * Gets the current point
			 *
			 * If the current figure in the path is not closed, and
			 * {@link Eto.Drawing.IGraphicsPath.StartFigure} is not called, the next segment will be
			 * connected from this point to its start point.
			 */
			readonly CurrentPoint: Eto.Drawing.PointF;

			/**
			 * Adds a line to the path with the specified start and end points
			 *
			 * If the current figure is not closed, it will connect with the start of this line. The
			 * current position will be moved to the specified end location.
			 */
			AddLine(
				startX: number,
				startY: number,
				endX: number,
				endY: number,
			): void;

			/**
			 * Adds lines to each of the specified `points` to the path
			 *
			 * If the current figure is not closed, it will connect with the first point specified.
			 * The current position will be moved to the last point specified
			 */
			AddLines(points: Iterable<Eto.Drawing.PointF>): void;

			/** Adds a line from the current position to the specified location */
			LineTo(
				x: number,
				y: number,
			): void;

			/**
			 * Moves the current position to the specified location without adding anything to the
			 * path
			 */
			MoveTo(
				x: number,
				y: number,
			): void;

			/**
			 * Adds an arc into the specified rectangle
			 *
			 * If the current figure is not closed, it will connect with the start of the arc. The
			 * current position will be moved to the ending point of the arc
			 */
			AddArc(
				x: number,
				y: number,
				width: number,
				height: number,
				startAngle: number,
				sweepAngle: number,
			): void;

			/**
			 * Adds a bezier curve to the path with two control points
			 *
			 * If the current figure is not closed, it will connect with the `start` of the bezier
			 * curve. The current position will be moved to the `end` point.
			 */
			AddBezier(
				start: Eto.Drawing.PointF,
				control1: Eto.Drawing.PointF,
				control2: Eto.Drawing.PointF,
				end: Eto.Drawing.PointF,
			): void;

			/**
			 * Adds a curve that intersects with the specified `points` to the path
			 *
			 * Each point in the list will fall on the line based on the `tension` parameter
			 */
			AddCurve(
				points: Iterable<Eto.Drawing.PointF>,
				tension?: number,
			): void;

			/**
			 * Adds an ellipse to the path
			 *
			 * Rectangles are separate figures and will not connect to the current or next figure in
			 * the path. The starting point of the path will no longer be set after this call.
			 */
			AddEllipse(
				x: number,
				y: number,
				width: number,
				height: number,
			): void;

			/**
			 * Adds a rectangle to the path
			 *
			 * Rectangles are separate figures and will not connect to the current or next figure in
			 * the path. The starting point of the path will no longer be set after this call.
			 */
			AddRectangle(
				x: number,
				y: number,
				width: number,
				height: number,
			): void;

			/**
			 * Adds the specified `path` to the current path, optionally connecting the current
			 * figure to the start of the path
			 *
			 * The `connect` parameter only specifies that the path should be connected to the
			 * current path at the beginning. The end of the specified path will always be connected
			 * to the next segment added to this path, unlesss
			 * {@link Eto.Drawing.IGraphicsPath.CloseFigure} or
			 * {@link Eto.Drawing.IGraphicsPath.StartFigure} are called after this.
			 */
			AddPath(
				path: Eto.Drawing.IGraphicsPath,
				connect?: boolean,
			): void;

			/** Transforms the points in the path with the specified matrix */
			Transform(matrix: Eto.Drawing.IMatrix): void;

			/**
			 * Starts a new figure without closing the current figure
			 *
			 * This will make the next segment added to the path independent (unconnected) to the
			 * last segment.
			 */
			StartFigure(): void;

			/**
			 * Closes the current figure by connecting a line to the beginning of the figure
			 *
			 * This will also make the next segment added to the path start independently from the
			 * last figure. To start a new figure without closing the current one, use
			 * {@link Eto.Drawing.IGraphicsPath.StartFigure}
			 */
			CloseFigure(): void;

			/** Creates a clone of the graphics path */
			Clone(): Eto.Drawing.IGraphicsPath;

			/**
			 * Gets a value indicating that the specified `point` is contained by the path when
			 * filled
			 */
			FillContains(point: Eto.Drawing.PointF): boolean;

			/**
			 * Gets a value indicating that the spedified `point` is on the path when stroked with
			 * the specified `pen`
			 */
			StrokeContains(
				pen: Eto.Drawing.Pen,
				point: Eto.Drawing.PointF,
			): boolean;
		}
	}

	export namespace Eto.Drawing {
		/** Extensions for the {@link Eto.Drawing.IGraphicsPath} */
		export namespace GraphicsPathExtensions {
			/**
			 * Moves the current position to the specified `point` without adding anything to the
			 * path
			 */
			export function MoveTo(
				path: Eto.Drawing.IGraphicsPath,
				point: Eto.Drawing.PointF,
			): void;

			/** Adds a line from the current position to the specified location */
			export function LineTo(
				path: Eto.Drawing.IGraphicsPath,
				point: Eto.Drawing.PointF,
			): void;

			/** Adds lines to each of the specified `points` */
			export function AddLines(
				path: Eto.Drawing.IGraphicsPath,
				points: Eto.Drawing.PointF[],
			): void;

			/** Adds a line to the path */
			export function AddLine(
				path: Eto.Drawing.IGraphicsPath,
				start: Eto.Drawing.PointF,
				end: Eto.Drawing.PointF,
			): void;

			/** Adds an arc to the path at the specified `location` */
			export function AddArc(
				path: Eto.Drawing.IGraphicsPath,
				location: Eto.Drawing.RectangleF,
				startAngle: number,
				sweepAngle: number,
			): void;

			/** Adds a curve that intersects with the specified `points` to the path */
			export function AddCurve(
				path: Eto.Drawing.IGraphicsPath,
				points: Eto.Drawing.PointF[],
			): void;

			/**
			 * Adds a curve that intersects with the specified `points` to the path with the given
			 * `tension`
			 */
			export function AddCurve(
				path: Eto.Drawing.IGraphicsPath,
				tension: number,
				points: Eto.Drawing.PointF[],
			): void;

			/** Adds an ellipse to the path at the specified `location` */
			export function AddEllipse(
				path: Eto.Drawing.IGraphicsPath,
				location: Eto.Drawing.RectangleF,
			): void;

			/** Adds a rectangle to the path at the specified `location` */
			export function AddRectangle(
				path: Eto.Drawing.IGraphicsPath,
				location: Eto.Drawing.RectangleF,
			): void;
		}
	}

	export namespace Eto.Drawing {
		/** Extension methods from {@link Eto.Drawing.GraphicsPathExtensions} */
		export interface IGraphicsPath {
			/**
			 * Moves the current position to the specified `point` without adding anything to the
			 * path
			 */
			MoveTo(point: Eto.Drawing.PointF): void;

			/** Adds a line from the current position to the specified location */
			LineTo(point: Eto.Drawing.PointF): void;

			/** Adds lines to each of the specified `points` */
			AddLines(points: Eto.Drawing.PointF[]): void;

			/** Adds a line to the path */
			AddLine(
				start: Eto.Drawing.PointF,
				end: Eto.Drawing.PointF,
			): void;

			/** Adds an arc to the path at the specified `location` */
			AddArc(
				location: Eto.Drawing.RectangleF,
				startAngle: number,
				sweepAngle: number,
			): void;

			/** Adds a curve that intersects with the specified `points` to the path */
			AddCurve(points: Eto.Drawing.PointF[]): void;

			/**
			 * Adds a curve that intersects with the specified `points` to the path with the given
			 * `tension`
			 */
			AddCurve(
				tension: number,
				points: Eto.Drawing.PointF[],
			): void;

			/** Adds an ellipse to the path at the specified `location` */
			AddEllipse(location: Eto.Drawing.RectangleF): void;

			/** Adds a rectangle to the path at the specified `location` */
			AddRectangle(location: Eto.Drawing.RectangleF): void;
		}
	}

	export namespace Eto.Drawing {
		/**
		 * Defines primitives that can be used to draw or fill a path on a
		 * {@link Eto.Drawing.Graphics} object
		 *
		 * This is a thin wrapper around the {@link Eto.Drawing.IGraphicsPath} interface, which
		 * is created via {@link Eto.Drawing.GraphicsPath.Create}.
		 */
		export class GraphicsPath {
			/** Initializes a new instance of the GraphicsPath class */
			constructor();

			/** Initializes a new instance of the {@link Eto.Drawing.GraphicsPath} class. */
			constructor(handler: Eto.Drawing.IGraphicsPath);

			/** Gets the bounding rectangle for this path */
			readonly Bounds: Eto.Drawing.RectangleF;

			/** Sets a value indicating how this graphics path should be filled. */
			FillMode: Eto.Drawing.FillMode;

			/** Gets a value indicating that this graphics path is empty and has no segments */
			readonly IsEmpty: boolean;

			/**
			 * Gets the current point
			 *
			 * If the current figure in the path is not closed, and
			 * {@link Eto.Drawing.GraphicsPath.StartFigure} is not called, the next segment will be
			 * connected from this point to its start point.
			 */
			readonly CurrentPoint: Eto.Drawing.PointF;

			/**
			 * Creates a delegate that can be used to create instances of the
			 * {@link Eto.Drawing.IGraphicsPath} with little overhead
			 *
			 * This is useful when creating a very large number of graphics path objects
			 */
			static readonly Instantiator: () => Eto.Drawing.IGraphicsPath;

			/** Creates a new instance of the IGraphicsPath for the specified generator */
			static Create(): Eto.Drawing.IGraphicsPath;

			/**
			 * Adds a line to the path with the specified start and end points
			 *
			 * If the current figure is not closed, it will connect with the start of this line. The
			 * current position will be moved to the specified end location.
			 */
			AddLine(
				startX: number,
				startY: number,
				endX: number,
				endY: number,
			): void;

			/**
			 * Adds lines to each of the specified `points` to the path
			 *
			 * If the current figure is not closed, it will connect with the first point specified.
			 * The current position will be moved to the last point specified
			 */
			AddLines(points: Iterable<Eto.Drawing.PointF>): void;

			/** Adds a line from the current position to the specified location */
			LineTo(
				x: number,
				y: number,
			): void;

			/**
			 * Moves the current position to the specified location without adding anything to the
			 * path
			 */
			MoveTo(
				x: number,
				y: number,
			): void;

			/**
			 * Adds an arc into the specified rectangle
			 *
			 * If the current figure is not closed, it will connect with the start of the arc. The
			 * current position will be moved to the ending point of the arc
			 */
			AddArc(
				x: number,
				y: number,
				width: number,
				height: number,
				startAngle: number,
				sweepAngle: number,
			): void;

			/**
			 * Adds a bezier curve to the path with two control points
			 *
			 * If the current figure is not closed, it will connect with the `start` of the bezier
			 * curve. The current position will be moved to the `end` point.
			 */
			AddBezier(
				start: Eto.Drawing.PointF,
				control1: Eto.Drawing.PointF,
				control2: Eto.Drawing.PointF,
				end: Eto.Drawing.PointF,
			): void;

			/**
			 * Adds a curve that intersects with the specified `points` to the path
			 *
			 * Each point in the list will fall on the line based on the `tension` parameter
			 */
			AddCurve(
				points: Iterable<Eto.Drawing.PointF>,
				tension?: number,
			): void;

			/**
			 * Adds an ellipse to the path
			 *
			 * Rectangles are separate figures and will not connect to the current or next figure in
			 * the path. The starting point of the path will no longer be set after this call.
			 */
			AddEllipse(
				x: number,
				y: number,
				width: number,
				height: number,
			): void;

			/**
			 * Adds a rectangle to the path
			 *
			 * Rectangles are separate figures and will not connect to the current or next figure in
			 * the path. The starting point of the path will no longer be set after this call.
			 */
			AddRectangle(
				x: number,
				y: number,
				width: number,
				height: number,
			): void;

			/**
			 * Adds the specified `path` to the current path, optionally connecting the current
			 * figure to the start of the path
			 *
			 * The `connect` parameter only specifies that the path should be connected to the
			 * current path at the beginning. The end of the specified path will always be connected
			 * to the next segment added to this path, unlesss
			 * {@link Eto.Drawing.GraphicsPath.CloseFigure} or
			 * {@link Eto.Drawing.GraphicsPath.StartFigure} are called after this.
			 */
			AddPath(
				path: Eto.Drawing.IGraphicsPath,
				connect?: boolean,
			): void;

			/**
			 * Gets a value indicating that the specified `point` is contained by the path when
			 * filled
			 */
			FillContains(point: Eto.Drawing.PointF): boolean;

			/**
			 * Gets a value indicating that the spedified `point` is on the path when stroked with
			 * the specified `pen`
			 */
			StrokeContains(
				pen: Eto.Drawing.Pen,
				point: Eto.Drawing.PointF,
			): boolean;

			/** Transforms the points in the path with the specified matrix */
			Transform(matrix: Eto.Drawing.IMatrix): void;

			/**
			 * Starts a new figure without closing the current figure
			 *
			 * This will make the next segment added to the path independent (unconnected) to the
			 * last segment.
			 */
			StartFigure(): void;

			/**
			 * Closes the current figure by connecting a line to the beginning of the figure
			 *
			 * This will also make the next segment added to the path start independently from the
			 * last figure. To start a new figure without closing the current one, use
			 * {@link Eto.Drawing.GraphicsPath.StartFigure}
			 */
			CloseFigure(): void;

			/** Releases all resources used by the {@link Eto.Drawing.GraphicsPath} object */
			dispose(): void;

			/** Creates a clone of the graphics path */
			Clone(): Eto.Drawing.IGraphicsPath;

			/** Creates a rounded rectangle using the specified corner radius */
			static GetRoundRect(
				rectangle: Eto.Drawing.RectangleF,
				radius: number,
			): Eto.Drawing.IGraphicsPath;

			/** Creates a rounded rectangle using the specified corner radius */
			static GetRoundRect(
				rectangle: Eto.Drawing.RectangleF,
				nwRadius: number,
				neRadius: number,
				seRadius: number,
				swRadius: number,
			): Eto.Drawing.IGraphicsPath;
		}
	}

	export namespace Eto.Drawing.GraphicsPath {
		export interface IHandler extends
			Eto.Drawing.IGraphicsPath,
			Eto.IControlObjectSource {
		}
	}

	export namespace Eto.Drawing {
		/**
		 * Represents an icon which allows for multiple sizes and resolutions of an image
		 *
		 * The formats supported vary by platform, however all platforms do support loading
		 * windows .ico format.  Using an icon for things like menus, toolbars, etc are preferred
		 * so that each platform can use the appropriate sized image.  For High DPI/Retina
		 * displays (e.g. on OS X), this will allow using a higher resolution image
		 * automatically.
		 */
		export class Icon implements
			Eto.IHandlerSource {
			constructor(handler: Eto.Drawing.Icon.IHandler);

			/**
			 * Initializes a new instance of the Icon class with the contents of the specified
			 * `stream`
			 */
			constructor(stream: Duplex);

			/**
			 * Intitializes a new instanc of the Icon class with the contents of the specified
			 * `fileName`
			 */
			constructor(fileName: string);

			/**
			 * Initializes a new instance of the {@link Eto.Drawing.Icon} class with the specified
			 * frames.
			 *
			 * This is used when you want to create an icon with specific bitmap frames at different
			 * scales or sizes.
			 */
			constructor(frames: Iterable<Eto.Drawing.IconFrame>);

			/**
			 * Initializes a new instance of the {@link Eto.Drawing.Icon} class with the specified
			 * frames.
			 *
			 * This is used when you want to create an icon with specific bitmap frames at different
			 * scales or sizes.
			 */
			constructor(frames: Eto.Drawing.IconFrame[]);

			/**
			 * Initializes a new instance of the {@link Eto.Drawing.Icon} class with the specified
			 * bitmap.
			 *
			 * This is used when you want to create an icon with a single bitmap frame with the
			 * specified logical scale.
			 */
			constructor(
				scale: number,
				bitmap: Eto.Drawing.Bitmap,
			);

			/** Gets the definition for each frame in this icon. */
			readonly Frames: Iterable<Eto.Drawing.IconFrame>;

			/** Gets the size of the image, in pixels */
			readonly Size: Eto.Drawing.Size;

			/**
			 * Gets the width of the image, in pixels.
			 *
			 * Use {@link Eto.Drawing.Image.Size} if you wish to get the width and height at the same
			 * time.
			 */
			readonly Width: number;

			/**
			 * Gets the height of the image, in pixels.
			 *
			 * Use {@link Eto.Drawing.Image.Size} if you wish to get the width and height at the same
			 * time.
			 */
			readonly Height: number;

			/**
			 * Gets the platform that was used to create the {@link Eto.Widget.Handler} for this
			 * widget
			 *
			 * This gets set to the current {@link Eto.Platform.Instance} during the construction of
			 * the object
			 */
			readonly Platform: Eto.Platform;

			/** Gets the platform-specific handler for this widget */
			Handler: unknown;

			/** Gets the native platform-specific handle for integration purposes */
			readonly NativeHandle: unknown;

			/** Gets the dictionary of properties for this widget */
			readonly Properties: Eto.PropertyStore;

			/** Gets or sets the ID of this widget */
			ID: string;

			/**
			 * Gets or sets the style of this widget
			 *
			 * Styles allow you to attach custom platform-specific logic to a widget. In your
			 * platform-specific assembly, use {@link Style.Add{H}(string, StyleHandler{H})} to add
			 * the style logic with the same id.
			 */
			Style: string;

			/**
			 * Gets the instance of the platform-specific object
			 *
			 * This can sometimes be useful to get the platform-specific object. Some handlers may
			 * not have any backing object for its functionality, so this may be null.  It is more
			 * preferred to use the {@link Eto.Widget.Handler} and cast that to the platform-specific
			 * handler class which can give you additional methods and helpers to do common tasks.
			 * For example, the {@link Eto.Forms.Application} object's handler for OS X has a
			 * AddFullScreenMenuItem property to specify if you want full screen support in your app.
			 */
			readonly ControlObject: unknown;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Widget} has been disposed.
			 *
			 * When the widget is disposed, it can no longer be used.
			 */
			IsDisposed: boolean;

			/** Loads an icon from an embedded resource of the specified assembly */
			static FromResource(
				resourceName: string,
				assembly?: unknown,
			): Eto.Drawing.Icon;

			/** Loads an icon from a resource in the same assembly as the specified `type` */
			static FromResource(
				resourceName: string,
				type: unknown,
			): Eto.Drawing.Icon;

			/**
			 * Gets the frame with the specified scale that can fit into the `fittingSize` if
			 * specified.
			 *
			 * This can be used to determine which frame should be used to draw to the screen, based
			 * on the desired logical pixel scale and final drawn size of the icon.
			 */
			GetFrame(
				scale: number,
				fittingSize?: Eto.Drawing.Size,
			): Eto.Drawing.IconFrame;

			/**
			 * Gets a copy of this Icon with frames scaled to draw within the specified fitting size.
			 *
			 * This is useful when you want to draw an Icon at a different size than the default
			 * size.  Note that the `fittingSize` specifies the maxiumum drawing size of the Icon,
			 * but will not change the aspect of each frame's bitmap.  For example, if an existing
			 * frame is 128x128, and you specify 16x32, then the resulting frame will draw at 16x16.
			 */
			WithSize(fittingSize: Eto.Drawing.Size): Eto.Drawing.Icon;

			/**
			 * Gets a copy of this Icon with frames scaled to draw within the specified fitting size.
			 *
			 * This is useful when you want to draw an Icon at a different size than the default
			 * size.  Note that the `width` and `height` specifies the maxiumum drawing size of the
			 * Icon, but will not change the aspect of each frame's bitmap.  For example, if an
			 * existing frame is 128x128, and you specify 16x32, then the resulting frame will draw
			 * at 16x16.
			 */
			WithSize(
				width: number,
				height: number,
			): Eto.Drawing.Icon;

			/** Disposes of this widget, supressing the finalizer */
			dispose(): void;

			/** Gets a string that represents the current object with its ID if specified. */
			ToString(): string;
		}
	}

	export namespace Eto.Drawing.Icon {
		export interface IHandler extends
			Eto.Drawing.Image.IHandler,
			Eto.Widget.IHandler {
			readonly Frames: Iterable<Eto.Drawing.IconFrame>;

			Create(stream: Duplex): void;

			Create(fileName: string): void;

			Create(frames: Iterable<Eto.Drawing.IconFrame>): void;
		}
	}

	export namespace Eto.Drawing {
		/**
		 * Represents a frame in an {@link Eto.Drawing.Icon}.
		 *
		 * The IconFrame represents a single frame in an Icon.   Each IconFrame can have a
		 * specific pixel size and scale, which will automatically be chosen based on the display
		 * and draw size of the image in various Eto controls.    You can load an icon from an
		 * .ico, where all frames will have a 1.0 scale (pixel size equals logical size)
		 */
		export class IconFrame implements
			Eto.IControlObjectSource {
			/** Initializes a new instance of the {@link Eto.Drawing.IconFrame} class. */
			constructor(
				scale: number,
				load: () => Duplex,
			);

			/** Initializes a new instance of the {@link Eto.Drawing.IconFrame} class. */
			constructor(
				scale: number,
				stream: Duplex,
			);

			/** Initializes a new instance of the {@link Eto.Drawing.IconFrame} class. */
			constructor(
				scale: number,
				bitmap: Eto.Drawing.Bitmap,
			);

			/** Gets the control object for this widget */
			ControlObject: unknown;

			/** Gets the pixel size of the frame's bitmap */
			readonly PixelSize: Eto.Drawing.Size;

			/**
			 * Gets the scale of this frame. 1.0 means the {@link Eto.Drawing.IconFrame.Size} and
			 * {@link Eto.Drawing.IconFrame.PixelSize} will be equal.
			 *
			 * When loading from an .ico, all frames will get a scale of 1.0.
			 */
			readonly Scale: number;

			/** Gets the logical size of the frame. */
			readonly Size: Eto.Drawing.Size;

			/** Gets the bitmap for this frame. */
			readonly Bitmap: Eto.Drawing.Bitmap;

			/**
			 * Creates an instance of the {@link Eto.Drawing.IconFrame} with the specified native
			 * control object.
			 *
			 * This is used by platform implementations to create instances of this class with the
			 * appropriate control object. This is not intended to be called directly.
			 */
			static FromControlObject(
				scale: number,
				controlObject: unknown,
			): Eto.Drawing.IconFrame;

			/**
			 * Creates an instance of the {@link Eto.Drawing.IconFrame} from an embedded resource.
			 */
			static FromResource(
				scale: number,
				resourceName: string,
				assembly?: unknown,
			): Eto.Drawing.IconFrame;
		}
	}

	export namespace Eto.Drawing.IconFrame {
		export interface IHandler {
			Create(
				frame: Eto.Drawing.IconFrame,
				stream: Duplex,
			): unknown;

			Create(
				frame: Eto.Drawing.IconFrame,
				load: () => Duplex,
			): unknown;

			Create(
				frame: Eto.Drawing.IconFrame,
				bitmap: Eto.Drawing.Bitmap,
			): unknown;

			GetBitmap(frame: Eto.Drawing.IconFrame): Eto.Drawing.Bitmap;

			GetPixelSize(frame: Eto.Drawing.IconFrame): Eto.Drawing.Size;
		}
	}

	export namespace Eto.Drawing {
		/** Interface for an image that can have its data locked for direct access */
		export interface ILockableImage {
			/**
			 * Locks the data of the image to directly access the bytes of the image
			 *
			 * This locks the data to read and write to directly using unsafe pointers. After reading
			 * or updating the data, you must call
			 * {@link Eto.Drawing.ILockableImage.Unlock(Eto.Drawing.BitmapData)} to unlock the data.
			 */
			Lock(): Eto.Drawing.BitmapData;

			/**
			 * Unlocks the previously locked data
			 *
			 * This will unlock the data, and in some platforms write the data back to the image.
			 * You must call this method before using the bitmap again.
			 */
			Unlock(bitmapData: Eto.Drawing.BitmapData): void;
		}
	}

	export namespace Eto.Drawing {
		/**
		 * Base class for images
		 *
		 * This provides a base for image functionality so that drawing and widgets can
		 * reference any type of image, if supported. For instance, {@link Eto.Drawing.Graphics}
		 * and {@link Eto.Forms.ImageView} can reference any Image-derived object.
		 */
		export class Image implements
			Eto.IHandlerSource {
			/** Gets the size of the image, in pixels */
			readonly Size: Eto.Drawing.Size;

			/**
			 * Gets the width of the image, in pixels.
			 *
			 * Use {@link Eto.Drawing.Image.Size} if you wish to get the width and height at the same
			 * time.
			 */
			readonly Width: number;

			/**
			 * Gets the height of the image, in pixels.
			 *
			 * Use {@link Eto.Drawing.Image.Size} if you wish to get the width and height at the same
			 * time.
			 */
			readonly Height: number;

			/**
			 * Gets the platform that was used to create the {@link Eto.Widget.Handler} for this
			 * widget
			 *
			 * This gets set to the current {@link Eto.Platform.Instance} during the construction of
			 * the object
			 */
			readonly Platform: Eto.Platform;

			/** Gets the platform-specific handler for this widget */
			Handler: unknown;

			/** Gets the native platform-specific handle for integration purposes */
			readonly NativeHandle: unknown;

			/** Gets the dictionary of properties for this widget */
			readonly Properties: Eto.PropertyStore;

			/** Gets or sets the ID of this widget */
			ID: string;

			/**
			 * Gets or sets the style of this widget
			 *
			 * Styles allow you to attach custom platform-specific logic to a widget. In your
			 * platform-specific assembly, use {@link Style.Add{H}(string, StyleHandler{H})} to add
			 * the style logic with the same id.
			 */
			Style: string;

			/**
			 * Gets the instance of the platform-specific object
			 *
			 * This can sometimes be useful to get the platform-specific object. Some handlers may
			 * not have any backing object for its functionality, so this may be null.  It is more
			 * preferred to use the {@link Eto.Widget.Handler} and cast that to the platform-specific
			 * handler class which can give you additional methods and helpers to do common tasks.
			 * For example, the {@link Eto.Forms.Application} object's handler for OS X has a
			 * AddFullScreenMenuItem property to specify if you want full screen support in your app.
			 */
			readonly ControlObject: unknown;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Widget} has been disposed.
			 *
			 * When the widget is disposed, it can no longer be used.
			 */
			IsDisposed: boolean;

			/** Disposes of this widget, supressing the finalizer */
			dispose(): void;

			/** Gets a string that represents the current object with its ID if specified. */
			ToString(): string;
		}
	}

	export namespace Eto.Drawing.Image {
		export interface IHandler extends Eto.Widget.IHandler {
			readonly Size: Eto.Drawing.Size;
		}
	}

	export namespace Eto.Drawing {
		/** Converter to convert a string to an {@link Eto.Drawing.Image} */
		export class ImageConverter {
			constructor();

			/**
			 * Gets a value indicating that this converter can convert from the source type to an
			 * image
			 */
			CanConvertFrom(
				context: Eto.ITypeDescriptorContext,
				sourceType: unknown,
			): boolean;

			/** Gets a value indicating that this converter can convert to the specified type. */
			CanConvertTo(
				context: Eto.ITypeDescriptorContext,
				destinationType: unknown,
			): boolean;

			/**
			 * Performs the conversion from the given `value` to an {@link Eto.Drawing.Image} object
			 */
			ConvertFrom(
				context: Eto.ITypeDescriptorContext,
				culture: unknown,
				value: unknown,
			): unknown;

			/** Determines whether this instance can convert from the specified sourceType. */
			CanConvertFrom(sourceType: unknown): boolean;

			/** Determines whether this instance can convert to the specified destinationType. */
			CanConvertTo(destinationType: unknown): boolean;

			/** Converts from the specified object. */
			ConvertFrom(o: unknown): unknown;

			/** Converts from an invariant string. */
			ConvertFromInvariantString(text: string): unknown;

			/** Converts from an invariant string. */
			ConvertFromInvariantString(
				context: Eto.ITypeDescriptorContext,
				text: string,
			): unknown;

			/** Converts from string. */
			ConvertFromString(text: string): unknown;

			/** Converts from string. */
			ConvertFromString(
				context: Eto.ITypeDescriptorContext,
				text: string,
			): unknown;

			/** Converts from string. */
			ConvertFromString(
				context: Eto.ITypeDescriptorContext,
				culture: unknown,
				text: string,
			): unknown;

			/** Converts to the specified type. */
			ConvertTo(
				value: unknown,
				destinationType: unknown,
			): unknown;

			/** Converts to the specified type. */
			ConvertTo(
				context: Eto.ITypeDescriptorContext,
				culture: unknown,
				value: unknown,
				destinationType: unknown,
			): unknown;

			/** Converts to an invariant string. */
			ConvertToInvariantString(value: unknown): string;

			/** Converts to invariant string. */
			ConvertToInvariantString(
				context: Eto.ITypeDescriptorContext,
				value: unknown,
			): string;

			/** Converts to a string. */
			ConvertToString(value: unknown): string;

			/** Converts to a string. */
			ConvertToString(
				context: Eto.ITypeDescriptorContext,
				value: unknown,
			): string;

			/** Converts to a string. */
			ConvertToString(
				context: Eto.ITypeDescriptorContext,
				culture: unknown,
				value: unknown,
			): string;

			/** Determines whether this instance is valid the specified value. */
			IsValid(value: unknown): boolean;

			/** Determines whether this instance is valid the specified context value. */
			IsValid(
				context: Eto.ITypeDescriptorContext,
				value: unknown,
			): boolean;
		}
	}

	export namespace Eto.Drawing {
		/**
		 * Interpolation modes when drawing images using the {@link Eto.Drawing.Graphics} object
		 */
		export enum ImageInterpolation {
			/** Default interplation mode - usually a balance between quality vs. performance */
			Default = 0,

			/** No interpolation (also known as nearest neighbour) */
			None = 1,

			/** Low interpolation quality (usually fastest) */
			Low = 2,

			/**
			 * Medium interpolation quality slower than {@link Eto.Drawing.ImageInterpolation.Low},
			 * but better quality
			 */
			Medium = 3,

			/** Highest interpolation quality - slowest but best quality */
			High = 4,
		}
	}

	export namespace Eto.Drawing {
		/**
		 * Represents a bitmap where each pixel is specified as an index in a
		 * {@link Eto.Drawing.IndexedBitmap.Palette}
		 */
		export class IndexedBitmap implements
			Eto.IHandlerSource {
			/** Initializes a new instance of the IndexedBitmap class */
			constructor(
				width: number,
				height: number,
				bitsPerPixel: number,
			);

			/** Gets the number of bits per pixel for this bitmap */
			BitsPerPixel: number;

			/**
			 * Gets or sets the palette of the image
			 *
			 * Note that the number of colors in the palette must match the number of colors
			 * specified by the bits per pixel of this bitmap
			 */
			Palette: Eto.Drawing.Palette;

			/** Gets the size of the image, in pixels */
			readonly Size: Eto.Drawing.Size;

			/**
			 * Gets the width of the image, in pixels.
			 *
			 * Use {@link Eto.Drawing.Image.Size} if you wish to get the width and height at the same
			 * time.
			 */
			readonly Width: number;

			/**
			 * Gets the height of the image, in pixels.
			 *
			 * Use {@link Eto.Drawing.Image.Size} if you wish to get the width and height at the same
			 * time.
			 */
			readonly Height: number;

			/**
			 * Gets the platform that was used to create the {@link Eto.Widget.Handler} for this
			 * widget
			 *
			 * This gets set to the current {@link Eto.Platform.Instance} during the construction of
			 * the object
			 */
			readonly Platform: Eto.Platform;

			/** Gets the platform-specific handler for this widget */
			Handler: unknown;

			/** Gets the native platform-specific handle for integration purposes */
			readonly NativeHandle: unknown;

			/** Gets the dictionary of properties for this widget */
			readonly Properties: Eto.PropertyStore;

			/** Gets or sets the ID of this widget */
			ID: string;

			/**
			 * Gets or sets the style of this widget
			 *
			 * Styles allow you to attach custom platform-specific logic to a widget. In your
			 * platform-specific assembly, use {@link Style.Add{H}(string, StyleHandler{H})} to add
			 * the style logic with the same id.
			 */
			Style: string;

			/**
			 * Gets the instance of the platform-specific object
			 *
			 * This can sometimes be useful to get the platform-specific object. Some handlers may
			 * not have any backing object for its functionality, so this may be null.  It is more
			 * preferred to use the {@link Eto.Widget.Handler} and cast that to the platform-specific
			 * handler class which can give you additional methods and helpers to do common tasks.
			 * For example, the {@link Eto.Forms.Application} object's handler for OS X has a
			 * AddFullScreenMenuItem property to specify if you want full screen support in your app.
			 */
			readonly ControlObject: unknown;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Widget} has been disposed.
			 *
			 * When the widget is disposed, it can no longer be used.
			 */
			IsDisposed: boolean;

			/** Resizes the bitmap to the specified size */
			Resize(
				width: number,
				height: number,
			): void;

			/**
			 * Locks the data of the image to directly access the bytes of the image
			 *
			 * This locks the data to read and write to directly using unsafe pointers. After reading
			 * or updating the data, you must call {@link Eto.Drawing.BitmapData.Dispose} to unlock
			 * the data before using the bitmap. e.g.: using (var bd = bitmap.Lock ()) { 	byte* pdata
			 * = bd.Data; 	// access data }
			 */
			Lock(): Eto.Drawing.BitmapData;

			/** Disposes of this widget, supressing the finalizer */
			dispose(): void;

			/** Gets a string that represents the current object with its ID if specified. */
			ToString(): string;
		}
	}

	export namespace Eto.Drawing.IndexedBitmap {
		export interface IHandler extends
			Eto.Drawing.Image.IHandler,
			Eto.Widget.IHandler,
			Eto.Drawing.ILockableImage {
			Palette: Eto.Drawing.Palette;

			Create(
				width: number,
				height: number,
				bitsPerPixel: number,
			): void;

			Resize(
				width: number,
				height: number,
			): void;
		}
	}

	export namespace Eto.Drawing {
		/** Wrap mode for a gradient */
		export enum GradientWrapMode {
			/** The start and end colors fill beyond the gradient */
			Pad = 0,

			/** The gradient repeats to fill the area */
			Repeat = 1,

			/** The gradient reflects (or reverses) each time it repeats to fill the area */
			Reflect = 2,
		}
	}

	export namespace Eto.Drawing {
		/** Brush with a linear gradient at an angle */
		export class LinearGradientBrush implements
			Eto.IHandlerSource,
			Eto.IControlObjectSource,
			Eto.Drawing.ITransformBrush {
			/**
			 * Initializes a new instance of the {@link Eto.Drawing.LinearGradientBrush} class
			 * between two points
			 */
			constructor(
				startColor: Eto.Drawing.Color,
				endColor: Eto.Drawing.Color,
				startPoint: Eto.Drawing.PointF,
				endPoint: Eto.Drawing.PointF,
			);

			/**
			 * Initializes a new instance of the {@link Eto.Drawing.LinearGradientBrush} class with a
			 * given `rectangle` and `angle`
			 */
			constructor(
				rectangle: Eto.Drawing.RectangleF,
				startColor: Eto.Drawing.Color,
				endColor: Eto.Drawing.Color,
				angle: number,
			);

			/** Gets the platform handler object for the widget */
			readonly Handler: unknown;

			/**
			 * Gets a delegate to instantiate {@link Eto.Drawing.LinearGradientBrush} objects
			 *
			 * Use this to instantiate many objects of this type
			 */
			static readonly Instantiator: (arg1: Eto.Drawing.Color, arg2: Eto.Drawing.Color, arg3: Eto.Drawing.PointF, arg4: Eto.Drawing.PointF) => Eto.Drawing.LinearGradientBrush;

			/** Gets or sets the transform to apply to the gradient */
			Transform: Eto.Drawing.IMatrix;

			/** Gets or sets the wrap mode for the gradient */
			Wrap: Eto.Drawing.GradientWrapMode;

			/** Gets or sets the control object for this widget */
			ControlObject: unknown;

			/**
			 * Releases all resource used by the {@link Eto.Drawing.Brush} object.
			 *
			 * Call {@link Eto.Drawing.Brush.Dispose} when you are finished using the
			 * {@link Eto.Drawing.Brush}. The {@link Eto.Drawing.Brush.Dispose} method leaves the
			 * {@link Eto.Drawing.Brush} in an unusable state. After calling
			 * {@link Eto.Drawing.Brush.Dispose}, you must release all references to the
			 * {@link Eto.Drawing.Brush} so the garbage collector can reclaim the memory that the
			 * {@link Eto.Drawing.Brush} was occupying.
			 */
			dispose(): void;
		}
	}

	export namespace Eto.Drawing.LinearGradientBrush {
		export interface IHandler extends Eto.Drawing.Brush.IHandler {
			Create(
				startColor: Eto.Drawing.Color,
				endColor: Eto.Drawing.Color,
				startPoint: Eto.Drawing.PointF,
				endPoint: Eto.Drawing.PointF,
			): unknown;

			Create(
				rectangle: Eto.Drawing.RectangleF,
				startColor: Eto.Drawing.Color,
				endColor: Eto.Drawing.Color,
				angle: number,
			): unknown;

			GetTransform(widget: Eto.Drawing.LinearGradientBrush): Eto.Drawing.IMatrix;

			SetTransform(
				widget: Eto.Drawing.LinearGradientBrush,
				transform: Eto.Drawing.IMatrix,
			): void;

			GetGradientWrap(widget: Eto.Drawing.LinearGradientBrush): Eto.Drawing.GradientWrapMode;

			SetGradientWrap(
				widget: Eto.Drawing.LinearGradientBrush,
				gradientWrap: Eto.Drawing.GradientWrapMode,
			): void;
		}
	}

	export namespace Eto.Drawing {
		/**
		 * Defines a matrix used for transforms in {@link Eto.Drawing.Graphics} and
		 * {@link Eto.Drawing.Brushes}
		 *
		 * A matrix is defined by six elements that are used to transform a coordinate system.
		 * The elements of the matrix are defined as: | xx yx 0 | 	| xy yy 0 | 	| x0 y0 1 |
		 */
		export interface IMatrix extends Eto.IControlObjectSource {
			/** Gets the elements of this matrix */
			readonly Elements: number[];

			/** Gets or sets the value at position [1,1] in the matrix */
			Xx: number;

			/** Gets or sets the value at position [1,2] in the matrix */
			Yx: number;

			/** Gets or sets the value at position [2,1] in the matrix */
			Xy: number;

			/** Gets or sets the value at position [2,2] in the matrix */
			Yy: number;

			/** Gets or sets the value at position [3,1] in the matrix */
			X0: number;

			/** Gets or sets the value at position [3,2] in the matrix */
			Y0: number;

			/** Prepend a rotation to the matrix around the origin (0,0) */
			Rotate(angle: number): void;

			/** Prepend a rotation around the specified point to the matrix */
			RotateAt(
				angle: number,
				centerX: number,
				centerY: number,
			): void;

			/** Prepend a translation to the matrix */
			Translate(
				offsetX: number,
				offsetY: number,
			): void;

			/** Prepend a scale to the matrix from the origin (0, 0) */
			Scale(
				scaleX: number,
				scaleY: number,
			): void;

			/** Prepend a scale to the matrix from the specified point */
			ScaleAt(
				scaleX: number,
				scaleY: number,
				centerX: number,
				centerY: number,
			): void;

			/** Prepend a skew to the matrix */
			Skew(
				skewX: number,
				skewY: number,
			): void;

			/** Append the specified `matrix` to this matrix */
			Append(matrix: Eto.Drawing.IMatrix): void;

			/** Prepend the specified matrix to this matrix */
			Prepend(matrix: Eto.Drawing.IMatrix): void;

			/** Inverts this matrix */
			Invert(): void;

			/** Transforms the specified point using this matrix transform */
			TransformPoint(point: Eto.Drawing.Point): Eto.Drawing.PointF;

			/** Transforms the specified point using this matrix transform */
			TransformPoint(point: Eto.Drawing.PointF): Eto.Drawing.PointF;

			/** Clone this instance */
			Clone(): Eto.Drawing.IMatrix;
		}
	}

	export namespace Eto.Drawing {
		/** Methods to create and manage an {@link Eto.Drawing.IMatrix} */
		export namespace Matrix {
			/** Gets a delegate that can be used to create an identity matrix with little overhead */
			export const Instantiator: () => Eto.Drawing.IMatrix;

			/**
			 * Gets a delegate that can be used to create instances of a matrix with specified
			 * components with little overhead
			 */
			export const InstantiatorWithElements: (arg1: number, arg2: number, arg3: number, arg4: number, arg5: number, arg6: number) => Eto.Drawing.IMatrix;

			/** Multiply the specified `matrix` and `matrices`. */
			export function Multiply(
				matrix: Eto.Drawing.IMatrix,
				matrices: Eto.Drawing.IMatrix[],
			): Eto.Drawing.IMatrix;

			/** Creates a new matrix with the specified `scale` */
			export function FromScale(scale: Eto.Drawing.SizeF): Eto.Drawing.IMatrix;

			/** Creates a new matrix with the specified scale factor */
			export function FromScale(
				scaleX: number,
				scaleY: number,
			): Eto.Drawing.IMatrix;

			/** Creates a new matrix with a `scale` at the specified `center` point */
			export function FromScaleAt(
				scale: Eto.Drawing.SizeF,
				center: Eto.Drawing.PointF,
			): Eto.Drawing.IMatrix;

			/** Creates a new matrix with a scale at the specified point */
			export function FromScaleAt(
				scaleX: number,
				scaleY: number,
				centerX: number,
				centerY: number,
			): Eto.Drawing.IMatrix;

			/** Creates a new matrix with a translation */
			export function FromTranslation(offset: Eto.Drawing.SizeF): Eto.Drawing.IMatrix;

			/** Creates a new matrix with a translation */
			export function FromTranslation(offset: Eto.Drawing.PointF): Eto.Drawing.IMatrix;

			/** Creates a new matrix with a translation */
			export function FromTranslation(
				distanceX: number,
				distanceY: number,
			): Eto.Drawing.IMatrix;

			/** Creates a new rotation matrix */
			export function FromRotation(angle: number): Eto.Drawing.IMatrix;

			/** Creates a new rotation matrix around a center point with the specified `angle` */
			export function FromRotationAt(
				angle: number,
				center: Eto.Drawing.PointF,
			): Eto.Drawing.IMatrix;

			/**
			 * Creates a new rotation matrix around a ( `centerX`, `centerY` ) point with the
			 * specified `angle`
			 */
			export function FromRotationAt(
				angle: number,
				centerX: number,
				centerY: number,
			): Eto.Drawing.IMatrix;

			/** Creates a new matrix with a skew */
			export function FromSkew(
				skewX: number,
				skewY: number,
			): Eto.Drawing.IMatrix;

			/** Creates a new identity matrix */
			export function Create(): Eto.Drawing.IMatrix;

			/** Creates a new matrix with the specified `elements` */
			export function Create(elements: number[]): Eto.Drawing.IMatrix;

			/** Creates a new matrix with the specified components */
			export function Create(
				xx: number,
				yx: number,
				xy: number,
				yy: number,
				x0: number,
				y0: number,
			): Eto.Drawing.IMatrix;

			/** Prepend a rotation around the specified point to the matrix */
			export function RotateAt(
				matrix: Eto.Drawing.IMatrix,
				angle: number,
				center: Eto.Drawing.PointF,
			): void;

			/** Prepend a translation to the matrix */
			export function Translate(
				matrix: Eto.Drawing.IMatrix,
				offset: Eto.Drawing.SizeF,
			): void;

			/** Prepend a translation to the matrix */
			export function Translate(
				matrix: Eto.Drawing.IMatrix,
				offset: Eto.Drawing.PointF,
			): void;

			/** Prepend a scale to the matrix from the origin (0, 0) */
			export function Scale(
				matrix: Eto.Drawing.IMatrix,
				scale: Eto.Drawing.SizeF,
			): void;

			/** Prepend a scale to the matrix from the origin (0, 0) */
			export function Scale(
				matrix: Eto.Drawing.IMatrix,
				scale: number,
			): void;

			/** Prepend a scale to the matrix from the specified point */
			export function ScaleAt(
				matrix: Eto.Drawing.IMatrix,
				scale: Eto.Drawing.SizeF,
				center: Eto.Drawing.PointF,
			): void;

			/** Prepend a scale to the matrix from the specified point */
			export function ScaleAt(
				matrix: Eto.Drawing.IMatrix,
				scale: number,
				center: Eto.Drawing.PointF,
			): void;

			/** Prepend a scale to the matrix from the specified point */
			export function ScaleAt(
				matrix: Eto.Drawing.IMatrix,
				scale: number,
				centerX: number,
				centerY: number,
			): void;

			/** Append the specified `matrices` to the `matrix` */
			export function Append(
				matrix: Eto.Drawing.IMatrix,
				matrices: Eto.Drawing.IMatrix[],
			): void;

			/** Prepends the specified `matrices` to the `matrix` */
			export function Prepend(
				matrix: Eto.Drawing.IMatrix,
				matrices: Eto.Drawing.IMatrix[],
			): void;

			/** Returns the scale coordinates Xx and Yy of the `matrix` as a PointF. */
			export function GetScale(matrix: Eto.Drawing.IMatrix): Eto.Drawing.PointF;

			/**
			 * Transforms the rectangle with the current matrix.
			 *
			 * This returns a rectangle that encompasses the specified `rect` after it is translated.
			 * When rotating, this means that the new rectangle may be larger in size to encompass
			 * the translated rectangle.
			 */
			export function TransformRectangle(
				matrix: Eto.Drawing.IMatrix,
				rect: Eto.Drawing.RectangleF,
			): Eto.Drawing.RectangleF;

			/**
			 * Transforms the size with the current matrix.
			 *
			 * This will get the transformed size
			 */
			export function TransformSize(
				matrix: Eto.Drawing.IMatrix,
				size: Eto.Drawing.SizeF,
			): Eto.Drawing.SizeF;

			/** Creates an inverted copy of the specified matrix. */
			export function Inverse(matrix: Eto.Drawing.IMatrix): Eto.Drawing.IMatrix;
		}
	}

	export namespace Eto.Drawing.Matrix {
		export interface IHandler extends
			Eto.Drawing.IMatrix,
			Eto.IControlObjectSource {
			Create(): void;

			Create(
				xx: number,
				yx: number,
				xy: number,
				yy: number,
				x0: number,
				y0: number,
			): void;
		}
	}

	export namespace Eto.Drawing {
		/** Extension methods from {@link Eto.Drawing.Matrix} */
		export interface IMatrix {
			/** Prepend a rotation around the specified point to the matrix */
			RotateAt(
				angle: number,
				center: Eto.Drawing.PointF,
			): void;

			/** Prepend a translation to the matrix */
			Translate(offset: Eto.Drawing.SizeF): void;

			/** Prepend a translation to the matrix */
			Translate(offset: Eto.Drawing.PointF): void;

			/** Prepend a scale to the matrix from the origin (0, 0) */
			Scale(scale: Eto.Drawing.SizeF): void;

			/** Prepend a scale to the matrix from the origin (0, 0) */
			Scale(scale: number): void;

			/** Prepend a scale to the matrix from the specified point */
			ScaleAt(
				scale: Eto.Drawing.SizeF,
				center: Eto.Drawing.PointF,
			): void;

			/** Prepend a scale to the matrix from the specified point */
			ScaleAt(
				scale: number,
				center: Eto.Drawing.PointF,
			): void;

			/** Prepend a scale to the matrix from the specified point */
			ScaleAt(
				scale: number,
				centerX: number,
				centerY: number,
			): void;

			/** Append the specified `matrices` to the `matrix` */
			Append(matrices: Eto.Drawing.IMatrix[]): void;

			/** Prepends the specified `matrices` to the `matrix` */
			Prepend(matrices: Eto.Drawing.IMatrix[]): void;

			/** Returns the scale coordinates Xx and Yy of the `matrix` as a PointF. */
			GetScale(): Eto.Drawing.PointF;

			/**
			 * Transforms the rectangle with the current matrix.
			 *
			 * This returns a rectangle that encompasses the specified `rect` after it is translated.
			 * When rotating, this means that the new rectangle may be larger in size to encompass
			 * the translated rectangle.
			 */
			TransformRectangle(rect: Eto.Drawing.RectangleF): Eto.Drawing.RectangleF;

			/**
			 * Transforms the size with the current matrix.
			 *
			 * This will get the transformed size
			 */
			TransformSize(size: Eto.Drawing.SizeF): Eto.Drawing.SizeF;

			/** Creates an inverted copy of the specified matrix. */
			Inverse(): Eto.Drawing.IMatrix;
		}
	}

	export namespace Eto.Drawing {
		/**
		 * Represents an amount of padding to apply to an object at the top, left, right, and
		 * bottom.
		 */
		export class Padding {
			/**
			 * Initializes a new instance of the Padding class with the specified padding for all
			 * sides
			 */
			constructor(all: number);

			/**
			 * Initializes a new instance of the Padding class with the specified padding for
			 * horizontal and vertical sides
			 */
			constructor(
				horizontal: number,
				vertical: number,
			);

			/** Initializes a new instance of the Padding class */
			constructor(
				left: number,
				top: number,
				right: number,
				bottom: number,
			);

			/** Gets or sets the padding on the top */
			Top: number;

			/** Gets or sets the padding on the left */
			Left: number;

			/** Gets or sets the padding on the right */
			Right: number;

			/** Gets or sets the padding on the bottom */
			Bottom: number;

			/**
			 * Gets the total horizontal padding, which is the sum of
			 * {@link Eto.Drawing.Padding.Left} and {@link Eto.Drawing.Padding.Right}.
			 */
			readonly Horizontal: number;

			/**
			 * Gets the total vertical padding, which is the sum of {@link Eto.Drawing.Padding.Top}
			 * and {@link Eto.Drawing.Padding.Bottom}
			 */
			readonly Vertical: number;

			/**
			 * Gets the padding as a size value with the {@link Eto.Drawing.Padding.Horizontal} and
			 * {@link Eto.Drawing.Padding.Vertical} values as  the {@link Eto.Drawing.Size.Width} and
			 * {@link Eto.Drawing.Size.Height}, respectively.
			 */
			readonly Size: Eto.Drawing.Size;

			/** Gets a value indicating that all sides of the padding are zero */
			readonly IsZero: boolean;

			/**
			 * Converts a floating point `padding` to an integral padding by rounding each of its
			 * components
			 */
			static Round(padding: Eto.Drawing.PaddingF): Eto.Drawing.Padding;

			/**
			 * Converts a floating point `padding` to an integral padding by truncating each of its
			 * components
			 */
			static Truncate(padding: Eto.Drawing.PaddingF): Eto.Drawing.Padding;

			/**
			 * Converts a floating point `padding` to an integral padding by taking the ceiling of
			 * its components
			 */
			static Ceiling(padding: Eto.Drawing.PaddingF): Eto.Drawing.Padding;

			/** Determines the equality between this instance and the specified object */
			Equals(obj: unknown): boolean;

			/** Gets the hash code for this Padding instance */
			GetHashCode(): number;

			/** Converts this object to a string */
			ToString(): string;

			/** Determines equality between this instance and the specified padding */
			Equals(other: Eto.Drawing.Padding): boolean;
		}
	}

	export namespace Eto.Drawing {
		/** Converter for the {@link Eto.Drawing.Padding} class */
		export class PaddingConverter {
			constructor();

			/**
			 * Determines if the specified `sourceType` can be converted to a
			 * {@link Eto.Drawing.Padding} object
			 */
			CanConvertFrom(
				context: Eto.ITypeDescriptorContext,
				sourceType: unknown,
			): boolean;

			/** Converts the specified value to a {@link Eto.Drawing.Padding} object */
			ConvertFrom(
				context: Eto.ITypeDescriptorContext,
				culture: unknown,
				value: unknown,
			): unknown;

			/** Determines whether this instance can convert from the specified sourceType. */
			CanConvertFrom(sourceType: unknown): boolean;

			/** Determines whether this instance can convert to the specified destinationType. */
			CanConvertTo(destinationType: unknown): boolean;

			/**
			 * Determines whether this instance can convert to the specified context destinationType.
			 */
			CanConvertTo(
				context: Eto.ITypeDescriptorContext,
				destinationType: unknown,
			): boolean;

			/** Converts from the specified object. */
			ConvertFrom(o: unknown): unknown;

			/** Converts from an invariant string. */
			ConvertFromInvariantString(text: string): unknown;

			/** Converts from an invariant string. */
			ConvertFromInvariantString(
				context: Eto.ITypeDescriptorContext,
				text: string,
			): unknown;

			/** Converts from string. */
			ConvertFromString(text: string): unknown;

			/** Converts from string. */
			ConvertFromString(
				context: Eto.ITypeDescriptorContext,
				text: string,
			): unknown;

			/** Converts from string. */
			ConvertFromString(
				context: Eto.ITypeDescriptorContext,
				culture: unknown,
				text: string,
			): unknown;

			/** Converts to the specified type. */
			ConvertTo(
				value: unknown,
				destinationType: unknown,
			): unknown;

			/** Converts to the specified type. */
			ConvertTo(
				context: Eto.ITypeDescriptorContext,
				culture: unknown,
				value: unknown,
				destinationType: unknown,
			): unknown;

			/** Converts to an invariant string. */
			ConvertToInvariantString(value: unknown): string;

			/** Converts to invariant string. */
			ConvertToInvariantString(
				context: Eto.ITypeDescriptorContext,
				value: unknown,
			): string;

			/** Converts to a string. */
			ConvertToString(value: unknown): string;

			/** Converts to a string. */
			ConvertToString(
				context: Eto.ITypeDescriptorContext,
				value: unknown,
			): string;

			/** Converts to a string. */
			ConvertToString(
				context: Eto.ITypeDescriptorContext,
				culture: unknown,
				value: unknown,
			): string;

			/** Determines whether this instance is valid the specified value. */
			IsValid(value: unknown): boolean;

			/** Determines whether this instance is valid the specified context value. */
			IsValid(
				context: Eto.ITypeDescriptorContext,
				value: unknown,
			): boolean;
		}
	}

	export namespace Eto.Drawing {
		/**
		 * Represents an amount of padding to apply to an object at the top, left, right, and
		 * bottom.
		 */
		export class PaddingF {
			/**
			 * Initializes a new instance of the Padding class with the specified padding for all
			 * sides
			 */
			constructor(all: number);

			/**
			 * Initializes a new instance of the Padding class with the specified padding for
			 * horizontal and vertical sides
			 */
			constructor(
				horizontal: number,
				vertical: number,
			);

			/** Initializes a new instance of the Padding class */
			constructor(
				left: number,
				top: number,
				right: number,
				bottom: number,
			);

			/** Gets or sets the padding on the top */
			Top: number;

			/** Gets or sets the padding on the left */
			Left: number;

			/** Gets or sets the padding on the right */
			Right: number;

			/** Gets or sets the padding on the bottom */
			Bottom: number;

			/**
			 * Gets the total horizontal padding, which is the sum of
			 * {@link Eto.Drawing.PaddingF.Left} and {@link Eto.Drawing.PaddingF.Right}.
			 */
			readonly Horizontal: number;

			/**
			 * Gets the total vertical padding, which is the sum of {@link Eto.Drawing.PaddingF.Top}
			 * and {@link Eto.Drawing.PaddingF.Bottom}
			 */
			readonly Vertical: number;

			/**
			 * Gets the padding as a size value with the {@link Eto.Drawing.PaddingF.Horizontal} and
			 * {@link Eto.Drawing.PaddingF.Vertical} values as  the {@link Eto.Drawing.Size.Width}
			 * and {@link Eto.Drawing.Size.Height}, respectively.
			 */
			readonly Size: Eto.Drawing.SizeF;

			/** Gets a value indicating that all sides of the padding are zero */
			readonly IsZero: boolean;

			/** Determines the equality between this instance and the specified object */
			Equals(obj: unknown): boolean;

			/** Gets the hash code for this Padding instance */
			GetHashCode(): number;

			/** Converts this object to a string */
			ToString(): string;

			/** Determines equality between this instance and the specified padding */
			Equals(other: Eto.Drawing.PaddingF): boolean;
		}
	}

	export namespace Eto.Drawing {
		/**
		 * Represents a collection of {@link Eto.Drawing.Color} objects
		 *
		 * Typically used for {@link Eto.Drawing.IndexedBitmap} or other purposes where a
		 * collection of colors is needed.  This class keeps a cache of 32-bit ARGB values for
		 * each element in the collection for faster retrieval. These values are generated using
		 * {@link Eto.Drawing.Color.ToArgb}.
		 */
		export class Palette {
			/** Initializes a new instance of the Pallette class */
			constructor();

			/** Initializes a new instance of the Palette class with the specified colors */
			constructor(colors: Iterable<Eto.Drawing.Color>);

			/** Gets the index of standard EGA colors from a 64-color palette */
			static readonly EGAColors: number[];

			/**
			 * Gets the standard 64-color EGA palette
			 *
			 * To get the standard 16-colors of an EGA palette, use
			 * {@link Eto.Drawing.Palette.FromEGA(Eto.Drawing.Palette)}
			 */
			static GetEgaPalette(): Eto.Drawing.Palette;

			/** Gets the standard 16-color palette used in DOS */
			static GetDosPalette(): Eto.Drawing.Palette;

			/**
			 * Gets the standard 16 colors of the specified EGA palette, at the indexes specified
			 * with {@link Eto.Drawing.Palette.EGAColors}
			 */
			static FromEGA(palEGA: Eto.Drawing.Palette): Eto.Drawing.Palette;

			/**
			 * Saves this palette to the specified binary writer in (A)RGB components
			 *
			 * Each component is saved as a single byte (regardless of the value of `shift` ). It is
			 * saved in the order of Alpha (if `includeAlpha` is true), Red, Green, then Blue.
			 */
			Save(
				writer: unknown,
				shift?: number,
				includeAlpha?: boolean,
			): void;

			/**
			 * Loads the palette from the specified binary reader in (A)RGB components
			 *
			 * Each component is read as a single byte (regardless of the value of `shift` ). It is
			 * read in the order of Alpha (if `includeAlpha` is true), Red, Green, then Blue.
			 */
			Load(
				reader: unknown,
				size: number,
				shift?: number,
				includeAlpha?: boolean,
			): void;

			/** Gets the cached ARGB value of the color at the specified `index` */
			GetRGBColor(index: number): number;

			/** Adds the specified `colors` to this palette collection */
			AddRange(colors: Iterable<Eto.Drawing.Color>): void;

			/** Finds the closest color in this palette to the specified `color` */
			FindClosest(color: Eto.Drawing.Color): number;

			/** Finds the index of the specified color, or adds it if it does not exist */
			FindAddColour(color: Eto.Drawing.Color): number;

			/** Gets the hash code for this palette */
			GetHashCode(): number;

			/** Gets a value indicating that this object is equal to the specified `obj` */
			Equals(obj: unknown): boolean;

			/** Creates a clone of this palette */
			Clone(): Eto.Drawing.Palette;
		}
	}

	export namespace Eto.Drawing {
		/** Defines attributes for line drawing methods in {@link Eto.Drawing.Graphics} */
		export class Pen implements
			Eto.IHandlerSource,
			Eto.IControlObjectSource {
			/** Creates a new pen with the specified `color` and `thickness` */
			constructor(
				color: Eto.Drawing.Color,
				thickness?: number,
			);

			/** Creates a new pen with the specified `brush` and `thickness` */
			constructor(
				brush: Eto.Drawing.Brush,
				thickness?: number,
			);

			/** Gets the control object for this widget */
			ControlObject: unknown;

			/** Gets the platform handler object for the widget */
			readonly Handler: unknown;

			/** Gets a delegate that can be used to create instances of the Pen with low overhead */
			static readonly Instantiator: (arg1: Eto.Drawing.Color, arg2: number) => Eto.Drawing.Pen;

			/** Gets or sets the color of the pen */
			Color: Eto.Drawing.Color;

			/** Gets the brush associated with the pen. */
			readonly Brush: Eto.Drawing.Brush;

			/** Gets or sets the thickness (width) of the pen */
			Thickness: number;

			/** Gets or sets the line join style of the pen */
			LineJoin: Eto.Drawing.PenLineJoin;

			/** Gets or sets the line cap style of the pen */
			LineCap: Eto.Drawing.PenLineCap;

			/**
			 * Gets or sets the miter limit on the ratio of the length vs. the
			 * {@link Eto.Drawing.Pen.Thickness} of this pen
			 *
			 * This is only used if the {@link Eto.Drawing.Pen.LineJoin} style is
			 * {@link Eto.Drawing.PenLineJoin.Miter}
			 */
			MiterLimit: number;

			/**
			 * Gets or sets the dash style of the pen
			 *
			 * The {@link Eto.Drawing.Pen.LineCap} specifies the dash cap used
			 */
			DashStyle: Eto.Drawing.DashStyle;

			/**
			 * Releases all resource used by the {@link Eto.Drawing.Pen} object.
			 *
			 * Call {@link Eto.Drawing.Pen.Dispose} when you are finished using the
			 * {@link Eto.Drawing.Pen}. The {@link Eto.Drawing.Pen.Dispose} method leaves the
			 * {@link Eto.Drawing.Pen} in an unusable state. After calling
			 * {@link Eto.Drawing.Pen.Dispose}, you must release all references to the
			 * {@link Eto.Drawing.Pen} so the garbage collector can reclaim the memory that the
			 * {@link Eto.Drawing.Pen} was occupying.
			 */
			dispose(): void;
		}
	}

	export namespace Eto.Drawing.Pen {
		export interface IHandler {
			Create(
				brush: Eto.Drawing.Brush,
				thickness: number,
			): unknown;

			GetBrush(widget: Eto.Drawing.Pen): Eto.Drawing.Brush;

			GetThickness(widget: Eto.Drawing.Pen): number;

			SetThickness(
				widget: Eto.Drawing.Pen,
				thickness: number,
			): void;

			GetLineJoin(widget: Eto.Drawing.Pen): Eto.Drawing.PenLineJoin;

			SetLineJoin(
				widget: Eto.Drawing.Pen,
				lineJoin: Eto.Drawing.PenLineJoin,
			): void;

			GetLineCap(widget: Eto.Drawing.Pen): Eto.Drawing.PenLineCap;

			SetLineCap(
				widget: Eto.Drawing.Pen,
				lineCap: Eto.Drawing.PenLineCap,
			): void;

			GetMiterLimit(widget: Eto.Drawing.Pen): number;

			SetMiterLimit(
				widget: Eto.Drawing.Pen,
				miterLimit: number,
			): void;

			SetDashStyle(
				widget: Eto.Drawing.Pen,
				dashStyle: Eto.Drawing.DashStyle,
			): void;
		}
	}

	export namespace Eto.Drawing {
		/** Specifies the line cap for a {@link Eto.Drawing.Pen} */
		export enum PenLineCap {
			/** Lines have a square cap, that is the same size as the width of the pen */
			Square = 0,

			/** Lines are capped exactly at the ending points of the line */
			Butt = 1,

			/** Lines have a rounded cap, which is equal to the width of the pen */
			Round = 2,
		}
	}

	export namespace Eto.Drawing {
		/** Specifies how lines are joined for a {@link Eto.Drawing.Pen} */
		export enum PenLineJoin {
			/**
			 * Uses a miter to join lines, usually within a certain limit specified by
			 * {@link Eto.Drawing.Pen.MiterLimit}
			 */
			Miter = 0,

			/** Uses a bevel along the angle of the join */
			Bevel = 1,

			/** Uses a rounded edge to join lines */
			Round = 2,
		}
	}

	export namespace Eto.Drawing {
		/**
		 * List of pens with common colors and pen cache for pens with a specified
		 * color/thickness
		 */
		export namespace Pens {
			/** Gets a pen with a thickness of 1 and ARGB color value of #00000000 */
			export const Transparent: Eto.Drawing.Pen;

			/** Gets a pen with a thickness of 1 and ARGB color value of #FFCD5C5C */
			export const IndianRed: Eto.Drawing.Pen;

			/** Gets a pen with a thickness of 1 and ARGB color value of #FFF08080 */
			export const LightCoral: Eto.Drawing.Pen;

			/** Gets a pen with a thickness of 1 and ARGB color value of #FFFA8072 */
			export const Salmon: Eto.Drawing.Pen;

			/** Gets a pen with a thickness of 1 and ARGB color value of #FFE9967A */
			export const DarkSalmon: Eto.Drawing.Pen;

			/** Gets a pen with a thickness of 1 and ARGB color value of #FFFFA07A */
			export const LightSalmon: Eto.Drawing.Pen;

			/** Gets a pen with a thickness of 1 and ARGB color value of #FFFF0000 */
			export const Red: Eto.Drawing.Pen;

			/** Gets a pen with a thickness of 1 and ARGB color value of #FFDC143C */
			export const Crimson: Eto.Drawing.Pen;

			/** Gets a pen with a thickness of 1 and ARGB color value of #FFB22222 */
			export const Firebrick: Eto.Drawing.Pen;

			/** Gets a pen with a thickness of 1 and ARGB color value of #FF8B0000 */
			export const DarkRed: Eto.Drawing.Pen;

			/** Gets a pen with a thickness of 1 and ARGB color value of #FFFFC0CB */
			export const Pink: Eto.Drawing.Pen;

			/** Gets a pen with a thickness of 1 and ARGB color value of #FFFFB6C1 */
			export const LightPink: Eto.Drawing.Pen;

			/** Gets a pen with a thickness of 1 and ARGB color value of #FFFF69B4 */
			export const HotPink: Eto.Drawing.Pen;

			/** Gets a pen with a thickness of 1 and ARGB color value of #FFFF1493 */
			export const DeepPink: Eto.Drawing.Pen;

			/** Gets a pen with a thickness of 1 and ARGB color value of #FFC71585 */
			export const MediumVioletRed: Eto.Drawing.Pen;

			/** Gets a pen with a thickness of 1 and ARGB color value of #FFDB7093 */
			export const PaleVioletRed: Eto.Drawing.Pen;

			/** Gets a pen with a thickness of 1 and ARGB color value of #FFFF7F50 */
			export const Coral: Eto.Drawing.Pen;

			/** Gets a pen with a thickness of 1 and ARGB color value of #FFFF6347 */
			export const Tomato: Eto.Drawing.Pen;

			/** Gets a pen with a thickness of 1 and ARGB color value of #FFFF4500 */
			export const OrangeRed: Eto.Drawing.Pen;

			/** Gets a pen with a thickness of 1 and ARGB color value of #FFFF8C00 */
			export const DarkOrange: Eto.Drawing.Pen;

			/** Gets a pen with a thickness of 1 and ARGB color value of #FFFFA500 */
			export const Orange: Eto.Drawing.Pen;

			/** Gets a pen with a thickness of 1 and ARGB color value of #FFFFD700 */
			export const Gold: Eto.Drawing.Pen;

			/** Gets a pen with a thickness of 1 and ARGB color value of #FFFFFF00 */
			export const Yellow: Eto.Drawing.Pen;

			/** Gets a pen with a thickness of 1 and ARGB color value of #FFFFFFE0 */
			export const LightYellow: Eto.Drawing.Pen;

			/** Gets a pen with a thickness of 1 and ARGB color value of #FFFFFACD */
			export const LemonChiffon: Eto.Drawing.Pen;

			/** Gets a pen with a thickness of 1 and ARGB color value of #FFFAFAD2 */
			export const LightGoldenrodYellow: Eto.Drawing.Pen;

			/** Gets a pen with a thickness of 1 and ARGB color value of #FFFFEFD5 */
			export const PapayaWhip: Eto.Drawing.Pen;

			/** Gets a pen with a thickness of 1 and ARGB color value of #FFFFE4B5 */
			export const Moccasin: Eto.Drawing.Pen;

			/** Gets a pen with a thickness of 1 and ARGB color value of #FFFFDAB9 */
			export const PeachPuff: Eto.Drawing.Pen;

			/** Gets a pen with a thickness of 1 and ARGB color value of #FFEEE8AA */
			export const PaleGoldenrod: Eto.Drawing.Pen;

			/** Gets a pen with a thickness of 1 and ARGB color value of #FFF0E68C */
			export const Khaki: Eto.Drawing.Pen;

			/** Gets a pen with a thickness of 1 and ARGB color value of #FFBDB76B */
			export const DarkKhaki: Eto.Drawing.Pen;

			/** Gets a pen with a thickness of 1 and ARGB color value of #FFE6E6FA */
			export const Lavender: Eto.Drawing.Pen;

			/** Gets a pen with a thickness of 1 and ARGB color value of #FFD8BFD8 */
			export const Thistle: Eto.Drawing.Pen;

			/** Gets a pen with a thickness of 1 and ARGB color value of #FFDDA0DD */
			export const Plum: Eto.Drawing.Pen;

			/** Gets a pen with a thickness of 1 and ARGB color value of #FFEE82EE */
			export const Violet: Eto.Drawing.Pen;

			/** Gets a pen with a thickness of 1 and ARGB color value of #FFDA70D6 */
			export const Orchid: Eto.Drawing.Pen;

			/** Gets a pen with a thickness of 1 and ARGB color value of #FFFF00FF */
			export const Fuchsia: Eto.Drawing.Pen;

			/** Gets a pen with a thickness of 1 and ARGB color value of #FFFF00FF */
			export const Magenta: Eto.Drawing.Pen;

			/** Gets a pen with a thickness of 1 and ARGB color value of #FFBA55D3 */
			export const MediumOrchid: Eto.Drawing.Pen;

			/** Gets a pen with a thickness of 1 and ARGB color value of #FF9370DB */
			export const MediumPurple: Eto.Drawing.Pen;

			/** Gets a pen with a thickness of 1 and ARGB color value of #FF8A2BE2 */
			export const BlueViolet: Eto.Drawing.Pen;

			/** Gets a pen with a thickness of 1 and ARGB color value of #FF9400D3 */
			export const DarkViolet: Eto.Drawing.Pen;

			/** Gets a pen with a thickness of 1 and ARGB color value of #FF9932CC */
			export const DarkOrchid: Eto.Drawing.Pen;

			/** Gets a pen with a thickness of 1 and ARGB color value of #FF8B008B */
			export const DarkMagenta: Eto.Drawing.Pen;

			/** Gets a pen with a thickness of 1 and ARGB color value of #FF800080 */
			export const Purple: Eto.Drawing.Pen;

			/** Gets a pen with a thickness of 1 and ARGB color value of #FF4B0082 */
			export const Indigo: Eto.Drawing.Pen;

			/** Gets a pen with a thickness of 1 and ARGB color value of #FF483D8B */
			export const DarkSlateBlue: Eto.Drawing.Pen;

			/** Gets a pen with a thickness of 1 and ARGB color value of #FF6A5ACD */
			export const SlateBlue: Eto.Drawing.Pen;

			/** Gets a pen with a thickness of 1 and ARGB color value of #FF7B68EE */
			export const MediumSlateBlue: Eto.Drawing.Pen;

			/** Gets a pen with a thickness of 1 and ARGB color value of #FFADFF2F */
			export const GreenYellow: Eto.Drawing.Pen;

			/** Gets a pen with a thickness of 1 and ARGB color value of #FF7FFF00 */
			export const Chartreuse: Eto.Drawing.Pen;

			/** Gets a pen with a thickness of 1 and ARGB color value of #FF7CFC00 */
			export const LawnGreen: Eto.Drawing.Pen;

			/** Gets a pen with a thickness of 1 and ARGB color value of #FF00FF00 */
			export const Lime: Eto.Drawing.Pen;

			/** Gets a pen with a thickness of 1 and ARGB color value of #FF32CD32 */
			export const LimeGreen: Eto.Drawing.Pen;

			/** Gets a pen with a thickness of 1 and ARGB color value of #FF98FB98 */
			export const PaleGreen: Eto.Drawing.Pen;

			/** Gets a pen with a thickness of 1 and ARGB color value of #FF90EE90 */
			export const LightGreen: Eto.Drawing.Pen;

			/** Gets a pen with a thickness of 1 and ARGB color value of #FF00FA9A */
			export const MediumSpringGreen: Eto.Drawing.Pen;

			/** Gets a pen with a thickness of 1 and ARGB color value of #FF00FF7F */
			export const SpringGreen: Eto.Drawing.Pen;

			/** Gets a pen with a thickness of 1 and ARGB color value of #FF3CB371 */
			export const MediumSeaGreen: Eto.Drawing.Pen;

			/** Gets a pen with a thickness of 1 and ARGB color value of #FF2E8B57 */
			export const SeaGreen: Eto.Drawing.Pen;

			/** Gets a pen with a thickness of 1 and ARGB color value of #FF228B22 */
			export const ForestGreen: Eto.Drawing.Pen;

			/** Gets a pen with a thickness of 1 and ARGB color value of #FF008000 */
			export const Green: Eto.Drawing.Pen;

			/** Gets a pen with a thickness of 1 and ARGB color value of #FF006400 */
			export const DarkGreen: Eto.Drawing.Pen;

			/** Gets a pen with a thickness of 1 and ARGB color value of #FF9ACD32 */
			export const YellowGreen: Eto.Drawing.Pen;

			/** Gets a pen with a thickness of 1 and ARGB color value of #FF6B8E23 */
			export const OliveDrab: Eto.Drawing.Pen;

			/** Gets a pen with a thickness of 1 and ARGB color value of #FF808000 */
			export const Olive: Eto.Drawing.Pen;

			/** Gets a pen with a thickness of 1 and ARGB color value of #FF556B2F */
			export const DarkOliveGreen: Eto.Drawing.Pen;

			/** Gets a pen with a thickness of 1 and ARGB color value of #FF66CDAA */
			export const MediumAquamarine: Eto.Drawing.Pen;

			/** Gets a pen with a thickness of 1 and ARGB color value of #FF8FBC8F */
			export const DarkSeaGreen: Eto.Drawing.Pen;

			/** Gets a pen with a thickness of 1 and ARGB color value of #FF20B2AA */
			export const LightSeaGreen: Eto.Drawing.Pen;

			/** Gets a pen with a thickness of 1 and ARGB color value of #FF008B8B */
			export const DarkCyan: Eto.Drawing.Pen;

			/** Gets a pen with a thickness of 1 and ARGB color value of #FF008080 */
			export const Teal: Eto.Drawing.Pen;

			/** Gets a pen with a thickness of 1 and ARGB color value of #FF00FFFF */
			export const Aqua: Eto.Drawing.Pen;

			/** Gets a pen with a thickness of 1 and ARGB color value of #FF00FFFF */
			export const Cyan: Eto.Drawing.Pen;

			/** Gets a pen with a thickness of 1 and ARGB color value of #FFE0FFFF */
			export const LightCyan: Eto.Drawing.Pen;

			/** Gets a pen with a thickness of 1 and ARGB color value of #FFAFEEEE */
			export const PaleTurquoise: Eto.Drawing.Pen;

			/** Gets a pen with a thickness of 1 and ARGB color value of #FF7FFFD4 */
			export const Aquamarine: Eto.Drawing.Pen;

			/** Gets a pen with a thickness of 1 and ARGB color value of #FF40E0D0 */
			export const Turquoise: Eto.Drawing.Pen;

			/** Gets a pen with a thickness of 1 and ARGB color value of #FF48D1CC */
			export const MediumTurquoise: Eto.Drawing.Pen;

			/** Gets a pen with a thickness of 1 and ARGB color value of #FF00CED1 */
			export const DarkTurquoise: Eto.Drawing.Pen;

			/** Gets a pen with a thickness of 1 and ARGB color value of #FF5F9EA0 */
			export const CadetBlue: Eto.Drawing.Pen;

			/** Gets a pen with a thickness of 1 and ARGB color value of #FF4682B4 */
			export const SteelBlue: Eto.Drawing.Pen;

			/** Gets a pen with a thickness of 1 and ARGB color value of #FFB0C4DE */
			export const LightSteelBlue: Eto.Drawing.Pen;

			/** Gets a pen with a thickness of 1 and ARGB color value of #FFB0E0E6 */
			export const PowderBlue: Eto.Drawing.Pen;

			/** Gets a pen with a thickness of 1 and ARGB color value of #FFADD8E6 */
			export const LightBlue: Eto.Drawing.Pen;

			/** Gets a pen with a thickness of 1 and ARGB color value of #FF87CEEB */
			export const SkyBlue: Eto.Drawing.Pen;

			/** Gets a pen with a thickness of 1 and ARGB color value of #FF87CEFA */
			export const LightSkyBlue: Eto.Drawing.Pen;

			/** Gets a pen with a thickness of 1 and ARGB color value of #FF00BFFF */
			export const DeepSkyBlue: Eto.Drawing.Pen;

			/** Gets a pen with a thickness of 1 and ARGB color value of #FF1E90FF */
			export const DodgerBlue: Eto.Drawing.Pen;

			/** Gets a pen with a thickness of 1 and ARGB color value of #FF6495ED */
			export const CornflowerBlue: Eto.Drawing.Pen;

			/** Gets a pen with a thickness of 1 and ARGB color value of #FF4169E1 */
			export const RoyalBlue: Eto.Drawing.Pen;

			/** Gets a pen with a thickness of 1 and ARGB color value of #FF0000FF */
			export const Blue: Eto.Drawing.Pen;

			/** Gets a pen with a thickness of 1 and ARGB color value of #FF0000CD */
			export const MediumBlue: Eto.Drawing.Pen;

			/** Gets a pen with a thickness of 1 and ARGB color value of #FF00008B */
			export const DarkBlue: Eto.Drawing.Pen;

			/** Gets a pen with a thickness of 1 and ARGB color value of #FF000080 */
			export const Navy: Eto.Drawing.Pen;

			/** Gets a pen with a thickness of 1 and ARGB color value of #FF191970 */
			export const MidnightBlue: Eto.Drawing.Pen;

			/** Gets a pen with a thickness of 1 and ARGB color value of #FFFFF8DC */
			export const Cornsilk: Eto.Drawing.Pen;

			/** Gets a pen with a thickness of 1 and ARGB color value of #FFFFEBCD */
			export const BlanchedAlmond: Eto.Drawing.Pen;

			/** Gets a pen with a thickness of 1 and ARGB color value of #FFFFE4C4 */
			export const Bisque: Eto.Drawing.Pen;

			/** Gets a pen with a thickness of 1 and ARGB color value of #FFFFDEAD */
			export const NavajoWhite: Eto.Drawing.Pen;

			/** Gets a pen with a thickness of 1 and ARGB color value of #FFF5DEB3 */
			export const Wheat: Eto.Drawing.Pen;

			/** Gets a pen with a thickness of 1 and ARGB color value of #FFDEB887 */
			export const BurlyWood: Eto.Drawing.Pen;

			/** Gets a pen with a thickness of 1 and ARGB color value of #FFD2B48C */
			export const Tan: Eto.Drawing.Pen;

			/** Gets a pen with a thickness of 1 and ARGB color value of #FFBC8F8F */
			export const RosyBrown: Eto.Drawing.Pen;

			/** Gets a pen with a thickness of 1 and ARGB color value of #FFF4A460 */
			export const SandyBrown: Eto.Drawing.Pen;

			/** Gets a pen with a thickness of 1 and ARGB color value of #FFDAA520 */
			export const Goldenrod: Eto.Drawing.Pen;

			/** Gets a pen with a thickness of 1 and ARGB color value of #FFB8860B */
			export const DarkGoldenrod: Eto.Drawing.Pen;

			/** Gets a pen with a thickness of 1 and ARGB color value of #FFCD853F */
			export const Peru: Eto.Drawing.Pen;

			/** Gets a pen with a thickness of 1 and ARGB color value of #FFD2691E */
			export const Chocolate: Eto.Drawing.Pen;

			/** Gets a pen with a thickness of 1 and ARGB color value of #FF8B4513 */
			export const SaddleBrown: Eto.Drawing.Pen;

			/** Gets a pen with a thickness of 1 and ARGB color value of #FFA0522D */
			export const Sienna: Eto.Drawing.Pen;

			/** Gets a pen with a thickness of 1 and ARGB color value of #FFA52A2A */
			export const Brown: Eto.Drawing.Pen;

			/** Gets a pen with a thickness of 1 and ARGB color value of #FF800000 */
			export const Maroon: Eto.Drawing.Pen;

			/** Gets a pen with a thickness of 1 and ARGB color value of #FFFFFFFF */
			export const White: Eto.Drawing.Pen;

			/** Gets a pen with a thickness of 1 and ARGB color value of #FFFFFAFA */
			export const Snow: Eto.Drawing.Pen;

			/** Gets a pen with a thickness of 1 and ARGB color value of #FFF0FFF0 */
			export const Honeydew: Eto.Drawing.Pen;

			/** Gets a pen with a thickness of 1 and ARGB color value of #FFF5FFFA */
			export const MintCream: Eto.Drawing.Pen;

			/** Gets a pen with a thickness of 1 and ARGB color value of #FFF0FFFF */
			export const Azure: Eto.Drawing.Pen;

			/** Gets a pen with a thickness of 1 and ARGB color value of #FFF0F8FF */
			export const AliceBlue: Eto.Drawing.Pen;

			/** Gets a pen with a thickness of 1 and ARGB color value of #FFF8F8FF */
			export const GhostWhite: Eto.Drawing.Pen;

			/** Gets a pen with a thickness of 1 and ARGB color value of #FFF5F5F5 */
			export const WhiteSmoke: Eto.Drawing.Pen;

			/** Gets a pen with a thickness of 1 and ARGB color value of #FFFFF5EE */
			export const Seashell: Eto.Drawing.Pen;

			/** Gets a pen with a thickness of 1 and ARGB color value of #FFF5F5DC */
			export const Beige: Eto.Drawing.Pen;

			/** Gets a pen with a thickness of 1 and ARGB color value of #FFFDF5E6 */
			export const OldLace: Eto.Drawing.Pen;

			/** Gets a pen with a thickness of 1 and ARGB color value of #FFFFFAF0 */
			export const FloralWhite: Eto.Drawing.Pen;

			/** Gets a pen with a thickness of 1 and ARGB color value of #FFFFFFF0 */
			export const Ivory: Eto.Drawing.Pen;

			/** Gets a pen with a thickness of 1 and ARGB color value of #FFFAEBD7 */
			export const AntiqueWhite: Eto.Drawing.Pen;

			/** Gets a pen with a thickness of 1 and ARGB color value of #FFFAF0E6 */
			export const Linen: Eto.Drawing.Pen;

			/** Gets a pen with a thickness of 1 and ARGB color value of #FFFFF0F5 */
			export const LavenderBlush: Eto.Drawing.Pen;

			/** Gets a pen with a thickness of 1 and ARGB color value of #FFFFE4E1 */
			export const MistyRose: Eto.Drawing.Pen;

			/** Gets a pen with a thickness of 1 and ARGB color value of #FFDCDCDC */
			export const Gainsboro: Eto.Drawing.Pen;

			/** Gets a pen with a thickness of 1 and ARGB color value of #FFD3D3D3 */
			export const LightGrey: Eto.Drawing.Pen;

			/** Gets a pen with a thickness of 1 and ARGB color value of #FFC0C0C0 */
			export const Silver: Eto.Drawing.Pen;

			/** Gets a pen with a thickness of 1 and ARGB color value of #FFA9A9A9 */
			export const DarkGray: Eto.Drawing.Pen;

			/** Gets a pen with a thickness of 1 and ARGB color value of #FF808080 */
			export const Gray: Eto.Drawing.Pen;

			/** Gets a pen with a thickness of 1 and ARGB color value of #FF696969 */
			export const DimGray: Eto.Drawing.Pen;

			/** Gets a pen with a thickness of 1 and ARGB color value of #FF778899 */
			export const LightSlateGray: Eto.Drawing.Pen;

			/** Gets a pen with a thickness of 1 and ARGB color value of #FF708090 */
			export const SlateGray: Eto.Drawing.Pen;

			/** Gets a pen with a thickness of 1 and ARGB color value of #FF2F4F4F */
			export const DarkSlateGray: Eto.Drawing.Pen;

			/** Gets a pen with a thickness of 1 and ARGB color value of #FF000000 */
			export const Black: Eto.Drawing.Pen;

			/** Gets a cached pen with the specified `color` and `thickness` */
			export function Cached(
				color: Eto.Drawing.Color,
				thickness?: number,
				dashStyle?: Eto.Drawing.DashStyle,
			): Eto.Drawing.Pen;

			/**
			 * Clears the pen cache
			 *
			 * This is useful if you are using the
			 * {@link Eto.Drawing.Pens.Cached(Eto.Drawing.Color,System.Single,Eto.Drawing.DashStyle)}
			 * method to cache pens and want to clear it to conserve memory or resources.
			 */
			export function ClearCache(): void;
		}
	}

	export namespace Eto.Drawing {
		/**
		 * Enumeration of the pixel offset modes of a {@link Eto.Drawing.Graphics}
		 *
		 * The pixel offset mode applies to all Draw* and Fill* graphics operations such as
		 * {@link Eto.Drawing.Graphics.DrawLine(Eto.Drawing.Pen,Eto.Drawing.PointF,Eto.Drawing.PointF)},
		 * {@link Eto.Drawing.Graphics.DrawRectangle(Eto.Drawing.Pen,Eto.Drawing.RectangleF)},
		 * etc.
		 */
		export enum PixelOffsetMode {
			/**
			 * Specifies that pixels will not be offset and be relative to the center of each pixel.
			 *
			 * This simplifies drawing odd-width lines and fills by aligning them to the pixel
			 * boundary. Fills on this mode have crisp pixel-aligned boundaries, such as
			 * {@link Eto.Drawing.Graphics.FillRectangle(Eto.Drawing.Brush,Eto.Drawing.RectangleF)}
			 * and variants.
			 */
			None = 0,

			/**
			 * Specifies that pixels are offset by half a pixel (-0.5) in both the horizontal and
			 * vertical axes. Use for high speed.
			 *
			 * In this mode, the center of lines will be at the point between logical pixels and can
			 * improve performance with some platforms.  Horizontal or vertical lines that are not a
			 * fraction will typically be antialiased. For example, to draw a 1px wide horizontal
			 * line without antialiasing, you would have to draw at a 0.5 offset in the vertical
			 * axis.  Only Draw operations are offset with this mode, Fill operations will not be
			 * offset. (new in 2.1) For example, filling a rectangle from 10, 10 to 20, 20 will not
			 * be antialiased and fall on (logical) pixel boundaries.
			 */
			Half = 1,

			/**
			 * Similar to None, specifies that pixels will be relative to the center of each pixel,
			 * but only for line drawing.
			 *
			 * This simplifies drawing lines and fills with the same dimensions, as they will both be
			 * offset by 0.5 pixels. Note that in this mode, any fills will not be aligned on a pixel
			 * boundary, such as
			 * {@link Eto.Drawing.Graphics.FillRectangle(Eto.Drawing.Brush,Eto.Drawing.RectangleF)}
			 * or other variants.
			 */
			Aligned = 2,
		}
	}

	export namespace Eto.Drawing {
		/**
		 * A struct representing X and Y co-ordinates as integer values
		 *
		 * The point struct is used for drawing and positioning of elements and widgets
		 */
		export class Point {
			/** Initializes a new instance of a Point class with specified `x` and `y` values */
			constructor(
				x: number,
				y: number,
			);

			/**
			 * Initializes a new instance of a Point class with {@link Eto.Drawing.Point.X} and
			 * {@link Eto.Drawing.Point.Y} values corresponding to the {@link Eto.Drawing.Size.Width}
			 * and {@link Eto.Drawing.Size.Height} values  of the specified `size`, respecitively
			 */
			constructor(size: Eto.Drawing.Size);

			/**
			 * Initializes a new instance of a Point class with truncated values of the specified
			 * floating-point `point`
			 */
			constructor(point: Eto.Drawing.PointF);

			/** Gets or sets the X co-ordinate of this point */
			X: number;

			/** Gets or sets the Y co-ordinate of this point */
			Y: number;

			/**
			 * Gets the point as a normal vector (perpendicular) to the current point from the origin
			 */
			readonly Normal: Eto.Drawing.Point;

			/**
			 * Gets the current point as a unit vector (a point with a
			 * {@link Eto.Drawing.Point.Length} of 1.0 from origin 0,0)
			 */
			readonly UnitVector: Eto.Drawing.PointF;

			/** Gets the length of the point as a vector from origin 0,0 */
			readonly Length: number;

			/** Gets the squared length of the point as a vector from origin 0,0. */
			readonly LengthSquared: number;

			/** Gets a value indicating that both the X and Y co-ordinates of this point are zero */
			readonly IsZero: boolean;

			/**
			 * Truncates the X and Y components of the specified `point` to a
			 * {@link Eto.Drawing.Point}
			 */
			static Truncate(point: Eto.Drawing.PointF): Eto.Drawing.Point;

			/**
			 * Rounds the X and Y components of the specified `point` to a {@link Eto.Drawing.Point}
			 */
			static Round(point: Eto.Drawing.PointF): Eto.Drawing.Point;

			/** Returns the minimum X and Y components of two points */
			static Min(
				point1: Eto.Drawing.Point,
				point2: Eto.Drawing.Point,
			): Eto.Drawing.Point;

			/** Returns the maximum X and Y components of two points */
			static Max(
				point1: Eto.Drawing.Point,
				point2: Eto.Drawing.Point,
			): Eto.Drawing.Point;

			/** Returns the absolute X and Y components of the specified `point` */
			static Abs(point: Eto.Drawing.Point): Eto.Drawing.Point;

			/**
			 * Creates a unit vector PointF (a point with a {@link Eto.Drawing.Point.Length} of 1.0
			 * from origin 0,0) with the specified angle, in degrees
			 */
			static UnitVectorAtAngle(angle: number): Eto.Drawing.PointF;

			/** Gets the distance between this point and the specified `point` */
			Distance(point: Eto.Drawing.Point): number;

			/** Gets the distance between two points using pythagoras theorem */
			static Distance(
				point1: Eto.Drawing.Point,
				point2: Eto.Drawing.Point,
			): number;

			/**
			 * Restricts the X and Y co-ordinates within the specified `rectangle`
			 *
			 * This will update the X and Y co-ordinates to be within the specified `rectangle` 's
			 * bounds. The updated co-ordinates will be the closest to the original value as
			 * possible. E.g. if the X co-ordinate is greater than the
			 * {@link Eto.Drawing.Rectangle.Right} of the rectangle, it will be set to be
			 * {@link Eto.Drawing.Rectangle.Right} minus one, to be within the rectangle's bounds.
			 */
			Restrict(rectangle: Eto.Drawing.Rectangle): void;

			/** Restricts the X and Y co-ordinates of the specified `point` within the `rectangle` */
			static Restrict(
				point: Eto.Drawing.Point,
				rectangle: Eto.Drawing.Rectangle,
			): Eto.Drawing.Point;

			/** Offsets the X and Y co-ordinates of this point by the specified `x` and `y` values */
			Offset(
				x: number,
				y: number,
			): void;

			/**
			 * Offsets the X and Y co-ordinates of this point by the values from the specified
			 * `point`
			 */
			Offset(point: Eto.Drawing.Point): void;

			/**
			 * Offsets the X and Y co-ordinates of the `point` by the specified `x` and `y` values
			 */
			static Offset(
				point: Eto.Drawing.Point,
				x: number,
				y: number,
			): Eto.Drawing.Point;

			/**
			 * Offsets the X and Y co-ordinates of the `point` by the values from the specified
			 * `offset`
			 */
			static Offset(
				point: Eto.Drawing.Point,
				offset: Eto.Drawing.Point,
			): Eto.Drawing.Point;

			/** Gets the dot product of this instance and the specified `point` */
			DotProduct(point: Eto.Drawing.Point): number;

			/** Gets the dot product between two points */
			static DotProduct(
				point1: Eto.Drawing.Point,
				point2: Eto.Drawing.Point,
			): number;

			/** Returns a value indicating that the specified `obj` is equal to this point */
			Equals(obj: unknown): boolean;

			/** Gets the hash code of this point */
			GetHashCode(): number;

			/** Converts this point to a string */
			ToString(): string;

			/** Returns a value indicating that the specified `other` point is equal to this point */
			Equals(other: Eto.Drawing.Point): boolean;
		}
	}

	export namespace Eto.Drawing {
		/**
		 * Converter for the {@link Eto.Drawing.Point} class
		 *
		 * Allows conversion from a string to a {@link Eto.Drawing.Point} via json/xaml or other
		 * sources.
		 */
		export class PointConverter {
			constructor();

			/** Determines if this converter can convert from the specified `sourceType` */
			CanConvertFrom(
				context: Eto.ITypeDescriptorContext,
				sourceType: unknown,
			): boolean;

			/** Converts the specified value to a {@link Eto.Drawing.Point} */
			ConvertFrom(
				context: Eto.ITypeDescriptorContext,
				culture: unknown,
				value: unknown,
			): unknown;

			/** Determines whether this instance can convert from the specified sourceType. */
			CanConvertFrom(sourceType: unknown): boolean;

			/** Determines whether this instance can convert to the specified destinationType. */
			CanConvertTo(destinationType: unknown): boolean;

			/**
			 * Determines whether this instance can convert to the specified context destinationType.
			 */
			CanConvertTo(
				context: Eto.ITypeDescriptorContext,
				destinationType: unknown,
			): boolean;

			/** Converts from the specified object. */
			ConvertFrom(o: unknown): unknown;

			/** Converts from an invariant string. */
			ConvertFromInvariantString(text: string): unknown;

			/** Converts from an invariant string. */
			ConvertFromInvariantString(
				context: Eto.ITypeDescriptorContext,
				text: string,
			): unknown;

			/** Converts from string. */
			ConvertFromString(text: string): unknown;

			/** Converts from string. */
			ConvertFromString(
				context: Eto.ITypeDescriptorContext,
				text: string,
			): unknown;

			/** Converts from string. */
			ConvertFromString(
				context: Eto.ITypeDescriptorContext,
				culture: unknown,
				text: string,
			): unknown;

			/** Converts to the specified type. */
			ConvertTo(
				value: unknown,
				destinationType: unknown,
			): unknown;

			/** Converts to the specified type. */
			ConvertTo(
				context: Eto.ITypeDescriptorContext,
				culture: unknown,
				value: unknown,
				destinationType: unknown,
			): unknown;

			/** Converts to an invariant string. */
			ConvertToInvariantString(value: unknown): string;

			/** Converts to invariant string. */
			ConvertToInvariantString(
				context: Eto.ITypeDescriptorContext,
				value: unknown,
			): string;

			/** Converts to a string. */
			ConvertToString(value: unknown): string;

			/** Converts to a string. */
			ConvertToString(
				context: Eto.ITypeDescriptorContext,
				value: unknown,
			): string;

			/** Converts to a string. */
			ConvertToString(
				context: Eto.ITypeDescriptorContext,
				culture: unknown,
				value: unknown,
			): string;

			/** Determines whether this instance is valid the specified value. */
			IsValid(value: unknown): boolean;

			/** Determines whether this instance is valid the specified context value. */
			IsValid(
				context: Eto.ITypeDescriptorContext,
				value: unknown,
			): boolean;
		}
	}

	export namespace Eto.Drawing {
		/**
		 * A struct representing X and Y co-ordinates as floating point values
		 *
		 * The point struct is used for drawing and positioning of elements and widgets
		 */
		export class PointF {
			/** Initializes a new instance of a Point class with specified `x` and `y` values */
			constructor(
				x: number,
				y: number,
			);

			/**
			 * Initializes a new instance of a Point class with {@link Eto.Drawing.PointF.X} and
			 * {@link Eto.Drawing.PointF.Y} values corresponding to the
			 * {@link Eto.Drawing.Size.Width} and {@link Eto.Drawing.Size.Height} values  of the
			 * specified `size`, respecitively
			 */
			constructor(size: Eto.Drawing.SizeF);

			/** Initializes a new instance of a PointF class with values of the Point `point` */
			constructor(point: Eto.Drawing.Point);

			/** Gets or sets the X co-ordinate of this point */
			X: number;

			/** Gets or sets the Y co-ordinate of this point */
			Y: number;

			/**
			 * Gets the point as a normal vector (perpendicular) to the current point from the origin
			 */
			readonly Normal: Eto.Drawing.PointF;

			/**
			 * Gets the current point as a unit vector (a point with a
			 * {@link Eto.Drawing.PointF.Length} of 1.0 from origin 0,0)
			 */
			readonly UnitVector: Eto.Drawing.PointF;

			/** Gets the angle of the point as a vector from origin 0,0. */
			readonly Angle: number;

			/** Gets the length of the point as a vector from origin 0,0 */
			readonly Length: number;

			/** Gets the squared length of the point as a vector from origin 0,0. */
			readonly LengthSquared: number;

			/** Gets a value indicating that both the X and Y co-ordinates of this point are zero */
			readonly IsZero: boolean;

			/** Returns the minimum X and Y components of two points */
			static Min(
				point1: Eto.Drawing.PointF,
				point2: Eto.Drawing.PointF,
			): Eto.Drawing.PointF;

			/** Returns the maximum X and Y components of two points */
			static Max(
				point1: Eto.Drawing.PointF,
				point2: Eto.Drawing.PointF,
			): Eto.Drawing.PointF;

			/** Returns the absolute X and Y components of the specified `point` */
			static Abs(point: Eto.Drawing.PointF): Eto.Drawing.PointF;

			/**
			 * Creates a unit vector PointF (a point with a {@link Eto.Drawing.PointF.Length} of 1.0
			 * from origin 0,0) with the specified angle, in degrees
			 */
			static UnitVectorAtAngle(angle: number): Eto.Drawing.PointF;

			/** Gets the angle of the width/height as a vector from the specified `destination`. */
			AngleTo(destination: Eto.Drawing.PointF): number;

			/** Gets the length between this point and the `destination` point. */
			LengthTo(destination: Eto.Drawing.PointF): number;

			/** Gets the distance between this point and the specified `point` */
			Distance(point: Eto.Drawing.PointF): number;

			/** Gets the distance between two points using pythagoras theorem */
			static Distance(
				point1: Eto.Drawing.PointF,
				point2: Eto.Drawing.PointF,
			): number;

			/**
			 * Restricts the X and Y co-ordinates within the specified `rectangle`
			 *
			 * This will update the X and Y co-ordinates to be within the specified `rectangle` 's
			 * bounds. The updated co-ordinates will be the closest to the original value as
			 * possible. E.g. if the X co-ordinate is greater than the
			 * {@link Eto.Drawing.Rectangle.Right} of the rectangle, it will be set to be
			 * {@link Eto.Drawing.Rectangle.Right} minus one, to be within the rectangle's bounds.
			 */
			Restrict(rectangle: Eto.Drawing.RectangleF): void;

			/** Restricts the X and Y co-ordinates of the specified `point` within the `rectangle` */
			static Restrict(
				point: Eto.Drawing.Point,
				rectangle: Eto.Drawing.Rectangle,
			): Eto.Drawing.Point;

			/** Offsets the X and Y co-ordinates of this point by the specified `x` and `y` values */
			Offset(
				x: number,
				y: number,
			): void;

			/**
			 * Offsets the X and Y co-ordinates of this point by the values from the specified
			 * `offset`
			 */
			Offset(offset: Eto.Drawing.PointF): void;

			/**
			 * Offsets the X and Y co-ordinates of the `point` by the specified `x` and `y` values
			 */
			static Offset(
				point: Eto.Drawing.PointF,
				x: number,
				y: number,
			): Eto.Drawing.PointF;

			/**
			 * Offsets the X and Y co-ordinates of the `point` by the values from the specified
			 * `offset`
			 */
			static Offset(
				point: Eto.Drawing.PointF,
				offset: Eto.Drawing.PointF,
			): Eto.Drawing.PointF;

			/**
			 * Treats the point as a vector and rotates it around the origin (0,0) by the specified
			 * `angle`.
			 */
			Rotate(angle: number): void;

			/**
			 * Treats the `point` as a vector and rotates it around the origin (0,0) by the specified
			 * `angle`.
			 */
			static Rotate(
				point: Eto.Drawing.PointF,
				angle: number,
			): Eto.Drawing.PointF;

			/** Gets the dot product of this instance and the specified `point` */
			DotProduct(point: Eto.Drawing.PointF): number;

			/** Gets the dot product between two points */
			static DotProduct(
				point1: Eto.Drawing.PointF,
				point2: Eto.Drawing.PointF,
			): number;

			/** Returns a value indicating that the specified `obj` is equal to this point */
			Equals(obj: unknown): boolean;

			/** Gets the hash code of this point */
			GetHashCode(): number;

			/** Converts this point to a string */
			ToString(): string;

			/** Returns a value indicating that the specified `other` point is equal to this point */
			Equals(other: Eto.Drawing.PointF): boolean;
		}
	}

	export namespace Eto.Drawing {
		/**
		 * Converter for the {@link Eto.Drawing.PointF} class
		 *
		 * Allows conversion from a string to a {@link Eto.Drawing.PointF} via json/xaml or other
		 * sources.
		 */
		export class PointFConverter {
			constructor();

			/** Determines if this converter can convert from the specified `sourceType` */
			CanConvertFrom(
				context: Eto.ITypeDescriptorContext,
				sourceType: unknown,
			): boolean;

			/** Converts the specified value to a {@link Eto.Drawing.PointF} */
			ConvertFrom(
				context: Eto.ITypeDescriptorContext,
				culture: unknown,
				value: unknown,
			): unknown;

			/** Determines whether this instance can convert from the specified sourceType. */
			CanConvertFrom(sourceType: unknown): boolean;

			/** Determines whether this instance can convert to the specified destinationType. */
			CanConvertTo(destinationType: unknown): boolean;

			/**
			 * Determines whether this instance can convert to the specified context destinationType.
			 */
			CanConvertTo(
				context: Eto.ITypeDescriptorContext,
				destinationType: unknown,
			): boolean;

			/** Converts from the specified object. */
			ConvertFrom(o: unknown): unknown;

			/** Converts from an invariant string. */
			ConvertFromInvariantString(text: string): unknown;

			/** Converts from an invariant string. */
			ConvertFromInvariantString(
				context: Eto.ITypeDescriptorContext,
				text: string,
			): unknown;

			/** Converts from string. */
			ConvertFromString(text: string): unknown;

			/** Converts from string. */
			ConvertFromString(
				context: Eto.ITypeDescriptorContext,
				text: string,
			): unknown;

			/** Converts from string. */
			ConvertFromString(
				context: Eto.ITypeDescriptorContext,
				culture: unknown,
				text: string,
			): unknown;

			/** Converts to the specified type. */
			ConvertTo(
				value: unknown,
				destinationType: unknown,
			): unknown;

			/** Converts to the specified type. */
			ConvertTo(
				context: Eto.ITypeDescriptorContext,
				culture: unknown,
				value: unknown,
				destinationType: unknown,
			): unknown;

			/** Converts to an invariant string. */
			ConvertToInvariantString(value: unknown): string;

			/** Converts to invariant string. */
			ConvertToInvariantString(
				context: Eto.ITypeDescriptorContext,
				value: unknown,
			): string;

			/** Converts to a string. */
			ConvertToString(value: unknown): string;

			/** Converts to a string. */
			ConvertToString(
				context: Eto.ITypeDescriptorContext,
				value: unknown,
			): string;

			/** Converts to a string. */
			ConvertToString(
				context: Eto.ITypeDescriptorContext,
				culture: unknown,
				value: unknown,
			): string;

			/** Determines whether this instance is valid the specified value. */
			IsValid(value: unknown): boolean;

			/** Determines whether this instance is valid the specified context value. */
			IsValid(
				context: Eto.ITypeDescriptorContext,
				value: unknown,
			): boolean;
		}
	}

	export namespace Eto.Drawing {
		/**
		 * Brush with an elliptical radial gradient from a specified origin.
		 *
		 * The gradient origin must fall within the ellipse, otherwise the behavior is undefined.
		 */
		export class RadialGradientBrush implements
			Eto.IHandlerSource,
			Eto.IControlObjectSource,
			Eto.Drawing.ITransformBrush {
			/** Initializes a new instance of the {@link Eto.Drawing.RadialGradientBrush}. */
			constructor(
				startColor: Eto.Drawing.Color,
				endColor: Eto.Drawing.Color,
				center: Eto.Drawing.PointF,
				gradientOrigin: Eto.Drawing.PointF,
				radius: Eto.Drawing.SizeF,
			);

			/** Gets the platform handler object for the widget */
			readonly Handler: unknown;

			/**
			 * Gets a delegate to instantiate {@link Eto.Drawing.RadialGradientBrush} objects
			 *
			 * Use this to instantiate many objects of this type
			 */
			static readonly Instantiator: (arg1: Eto.Drawing.Color, arg2: Eto.Drawing.Color, arg3: Eto.Drawing.PointF, arg4: Eto.Drawing.PointF, arg5: Eto.Drawing.SizeF) => Eto.Drawing.RadialGradientBrush;

			/** Gets or sets the transform to apply to the gradient */
			Transform: Eto.Drawing.IMatrix;

			/** Gets or sets the wrap mode for the gradient */
			Wrap: Eto.Drawing.GradientWrapMode;

			/** Gets or sets the control object for this widget */
			ControlObject: unknown;

			/**
			 * Releases all resource used by the {@link Eto.Drawing.Brush} object.
			 *
			 * Call {@link Eto.Drawing.Brush.Dispose} when you are finished using the
			 * {@link Eto.Drawing.Brush}. The {@link Eto.Drawing.Brush.Dispose} method leaves the
			 * {@link Eto.Drawing.Brush} in an unusable state. After calling
			 * {@link Eto.Drawing.Brush.Dispose}, you must release all references to the
			 * {@link Eto.Drawing.Brush} so the garbage collector can reclaim the memory that the
			 * {@link Eto.Drawing.Brush} was occupying.
			 */
			dispose(): void;
		}
	}

	export namespace Eto.Drawing.RadialGradientBrush {
		export interface IHandler extends Eto.Drawing.Brush.IHandler {
			Create(
				startColor: Eto.Drawing.Color,
				endColor: Eto.Drawing.Color,
				center: Eto.Drawing.PointF,
				gradientOrigin: Eto.Drawing.PointF,
				radius: Eto.Drawing.SizeF,
			): unknown;

			GetTransform(widget: Eto.Drawing.RadialGradientBrush): Eto.Drawing.IMatrix;

			SetTransform(
				widget: Eto.Drawing.RadialGradientBrush,
				transform: Eto.Drawing.IMatrix,
			): void;

			GetGradientWrap(widget: Eto.Drawing.RadialGradientBrush): Eto.Drawing.GradientWrapMode;

			SetGradientWrap(
				widget: Eto.Drawing.RadialGradientBrush,
				gradientWrap: Eto.Drawing.GradientWrapMode,
			): void;
		}
	}

	export namespace Eto.Drawing {
		/**
		 * Represents a rectangle with a location (X, Y) and size (Width, Height) components.
		 *
		 * A rectangle is defined by a location (X, Y) and a size (Width, Height). The width
		 * and/or height can be negative.
		 */
		export class Rectangle {
			/** Initializes a new instance of the Rectangle class with two points */
			constructor(
				start: Eto.Drawing.Point,
				end: Eto.Drawing.Point,
			);

			/**
			 * Initializes a new instance of the Rectangle class with the specified `location` and
			 * `size`
			 */
			constructor(
				location: Eto.Drawing.Point,
				size: Eto.Drawing.Size,
			);

			/**
			 * Initializes a new instance of the Rectangle class with X, Y co-ordinates at 0,0 and
			 * the specified `size`
			 */
			constructor(size: Eto.Drawing.Size);

			/**
			 * Initializes a new instance of the Rectangle class with the specified `x`, `y`,
			 * `width`, and `height`
			 */
			constructor(
				x: number,
				y: number,
				width: number,
				height: number,
			);

			/**
			 * Initializes a new instance of a Rectangle class with truncated values of the specified
			 * floating-point `rectangle`
			 */
			constructor(rectangle: Eto.Drawing.RectangleF);

			/**
			 * Gets a value indicating that both the  and {@link Eto.Drawing.Rectangle.Size} of this
			 * rectangle are zero
			 *
			 * The X, Y, Width, and Height components of this rectangle must be zero for this to
			 * return true.
			 */
			readonly IsZero: boolean;

			/**
			 * Gets a value indicating that the {@link Eto.Drawing.Rectangle.Size} of this rectangle
			 * is empty (either the width or height are zero)
			 */
			readonly IsEmpty: boolean;

			/**
			 * Gets the location of this rectangle
			 *
			 * Same as getting the {@link Eto.Drawing.Rectangle.X} and
			 * {@link Eto.Drawing.Rectangle.Y} co-ordinates of this rectangle
			 */
			Location: Eto.Drawing.Point;

			/**
			 * Gets the ending location of this rectangle
			 *
			 * This gets/sets the product of the {@link Eto.Drawing.Rectangle.Location} +
			 * {@link Eto.Drawing.Rectangle.Size}. If the Width or Height of this rectangle is
			 * positive, then the X/Y of the returned location will be minus 1 so as to be inside of
			 * the rectangle's bounds.
			 */
			EndLocation: Eto.Drawing.Point;

			/** Gets or sets the size of the rectangle */
			Size: Eto.Drawing.Size;

			/**
			 * Gets or sets the X co-ordinate of the {@link Eto.Drawing.Rectangle.Location} of this
			 * rectangle
			 */
			X: number;

			/**
			 * Gets or sets the Y co-ordinate of the {@link Eto.Drawing.Rectangle.Location} of this
			 * rectangle
			 */
			Y: number;

			/** Gets or sets the Width of this rectangle */
			Width: number;

			/** Gets or sets the Height of this rectangle */
			Height: number;

			/**
			 * Gets or sets the logical top of this rectangle (Y co-ordinate if Height is positive, Y
			 * + Height if negative)
			 *
			 * This is always the logical top, where if the {@link Eto.Drawing.Rectangle.Height} is
			 * positive it will adjust the Y co-ordinate. If the Height of the rectangle is negative,
			 * then this will adjust the Height when setting the value.
			 */
			Top: number;

			/**
			 * Gets or sets the logical left of this rectangle (X co-ordinate if Width is positive, X
			 * + Width if negative)
			 */
			Left: number;

			/**
			 * Gets or sets the logical right of this rectangle (X + Width if Width is positive, X +
			 * 1 if negative)
			 *
			 * This differs from the  in that this will return the co-ordinate adjacent to the right
			 * edge of the rectangle, whereas  returns the co-ordinate that is inside the rectangle
			 */
			Right: number;

			/**
			 * Gets or sets the logical bottom of this rectangle (Y + Height if Height is positive, Y
			 * + 1 if negative)
			 *
			 * This differs from the  in that this will return the co-ordinate adjacent to the bottom
			 * edge of the rectangle, whereas  returns the co-ordinate that is inside the rectangle
			 */
			Bottom: number;

			/**
			 * Gets or sets the point at the {@link Eto.Drawing.Rectangle.Top} and
			 * {@link Eto.Drawing.Rectangle.Left} of the rectangle
			 */
			TopLeft: Eto.Drawing.Point;

			/**
			 * Gets or sets the point at the {@link Eto.Drawing.Rectangle.Top} and
			 * {@link Eto.Drawing.Rectangle.Right} of the rectangle
			 */
			TopRight: Eto.Drawing.Point;

			/**
			 * Gets or sets the point at the {@link Eto.Drawing.Rectangle.Bottom} and
			 * {@link Eto.Drawing.Rectangle.Right} of the rectangle
			 */
			BottomRight: Eto.Drawing.Point;

			/**
			 * Gets or sets the point at the {@link Eto.Drawing.Rectangle.Bottom} and
			 * {@link Eto.Drawing.Rectangle.Left} of the rectangle
			 */
			BottomLeft: Eto.Drawing.Point;

			/**
			 * Gets or sets the point at the {@link Eto.Drawing.Rectangle.Left} and
			 * {@link Eto.Drawing.Rectangle.MiddleY} of the rectangle
			 */
			MiddleLeft: Eto.Drawing.Point;

			/**
			 * Gets or sets the point at the {@link Eto.Drawing.Rectangle.Right} and
			 * {@link Eto.Drawing.Rectangle.MiddleY} of the rectangle
			 */
			MiddleRight: Eto.Drawing.Point;

			/**
			 * Gets or sets the point at the {@link Eto.Drawing.Rectangle.MiddleX} and
			 * {@link Eto.Drawing.Rectangle.Top} of the rectangle
			 */
			MiddleTop: Eto.Drawing.Point;

			/**
			 * Gets or sets the point at the {@link Eto.Drawing.Rectangle.MiddleX} and
			 * {@link Eto.Drawing.Rectangle.Bottom} of the rectangle
			 */
			MiddleBottom: Eto.Drawing.Point;

			/**
			 * Gets or sets the point at the {@link Eto.Drawing.Rectangle.Top} and
			 * {@link Eto.Drawing.Rectangle.InnerRight} of the rectangle
			 *
			 * Similar to  but inside the rectangle's bounds instead of just to the right
			 */
			InnerTopRight: Eto.Drawing.Point;

			/**
			 * Gets or sets the point at the {@link Eto.Drawing.Rectangle.InnerBottom} and
			 * {@link Eto.Drawing.Rectangle.InnerRight} of the rectangle
			 *
			 * Similar to  but inside the rectangle's bounds instead of just to the right and bottom
			 */
			InnerBottomRight: Eto.Drawing.Point;

			/**
			 * Gets or sets the point at the {@link Eto.Drawing.Rectangle.InnerBottom} and
			 * {@link Eto.Drawing.Rectangle.Left} of the rectangle
			 *
			 * Similar to  but inside the rectangle's bounds instead of just below the bottom
			 */
			InnerBottomLeft: Eto.Drawing.Point;

			/**
			 * Gets or sets the bottom of the rectangle that is inside the bounds
			 *
			 * Similar to  but inside the rectangle's bounds instead of just below the bottom
			 */
			InnerBottom: number;

			/**
			 * Gets or sets the right of the rectangle that is inside the bounds
			 *
			 * Similar to  but inside the rectangle's bounds instead of just to the right
			 */
			InnerRight: number;

			/**
			 * Gets or sets the rectangle's center position
			 *
			 * This gets/sets the {@link Eto.Drawing.Rectangle.MiddleX} and
			 * {@link Eto.Drawing.Rectangle.MiddleY} as a point
			 */
			Center: Eto.Drawing.Point;

			/** Gets or sets the rectangle's middle horizontal position */
			MiddleX: number;

			/** Gets or sets the rectangle's middle vertical position */
			MiddleY: number;

			/**
			 * Converts a floating point `rectangle` to an integral {@link Eto.Drawing.Rectangle} by
			 * rounding the X, Y, Width, and Height.
			 */
			static Round(rectangle: Eto.Drawing.RectangleF): Eto.Drawing.Rectangle;

			/**
			 * Converts a floating point `rectangle` to an integral {@link Eto.Drawing.Rectangle} by
			 * getting the smallest integral value of X, Y, Width, and Height
			 *
			 * This is used to get an integral rectangle that bounds the floating point rectangle
			 * completely. E.g. if a RectangleF has (X,Y,W,H) values of 0.2, 0.9, 1.1, 1.9, it would
			 * return a new integral rectangle with values 0, 0, 2, 2.
			 */
			static Ceiling(rectangle: Eto.Drawing.RectangleF): Eto.Drawing.Rectangle;

			/**
			 * Converts a floating point `rectangle` to an integral {@link Eto.Drawing.Rectangle} by
			 * truncating the X, Y, Width, and Height values
			 */
			static Truncate(rectangle: Eto.Drawing.RectangleF): Eto.Drawing.Rectangle;

			/**
			 * Normalizes the rectangle so both the {@link Eto.Drawing.Rectangle.Width} and
			 * {@link Eto.Drawing.Rectangle.Height} are positive, without changing the location of
			 * the rectangle
			 *
			 * Rectangles can have negative widths/heights, which means that the starting location
			 * will not always be at the top left corner.  Normalizing the rectangle will ensure that
			 * the {@link Eto.Drawing.Rectangle.X} and {@link Eto.Drawing.Rectangle.Y} co-ordinates
			 * of the rectangle are at the top left.
			 */
			Normalize(): void;

			/**
			 * Creates a new instance of a RectangleF from the values of the `left`, `top`, `right`
			 * and `bottom` sides
			 */
			static FromSides(
				left: number,
				top: number,
				right: number,
				bottom: number,
			): Eto.Drawing.Rectangle;

			/** Creates a new instance of a Rectangle with a specified `center` and `size` */
			static FromCenter(
				center: Eto.Drawing.Point,
				size: Eto.Drawing.Size,
			): Eto.Drawing.Rectangle;

			/**
			 * Gets a value indicating that the specified `point` is within the bounds of this
			 * rectangle
			 */
			Contains(point: Eto.Drawing.Point): boolean;

			/**
			 * Gets a value indicating that the specified `x` and `y` co-ordinates are within the
			 * bounds of this rectangle
			 */
			Contains(
				x: number,
				y: number,
			): boolean;

			/**
			 * Gets a value indicating that the specified `rectangle` is entirely contained within
			 * the bounds of this rectangle
			 */
			Contains(rectangle: Eto.Drawing.Rectangle): boolean;

			/** Gets a value indicating that the specified `rectangle` overlaps this rectangle */
			Intersects(rectangle: Eto.Drawing.Rectangle): boolean;

			/** Offsets the location of the rectangle by the specified `x` and `y` values */
			Offset(
				x: number,
				y: number,
			): void;

			/** Offsets the location of the rectangle by the specified `size` */
			Offset(size: Eto.Drawing.Size): void;

			/**
			 * Offsets the location of the rectangle by the X and Y values of the specified `point`
			 */
			Offset(point: Eto.Drawing.Point): void;

			/** Offsets the location of the `rectangle` by the specified `x` and `y` values */
			static Offset(
				rectangle: Eto.Drawing.Rectangle,
				x: number,
				y: number,
			): Eto.Drawing.Rectangle;

			/** Offsets the location of the `rectangle` by the specified `size` */
			static Offset(
				rectangle: Eto.Drawing.Rectangle,
				size: Eto.Drawing.Size,
			): Eto.Drawing.Rectangle;

			/**
			 * Offsets the location of the `rectangle` by the X and Y values of the specified `point`
			 */
			static Offset(
				rectangle: Eto.Drawing.Rectangle,
				point: Eto.Drawing.Point,
			): Eto.Drawing.Rectangle;

			/**
			 * Inflates all dimensions of this rectangle by the specified `size`
			 *
			 * This inflates the rectangle in all dimensions by the width and height specified by
			 * `size`. The resulting rectangle will be increased in width and height twice that of
			 * the specified size, and the center will be in the same location. A negative width
			 * and/or height can be passed in to deflate the rectangle.
			 */
			Inflate(size: Eto.Drawing.Size): void;

			/**
			 * Inflates all dimensions of this rectangle by the specified `width` and `height`
			 *
			 * This inflates the rectangle in all dimensions by the specified `width` and `height`.
			 * The resulting rectangle will be increased in width and height twice that of the
			 * specified size, and the center will be in the same location. A negative width and/or
			 * height can be passed in to deflate the rectangle.
			 */
			Inflate(
				width: number,
				height: number,
			): void;

			/**
			 * Inflates all dimensions of the `rectangle` by the specified `size`
			 *
			 * This inflates the `rectangle` in all dimensions by the width and height specified by
			 * `size`. The resulting rectangle will be increased in width and height twice that of
			 * the specified size, and the center will be in the same location. A negative width
			 * and/or height can be passed in to deflate the rectangle.
			 */
			static Inflate(
				rectangle: Eto.Drawing.Rectangle,
				size: Eto.Drawing.Size,
			): Eto.Drawing.Rectangle;

			/**
			 * Inflates all dimensions of this `rectangle` by the specified `width` and `height`
			 *
			 * This inflates the `rectangle` in all dimensions by the specified `width` and `height`.
			 * The resulting rectangle will be increased in width and height twice that of the
			 * specified size, and the center will be in the same location. A negative width and/or
			 * height can be passed in to deflate the rectangle.
			 */
			static Inflate(
				rectangle: Eto.Drawing.Rectangle,
				width: number,
				height: number,
			): Eto.Drawing.Rectangle;

			/** Insets the rectangle by the specified padding. */
			Inset(padding: Eto.Drawing.Padding): void;

			/** Returns a new rectangle that is inset by the specified `padding` */
			static Inset(
				rectangle: Eto.Drawing.Rectangle,
				padding: Eto.Drawing.Padding,
			): Eto.Drawing.Rectangle;

			/**
			 * Aligns the rectangle to a grid of the specified `gridSize`
			 *
			 * This will align the top, left, right, and bottom to a grid by inflating each edge to
			 * the next grid line.
			 */
			Align(gridSize: Eto.Drawing.Size): void;

			/**
			 * Aligns the rectangle to a grid of the specified `gridWidth` and `gridHeight`
			 *
			 * This will align the top, left, right, and bottom to a grid by inflating each edge to
			 * the next grid line.
			 */
			Align(
				gridWidth: number,
				gridHeight: number,
			): void;

			/**
			 * Aligns the `rectangle` to a grid of the specified `gridSize`
			 *
			 * This will align the top, left, right, and bottom to a grid by inflating each edge to
			 * the next grid line.
			 */
			static Align(
				rectangle: Eto.Drawing.Rectangle,
				gridSize: Eto.Drawing.Size,
			): Eto.Drawing.Rectangle;

			/**
			 * Aligns the `rectangle` to a grid of the specified `gridWidth` and `gridHeight`
			 *
			 * This will align the top, left, right, and bottom to a grid by inflating each edge to
			 * the next grid line.
			 */
			static Align(
				rectangle: Eto.Drawing.Rectangle,
				gridWidth: number,
				gridHeight: number,
			): Eto.Drawing.Rectangle;

			/** Union the `rectangle` into this instance to encompass both rectangles */
			Union(rectangle: Eto.Drawing.Rectangle): void;

			/** Combines two rectangles into one rectangle that encompasses both */
			static Union(
				rect1: Eto.Drawing.Rectangle,
				rect2: Eto.Drawing.Rectangle,
			): Eto.Drawing.Rectangle;

			/** Intersect the rectangle with the specified `rectangle` */
			Intersect(rectangle: Eto.Drawing.Rectangle): void;

			/** Intersect the two specified rectangles */
			static Intersect(
				rect1: Eto.Drawing.Rectangle,
				rect2: Eto.Drawing.Rectangle,
			): Eto.Drawing.Rectangle;

			/**
			 * Restricts the rectangle to be within the specified `location` and `size`
			 *
			 * This is a shortcut for
			 */
			Restrict(
				location: Eto.Drawing.Point,
				size: Eto.Drawing.Size,
			): void;

			/**
			 * Restricts the rectangle to be within the specified `size` at an X,Y location of 0, 0
			 *
			 * This is a shortcut for
			 */
			Restrict(size: Eto.Drawing.Size): void;

			/**
			 * Restricts the rectangle to be within the specified `rectangle`
			 *
			 * This ensures that the current rectangle's bounds fall within the bounds of the
			 * specified `rectangle`. It is useful to ensure that the rectangle does not exceed
			 * certain limits (e.g. for drawing)
			 */
			Restrict(rectangle: Eto.Drawing.Rectangle): void;

			/**
			 * Restricts the `rectangle` to be within the specified `size`
			 *
			 * This ensures that `rectangle` 's bounds fall within the bounds of the specified `size`
			 * It is useful to ensure that the rectangle does not exceed certain limits (e.g. for
			 * drawing)
			 */
			static Restrict(
				rectangle: Eto.Drawing.Rectangle,
				size: Eto.Drawing.Size,
			): Eto.Drawing.Rectangle;

			/**
			 * Restricts the `rectangle` to be within the `restrict` rectangle
			 *
			 * This ensures that `rectangle` 's bounds fall within the bounds of the specified
			 * `restrict` rectangle It is useful to ensure that the rectangle does not exceed certain
			 * limits (e.g. for drawing)
			 */
			static Restrict(
				rectangle: Eto.Drawing.Rectangle,
				restrict: Eto.Drawing.Rectangle,
			): Eto.Drawing.Rectangle;

			/** Converts this rectangle to a string */
			ToString(): string;

			/** Compares this rectangle to an object for equality */
			Equals(obj: unknown): boolean;

			/** Gets the hash code for this rectangle */
			GetHashCode(): number;

			/** Compares this rectangle with the specified `other` rectangle */
			Equals(other: Eto.Drawing.Rectangle): boolean;
		}
	}

	export namespace Eto.Drawing {
		/**
		 * Converter for the {@link Eto.Drawing.Rectangle} class
		 *
		 * Allows for conversion from a string to a {@link Eto.Drawing.Rectangle}.
		 */
		export class RectangleConverter {
			constructor();

			/** Determines if this converter can convert from the specified `sourceType` */
			CanConvertFrom(
				context: Eto.ITypeDescriptorContext,
				sourceType: unknown,
			): boolean;

			/** Converts the specified value to a {@link Eto.Drawing.Rectangle} */
			ConvertFrom(
				context: Eto.ITypeDescriptorContext,
				culture: unknown,
				value: unknown,
			): unknown;

			/** Determines whether this instance can convert from the specified sourceType. */
			CanConvertFrom(sourceType: unknown): boolean;

			/** Determines whether this instance can convert to the specified destinationType. */
			CanConvertTo(destinationType: unknown): boolean;

			/**
			 * Determines whether this instance can convert to the specified context destinationType.
			 */
			CanConvertTo(
				context: Eto.ITypeDescriptorContext,
				destinationType: unknown,
			): boolean;

			/** Converts from the specified object. */
			ConvertFrom(o: unknown): unknown;

			/** Converts from an invariant string. */
			ConvertFromInvariantString(text: string): unknown;

			/** Converts from an invariant string. */
			ConvertFromInvariantString(
				context: Eto.ITypeDescriptorContext,
				text: string,
			): unknown;

			/** Converts from string. */
			ConvertFromString(text: string): unknown;

			/** Converts from string. */
			ConvertFromString(
				context: Eto.ITypeDescriptorContext,
				text: string,
			): unknown;

			/** Converts from string. */
			ConvertFromString(
				context: Eto.ITypeDescriptorContext,
				culture: unknown,
				text: string,
			): unknown;

			/** Converts to the specified type. */
			ConvertTo(
				value: unknown,
				destinationType: unknown,
			): unknown;

			/** Converts to the specified type. */
			ConvertTo(
				context: Eto.ITypeDescriptorContext,
				culture: unknown,
				value: unknown,
				destinationType: unknown,
			): unknown;

			/** Converts to an invariant string. */
			ConvertToInvariantString(value: unknown): string;

			/** Converts to invariant string. */
			ConvertToInvariantString(
				context: Eto.ITypeDescriptorContext,
				value: unknown,
			): string;

			/** Converts to a string. */
			ConvertToString(value: unknown): string;

			/** Converts to a string. */
			ConvertToString(
				context: Eto.ITypeDescriptorContext,
				value: unknown,
			): string;

			/** Converts to a string. */
			ConvertToString(
				context: Eto.ITypeDescriptorContext,
				culture: unknown,
				value: unknown,
			): string;

			/** Determines whether this instance is valid the specified value. */
			IsValid(value: unknown): boolean;

			/** Determines whether this instance is valid the specified context value. */
			IsValid(
				context: Eto.ITypeDescriptorContext,
				value: unknown,
			): boolean;
		}
	}

	export namespace Eto.Drawing {
		/**
		 * Represents a floating point rectangle with a location (X, Y) and size (Width, Height)
		 * components.
		 *
		 * A rectangle is defined by a location (X, Y) and a size (Width, Height). The width
		 * and/or height can be negative.
		 */
		export class RectangleF {
			/** Initializes a new instance of the Rectangle class with two points */
			constructor(
				start: Eto.Drawing.PointF,
				end: Eto.Drawing.PointF,
			);

			/**
			 * Initializes a new instance of the Rectangle class with the specified `location` and
			 * `size`
			 */
			constructor(
				location: Eto.Drawing.PointF,
				size: Eto.Drawing.SizeF,
			);

			/** Initilizes a new instance of the RectangleF class with the specified `rectangle`. */
			constructor(rectangle: Eto.Drawing.Rectangle);

			/**
			 * Initializes a new instance of the Rectangle class with X, Y co-ordinates at 0,0 and
			 * the specified `size`
			 */
			constructor(size: Eto.Drawing.SizeF);

			/**
			 * Initializes a new instance of the Rectangle class with the specified `x`, `y`,
			 * `width`, and `height`
			 */
			constructor(
				x: number,
				y: number,
				width: number,
				height: number,
			);

			/**
			 * Gets a value indicating that both the  and {@link Eto.Drawing.RectangleF.Size} of this
			 * rectangle are zero
			 *
			 * The X, Y, Width, and Height components of this rectangle must be zero for this to
			 * return true.
			 */
			readonly IsZero: boolean;

			/**
			 * Gets a value indicating that the {@link Eto.Drawing.RectangleF.Size} of this rectangle
			 * is empty (either the width or height are zero)
			 */
			readonly IsEmpty: boolean;

			/**
			 * Gets the location of this rectangle
			 *
			 * Same as getting the {@link Eto.Drawing.RectangleF.X} and
			 * {@link Eto.Drawing.RectangleF.Y} co-ordinates of this rectangle
			 */
			Location: Eto.Drawing.PointF;

			/**
			 * Gets the ending location of this rectangle
			 *
			 * This gets/sets the product of the {@link Eto.Drawing.RectangleF.Location} +
			 * {@link Eto.Drawing.RectangleF.Size}. If the Width or Height of this rectangle is
			 * positive, then the X/Y of the returned location will be minus 1 so as to be inside of
			 * the rectangle's bounds.
			 */
			EndLocation: Eto.Drawing.PointF;

			/** Gets or sets the size of the rectangle */
			Size: Eto.Drawing.SizeF;

			/**
			 * Gets or sets the X co-ordinate of the {@link Eto.Drawing.RectangleF.Location} of this
			 * rectangle
			 */
			X: number;

			/**
			 * Gets or sets the Y co-ordinate of the {@link Eto.Drawing.RectangleF.Location} of this
			 * rectangle
			 */
			Y: number;

			/** Gets or sets the Width of this rectangle */
			Width: number;

			/** Gets or sets the Height of this rectangle */
			Height: number;

			/**
			 * Gets or sets the logical top of this rectangle (Y co-ordinate if Height is positive, Y
			 * + Height if negative)
			 *
			 * This is always the logical top, where if the {@link Eto.Drawing.RectangleF.Height} is
			 * positive it will adjust the Y co-ordinate. If the Height of the rectangle is negative,
			 * then this will adjust the Height when setting the value.
			 */
			Top: number;

			/**
			 * Gets or sets the logical left of this rectangle (X co-ordinate if Width is positive, X
			 * + Width if negative)
			 */
			Left: number;

			/**
			 * Gets or sets the logical right of this rectangle (X + Width if Width is positive, X +
			 * 1 if negative)
			 *
			 * This differs from the  in that this will return the co-ordinate adjacent to the right
			 * edge of the rectangle, whereas  returns the co-ordinate that is inside the rectangle
			 */
			Right: number;

			/**
			 * Gets or sets the logical bottom of this rectangle (Y + Height if Height is positive, Y
			 * + 1 if negative)
			 *
			 * This differs from the  in that this will return the co-ordinate adjacent to the bottom
			 * edge of the rectangle, whereas  returns the co-ordinate that is inside the rectangle
			 */
			Bottom: number;

			/**
			 * Gets or sets the point at the {@link Eto.Drawing.RectangleF.Top} and
			 * {@link Eto.Drawing.RectangleF.Left} of the rectangle
			 */
			TopLeft: Eto.Drawing.PointF;

			/**
			 * Gets or sets the point at the {@link Eto.Drawing.RectangleF.Top} and
			 * {@link Eto.Drawing.RectangleF.Right} of the rectangle
			 */
			TopRight: Eto.Drawing.PointF;

			/**
			 * Gets or sets the point at the {@link Eto.Drawing.RectangleF.Bottom} and
			 * {@link Eto.Drawing.RectangleF.Right} of the rectangle
			 */
			BottomRight: Eto.Drawing.PointF;

			/**
			 * Gets or sets the point at the {@link Eto.Drawing.RectangleF.Bottom} and
			 * {@link Eto.Drawing.RectangleF.Left} of the rectangle
			 */
			BottomLeft: Eto.Drawing.PointF;

			/**
			 * Gets or sets the point at the {@link Eto.Drawing.RectangleF.Left} and
			 * {@link Eto.Drawing.RectangleF.MiddleY} of the rectangle
			 */
			MiddleLeft: Eto.Drawing.PointF;

			/**
			 * Gets or sets the point at the {@link Eto.Drawing.RectangleF.Right} and
			 * {@link Eto.Drawing.RectangleF.MiddleY} of the rectangle
			 */
			MiddleRight: Eto.Drawing.PointF;

			/**
			 * Gets or sets the point at the {@link Eto.Drawing.RectangleF.MiddleX} and
			 * {@link Eto.Drawing.RectangleF.Top} of the rectangle
			 */
			MiddleTop: Eto.Drawing.PointF;

			/**
			 * Gets or sets the point at the {@link Eto.Drawing.RectangleF.MiddleX} and
			 * {@link Eto.Drawing.RectangleF.Bottom} of the rectangle
			 */
			MiddleBottom: Eto.Drawing.PointF;

			/**
			 * Gets or sets the point at the {@link Eto.Drawing.RectangleF.Top} and
			 * {@link Eto.Drawing.RectangleF.InnerRight} of the rectangle
			 *
			 * Similar to  but inside the rectangle's bounds instead of just to the right
			 */
			InnerTopRight: Eto.Drawing.PointF;

			/**
			 * Gets or sets the point at the {@link Eto.Drawing.RectangleF.InnerBottom} and
			 * {@link Eto.Drawing.RectangleF.InnerRight} of the rectangle
			 *
			 * Similar to  but inside the rectangle's bounds instead of just to the right and bottom
			 */
			InnerBottomRight: Eto.Drawing.PointF;

			/**
			 * Gets or sets the point at the {@link Eto.Drawing.RectangleF.InnerBottom} and
			 * {@link Eto.Drawing.RectangleF.Left} of the rectangle
			 *
			 * Similar to  but inside the rectangle's bounds instead of just below the bottom
			 */
			InnerBottomLeft: Eto.Drawing.PointF;

			/**
			 * Gets or sets the bottom of the rectangle that is inside the bounds
			 *
			 * Similar to  but inside the rectangle's bounds instead of just below the bottom
			 */
			InnerBottom: number;

			/**
			 * Gets or sets the right of the rectangle that is inside the bounds
			 *
			 * Similar to  but inside the rectangle's bounds instead of just to the right
			 */
			InnerRight: number;

			/**
			 * Gets or sets the rectangle's center position
			 *
			 * This gets/sets the {@link Eto.Drawing.RectangleF.MiddleX} and
			 * {@link Eto.Drawing.RectangleF.MiddleY} as a point
			 */
			Center: Eto.Drawing.PointF;

			/** Gets or sets the rectangle's middle horizontal position */
			MiddleX: number;

			/** Gets or sets the rectangle's middle vertical position */
			MiddleY: number;

			/**
			 * Normalizes the rectangle so both the {@link Eto.Drawing.RectangleF.Width} and
			 * {@link Eto.Drawing.RectangleF.Height} are positive, without changing the location of
			 * the rectangle
			 *
			 * Rectangles can have negative widths/heights, which means that the starting location
			 * will not always be at the top left corner.  Normalizing the rectangle will ensure that
			 * the {@link Eto.Drawing.RectangleF.X} and {@link Eto.Drawing.RectangleF.Y} co-ordinates
			 * of the rectangle are at the top left.
			 */
			Normalize(): void;

			/**
			 * Creates a new instance of a RectangleF from the values of the `left`, `top`, `right`
			 * and `bottom` sides
			 */
			static FromSides(
				left: number,
				top: number,
				right: number,
				bottom: number,
			): Eto.Drawing.RectangleF;

			/** Creates a new instance of a RectangleF with a specified `center` and `size` */
			static FromCenter(
				center: Eto.Drawing.PointF,
				size: Eto.Drawing.SizeF,
			): Eto.Drawing.RectangleF;

			/**
			 * Gets a value indicating that the specified `point` is within the bounds of this
			 * rectangle
			 */
			Contains(point: Eto.Drawing.PointF): boolean;

			/**
			 * Gets a value indicating that the specified `x` and `y` co-ordinates are within the
			 * bounds of this rectangle
			 */
			Contains(
				x: number,
				y: number,
			): boolean;

			/**
			 * Gets a value indicating that the specified `rectangle` is entirely contained within
			 * the bounds of this rectangle
			 */
			Contains(rectangle: Eto.Drawing.RectangleF): boolean;

			/** Gets a value indicating that the specified `rectangle` overlaps this rectangle */
			Intersects(rectangle: Eto.Drawing.RectangleF): boolean;

			/** Offsets the location of the rectangle by the specified `x` and `y` values */
			Offset(
				x: number,
				y: number,
			): void;

			/** Offsets the location of the rectangle by the specified `size` */
			Offset(size: Eto.Drawing.SizeF): void;

			/**
			 * Offsets the location of the rectangle by the X and Y values of the specified `point`
			 */
			Offset(point: Eto.Drawing.PointF): void;

			/** Offsets the location of the `rectangle` by the specified `x` and `y` values */
			static Offset(
				rectangle: Eto.Drawing.RectangleF,
				x: number,
				y: number,
			): Eto.Drawing.RectangleF;

			/** Offsets the location of the `rectangle` by the specified `size` */
			static Offset(
				rectangle: Eto.Drawing.RectangleF,
				size: Eto.Drawing.SizeF,
			): Eto.Drawing.RectangleF;

			/**
			 * Offsets the location of the `rectangle` by the X and Y values of the specified `point`
			 */
			static Offset(
				rectangle: Eto.Drawing.RectangleF,
				point: Eto.Drawing.PointF,
			): Eto.Drawing.RectangleF;

			/**
			 * Inflates all dimensions of this rectangle by the specified `size`
			 *
			 * This inflates the rectangle in all dimensions by the width and height specified by
			 * `size`. The resulting rectangle will be increased in width and height twice that of
			 * the specified size, and the center will be in the same location. A negative width
			 * and/or height can be passed in to deflate the rectangle.
			 */
			Inflate(size: Eto.Drawing.SizeF): void;

			/**
			 * Inflates all dimensions of this rectangle by the specified `width` and `height`
			 *
			 * This inflates the rectangle in all dimensions by the specified `width` and `height`.
			 * The resulting rectangle will be increased in width and height twice that of the
			 * specified size, and the center will be in the same location. A negative width and/or
			 * height can be passed in to deflate the rectangle.
			 */
			Inflate(
				width: number,
				height: number,
			): void;

			/**
			 * Inflates all dimensions of the `rectangle` by the specified `size`
			 *
			 * This inflates the `rectangle` in all dimensions by the width and height specified by
			 * `size`. The resulting rectangle will be increased in width and height twice that of
			 * the specified size, and the center will be in the same location. A negative width
			 * and/or height can be passed in to deflate the rectangle.
			 */
			static Inflate(
				rectangle: Eto.Drawing.RectangleF,
				size: Eto.Drawing.SizeF,
			): Eto.Drawing.RectangleF;

			/**
			 * Inflates all dimensions of this `rectangle` by the specified `width` and `height`
			 *
			 * This inflates the `rectangle` in all dimensions by the specified `width` and `height`.
			 * The resulting rectangle will be increased in width and height twice that of the
			 * specified size, and the center will be in the same location. A negative width and/or
			 * height can be passed in to deflate the rectangle.
			 */
			static Inflate(
				rectangle: Eto.Drawing.RectangleF,
				width: number,
				height: number,
			): Eto.Drawing.RectangleF;

			/** Insets the rectangle by the specified padding. */
			Inset(padding: Eto.Drawing.PaddingF): void;

			/** Returns a new rectangle that is inset by the specified `padding` */
			static Inset(
				rectangle: Eto.Drawing.RectangleF,
				padding: Eto.Drawing.PaddingF,
			): Eto.Drawing.RectangleF;

			/**
			 * Calculates the distance between the specified `point` and `rect`.
			 *
			 * This calculates the horizontal and vertical distance of any of the edges of the
			 * rectangle to the specified point.
			 */
			static Distance(
				rect: Eto.Drawing.RectangleF,
				point: Eto.Drawing.PointF,
			): Eto.Drawing.SizeF;

			/**
			 * Calculates the distance between two rectangles.
			 *
			 * This calculates the horizontal and vertical distance of any of the edges of each
			 * rectangle. If the rectangles intersect, the distance will be empty.
			 */
			static Distance(
				rect1: Eto.Drawing.RectangleF,
				rect2: Eto.Drawing.RectangleF,
			): Eto.Drawing.SizeF;

			/**
			 * Aligns the rectangle to a grid of the specified `gridSize`
			 *
			 * This will align the top, left, right, and bottom to a grid by inflating each edge to
			 * the next grid line.
			 */
			Align(gridSize: Eto.Drawing.SizeF): void;

			/**
			 * Aligns the rectangle to a grid of the specified `gridWidth` and `gridHeight`
			 *
			 * This will align the top, left, right, and bottom to a grid by inflating each edge to
			 * the next grid line.
			 */
			Align(
				gridWidth: number,
				gridHeight: number,
			): void;

			/**
			 * Aligns the `rectangle` to a grid of the specified `gridSize`
			 *
			 * This will align the top, left, right, and bottom to a grid by inflating each edge to
			 * the next grid line.
			 */
			static Align(
				rectangle: Eto.Drawing.RectangleF,
				gridSize: Eto.Drawing.SizeF,
			): Eto.Drawing.RectangleF;

			/**
			 * Aligns the `rectangle` to a grid of the specified `gridWidth` and `gridHeight`
			 *
			 * This will align the top, left, right, and bottom to a grid by inflating each edge to
			 * the next grid line.
			 */
			static Align(
				rectangle: Eto.Drawing.RectangleF,
				gridWidth: number,
				gridHeight: number,
			): Eto.Drawing.RectangleF;

			/** Union the `rectangle` into this instance to encompass both rectangles */
			Union(rectangle: Eto.Drawing.RectangleF): void;

			/** Combines two rectangles into one rectangle that encompasses both */
			static Union(
				rect1: Eto.Drawing.RectangleF,
				rect2: Eto.Drawing.RectangleF,
			): Eto.Drawing.RectangleF;

			/** Intersect the rectangle with the specified `rectangle` */
			Intersect(rectangle: Eto.Drawing.RectangleF): void;

			/** Intersect the two specified rectangles */
			static Intersect(
				rect1: Eto.Drawing.RectangleF,
				rect2: Eto.Drawing.RectangleF,
			): Eto.Drawing.RectangleF;

			/**
			 * Restricts the rectangle to be within the specified `point` and `size`
			 *
			 * This is a shortcut for
			 */
			Restrict(
				point: Eto.Drawing.PointF,
				size: Eto.Drawing.SizeF,
			): void;

			/**
			 * Restricts the rectangle to be within the specified `size` at an X,Y location of 0, 0
			 *
			 * This is a shortcut for
			 */
			Restrict(size: Eto.Drawing.SizeF): void;

			/**
			 * Restricts the rectangle to be within the specified `rectangle`
			 *
			 * This ensures that the current rectangle's bounds fall within the bounds of the
			 * specified `rectangle`. It is useful to ensure that the rectangle does not exceed
			 * certain limits (e.g. for drawing)
			 */
			Restrict(rectangle: Eto.Drawing.RectangleF): void;

			/**
			 * Restricts the `rectangle` to be within the `restrict` rectangle
			 *
			 * This ensures that `rectangle` 's bounds fall within the bounds of the specified
			 * `restrict` rectangle It is useful to ensure that the rectangle does not exceed certain
			 * limits (e.g. for drawing)
			 */
			static Restrict(
				rectangle: Eto.Drawing.Rectangle,
				restrict: Eto.Drawing.Rectangle,
			): Eto.Drawing.Rectangle;

			/** Converts this rectangle to a string */
			ToString(): string;

			/** Compares this rectangle to an object for equality */
			Equals(obj: unknown): boolean;

			/** Gets the hash code for this rectangle */
			GetHashCode(): number;

			/** Compares this rectangle with the specified `other` rectangle */
			Equals(other: Eto.Drawing.RectangleF): boolean;
		}
	}

	export namespace Eto.Drawing {
		/**
		 * Converter for the {@link Eto.Drawing.RectangleF} class
		 *
		 * Allows for conversion from a string to a {@link Eto.Drawing.RectangleF}.
		 */
		export class RectangleFConverter {
			constructor();

			/** Determines if this converter can convert from the specified `sourceType` */
			CanConvertFrom(
				context: Eto.ITypeDescriptorContext,
				sourceType: unknown,
			): boolean;

			/** Converts the specified value to a {@link Eto.Drawing.RectangleF} */
			ConvertFrom(
				context: Eto.ITypeDescriptorContext,
				culture: unknown,
				value: unknown,
			): unknown;

			/** Determines whether this instance can convert from the specified sourceType. */
			CanConvertFrom(sourceType: unknown): boolean;

			/** Determines whether this instance can convert to the specified destinationType. */
			CanConvertTo(destinationType: unknown): boolean;

			/**
			 * Determines whether this instance can convert to the specified context destinationType.
			 */
			CanConvertTo(
				context: Eto.ITypeDescriptorContext,
				destinationType: unknown,
			): boolean;

			/** Converts from the specified object. */
			ConvertFrom(o: unknown): unknown;

			/** Converts from an invariant string. */
			ConvertFromInvariantString(text: string): unknown;

			/** Converts from an invariant string. */
			ConvertFromInvariantString(
				context: Eto.ITypeDescriptorContext,
				text: string,
			): unknown;

			/** Converts from string. */
			ConvertFromString(text: string): unknown;

			/** Converts from string. */
			ConvertFromString(
				context: Eto.ITypeDescriptorContext,
				text: string,
			): unknown;

			/** Converts from string. */
			ConvertFromString(
				context: Eto.ITypeDescriptorContext,
				culture: unknown,
				text: string,
			): unknown;

			/** Converts to the specified type. */
			ConvertTo(
				value: unknown,
				destinationType: unknown,
			): unknown;

			/** Converts to the specified type. */
			ConvertTo(
				context: Eto.ITypeDescriptorContext,
				culture: unknown,
				value: unknown,
				destinationType: unknown,
			): unknown;

			/** Converts to an invariant string. */
			ConvertToInvariantString(value: unknown): string;

			/** Converts to invariant string. */
			ConvertToInvariantString(
				context: Eto.ITypeDescriptorContext,
				value: unknown,
			): string;

			/** Converts to a string. */
			ConvertToString(value: unknown): string;

			/** Converts to a string. */
			ConvertToString(
				context: Eto.ITypeDescriptorContext,
				value: unknown,
			): string;

			/** Converts to a string. */
			ConvertToString(
				context: Eto.ITypeDescriptorContext,
				culture: unknown,
				value: unknown,
			): string;

			/** Determines whether this instance is valid the specified value. */
			IsValid(value: unknown): boolean;

			/** Determines whether this instance is valid the specified context value. */
			IsValid(
				context: Eto.ITypeDescriptorContext,
				value: unknown,
			): boolean;
		}
	}

	export namespace Eto.Drawing {
		/** Defines a region to use for clipping */
		export class Region implements
			Eto.IHandlerSource {
			constructor();

			/**
			 * Gets the platform that was used to create the {@link Eto.Widget.Handler} for this
			 * widget
			 *
			 * This gets set to the current {@link Eto.Platform.Instance} during the construction of
			 * the object
			 */
			readonly Platform: Eto.Platform;

			/** Gets the platform-specific handler for this widget */
			Handler: unknown;

			/** Gets the native platform-specific handle for integration purposes */
			readonly NativeHandle: unknown;

			/** Gets the dictionary of properties for this widget */
			readonly Properties: Eto.PropertyStore;

			/** Gets or sets the ID of this widget */
			ID: string;

			/**
			 * Gets or sets the style of this widget
			 *
			 * Styles allow you to attach custom platform-specific logic to a widget. In your
			 * platform-specific assembly, use {@link Style.Add{H}(string, StyleHandler{H})} to add
			 * the style logic with the same id.
			 */
			Style: string;

			/**
			 * Gets the instance of the platform-specific object
			 *
			 * This can sometimes be useful to get the platform-specific object. Some handlers may
			 * not have any backing object for its functionality, so this may be null.  It is more
			 * preferred to use the {@link Eto.Widget.Handler} and cast that to the platform-specific
			 * handler class which can give you additional methods and helpers to do common tasks.
			 * For example, the {@link Eto.Forms.Application} object's handler for OS X has a
			 * AddFullScreenMenuItem property to specify if you want full screen support in your app.
			 */
			readonly ControlObject: unknown;

			/**
			 * Gets or sets a value indicating whether this {@link Eto.Widget} has been disposed.
			 *
			 * When the widget is disposed, it can no longer be used.
			 */
			IsDisposed: boolean;

			/** Excludes the specified `rectangle` from the region */
			Exclude(rectangle: Eto.Drawing.Rectangle): void;

			/** Resets the region */
			Reset(): void;

			/** Sets the specified `rectangle` in the region */
			Set(rectangle: Eto.Drawing.Rectangle): void;

			/** Disposes of this widget, supressing the finalizer */
			dispose(): void;

			/** Gets a string that represents the current object with its ID if specified. */
			ToString(): string;
		}
	}

	export namespace Eto.Drawing.Region {
		export interface IHandler extends Eto.Widget.IHandler {
			Exclude(rectangle: Eto.Drawing.Rectangle): void;

			Reset(): void;

			Set(rectangle: Eto.Drawing.Rectangle): void;
		}
	}

	export namespace Eto.Drawing {
		/** Represents a size with width and height components */
		export class Size {
			/** Initializes a new Size class with the specified width and height */
			constructor(
				width: number,
				height: number,
			);

			/**
			 * Initializes a new Size class with width and height corresponding to the
			 * {@link Eto.Drawing.Point.X} and {@link Eto.Drawing.Point.Y} of the specified `point`
			 */
			constructor(point: Eto.Drawing.Point);

			/** Initializes a new Size with the truncated width and height of size. */
			constructor(size: Eto.Drawing.SizeF);

			/** Gets or sets the width */
			Width: number;

			/** Gets or sets the height */
			Height: number;

			/**
			 * Gets a value indicating that both the {@link Eto.Drawing.Size.Width} and
			 * {@link Eto.Drawing.Size.Height} are zero
			 */
			readonly IsZero: boolean;

			/**
			 * Gets a value indicating that either the {@link Eto.Drawing.Size.Width} or
			 * {@link Eto.Drawing.Size.Height} are zero
			 */
			readonly IsEmpty: boolean;

			/**
			 * Converts a floating point `size` to an integral size by rounding the width and height
			 */
			static Round(size: Eto.Drawing.SizeF): Eto.Drawing.Size;

			/**
			 * Converts a floating point `size` to an integral size by truncating the width and
			 * height
			 */
			static Truncate(size: Eto.Drawing.SizeF): Eto.Drawing.Size;

			/** Returns the minimum width and height of two sizes */
			static Min(
				size1: Eto.Drawing.Size,
				size2: Eto.Drawing.Size,
			): Eto.Drawing.Size;

			/** Returns the maximum width and height of two sizes */
			static Max(
				size1: Eto.Drawing.Size,
				size2: Eto.Drawing.Size,
			): Eto.Drawing.Size;

			/** Returns the absolute width and height of the specified `size` */
			static Abs(size: Eto.Drawing.Size): Eto.Drawing.Size;

			/**
			 * Converts a floating point `size` to an integral size by rounding the width and height
			 * to the  next integral value.
			 *
			 * This is useful to get a size struct that includes the floating point values
			 * completely.  As opposed to the {@link Eto.Drawing.Size.Round(Eto.Drawing.SizeF)},
			 * which will round down to the nearest integral number.  For example, a Width or Height
			 * of 2.1 or 2.6 would be translated to 3.
			 */
			static Ceiling(size: Eto.Drawing.SizeF): Eto.Drawing.Size;

			/** Fits this size to the specified `constraint`, keeping the aspect */
			FitTo(constraint: Eto.Drawing.Size): Eto.Drawing.Size;

			/**
			 * Gets a value indicating that the specified `point` is within the
			 * {@link Eto.Drawing.Size.Width} and {@link Eto.Drawing.Size.Height} of this size
			 */
			Contains(point: Eto.Drawing.Point): boolean;

			/**
			 * Gets a value indicating that the specified `x` and `y` values are within the
			 * {@link Eto.Drawing.Size.Width} and {@link Eto.Drawing.Size.Height} of this size
			 */
			Contains(
				x: number,
				y: number,
			): boolean;

			/** Compares this size to the specified `obj` */
			Equals(obj: unknown): boolean;

			/** Gets the hash code for this Size */
			GetHashCode(): number;

			/** Converts this Size struct to a string */
			ToString(): string;

			/** Compares this size to the `other` size */
			Equals(other: Eto.Drawing.Size): boolean;
		}
	}

	export namespace Eto.Drawing {
		/**
		 * Converter for the {@link Eto.Drawing.Size} class
		 *
		 * Allows for conversion from a string to a {@link Eto.Drawing.Size}.
		 */
		export class SizeConverter {
			constructor();

			/** Determines if this converter can convert from the specified `sourceType` */
			CanConvertFrom(
				context: Eto.ITypeDescriptorContext,
				sourceType: unknown,
			): boolean;

			/** Converts the specified value to a {@link Eto.Drawing.Size} */
			ConvertFrom(
				context: Eto.ITypeDescriptorContext,
				culture: unknown,
				value: unknown,
			): unknown;

			/** Determines whether this instance can convert from the specified sourceType. */
			CanConvertFrom(sourceType: unknown): boolean;

			/** Determines whether this instance can convert to the specified destinationType. */
			CanConvertTo(destinationType: unknown): boolean;

			/**
			 * Determines whether this instance can convert to the specified context destinationType.
			 */
			CanConvertTo(
				context: Eto.ITypeDescriptorContext,
				destinationType: unknown,
			): boolean;

			/** Converts from the specified object. */
			ConvertFrom(o: unknown): unknown;

			/** Converts from an invariant string. */
			ConvertFromInvariantString(text: string): unknown;

			/** Converts from an invariant string. */
			ConvertFromInvariantString(
				context: Eto.ITypeDescriptorContext,
				text: string,
			): unknown;

			/** Converts from string. */
			ConvertFromString(text: string): unknown;

			/** Converts from string. */
			ConvertFromString(
				context: Eto.ITypeDescriptorContext,
				text: string,
			): unknown;

			/** Converts from string. */
			ConvertFromString(
				context: Eto.ITypeDescriptorContext,
				culture: unknown,
				text: string,
			): unknown;

			/** Converts to the specified type. */
			ConvertTo(
				value: unknown,
				destinationType: unknown,
			): unknown;

			/** Converts to the specified type. */
			ConvertTo(
				context: Eto.ITypeDescriptorContext,
				culture: unknown,
				value: unknown,
				destinationType: unknown,
			): unknown;

			/** Converts to an invariant string. */
			ConvertToInvariantString(value: unknown): string;

			/** Converts to invariant string. */
			ConvertToInvariantString(
				context: Eto.ITypeDescriptorContext,
				value: unknown,
			): string;

			/** Converts to a string. */
			ConvertToString(value: unknown): string;

			/** Converts to a string. */
			ConvertToString(
				context: Eto.ITypeDescriptorContext,
				value: unknown,
			): string;

			/** Converts to a string. */
			ConvertToString(
				context: Eto.ITypeDescriptorContext,
				culture: unknown,
				value: unknown,
			): string;

			/** Determines whether this instance is valid the specified value. */
			IsValid(value: unknown): boolean;

			/** Determines whether this instance is valid the specified context value. */
			IsValid(
				context: Eto.ITypeDescriptorContext,
				value: unknown,
			): boolean;
		}
	}

	export namespace Eto.Drawing {
		/** Represents a floating point size with width and height components */
		export class SizeF {
			/** Initializes a new SizeF class with the specified width and height */
			constructor(
				width: number,
				height: number,
			);

			/**
			 * Initializes a new SizeF class with width and height corresponding to the
			 * {@link Eto.Drawing.PointF.X} and {@link Eto.Drawing.PointF.Y} of the specified `point`
			 */
			constructor(point: Eto.Drawing.PointF);

			/** Gets or sets the width */
			Width: number;

			/** Gets or sets the height */
			Height: number;

			/**
			 * Gets a value indicating that both the {@link Eto.Drawing.SizeF.Width} and
			 * {@link Eto.Drawing.SizeF.Height} are zero
			 */
			readonly IsZero: boolean;

			/**
			 * Gets a value indicating that either the {@link Eto.Drawing.SizeF.Width} or
			 * {@link Eto.Drawing.SizeF.Height} are zero
			 */
			readonly IsEmpty: boolean;

			/** Returns the minimum width and height of two sizes */
			static Min(
				size1: Eto.Drawing.SizeF,
				size2: Eto.Drawing.SizeF,
			): Eto.Drawing.SizeF;

			/** Returns the maximum width and height of two sizes */
			static Max(
				size1: Eto.Drawing.SizeF,
				size2: Eto.Drawing.SizeF,
			): Eto.Drawing.SizeF;

			/** Returns the absolute width and height of the specified `size` */
			static Abs(size: Eto.Drawing.SizeF): Eto.Drawing.SizeF;

			/** Fits this size to the specified `constraint`, keeping the aspect */
			FitTo(constraint: Eto.Drawing.SizeF): Eto.Drawing.SizeF;

			/**
			 * Gets a value indicating that the specified `point` is within the
			 * {@link Eto.Drawing.SizeF.Width} and {@link Eto.Drawing.SizeF.Height} of this size
			 */
			Contains(point: Eto.Drawing.PointF): boolean;

			/**
			 * Gets a value indicating that the specified `x` and `y` values are within the
			 * {@link Eto.Drawing.SizeF.Width} and {@link Eto.Drawing.SizeF.Height} of this size
			 */
			Contains(
				x: number,
				y: number,
			): boolean;

			/** Compares this size to the specified `obj` */
			Equals(obj: unknown): boolean;

			/** Gets the hash code for this Size */
			GetHashCode(): number;

			/** Converts this Size struct to a string */
			ToString(): string;

			/** Compares this size to the `other` size */
			Equals(other: Eto.Drawing.SizeF): boolean;
		}
	}

	export namespace Eto.Drawing {
		/**
		 * Converter for the {@link Eto.Drawing.SizeF} class
		 *
		 * Allows for conversion from a string to a {@link Eto.Drawing.SizeF}.
		 */
		export class SizeFConverter {
			constructor();

			/** Determines if this converter can convert from the specified `sourceType` */
			CanConvertFrom(
				context: Eto.ITypeDescriptorContext,
				sourceType: unknown,
			): boolean;

			/** Converts the specified value to a {@link Eto.Drawing.SizeF} */
			ConvertFrom(
				context: Eto.ITypeDescriptorContext,
				culture: unknown,
				value: unknown,
			): unknown;

			/** Determines whether this instance can convert from the specified sourceType. */
			CanConvertFrom(sourceType: unknown): boolean;

			/** Determines whether this instance can convert to the specified destinationType. */
			CanConvertTo(destinationType: unknown): boolean;

			/**
			 * Determines whether this instance can convert to the specified context destinationType.
			 */
			CanConvertTo(
				context: Eto.ITypeDescriptorContext,
				destinationType: unknown,
			): boolean;

			/** Converts from the specified object. */
			ConvertFrom(o: unknown): unknown;

			/** Converts from an invariant string. */
			ConvertFromInvariantString(text: string): unknown;

			/** Converts from an invariant string. */
			ConvertFromInvariantString(
				context: Eto.ITypeDescriptorContext,
				text: string,
			): unknown;

			/** Converts from string. */
			ConvertFromString(text: string): unknown;

			/** Converts from string. */
			ConvertFromString(
				context: Eto.ITypeDescriptorContext,
				text: string,
			): unknown;

			/** Converts from string. */
			ConvertFromString(
				context: Eto.ITypeDescriptorContext,
				culture: unknown,
				text: string,
			): unknown;

			/** Converts to the specified type. */
			ConvertTo(
				value: unknown,
				destinationType: unknown,
			): unknown;

			/** Converts to the specified type. */
			ConvertTo(
				context: Eto.ITypeDescriptorContext,
				culture: unknown,
				value: unknown,
				destinationType: unknown,
			): unknown;

			/** Converts to an invariant string. */
			ConvertToInvariantString(value: unknown): string;

			/** Converts to invariant string. */
			ConvertToInvariantString(
				context: Eto.ITypeDescriptorContext,
				value: unknown,
			): string;

			/** Converts to a string. */
			ConvertToString(value: unknown): string;

			/** Converts to a string. */
			ConvertToString(
				context: Eto.ITypeDescriptorContext,
				value: unknown,
			): string;

			/** Converts to a string. */
			ConvertToString(
				context: Eto.ITypeDescriptorContext,
				culture: unknown,
				value: unknown,
			): string;

			/** Determines whether this instance is valid the specified value. */
			IsValid(value: unknown): boolean;

			/** Determines whether this instance is valid the specified context value. */
			IsValid(
				context: Eto.ITypeDescriptorContext,
				value: unknown,
			): boolean;
		}
	}

	export namespace Eto.Drawing {
		/**
		 * Defines a brush with a solid color for use with {@link Eto.Drawing.Graphics} fill
		 * operations
		 */
		export class SolidBrush implements
			Eto.IHandlerSource,
			Eto.IControlObjectSource {
			/** Initializes a new instance of a SolidBrush with the specified `color` */
			constructor(color: Eto.Drawing.Color);

			/** Gets the platform handler object for the widget */
			readonly Handler: unknown;

			/** Gets a delegate to instantiate objects of this type with minimal overhead */
			static readonly Instantiator: (arg1: Eto.Drawing.Color) => Eto.Drawing.SolidBrush;

			/** Gets or sets the fill color of this brush */
			Color: Eto.Drawing.Color;

			/** Gets or sets the control object for this widget */
			ControlObject: unknown;

			/**
			 * Releases all resource used by the {@link Eto.Drawing.Brush} object.
			 *
			 * Call {@link Eto.Drawing.Brush.Dispose} when you are finished using the
			 * {@link Eto.Drawing.Brush}. The {@link Eto.Drawing.Brush.Dispose} method leaves the
			 * {@link Eto.Drawing.Brush} in an unusable state. After calling
			 * {@link Eto.Drawing.Brush.Dispose}, you must release all references to the
			 * {@link Eto.Drawing.Brush} so the garbage collector can reclaim the memory that the
			 * {@link Eto.Drawing.Brush} was occupying.
			 */
			dispose(): void;
		}
	}

	export namespace Eto.Drawing.SolidBrush {
		export interface IHandler extends Eto.Drawing.Brush.IHandler {
			GetColor(widget: Eto.Drawing.SolidBrush): Eto.Drawing.Color;

			SetColor(
				widget: Eto.Drawing.SolidBrush,
				color: Eto.Drawing.Color,
			): void;

			Create(color: Eto.Drawing.Color): unknown;
		}
	}

	export namespace Eto.Drawing {
		/** Methods to get colors of system elements */
		export namespace SystemColors {
			/** Gets the color of disabled text. */
			export const DisabledText: Eto.Drawing.Color;

			/** Gets the color of text in a control, such as a TextBox or GridView. */
			export const ControlText: Eto.Drawing.Color;

			/** Gets the color of highlighted text in controls such as a TextBox or GridView. */
			export const HighlightText: Eto.Drawing.Color;

			/** Gets the color of a control. */
			export const Control: Eto.Drawing.Color;

			/** Gets the color of a control's background, such as the entry area of a TextBox. */
			export const ControlBackground: Eto.Drawing.Color;

			/** Gets the highlight color. */
			export const Highlight: Eto.Drawing.Color;

			/** Gets the color of a window background. */
			export const WindowBackground: Eto.Drawing.Color;

			/** Gets the color of selected text */
			export const SelectionText: Eto.Drawing.Color;

			/** Gets the background color of selected text */
			export const Selection: Eto.Drawing.Color;

			/** Gets the color of hyperlink text */
			export const LinkText: Eto.Drawing.Color;
		}
	}

	export namespace Eto.Drawing.SystemColors {
		export interface IHandler {
			readonly DisabledText: Eto.Drawing.Color;

			readonly ControlText: Eto.Drawing.Color;

			readonly HighlightText: Eto.Drawing.Color;

			readonly Control: Eto.Drawing.Color;

			readonly ControlBackground: Eto.Drawing.Color;

			readonly Highlight: Eto.Drawing.Color;

			readonly WindowBackground: Eto.Drawing.Color;

			readonly SelectionText: Eto.Drawing.Color;

			readonly Selection: Eto.Drawing.Color;

			readonly LinkText: Eto.Drawing.Color;
		}
	}

	export namespace Eto.Drawing {
		/** Methods to get information about current fonts installed the running system */
		export namespace SystemFonts {
			/** Gets a cached font */
			export function Cached(
				systemFont: Eto.Drawing.SystemFont,
				size?: number,
				decoration?: Eto.Drawing.FontDecoration,
			): Eto.Drawing.Font;

			/**
			 * Clears the font cache
			 *
			 * This is useful if you are using the
			 * {@link Eto.Drawing.SystemFonts.Cached(Eto.Drawing.SystemFont,System.Nullable{System.Single},Eto.Drawing.FontDecoration)}
			 * method to cache fonts and want to clear it to conserve memory or resources.
			 */
			export function ClearCache(): void;

			/** Gets the system bold font with optional specified `size` and `decoration`. */
			export function Bold(
				size?: number,
				decoration?: Eto.Drawing.FontDecoration,
			): Eto.Drawing.Font;

			/** Gets the system default font with optional specified `size` and `decoration`. */
			export function Default(
				size?: number,
				decoration?: Eto.Drawing.FontDecoration,
			): Eto.Drawing.Font;

			/** Gets the system label font with optional specified `size` and `decoration`. */
			export function Label(
				size?: number,
				decoration?: Eto.Drawing.FontDecoration,
			): Eto.Drawing.Font;

			/** Gets the system menu font with optional specified `size` and `decoration`. */
			export function Menu(
				size?: number,
				decoration?: Eto.Drawing.FontDecoration,
			): Eto.Drawing.Font;

			/** Gets the system menu bar font with optional specified `size` and `decoration`. */
			export function MenuBar(
				size?: number,
				decoration?: Eto.Drawing.FontDecoration,
			): Eto.Drawing.Font;

			/** Gets the system message box font with optional specified `size` and `decoration`. */
			export function Message(
				size?: number,
				decoration?: Eto.Drawing.FontDecoration,
			): Eto.Drawing.Font;

			/** Gets the system palette font with optional specified `size` and `decoration`. */
			export function Palette(
				size?: number,
				decoration?: Eto.Drawing.FontDecoration,
			): Eto.Drawing.Font;

			/** Gets the system status bar font with optional specified `size` and `decoration`. */
			export function StatusBar(
				size?: number,
				decoration?: Eto.Drawing.FontDecoration,
			): Eto.Drawing.Font;

			/** Gets the system title bar font with optional specified `size` and `decoration`. */
			export function TitleBar(
				size?: number,
				decoration?: Eto.Drawing.FontDecoration,
			): Eto.Drawing.Font;

			/** Gets the system tooltip font with optional specified `size` and `decoration`. */
			export function ToolTip(
				size?: number,
				decoration?: Eto.Drawing.FontDecoration,
			): Eto.Drawing.Font;

			/**
			 * Gets the user font with optional specified `size` and `decoration`.
			 *
			 * On macOS, the system font isn't normally a font that the user would select or use,
			 * other than for user interface elements. This should be used instead as the starting
			 * font for the user to select.
			 */
			export function User(
				size?: number,
				decoration?: Eto.Drawing.FontDecoration,
			): Eto.Drawing.Font;
		}
	}

	export namespace Eto.Drawing {
		/** Type of system icon to get */
		export enum SystemIconType {
			/** Icon for an open directory/folder */
			OpenDirectory = 0,

			/** Icon for a closed directory/folder */
			CloseDirectory = 1,

			/** Icon for a question mark */
			Question = 2,

			/** Icon for errors */
			Error = 3,

			/** Icon to use for informational messages */
			Information = 4,

			/** Icon to use for warnings */
			Warning = 5,
		}
	}

	export namespace Eto.Drawing {
		/** Size of icon to get */
		export enum SystemIconSize {
			/** Large icon (usually suitable to display at 32x32 logical pixels) */
			Large = 0,

			/** Small icon (usually suitable to display at 16x16 logical pixels) */
			Small = 1,
		}
	}

	export namespace Eto.Drawing {
		/** Methods to get system icons for file types and static icons */
		export namespace SystemIcons {
			/**
			 * Gets a file icon for the specified file
			 *
			 * The file does not necessarily have to exist for the icon to be retrieved, though if it
			 * is a specific file then the platform may be able to return a file-specific icon if one
			 * is available.
			 */
			export function GetFileIcon(
				fileName: string,
				size: Eto.Drawing.SystemIconSize,
			): Eto.Drawing.Icon;

			/** Gets a static system-defined icon for the specified type. */
			export function Get(
				type: Eto.Drawing.SystemIconType,
				size: Eto.Drawing.SystemIconSize,
			): Eto.Drawing.Icon;
		}
	}

	export namespace Eto.Drawing.SystemIcons {
		export interface IHandler {
			GetFileIcon(
				fileName: string,
				size: Eto.Drawing.SystemIconSize,
			): Eto.Drawing.Icon;

			Get(
				type: Eto.Drawing.SystemIconType,
				size: Eto.Drawing.SystemIconSize,
			): Eto.Drawing.Icon;
		}
	}

	export namespace Eto.Drawing {
		/**
		 * Interface for brushes with a transform
		 *
		 * The transform is used to specify how the brush will be applied to the drawing.
		 */
		export interface ITransformBrush {
			/** Gets or sets the transform for this brush */
			Transform: Eto.Drawing.IMatrix;
		}
	}

	export namespace Eto.Drawing {
		/**
		 * Defines a brush with an image texture for use with {@link Eto.Drawing.Graphics} fill
		 * operations
		 */
		export class TextureBrush implements
			Eto.IHandlerSource,
			Eto.IControlObjectSource,
			Eto.Drawing.ITransformBrush {
			/** Initializes a new instance of the {@link Eto.Drawing.TextureBrush} class. */
			constructor(
				image: Eto.Drawing.Image,
				opacity?: number,
			);

			/** Gets the texture's image to paint with */
			Image: Eto.Drawing.Image;

			/** Gets the platform handler object for the widget */
			readonly Handler: unknown;

			/**
			 * Gets an instantiator for the texture brush to create instances
			 *
			 * This can be used to instantiate texture brushes when creating many brushes to minimize
			 * overhead
			 */
			static readonly Instantiator: (arg1: Eto.Drawing.Image, arg2: number) => Eto.Drawing.TextureBrush;

			/** Gets or sets the transform for this brush */
			Transform: Eto.Drawing.IMatrix;

			/** Gets or sets the opacity of the brush texture */
			Opacity: number;

			/** Gets or sets the control object for this widget */
			ControlObject: unknown;

			/**
			 * Releases all resource used by the {@link Eto.Drawing.Brush} object.
			 *
			 * Call {@link Eto.Drawing.Brush.Dispose} when you are finished using the
			 * {@link Eto.Drawing.Brush}. The {@link Eto.Drawing.Brush.Dispose} method leaves the
			 * {@link Eto.Drawing.Brush} in an unusable state. After calling
			 * {@link Eto.Drawing.Brush.Dispose}, you must release all references to the
			 * {@link Eto.Drawing.Brush} so the garbage collector can reclaim the memory that the
			 * {@link Eto.Drawing.Brush} was occupying.
			 */
			dispose(): void;
		}
	}

	export namespace Eto.Drawing.TextureBrush {
		export interface IHandler extends Eto.Drawing.Brush.IHandler {
			GetTransform(widget: Eto.Drawing.TextureBrush): Eto.Drawing.IMatrix;

			SetTransform(
				widget: Eto.Drawing.TextureBrush,
				transform: Eto.Drawing.IMatrix,
			): void;

			SetOpacity(
				widget: Eto.Drawing.TextureBrush,
				opacity: number,
			): void;

			Create(
				image: Eto.Drawing.Image,
				opacity: number,
			): unknown;
		}
	}
}
