// Generated for: GH_Util 8.9.24194.18121
// Generated by: Microsoft.JavaScript.NodeApi.Generator 0.7.0.0
/* eslint-disable */

/** A JavaScript projection of a .NET type. */
interface IType {
	/**
	 * Constructs a new instance of the type.
	 * (Not available for static class or interface types.)
	 */
	new?(...args: any[]): IType;

	/** Gets the full name of the .NET type. */
	toString(): string;
}

declare module 'node-api-dotnet' {

	export namespace GH_Util {
		export class GH_2DIndex {
			constructor(
				new_i: number,
				new_j: number,
			);

			constructor(other: GH_Util.GH_2DIndex);

			Set(
				new_i: number,
				new_j: number,
			): void;

			Shift(
				offset_i: number,
				offset_j: number,
			): void;
		}
	}

	export namespace GH_Util {
		export class GH_3DIndex {
			constructor(
				new_i: number,
				new_j: number,
				new_k: number,
			);

			constructor(other: GH_Util.GH_3DIndex);

			Set(
				new_i: number,
				new_j: number,
				new_k: number,
			): void;

			Shift(
				offset_i: number,
				offset_j: number,
				offset_k: number,
			): void;
		}
	}

	export namespace GH_Util {
		export function GH_2DSparseArray$(T: IType): typeof GH_2DSparseArray$1<any>;

		export class GH_2DSparseArray$1<T> {
			new(): GH_2DSparseArray$1<T>;

			ValueProvider: GH_Util.GH_2DSparseArray.ValueDelegate$1<T>;

			ContainsIndex(
				x: number,
				y: number,
			): boolean;

			Remove(x: number): void;

			Remove(
				x: number,
				y: number,
			): void;

			Clear(): void;

			AllIndices(): unknown;
		}
	}

	export namespace GH_Util.GH_2DSparseArray {
		export function ValueDelegate$(T: IType): IType;

		export interface ValueDelegate$1<T> { (
			x: number,
			y: number,
		): T; }
	}

	export namespace GH_Util {
		export enum BezierShape {
			Unknown = 0,

			Arch = 1,

			SingleInflection = 2,

			DoubleInflection = 3,

			Cusp = 4,

			Closed = 5,

			LoopAtStart = 6,

			LoopAtEnd = 7,

			LoopOnInterior = 8,
		}
	}

	export namespace GH_Util {
		export class BezierF {
			constructor(
				p0: unknown,
				p1: unknown,
				p2: unknown,
				p3: unknown,
			);

			constructor(
				x0: number,
				y0: number,
				x1: number,
				y1: number,
				x2: number,
				y2: number,
				x3: number,
				y3: number,
			);

			readonly IsEmpty: boolean;

			readonly P0: unknown;

			readonly P1: unknown;

			readonly P2: unknown;

			readonly P3: unknown;

			readonly T0: unknown;

			readonly T3: unknown;

			readonly IsClosed: boolean;

			readonly Bounds: unknown;

			PointAt(t: number): unknown;

			TangentAt(t: number): unknown;

			Reverse(): GH_Util.BezierF;

			Extremes(): { x: number[], y: number[] };

			Project(point: unknown): number;

			Distance(point: unknown): number;
		}
	}

	export namespace GH_Util {
		export class GH_NaturalComparer {
			constructor();
		}
	}

	export namespace GH_Util {
		export class GH_NaturalStringComparer {
			constructor();

			static Compare(
				s1: string,
				s2: string,
			): number;
		}
	}

	export namespace GH_Util.MetaBall {
		export enum GH_Mask {
			_0000 = 0,

			_0001 = 1,

			_0010 = 2,

			_0011 = 3,

			_0100 = 4,

			_0101 = 5,

			_0110 = 6,

			_0111 = 7,

			_1000 = 8,

			_1001 = 9,

			_1010 = 10,

			_1011 = 11,

			_1100 = 12,

			_1101 = 13,

			_1110 = 14,

			_1111 = 15,
		}
	}

	export namespace GH_Util.MetaBall {
		export enum GH_Direction {
			invalid = 0,

			left = 1,

			right = 2,

			down = 3,

			up = 4,
		}
	}

	export namespace GH_Util.MetaBall {
		export class GH_Vertex {
			constructor();

			constructor(
				vx: number,
				vy: number,
			);

			constructor(pt: unknown);

			constructor(other: GH_Util.MetaBall.GH_Vertex);

			GetHashCode(): number;

			Equals(obj: unknown): boolean;
		}
	}

	export namespace GH_Util.MetaBall {
		export class GH_IsoSurface {
			constructor();

			constructor(initial_capacity: number);

			readonly IsClosed: boolean;

			Smooth(): void;
		}
	}

	export namespace GH_Util.MetaBall {
		export class GH_CellInfo {
			constructor();

			constructor(
				nX: number,
				nY: number,
			);

			constructor(
				nX: number,
				nY: number,
				na: number,
				nb: number,
				nc: number,
				nd: number,
			);

			DetermineMask(threshold: number): void;

			DetermineRealBox(accuracy: number): void;
		}
	}

	export namespace GH_Util.MetaBall {
		export class GH_Particle {
			constructor();

			constructor(
				nx: number,
				ny: number,
				nz: number,
				nc: number,
				nr: number,
			);
		}
	}

	export namespace GH_Util.MetaBall {
		export class GH_Context {
			constructor();

			Affinity: number;

			Accuracy: number;

			readonly ParticleCount: number;

			SolverDelegate: GH_Util.MetaBall.GH_Context.FieldSolver;

			Particle(index: number): GH_Util.MetaBall.GH_Particle;

			AddParticle(
				particle_x: number,
				particle_y: number,
			): void;

			AddParticle(
				particle_x: number,
				particle_y: number,
				particle_charge: number,
				particle_radius: number,
			): void;

			AddParticle(
				particle_x: number,
				particle_y: number,
				particle_z: number,
				particle_charge: number,
				particle_radius: number,
			): void;

			RemoveParticle(index: number): void;

			ClosestParticle(
				sample_x: number,
				sample_y: number,
			): { result: number, distance: number };

			ClosestParticle(
				sample_x: number,
				sample_y: number,
				sample_z: number,
			): { result: number, distance: number };

			Potential(
				x: number,
				y: number,
			): number;

			static InverseSquareSolver(
				context: GH_Util.MetaBall.GH_Context,
				x: number,
				y: number,
			): number;

			static SineFallOffSolver(
				context: GH_Util.MetaBall.GH_Context,
				x: number,
				y: number,
			): number;

			SolveIsoSurfaces(threshold: number): unknown;

			SolveIsoSurfaces(threshold: number): { result: unknown, history: GH_Util.GH_2DSparseArray$1<boolean> };
		}
	}

	export namespace GH_Util.MetaBall.GH_Context {
		export interface FieldSolver { (
			context: GH_Util.MetaBall.GH_Context,
			x: number,
			y: number,
		): number; }
	}
}
